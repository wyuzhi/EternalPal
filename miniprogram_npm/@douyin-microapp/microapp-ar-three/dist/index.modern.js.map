{"version":3,"file":"node_modules/@douyin-microapp/microapp-ar-three/dist/index.modern.js","names":["MaskType","ArFootProcessor","constructor","three","name","maskTextures","threshold","this","maskType","remove","DataTexture","Uint8Array","AlphaFormat","updateMesh","matrix","mesh","position","Vector3","quaternion","Quaternion","scale","trs","Matrix4","i","length","elements","decompose","copy","updateModels","algResult","models","left","visible","right","image","width","leftMask","maskWidth","maskHeight","rightMask","data","set","needsUpdate","getMaskTexelAndBinarizeAlphaCodeSegment","maskTextureID","maskTexelID","processor","toPrecision","ArMixer","processors","cameraTexture","modelTexture","mixedTextureWidth","mixedTextureHeight","mixedRenderTarget","maskScene","maskCamera","mixedTexture","shaderUniformsFsCodeData","fsDeclareMaskTexture","fsRemoveMaskProcessCodeSegment","fsRevealMaskProcessCodeSegment","shaderUniforms","texCamera","value","texModel","revealMaskTexelIDs","removeMaskTexelIDs","processorName","toLocaleLowerCase","slice","j","String","push","reveal","join","fsCode","mixedShaderMaterial","ShaderMaterial","uniforms","vertexShader","fragmentShader","planeGeometry","PlaneGeometry","WebGLRenderTarget","maskPlane","Mesh","z","Scene","add","OrthographicCamera","texture","render","renderer","originRenderTarget","getRenderTarget","setRenderTarget","getTriangleAreaAndCentroid","p0","p1","p2","x1","Math","abs","x","x2","y1","y","y2","area","centroid","updateNailModel","nailModel","keyPoints","cameraWidth","cameraHeight","THREE","nailCentroid","tempPointArray","Array","fixPoint","get","result","nailArea","nailCentroidX","nailCentroidY","point","positionArray","Float32Array","geometry","attributes","array","BufferAttribute","offsetY","ArNailProcessor","nailMaskResult","nailMask","height","nailModelGroup","children","nailNum","nailType","nailKeypointResults","NAIL_UV_ARRAY","HIGHLIGHT_GEOMETRY_INDEX","NAIL_GEOMETRY_INDEX","getNailModel","highLightTexture","nailKeyPointsConponentCount","nailGeometry","BufferGeometry","setAttribute","setIndex","nailShaderMaterial","side","DoubleSide","getNailModelGroup","Group","ArNailUtils","getNailModelGroupByColor","color","Color","highLightVertices","highLightScene","highLightCamera","HIGHLIGHT_TEXTURE_WIDTH","HIGHLIGHT_TEXTURE_HEIGHT","highLightRenderTarget","highLightGeometry","highLightMaterial","MeshBasicMaterial","highLightModel","originColor","getClearColor","setClearColor","getClearAlpha","getNailModelGroupByTexture"],"sources":["../src/ArProcessor.ts","../src/ArFootProcessor.ts","../src/ArMixer.ts","../src/ArNailProcessor.ts","../src/Utils/ArNailUtils.ts"],"sourcesContent":["export enum MaskType {\n  remove = 0,\n  reveal = 1,\n}\n\nexport interface ArProcessor {\n  name: string\n\n  maskTextures?: THREE.DataTexture[]\n  maskType?: MaskType\n  threshold?: number\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\ninterface FootAlgResult {\n  left: number[][]\n  right: number[][]\n  leftMask: Uint8Array\n  rightMask: Uint8Array\n  maskWidth: number\n  maskHeight: number\n}\n\ninterface FootModels {\n  left: THREE.Object3D\n  right: THREE.Object3D\n}\n\ninterface ArFootProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: FootAlgResult\n  models: FootModels\n}\n\nexport class ArFootProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.remove\n\n  constructor({ three }: ArFootProcessorParams) {\n    this.name = 'ArFootProcessor'\n    this.three = three\n    this.threshold = 1.0\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n  }\n\n  private updateMesh(matrix: number[], mesh: THREE.Object3D) {\n    const position = new this.three.Vector3()\n    const quaternion = new this.three.Quaternion()\n    const scale = new this.three.Vector3(1, 1, 1)\n    const trs = new this.three.Matrix4()\n    for (let i = 0; i < matrix.length; i++) {\n      trs.elements[i] = matrix[i]\n    }\n    trs.decompose(position, quaternion, scale)\n\n    mesh.position.copy(position)\n    mesh.scale.copy(scale)\n    mesh.quaternion.copy(quaternion)\n  }\n\n  public updateModels({ algResult, models }: UpdateModelsParams) {\n    if (algResult == null) {\n      models['left'].visible = false\n      models['right'].visible = false\n      return\n    }\n    if (algResult.left.length !== 0) {\n      this.updateMesh(algResult.left[0], models['left'])\n      models['left'].visible = true\n    } else {\n      models['left'].visible = false\n    }\n    if (algResult.right.length !== 0) {\n      this.updateMesh(algResult.right[0], models['right'])\n      models['right'].visible = true\n    } else {\n      models['right'].visible = false\n    }\n\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.leftMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n      this.maskTextures[1].copy(\n        new this.three.DataTexture(\n          algResult.rightMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.leftMask)\n      this.maskTextures[1].image.data.set(algResult.rightMask)\n    }\n\n    this.maskTextures[0].needsUpdate = true\n    this.maskTextures[1].needsUpdate = true\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\n\nconst VS_CODE_TEMPLATE = `\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\nconst FS_CODE_HEADER = `\nuniform sampler2D texModel;\nuniform sampler2D texCamera;\n\nvarying vec2 vUv;\nvoid main(void) {\n    vec4 model = texture2D(texModel, vUv);\n    vec4 camera = texture2D(texCamera, vUv);\n    vec4 result = camera;\n\n    vec4 removeMaskTexel;\n    vec4 revealMaskTexel;\n\n`\nconst FS_CODE_REMOVE_PROCESSOR = `\n    if(removeMaskTexel.a >= 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\nconst FS_CODE_REVEAL_PROCESSOR = `\n    if(revealMaskTexel.a < 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\n\nconst FS_CODE_FOOTER = `\n    gl_FragColor = vec4(result);\n}`\n\nfunction getMaskTexelAndBinarizeAlphaCodeSegment(\n  maskTextureID: string,\n  maskTexelID: string,\n  processor: ArProcessor\n) {\n  // get mask texel and binarize texel alpha value\n  const threshold = processor.threshold == null ? 0.0 : processor.threshold\n  return `\n    vec4 ${maskTexelID} = texture2D(${maskTextureID}, vUv);\n    ${maskTexelID}.a = ${maskTexelID}.a >= ${threshold.toPrecision(\n    2\n  )} ? 1.0 : 0.0;\n`\n}\n\ninterface ArMixerParams {\n  three: typeof THREE\n  processors: ArProcessor[]\n  cameraTexture: THREE.Texture\n  modelTexture: THREE.Texture\n  mixedTextureWidth: number\n  mixedTextureHeight: number\n}\n\ninterface RenderParams {\n  renderer: THREE.WebGLRenderer\n}\n\nfunction getFsCodeAndShaderUniforms(\n  cameraTexture: THREE.Texture,\n  modelTexture: THREE.Texture,\n  processors: ArProcessor[]\n) {\n  let fsDeclareMaskTexture: string = ''\n\n  let fsRemoveMaskProcessCodeSegment: string = ''\n  let fsRevealMaskProcessCodeSegment: string = ''\n\n  const shaderUniforms: { [uniform: string]: THREE.IUniform } = {\n    texCamera: { value: cameraTexture },\n    texModel: { value: modelTexture },\n  }\n\n  const revealMaskTexelIDs: string[] = []\n  const removeMaskTexelIDs: string[] = []\n\n  for (let i = 0; i < processors.length; i++) {\n    const { maskTextures, maskType } = processors[i]\n    if (maskTextures == null) continue\n    if (maskType == null) continue\n\n    // get arXxxxProcessor from ArXxxxProcessor and use it in shader\n    const processorName = `${processors[\n      i\n    ].name[0].toLocaleLowerCase()}${processors[i].name.slice(1)}`\n\n    for (let j = 0; j < maskTextures.length; j++) {\n      const maskTextureID = `${processorName}MaskTextures${String(j)}`\n      const maskTexelID = `${processorName}MaskTexel${String(j)}`\n\n      // add maskTexture to shader uniform\n      fsDeclareMaskTexture += `uniform sampler2D ${maskTextureID};\\n`\n      shaderUniforms[maskTextureID] = { value: maskTextures[j] }\n\n      // add all maskTexel\n      switch (maskType) {\n        case MaskType.remove:\n          fsRemoveMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          removeMaskTexelIDs.push(maskTexelID)\n          break\n        case MaskType.reveal:\n          fsRevealMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          revealMaskTexelIDs.push(maskTexelID)\n          break\n      }\n    }\n  }\n\n  if (removeMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    removeMaskTexel = ${removeMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRemoveMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REMOVE_PROCESSOR}`\n  }\n  if (revealMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    revealMaskTexel = ${revealMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRevealMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REVEAL_PROCESSOR}`\n  }\n\n  const fsCode =\n    fsDeclareMaskTexture +\n    FS_CODE_HEADER +\n    fsRemoveMaskProcessCodeSegment +\n    fsRevealMaskProcessCodeSegment +\n    FS_CODE_FOOTER\n\n  return { shaderUniforms, fsCode }\n}\n\nexport class ArMixer {\n  private mixedRenderTarget: THREE.WebGLRenderTarget\n  private maskScene: THREE.Scene\n  private maskCamera: THREE.OrthographicCamera\n  private three: typeof THREE\n\n  public mixedTexture: THREE.Texture\n  public processors: ArProcessor[]\n\n  constructor({\n    three,\n    processors,\n    cameraTexture,\n    modelTexture,\n    mixedTextureWidth,\n    mixedTextureHeight,\n  }: ArMixerParams) {\n    this.three = three\n    this.processors = processors\n\n    const shaderUniformsFsCodeData = getFsCodeAndShaderUniforms(\n      cameraTexture,\n      modelTexture,\n      this.processors\n    )\n\n    const mixedShaderMaterial = new this.three.ShaderMaterial({\n      uniforms: shaderUniformsFsCodeData.shaderUniforms,\n      vertexShader: VS_CODE_TEMPLATE,\n      fragmentShader: shaderUniformsFsCodeData.fsCode,\n    })\n\n    const planeGeometry = new this.three.PlaneGeometry(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n    this.mixedRenderTarget = new this.three.WebGLRenderTarget(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n\n    const maskPlane = new this.three.Mesh(planeGeometry, mixedShaderMaterial)\n    maskPlane.position.z = -10\n    this.maskScene = new this.three.Scene()\n    this.maskScene.add(maskPlane)\n\n    this.maskCamera = new this.three.OrthographicCamera(\n      mixedTextureWidth / -2,\n      mixedTextureWidth / 2,\n      mixedTextureHeight / 2,\n      mixedTextureHeight / -2,\n      1,\n      1000\n    )\n\n    this.mixedTexture = this.mixedRenderTarget.texture\n  }\n\n  public render({ renderer }: RenderParams) {\n    const originRenderTarget = renderer.getRenderTarget()\n    renderer.setRenderTarget(this.mixedRenderTarget)\n    renderer.render(this.maskScene, this.maskCamera)\n    renderer.setRenderTarget(originRenderTarget)\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\nimport { Rect, PointArray } from './Utils/base_type'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n\ninterface SingleNailKeypointResult {\n  nailRect: Rect\n  keyPoints: PointArray\n  nailType: number\n}\n\ninterface NailMaskResult {\n  width: number\n  height: number\n  nailNum: number\n  nailMask: Uint8Array\n}\n\ninterface NailAlgResult {\n  nailMaskResult: NailMaskResult\n  nailKeypointResults: SingleNailKeypointResult[]\n}\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\n// Get the area and centroid of the triangle, used to calculate the centroid of the nail polygon\ninterface GetTriangleAreaAndCentroidParams {\n  p0: Point\n  p1: Point\n  p2: Point\n}\n\ninterface GetNailPolygonCentroidParams {\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n}\n\ninterface UpdateNailModelParams {\n  nailModel: THREE.Mesh\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\ninterface UpdateNailModelGroupParams {\n  nailModelGroup: THREE.Group\n  algResult: NailAlgResult\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\nfunction getTriangleAreaAndCentroid({\n  p0,\n  p1,\n  p2,\n}: GetTriangleAreaAndCentroidParams) {\n  const x1 = Math.abs(p0.x - p2.x)\n  const x2 = Math.abs(p1.x - p2.x)\n\n  const y1 = Math.abs(p0.y - p2.y)\n  const y2 = Math.abs(p1.y - p2.y)\n\n  const triangleArea = 0.5 * Math.abs(x1 * y2 - x2 * y1)\n\n  const triangleCenterX = (p2.x + p0.x + p1.x) / 3\n  const triangleCenterY = (p2.y + p0.y + p1.y) / 3\n\n  return {\n    area: triangleArea,\n    centroid: {\n      x: triangleCenterX,\n      y: triangleCenterY,\n    },\n  }\n}\n\nfunction getNailPolygonCentroid({\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n}: GetNailPolygonCentroidParams) {\n  const tempPointArray = new Array()\n  const fixPoint = {\n    x: keyPoints.get(7).x * cameraWidth - cameraWidth / 2,\n    y: keyPoints.get(7).y * cameraHeight - cameraHeight / 2,\n    z: -10,\n  }\n  let result\n  let nailArea = 0\n  let nailCentroidX = 0\n  let nailCentroidY = 0\n\n  for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n    const point = keyPoints.get(i)\n\n    tempPointArray.push({\n      x: point.x * cameraWidth - cameraWidth / 2,\n      y: point.y * cameraHeight - cameraHeight / 2,\n      z: -10,\n    })\n\n    if (i > 0 && i !== 7) {\n      result = getTriangleAreaAndCentroid({\n        p0: tempPointArray[i - 1],\n        p1: tempPointArray[i],\n        p2: fixPoint,\n      })\n      nailArea += result.area\n      nailCentroidX += result.centroid.x * result.area\n      nailCentroidY += result.centroid.y * result.area\n    }\n  }\n  nailCentroidX /= nailArea\n  nailCentroidY /= nailArea\n  return {\n    x: nailCentroidX,\n    y: nailCentroidY,\n  }\n}\n\nfunction updateNailModel({\n  nailModel,\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelParams): void {\n  const nailCentroid = getNailPolygonCentroid({\n    keyPoints,\n    cameraWidth,\n    cameraHeight,\n  })\n\n  const positionArray = new Float32Array(\n    nailModel.geometry.attributes.position.array.length\n  )\n\n  // move nail convex polygon vertices so that the convex polygon wraps the nail\n  if (nailModel.geometry.attributes.position instanceof THREE.BufferAttribute) {\n    for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n      const point = {\n        x: keyPoints.get(i).x * cameraWidth - cameraWidth / 2,\n        y: keyPoints.get(i).y * cameraHeight - cameraHeight / 2,\n      }\n      const offsetX = point.x - nailCentroid.x\n      const offsetY = point.y - nailCentroid.y\n      positionArray[i * 3] = point.x + 0.2 * offsetX\n      positionArray[i * 3 + 1] = point.y + 0.2 * offsetY\n      positionArray[i * 3 + 2] = -10\n    }\n    nailModel.geometry.attributes.position.array = positionArray\n  }\n\n  nailModel.visible = true\n  nailModel.geometry.attributes.position.needsUpdate = true\n}\n\nfunction updateNailModelGroup({\n  algResult,\n  nailModelGroup,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelGroupParams) {\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.children[i].visible = false\n  }\n  for (let i = 0; i < algResult.nailMaskResult.nailNum; i++) {\n    const nailType = algResult.nailKeypointResults[i].nailType - 1\n    const { keyPoints } = algResult.nailKeypointResults[i]\n    if (nailType < 0) continue\n    updateNailModel({\n      nailModel: nailModelGroup.children[nailType] as THREE.Mesh,\n      keyPoints,\n      cameraWidth,\n      cameraHeight,\n      THREE,\n    })\n  }\n}\n\ninterface ArNailProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: NailAlgResult\n  models: THREE.Group\n  cameraWidth: number\n  cameraHeight: number\n}\n\nexport class ArNailProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.reveal\n\n  constructor({ three }: ArNailProcessorParams) {\n    this.name = 'ArNailProcessor'\n    this.three = three\n    this.threshold = 0.5\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n    this.maskTextures[0].needsUpdate = true\n  }\n\n  public updateModels({\n    algResult,\n    models,\n    cameraWidth,\n    cameraHeight,\n  }: UpdateModelsParams) {\n    if (algResult == null) {\n      return\n    }\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.nailMaskResult.nailMask,\n          algResult.nailMaskResult.width,\n          algResult.nailMaskResult.height,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.nailMaskResult.nailMask)\n    }\n    this.maskTextures[0].needsUpdate = true\n\n    updateNailModelGroup({\n      algResult,\n      nailModelGroup: models,\n      cameraWidth,\n      cameraHeight,\n      THREE: this.three,\n    })\n  }\n}\n","import type THREE from 'three'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n// Texture Coordinates used to generate highlights\nconst NAIL_UV_ARRAY = new Float32Array([\n  1 / 6,\n  1 / 4,\n  7 / 24,\n  1 / 8,\n  1 / 2,\n  1 / 12,\n  17 / 24,\n  1 / 8,\n  5 / 6,\n  1 / 4,\n  17 / 24,\n  5 / 6,\n  1 / 2,\n  11 / 12,\n  7 / 24,\n  5 / 6,\n])\nconst HIGHLIGHT_TEXTURE_WIDTH = 512\nconst HIGHLIGHT_TEXTURE_HEIGHT = 512\n// Index used to generate highlight polygon\nconst HIGHLIGHT_GEOMETRY_INDEX = [0, 1, 4, 1, 2, 4, 2, 3, 4]\n// Index used to generate nail polygon\nconst NAIL_GEOMETRY_INDEX = [\n  7, 0, 6, 0, 1, 6, 1, 2, 6, 2, 3, 6, 3, 4, 6, 4, 5, 6,\n]\n\ninterface GetHighLightTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color\n}\n\ninterface GetNailModelParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\ninterface GetNailModelGroupParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\nfunction getHighLightTexture({\n  THREE,\n  renderer,\n  color,\n}: GetHighLightTextureParams) {\n  // Highlight polygon\n  const highLightVertices = new Float32Array([\n    -0.17 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.25 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.07 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.03 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.16 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.22 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.14 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.02 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n  ])\n  const highLightScene = new THREE.Scene()\n  const highLightCamera = new THREE.OrthographicCamera(\n    HIGHLIGHT_TEXTURE_WIDTH / -2,\n    HIGHLIGHT_TEXTURE_WIDTH / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / -2,\n    1,\n    1000\n  )\n  const highLightRenderTarget = new THREE.WebGLRenderTarget(\n    HIGHLIGHT_TEXTURE_WIDTH,\n    HIGHLIGHT_TEXTURE_HEIGHT\n  )\n  const highLightGeometry = new THREE.BufferGeometry()\n  highLightGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(highLightVertices, 3)\n  )\n  highLightGeometry.setIndex(HIGHLIGHT_GEOMETRY_INDEX)\n  const highLightMaterial = new THREE.MeshBasicMaterial({\n    color: new THREE.Color(0xffffff),\n  })\n\n  const highLightModel = new THREE.Mesh(highLightGeometry, highLightMaterial)\n  highLightModel.position.z = -10\n\n  // set nail color\n  highLightScene.add(highLightModel)\n  renderer.setRenderTarget(highLightRenderTarget)\n  const originColor = new THREE.Color()\n  renderer.getClearColor(originColor)\n  renderer.setClearColor(color)\n  renderer.render(highLightScene, highLightCamera)\n  renderer.setClearColor(originColor, renderer.getClearAlpha())\n  renderer.setRenderTarget(null)\n\n  return highLightRenderTarget.texture\n}\n\nfunction getNailModel({ THREE, highLightTexture }: GetNailModelParams) {\n  const nailVSCode = `\n    varying vec2 vUv;\n\n    void main()\n    {\n        vUv = uv;\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n  `\n\n  const nailFSCode = `\n    uniform sampler2D highLightTexture;\n\n    varying vec2 vUv;\n    void main(void) {\n        vec4 tex = texture2D(highLightTexture, vUv);\n        gl_FragColor = vec4(tex.r, tex.g, tex.b, 1.0);\n    }\n  `\n  const nailKeyPointsConponentCount = 3\n  const positionArray = new Float32Array(\n    nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT\n  )\n\n  for (\n    let i = 0;\n    i < nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT;\n    i++\n  ) {\n    positionArray[i] = i\n  }\n  const nailGeometry = new THREE.BufferGeometry()\n  nailGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(positionArray, nailKeyPointsConponentCount)\n  )\n  nailGeometry.setAttribute('uv', new THREE.BufferAttribute(NAIL_UV_ARRAY, 2))\n  nailGeometry.setIndex(NAIL_GEOMETRY_INDEX)\n\n  const nailShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      highLightTexture: { value: highLightTexture },\n    },\n    vertexShader: nailVSCode,\n    fragmentShader: nailFSCode,\n  })\n  nailShaderMaterial.side = THREE.DoubleSide\n\n  return new THREE.Mesh(nailGeometry, nailShaderMaterial)\n}\n\nfunction getNailModelGroup({\n  THREE,\n  highLightTexture,\n}: GetNailModelGroupParams) {\n  const nailModelGroup = new THREE.Group()\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.add(getNailModel({ THREE, highLightTexture }))\n  }\n  return nailModelGroup\n}\n\ninterface GetNailModelGroupByColorParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color | string | number\n}\n\ninterface GetNailModelGroupByTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  texture: THREE.Texture\n}\n\nconst ArNailUtils = {\n  getNailModelGroupByColor: ({\n    THREE,\n    renderer,\n    color,\n  }: GetNailModelGroupByColorParams) => {\n    if (!(color instanceof THREE.Color)) {\n      color = new THREE.Color(color)\n    }\n    const highLightTexture = getHighLightTexture({ THREE, renderer, color })\n    const nailModelGroup = getNailModelGroup({ THREE, highLightTexture })\n    return nailModelGroup\n  },\n\n  getNailModelGroupByTexture: ({\n    THREE,\n    texture,\n  }: GetNailModelGroupByTextureParams) => {\n    const nailModelGroup = getNailModelGroup({\n      THREE,\n      highLightTexture: texture,\n    })\n    return nailModelGroup\n  },\n}\n\nexport { ArNailUtils }\n"],"mappings":"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","ignoreList":[]}