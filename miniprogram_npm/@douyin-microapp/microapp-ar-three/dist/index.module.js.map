{"version":3,"file":"node_modules/@douyin-microapp/microapp-ar-three/dist/index.module.js","names":["MaskType","ArFootProcessor","t","three","name","maskTextures","threshold","this","maskType","remove","DataTexture","Uint8Array","AlphaFormat","r","prototype","updateMesh","matrix","mesh","position","Vector3","quaternion","Quaternion","scale","trs","Matrix4","i","length","elements","decompose","copy","updateModels","e","algResult","models","left","visible","right","image","width","leftMask","maskWidth","maskHeight","rightMask","data","set","needsUpdate","getMaskTexelAndBinarizeAlphaCodeSegment","maskTextureID","maskTexelID","processor","toPrecision","ArMixer","processors","cameraTexture","modelTexture","mixedTextureWidth","mixedTextureHeight","mixedRenderTarget","maskScene","maskCamera","mixedTexture","shaderUniformsFsCodeData","fsDeclareMaskTexture","fsRemoveMaskProcessCodeSegment","fsRevealMaskProcessCodeSegment","shaderUniforms","texCamera","value","texModel","revealMaskTexelIDs","removeMaskTexelIDs","d","processorName","toLocaleLowerCase","slice","j","String","push","reveal","join","addAllTexelCode","fsCode","mixedShaderMaterial","ShaderMaterial","uniforms","vertexShader","fragmentShader","planeGeometry","PlaneGeometry","WebGLRenderTarget","maskPlane","Mesh","z","Scene","add","OrthographicCamera","texture","render","renderer","originRenderTarget","getRenderTarget","setRenderTarget","updateNailModel","nailModel","keyPoints","cameraWidth","cameraHeight","THREE","nailCentroid","result","p0","p1","p2","x1","x2","y1","y2","tempPointArray","Array","fixPoint","x","get","y","nailArea","nailCentroidX","nailCentroidY","point","Math","abs","area","centroid","positionArray","Float32Array","geometry","attributes","array","BufferAttribute","offsetY","ArNailProcessor","nailMaskResult","nailMask","height","nailModelGroup","children","nailNum","nailType","nailKeypointResults","NAIL_UV_ARRAY","HIGHLIGHT_GEOMETRY_INDEX","NAIL_GEOMETRY_INDEX","getNailModel","highLightTexture","nailKeyPointsConponentCount","nailGeometry","BufferGeometry","setAttribute","setIndex","nailShaderMaterial","side","DoubleSide","getNailModelGroup","Group","ArNailUtils","getNailModelGroupByColor","color","Color","highLightVertices","highLightScene","highLightCamera","HIGHLIGHT_TEXTURE_WIDTH","HIGHLIGHT_TEXTURE_HEIGHT","highLightRenderTarget","highLightGeometry","highLightMaterial","MeshBasicMaterial","highLightModel","originColor","getClearColor","setClearColor","getClearAlpha","getNailModelGroupByTexture"],"sources":["../src/ArProcessor.ts","../src/ArFootProcessor.ts","../src/ArMixer.ts","../src/ArNailProcessor.ts","../src/Utils/ArNailUtils.ts"],"sourcesContent":["export enum MaskType {\n  remove = 0,\n  reveal = 1,\n}\n\nexport interface ArProcessor {\n  name: string\n\n  maskTextures?: THREE.DataTexture[]\n  maskType?: MaskType\n  threshold?: number\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\ninterface FootAlgResult {\n  left: number[][]\n  right: number[][]\n  leftMask: Uint8Array\n  rightMask: Uint8Array\n  maskWidth: number\n  maskHeight: number\n}\n\ninterface FootModels {\n  left: THREE.Object3D\n  right: THREE.Object3D\n}\n\ninterface ArFootProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: FootAlgResult\n  models: FootModels\n}\n\nexport class ArFootProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.remove\n\n  constructor({ three }: ArFootProcessorParams) {\n    this.name = 'ArFootProcessor'\n    this.three = three\n    this.threshold = 1.0\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n  }\n\n  private updateMesh(matrix: number[], mesh: THREE.Object3D) {\n    const position = new this.three.Vector3()\n    const quaternion = new this.three.Quaternion()\n    const scale = new this.three.Vector3(1, 1, 1)\n    const trs = new this.three.Matrix4()\n    for (let i = 0; i < matrix.length; i++) {\n      trs.elements[i] = matrix[i]\n    }\n    trs.decompose(position, quaternion, scale)\n\n    mesh.position.copy(position)\n    mesh.scale.copy(scale)\n    mesh.quaternion.copy(quaternion)\n  }\n\n  public updateModels({ algResult, models }: UpdateModelsParams) {\n    if (algResult == null) {\n      models['left'].visible = false\n      models['right'].visible = false\n      return\n    }\n    if (algResult.left.length !== 0) {\n      this.updateMesh(algResult.left[0], models['left'])\n      models['left'].visible = true\n    } else {\n      models['left'].visible = false\n    }\n    if (algResult.right.length !== 0) {\n      this.updateMesh(algResult.right[0], models['right'])\n      models['right'].visible = true\n    } else {\n      models['right'].visible = false\n    }\n\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.leftMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n      this.maskTextures[1].copy(\n        new this.three.DataTexture(\n          algResult.rightMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.leftMask)\n      this.maskTextures[1].image.data.set(algResult.rightMask)\n    }\n\n    this.maskTextures[0].needsUpdate = true\n    this.maskTextures[1].needsUpdate = true\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\n\nconst VS_CODE_TEMPLATE = `\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\nconst FS_CODE_HEADER = `\nuniform sampler2D texModel;\nuniform sampler2D texCamera;\n\nvarying vec2 vUv;\nvoid main(void) {\n    vec4 model = texture2D(texModel, vUv);\n    vec4 camera = texture2D(texCamera, vUv);\n    vec4 result = camera;\n\n    vec4 removeMaskTexel;\n    vec4 revealMaskTexel;\n\n`\nconst FS_CODE_REMOVE_PROCESSOR = `\n    if(removeMaskTexel.a >= 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\nconst FS_CODE_REVEAL_PROCESSOR = `\n    if(revealMaskTexel.a < 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\n\nconst FS_CODE_FOOTER = `\n    gl_FragColor = vec4(result);\n}`\n\nfunction getMaskTexelAndBinarizeAlphaCodeSegment(\n  maskTextureID: string,\n  maskTexelID: string,\n  processor: ArProcessor\n) {\n  // get mask texel and binarize texel alpha value\n  const threshold = processor.threshold == null ? 0.0 : processor.threshold\n  return `\n    vec4 ${maskTexelID} = texture2D(${maskTextureID}, vUv);\n    ${maskTexelID}.a = ${maskTexelID}.a >= ${threshold.toPrecision(\n    2\n  )} ? 1.0 : 0.0;\n`\n}\n\ninterface ArMixerParams {\n  three: typeof THREE\n  processors: ArProcessor[]\n  cameraTexture: THREE.Texture\n  modelTexture: THREE.Texture\n  mixedTextureWidth: number\n  mixedTextureHeight: number\n}\n\ninterface RenderParams {\n  renderer: THREE.WebGLRenderer\n}\n\nfunction getFsCodeAndShaderUniforms(\n  cameraTexture: THREE.Texture,\n  modelTexture: THREE.Texture,\n  processors: ArProcessor[]\n) {\n  let fsDeclareMaskTexture: string = ''\n\n  let fsRemoveMaskProcessCodeSegment: string = ''\n  let fsRevealMaskProcessCodeSegment: string = ''\n\n  const shaderUniforms: { [uniform: string]: THREE.IUniform } = {\n    texCamera: { value: cameraTexture },\n    texModel: { value: modelTexture },\n  }\n\n  const revealMaskTexelIDs: string[] = []\n  const removeMaskTexelIDs: string[] = []\n\n  for (let i = 0; i < processors.length; i++) {\n    const { maskTextures, maskType } = processors[i]\n    if (maskTextures == null) continue\n    if (maskType == null) continue\n\n    // get arXxxxProcessor from ArXxxxProcessor and use it in shader\n    const processorName = `${processors[\n      i\n    ].name[0].toLocaleLowerCase()}${processors[i].name.slice(1)}`\n\n    for (let j = 0; j < maskTextures.length; j++) {\n      const maskTextureID = `${processorName}MaskTextures${String(j)}`\n      const maskTexelID = `${processorName}MaskTexel${String(j)}`\n\n      // add maskTexture to shader uniform\n      fsDeclareMaskTexture += `uniform sampler2D ${maskTextureID};\\n`\n      shaderUniforms[maskTextureID] = { value: maskTextures[j] }\n\n      // add all maskTexel\n      switch (maskType) {\n        case MaskType.remove:\n          fsRemoveMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          removeMaskTexelIDs.push(maskTexelID)\n          break\n        case MaskType.reveal:\n          fsRevealMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          revealMaskTexelIDs.push(maskTexelID)\n          break\n      }\n    }\n  }\n\n  if (removeMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    removeMaskTexel = ${removeMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRemoveMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REMOVE_PROCESSOR}`\n  }\n  if (revealMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    revealMaskTexel = ${revealMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRevealMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REVEAL_PROCESSOR}`\n  }\n\n  const fsCode =\n    fsDeclareMaskTexture +\n    FS_CODE_HEADER +\n    fsRemoveMaskProcessCodeSegment +\n    fsRevealMaskProcessCodeSegment +\n    FS_CODE_FOOTER\n\n  return { shaderUniforms, fsCode }\n}\n\nexport class ArMixer {\n  private mixedRenderTarget: THREE.WebGLRenderTarget\n  private maskScene: THREE.Scene\n  private maskCamera: THREE.OrthographicCamera\n  private three: typeof THREE\n\n  public mixedTexture: THREE.Texture\n  public processors: ArProcessor[]\n\n  constructor({\n    three,\n    processors,\n    cameraTexture,\n    modelTexture,\n    mixedTextureWidth,\n    mixedTextureHeight,\n  }: ArMixerParams) {\n    this.three = three\n    this.processors = processors\n\n    const shaderUniformsFsCodeData = getFsCodeAndShaderUniforms(\n      cameraTexture,\n      modelTexture,\n      this.processors\n    )\n\n    const mixedShaderMaterial = new this.three.ShaderMaterial({\n      uniforms: shaderUniformsFsCodeData.shaderUniforms,\n      vertexShader: VS_CODE_TEMPLATE,\n      fragmentShader: shaderUniformsFsCodeData.fsCode,\n    })\n\n    const planeGeometry = new this.three.PlaneGeometry(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n    this.mixedRenderTarget = new this.three.WebGLRenderTarget(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n\n    const maskPlane = new this.three.Mesh(planeGeometry, mixedShaderMaterial)\n    maskPlane.position.z = -10\n    this.maskScene = new this.three.Scene()\n    this.maskScene.add(maskPlane)\n\n    this.maskCamera = new this.three.OrthographicCamera(\n      mixedTextureWidth / -2,\n      mixedTextureWidth / 2,\n      mixedTextureHeight / 2,\n      mixedTextureHeight / -2,\n      1,\n      1000\n    )\n\n    this.mixedTexture = this.mixedRenderTarget.texture\n  }\n\n  public render({ renderer }: RenderParams) {\n    const originRenderTarget = renderer.getRenderTarget()\n    renderer.setRenderTarget(this.mixedRenderTarget)\n    renderer.render(this.maskScene, this.maskCamera)\n    renderer.setRenderTarget(originRenderTarget)\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\nimport { Rect, PointArray } from './Utils/base_type'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n\ninterface SingleNailKeypointResult {\n  nailRect: Rect\n  keyPoints: PointArray\n  nailType: number\n}\n\ninterface NailMaskResult {\n  width: number\n  height: number\n  nailNum: number\n  nailMask: Uint8Array\n}\n\ninterface NailAlgResult {\n  nailMaskResult: NailMaskResult\n  nailKeypointResults: SingleNailKeypointResult[]\n}\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\n// Get the area and centroid of the triangle, used to calculate the centroid of the nail polygon\ninterface GetTriangleAreaAndCentroidParams {\n  p0: Point\n  p1: Point\n  p2: Point\n}\n\ninterface GetNailPolygonCentroidParams {\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n}\n\ninterface UpdateNailModelParams {\n  nailModel: THREE.Mesh\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\ninterface UpdateNailModelGroupParams {\n  nailModelGroup: THREE.Group\n  algResult: NailAlgResult\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\nfunction getTriangleAreaAndCentroid({\n  p0,\n  p1,\n  p2,\n}: GetTriangleAreaAndCentroidParams) {\n  const x1 = Math.abs(p0.x - p2.x)\n  const x2 = Math.abs(p1.x - p2.x)\n\n  const y1 = Math.abs(p0.y - p2.y)\n  const y2 = Math.abs(p1.y - p2.y)\n\n  const triangleArea = 0.5 * Math.abs(x1 * y2 - x2 * y1)\n\n  const triangleCenterX = (p2.x + p0.x + p1.x) / 3\n  const triangleCenterY = (p2.y + p0.y + p1.y) / 3\n\n  return {\n    area: triangleArea,\n    centroid: {\n      x: triangleCenterX,\n      y: triangleCenterY,\n    },\n  }\n}\n\nfunction getNailPolygonCentroid({\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n}: GetNailPolygonCentroidParams) {\n  const tempPointArray = new Array()\n  const fixPoint = {\n    x: keyPoints.get(7).x * cameraWidth - cameraWidth / 2,\n    y: keyPoints.get(7).y * cameraHeight - cameraHeight / 2,\n    z: -10,\n  }\n  let result\n  let nailArea = 0\n  let nailCentroidX = 0\n  let nailCentroidY = 0\n\n  for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n    const point = keyPoints.get(i)\n\n    tempPointArray.push({\n      x: point.x * cameraWidth - cameraWidth / 2,\n      y: point.y * cameraHeight - cameraHeight / 2,\n      z: -10,\n    })\n\n    if (i > 0 && i !== 7) {\n      result = getTriangleAreaAndCentroid({\n        p0: tempPointArray[i - 1],\n        p1: tempPointArray[i],\n        p2: fixPoint,\n      })\n      nailArea += result.area\n      nailCentroidX += result.centroid.x * result.area\n      nailCentroidY += result.centroid.y * result.area\n    }\n  }\n  nailCentroidX /= nailArea\n  nailCentroidY /= nailArea\n  return {\n    x: nailCentroidX,\n    y: nailCentroidY,\n  }\n}\n\nfunction updateNailModel({\n  nailModel,\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelParams): void {\n  const nailCentroid = getNailPolygonCentroid({\n    keyPoints,\n    cameraWidth,\n    cameraHeight,\n  })\n\n  const positionArray = new Float32Array(\n    nailModel.geometry.attributes.position.array.length\n  )\n\n  // move nail convex polygon vertices so that the convex polygon wraps the nail\n  if (nailModel.geometry.attributes.position instanceof THREE.BufferAttribute) {\n    for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n      const point = {\n        x: keyPoints.get(i).x * cameraWidth - cameraWidth / 2,\n        y: keyPoints.get(i).y * cameraHeight - cameraHeight / 2,\n      }\n      const offsetX = point.x - nailCentroid.x\n      const offsetY = point.y - nailCentroid.y\n      positionArray[i * 3] = point.x + 0.2 * offsetX\n      positionArray[i * 3 + 1] = point.y + 0.2 * offsetY\n      positionArray[i * 3 + 2] = -10\n    }\n    nailModel.geometry.attributes.position.array = positionArray\n  }\n\n  nailModel.visible = true\n  nailModel.geometry.attributes.position.needsUpdate = true\n}\n\nfunction updateNailModelGroup({\n  algResult,\n  nailModelGroup,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelGroupParams) {\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.children[i].visible = false\n  }\n  for (let i = 0; i < algResult.nailMaskResult.nailNum; i++) {\n    const nailType = algResult.nailKeypointResults[i].nailType - 1\n    const { keyPoints } = algResult.nailKeypointResults[i]\n    if (nailType < 0) continue\n    updateNailModel({\n      nailModel: nailModelGroup.children[nailType] as THREE.Mesh,\n      keyPoints,\n      cameraWidth,\n      cameraHeight,\n      THREE,\n    })\n  }\n}\n\ninterface ArNailProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: NailAlgResult\n  models: THREE.Group\n  cameraWidth: number\n  cameraHeight: number\n}\n\nexport class ArNailProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.reveal\n\n  constructor({ three }: ArNailProcessorParams) {\n    this.name = 'ArNailProcessor'\n    this.three = three\n    this.threshold = 0.5\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n    this.maskTextures[0].needsUpdate = true\n  }\n\n  public updateModels({\n    algResult,\n    models,\n    cameraWidth,\n    cameraHeight,\n  }: UpdateModelsParams) {\n    if (algResult == null) {\n      return\n    }\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.nailMaskResult.nailMask,\n          algResult.nailMaskResult.width,\n          algResult.nailMaskResult.height,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.nailMaskResult.nailMask)\n    }\n    this.maskTextures[0].needsUpdate = true\n\n    updateNailModelGroup({\n      algResult,\n      nailModelGroup: models,\n      cameraWidth,\n      cameraHeight,\n      THREE: this.three,\n    })\n  }\n}\n","import type THREE from 'three'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n// Texture Coordinates used to generate highlights\nconst NAIL_UV_ARRAY = new Float32Array([\n  1 / 6,\n  1 / 4,\n  7 / 24,\n  1 / 8,\n  1 / 2,\n  1 / 12,\n  17 / 24,\n  1 / 8,\n  5 / 6,\n  1 / 4,\n  17 / 24,\n  5 / 6,\n  1 / 2,\n  11 / 12,\n  7 / 24,\n  5 / 6,\n])\nconst HIGHLIGHT_TEXTURE_WIDTH = 512\nconst HIGHLIGHT_TEXTURE_HEIGHT = 512\n// Index used to generate highlight polygon\nconst HIGHLIGHT_GEOMETRY_INDEX = [0, 1, 4, 1, 2, 4, 2, 3, 4]\n// Index used to generate nail polygon\nconst NAIL_GEOMETRY_INDEX = [\n  7, 0, 6, 0, 1, 6, 1, 2, 6, 2, 3, 6, 3, 4, 6, 4, 5, 6,\n]\n\ninterface GetHighLightTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color\n}\n\ninterface GetNailModelParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\ninterface GetNailModelGroupParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\nfunction getHighLightTexture({\n  THREE,\n  renderer,\n  color,\n}: GetHighLightTextureParams) {\n  // Highlight polygon\n  const highLightVertices = new Float32Array([\n    -0.17 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.25 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.07 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.03 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.16 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.22 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.14 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.02 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n  ])\n  const highLightScene = new THREE.Scene()\n  const highLightCamera = new THREE.OrthographicCamera(\n    HIGHLIGHT_TEXTURE_WIDTH / -2,\n    HIGHLIGHT_TEXTURE_WIDTH / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / -2,\n    1,\n    1000\n  )\n  const highLightRenderTarget = new THREE.WebGLRenderTarget(\n    HIGHLIGHT_TEXTURE_WIDTH,\n    HIGHLIGHT_TEXTURE_HEIGHT\n  )\n  const highLightGeometry = new THREE.BufferGeometry()\n  highLightGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(highLightVertices, 3)\n  )\n  highLightGeometry.setIndex(HIGHLIGHT_GEOMETRY_INDEX)\n  const highLightMaterial = new THREE.MeshBasicMaterial({\n    color: new THREE.Color(0xffffff),\n  })\n\n  const highLightModel = new THREE.Mesh(highLightGeometry, highLightMaterial)\n  highLightModel.position.z = -10\n\n  // set nail color\n  highLightScene.add(highLightModel)\n  renderer.setRenderTarget(highLightRenderTarget)\n  const originColor = new THREE.Color()\n  renderer.getClearColor(originColor)\n  renderer.setClearColor(color)\n  renderer.render(highLightScene, highLightCamera)\n  renderer.setClearColor(originColor, renderer.getClearAlpha())\n  renderer.setRenderTarget(null)\n\n  return highLightRenderTarget.texture\n}\n\nfunction getNailModel({ THREE, highLightTexture }: GetNailModelParams) {\n  const nailVSCode = `\n    varying vec2 vUv;\n\n    void main()\n    {\n        vUv = uv;\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n  `\n\n  const nailFSCode = `\n    uniform sampler2D highLightTexture;\n\n    varying vec2 vUv;\n    void main(void) {\n        vec4 tex = texture2D(highLightTexture, vUv);\n        gl_FragColor = vec4(tex.r, tex.g, tex.b, 1.0);\n    }\n  `\n  const nailKeyPointsConponentCount = 3\n  const positionArray = new Float32Array(\n    nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT\n  )\n\n  for (\n    let i = 0;\n    i < nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT;\n    i++\n  ) {\n    positionArray[i] = i\n  }\n  const nailGeometry = new THREE.BufferGeometry()\n  nailGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(positionArray, nailKeyPointsConponentCount)\n  )\n  nailGeometry.setAttribute('uv', new THREE.BufferAttribute(NAIL_UV_ARRAY, 2))\n  nailGeometry.setIndex(NAIL_GEOMETRY_INDEX)\n\n  const nailShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      highLightTexture: { value: highLightTexture },\n    },\n    vertexShader: nailVSCode,\n    fragmentShader: nailFSCode,\n  })\n  nailShaderMaterial.side = THREE.DoubleSide\n\n  return new THREE.Mesh(nailGeometry, nailShaderMaterial)\n}\n\nfunction getNailModelGroup({\n  THREE,\n  highLightTexture,\n}: GetNailModelGroupParams) {\n  const nailModelGroup = new THREE.Group()\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.add(getNailModel({ THREE, highLightTexture }))\n  }\n  return nailModelGroup\n}\n\ninterface GetNailModelGroupByColorParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color | string | number\n}\n\ninterface GetNailModelGroupByTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  texture: THREE.Texture\n}\n\nconst ArNailUtils = {\n  getNailModelGroupByColor: ({\n    THREE,\n    renderer,\n    color,\n  }: GetNailModelGroupByColorParams) => {\n    if (!(color instanceof THREE.Color)) {\n      color = new THREE.Color(color)\n    }\n    const highLightTexture = getHighLightTexture({ THREE, renderer, color })\n    const nailModelGroup = getNailModelGroup({ THREE, highLightTexture })\n    return nailModelGroup\n  },\n\n  getNailModelGroupByTexture: ({\n    THREE,\n    texture,\n  }: GetNailModelGroupByTextureParams) => {\n    const nailModelGroup = getNailModelGroup({\n      THREE,\n      highLightTexture: texture,\n    })\n    return nailModelGroup\n  },\n}\n\nexport { ArNailUtils }\n"],"mappings":"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","ignoreList":[]}