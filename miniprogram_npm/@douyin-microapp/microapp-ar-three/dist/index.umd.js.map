{"version":3,"file":"node_modules/@douyin-microapp/microapp-ar-three/dist/index.umd.js","names":["MaskType","ArFootProcessor","this","name","three","maskTextures","threshold","maskType","remove","DataTexture","Uint8Array","AlphaFormat","e","t","r","updateMesh","a","matrix","Quaternion","i","Vector3","quaternion","Matrix4","s","trs","elements","length","decompose","position","copy","updateModels","algResult","models","visible","left","right","width","image","maskHeight","leftMask","maskWidth","rightMask","data","needsUpdate","maskTextureID","maskTexelID","processor","toPrecision","ArMixer","cameraTexture","processors","mixedTextureWidth","mixedTextureHeight","mixedRenderTarget","maskScene","maskCamera","mixedTexture","h","shaderUniformsFsCodeData","texModel","value","fsRevealMaskProcessCodeSegment","l","shaderUniforms","texCamera","d","modelTexture","revealMaskTexelIDs","toLocaleLowerCase","processorName","g","String","j","fsDeclareMaskTexture","fsRemoveMaskProcessCodeSegment","getMaskTexelAndBinarizeAlphaCodeSegment","removeMaskTexelIDs","push","reveal","u","join","addAllTexelCode","mixedShaderMaterial","ShaderMaterial","vertexShader","fragmentShader","fsCode","PlaneGeometry","WebGLRenderTarget","maskPlane","Mesh","Scene","OrthographicCamera","texture","setRenderTarget","renderer","originRenderTarget","getRenderTarget","cameraWidth","nailModel","keyPoints","cameraHeight","THREE","nailCentroid","p0","p1","p2","tempPointArray","m","Array","fixPoint","x","get","f","p","y","z","v","nailCentroidX","T","nailCentroidY","point","c","Math","abs","y1","y2","nailArea","result","area","x1","x2","centroid","o","Float32Array","geometry","attributes","n","BufferAttribute","offsetY","positionArray","ArNailProcessor","nailMask","nailMaskResult","height","nailModelGroup","nailNum","nailType","nailKeypointResults","children","NAIL_UV_ARRAY","HIGHLIGHT_GEOMETRY_INDEX","highLightTexture","getNailModel","BufferGeometry","setAttribute","nailGeometry","uniforms","setIndex","nailShaderMaterial","side","DoubleSide","getNailModelGroup","Group","add","ArNailUtils","getNailModelGroupByColor","color","Color","highLightCamera","HIGHLIGHT_TEXTURE_WIDTH","HIGHLIGHT_TEXTURE_HEIGHT","highLightGeometry","highLightMaterial","MeshBasicMaterial","highLightModel","highLightRenderTarget","setClearColor","render","getClearColor","highLightScene","originColor","getClearAlpha","getNailModelGroupByTexture"],"sources":["../src/ArProcessor.ts","../src/ArFootProcessor.ts","../src/ArMixer.ts","../src/ArNailProcessor.ts","../src/Utils/ArNailUtils.ts"],"sourcesContent":["export enum MaskType {\n  remove = 0,\n  reveal = 1,\n}\n\nexport interface ArProcessor {\n  name: string\n\n  maskTextures?: THREE.DataTexture[]\n  maskType?: MaskType\n  threshold?: number\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\ninterface FootAlgResult {\n  left: number[][]\n  right: number[][]\n  leftMask: Uint8Array\n  rightMask: Uint8Array\n  maskWidth: number\n  maskHeight: number\n}\n\ninterface FootModels {\n  left: THREE.Object3D\n  right: THREE.Object3D\n}\n\ninterface ArFootProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: FootAlgResult\n  models: FootModels\n}\n\nexport class ArFootProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.remove\n\n  constructor({ three }: ArFootProcessorParams) {\n    this.name = 'ArFootProcessor'\n    this.three = three\n    this.threshold = 1.0\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n  }\n\n  private updateMesh(matrix: number[], mesh: THREE.Object3D) {\n    const position = new this.three.Vector3()\n    const quaternion = new this.three.Quaternion()\n    const scale = new this.three.Vector3(1, 1, 1)\n    const trs = new this.three.Matrix4()\n    for (let i = 0; i < matrix.length; i++) {\n      trs.elements[i] = matrix[i]\n    }\n    trs.decompose(position, quaternion, scale)\n\n    mesh.position.copy(position)\n    mesh.scale.copy(scale)\n    mesh.quaternion.copy(quaternion)\n  }\n\n  public updateModels({ algResult, models }: UpdateModelsParams) {\n    if (algResult == null) {\n      models['left'].visible = false\n      models['right'].visible = false\n      return\n    }\n    if (algResult.left.length !== 0) {\n      this.updateMesh(algResult.left[0], models['left'])\n      models['left'].visible = true\n    } else {\n      models['left'].visible = false\n    }\n    if (algResult.right.length !== 0) {\n      this.updateMesh(algResult.right[0], models['right'])\n      models['right'].visible = true\n    } else {\n      models['right'].visible = false\n    }\n\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.leftMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n      this.maskTextures[1].copy(\n        new this.three.DataTexture(\n          algResult.rightMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.leftMask)\n      this.maskTextures[1].image.data.set(algResult.rightMask)\n    }\n\n    this.maskTextures[0].needsUpdate = true\n    this.maskTextures[1].needsUpdate = true\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\n\nconst VS_CODE_TEMPLATE = `\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\nconst FS_CODE_HEADER = `\nuniform sampler2D texModel;\nuniform sampler2D texCamera;\n\nvarying vec2 vUv;\nvoid main(void) {\n    vec4 model = texture2D(texModel, vUv);\n    vec4 camera = texture2D(texCamera, vUv);\n    vec4 result = camera;\n\n    vec4 removeMaskTexel;\n    vec4 revealMaskTexel;\n\n`\nconst FS_CODE_REMOVE_PROCESSOR = `\n    if(removeMaskTexel.a >= 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\nconst FS_CODE_REVEAL_PROCESSOR = `\n    if(revealMaskTexel.a < 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\n\nconst FS_CODE_FOOTER = `\n    gl_FragColor = vec4(result);\n}`\n\nfunction getMaskTexelAndBinarizeAlphaCodeSegment(\n  maskTextureID: string,\n  maskTexelID: string,\n  processor: ArProcessor\n) {\n  // get mask texel and binarize texel alpha value\n  const threshold = processor.threshold == null ? 0.0 : processor.threshold\n  return `\n    vec4 ${maskTexelID} = texture2D(${maskTextureID}, vUv);\n    ${maskTexelID}.a = ${maskTexelID}.a >= ${threshold.toPrecision(\n    2\n  )} ? 1.0 : 0.0;\n`\n}\n\ninterface ArMixerParams {\n  three: typeof THREE\n  processors: ArProcessor[]\n  cameraTexture: THREE.Texture\n  modelTexture: THREE.Texture\n  mixedTextureWidth: number\n  mixedTextureHeight: number\n}\n\ninterface RenderParams {\n  renderer: THREE.WebGLRenderer\n}\n\nfunction getFsCodeAndShaderUniforms(\n  cameraTexture: THREE.Texture,\n  modelTexture: THREE.Texture,\n  processors: ArProcessor[]\n) {\n  let fsDeclareMaskTexture: string = ''\n\n  let fsRemoveMaskProcessCodeSegment: string = ''\n  let fsRevealMaskProcessCodeSegment: string = ''\n\n  const shaderUniforms: { [uniform: string]: THREE.IUniform } = {\n    texCamera: { value: cameraTexture },\n    texModel: { value: modelTexture },\n  }\n\n  const revealMaskTexelIDs: string[] = []\n  const removeMaskTexelIDs: string[] = []\n\n  for (let i = 0; i < processors.length; i++) {\n    const { maskTextures, maskType } = processors[i]\n    if (maskTextures == null) continue\n    if (maskType == null) continue\n\n    // get arXxxxProcessor from ArXxxxProcessor and use it in shader\n    const processorName = `${processors[\n      i\n    ].name[0].toLocaleLowerCase()}${processors[i].name.slice(1)}`\n\n    for (let j = 0; j < maskTextures.length; j++) {\n      const maskTextureID = `${processorName}MaskTextures${String(j)}`\n      const maskTexelID = `${processorName}MaskTexel${String(j)}`\n\n      // add maskTexture to shader uniform\n      fsDeclareMaskTexture += `uniform sampler2D ${maskTextureID};\\n`\n      shaderUniforms[maskTextureID] = { value: maskTextures[j] }\n\n      // add all maskTexel\n      switch (maskType) {\n        case MaskType.remove:\n          fsRemoveMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          removeMaskTexelIDs.push(maskTexelID)\n          break\n        case MaskType.reveal:\n          fsRevealMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          revealMaskTexelIDs.push(maskTexelID)\n          break\n      }\n    }\n  }\n\n  if (removeMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    removeMaskTexel = ${removeMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRemoveMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REMOVE_PROCESSOR}`\n  }\n  if (revealMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    revealMaskTexel = ${revealMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRevealMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REVEAL_PROCESSOR}`\n  }\n\n  const fsCode =\n    fsDeclareMaskTexture +\n    FS_CODE_HEADER +\n    fsRemoveMaskProcessCodeSegment +\n    fsRevealMaskProcessCodeSegment +\n    FS_CODE_FOOTER\n\n  return { shaderUniforms, fsCode }\n}\n\nexport class ArMixer {\n  private mixedRenderTarget: THREE.WebGLRenderTarget\n  private maskScene: THREE.Scene\n  private maskCamera: THREE.OrthographicCamera\n  private three: typeof THREE\n\n  public mixedTexture: THREE.Texture\n  public processors: ArProcessor[]\n\n  constructor({\n    three,\n    processors,\n    cameraTexture,\n    modelTexture,\n    mixedTextureWidth,\n    mixedTextureHeight,\n  }: ArMixerParams) {\n    this.three = three\n    this.processors = processors\n\n    const shaderUniformsFsCodeData = getFsCodeAndShaderUniforms(\n      cameraTexture,\n      modelTexture,\n      this.processors\n    )\n\n    const mixedShaderMaterial = new this.three.ShaderMaterial({\n      uniforms: shaderUniformsFsCodeData.shaderUniforms,\n      vertexShader: VS_CODE_TEMPLATE,\n      fragmentShader: shaderUniformsFsCodeData.fsCode,\n    })\n\n    const planeGeometry = new this.three.PlaneGeometry(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n    this.mixedRenderTarget = new this.three.WebGLRenderTarget(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n\n    const maskPlane = new this.three.Mesh(planeGeometry, mixedShaderMaterial)\n    maskPlane.position.z = -10\n    this.maskScene = new this.three.Scene()\n    this.maskScene.add(maskPlane)\n\n    this.maskCamera = new this.three.OrthographicCamera(\n      mixedTextureWidth / -2,\n      mixedTextureWidth / 2,\n      mixedTextureHeight / 2,\n      mixedTextureHeight / -2,\n      1,\n      1000\n    )\n\n    this.mixedTexture = this.mixedRenderTarget.texture\n  }\n\n  public render({ renderer }: RenderParams) {\n    const originRenderTarget = renderer.getRenderTarget()\n    renderer.setRenderTarget(this.mixedRenderTarget)\n    renderer.render(this.maskScene, this.maskCamera)\n    renderer.setRenderTarget(originRenderTarget)\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\nimport { Rect, PointArray } from './Utils/base_type'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n\ninterface SingleNailKeypointResult {\n  nailRect: Rect\n  keyPoints: PointArray\n  nailType: number\n}\n\ninterface NailMaskResult {\n  width: number\n  height: number\n  nailNum: number\n  nailMask: Uint8Array\n}\n\ninterface NailAlgResult {\n  nailMaskResult: NailMaskResult\n  nailKeypointResults: SingleNailKeypointResult[]\n}\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\n// Get the area and centroid of the triangle, used to calculate the centroid of the nail polygon\ninterface GetTriangleAreaAndCentroidParams {\n  p0: Point\n  p1: Point\n  p2: Point\n}\n\ninterface GetNailPolygonCentroidParams {\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n}\n\ninterface UpdateNailModelParams {\n  nailModel: THREE.Mesh\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\ninterface UpdateNailModelGroupParams {\n  nailModelGroup: THREE.Group\n  algResult: NailAlgResult\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\nfunction getTriangleAreaAndCentroid({\n  p0,\n  p1,\n  p2,\n}: GetTriangleAreaAndCentroidParams) {\n  const x1 = Math.abs(p0.x - p2.x)\n  const x2 = Math.abs(p1.x - p2.x)\n\n  const y1 = Math.abs(p0.y - p2.y)\n  const y2 = Math.abs(p1.y - p2.y)\n\n  const triangleArea = 0.5 * Math.abs(x1 * y2 - x2 * y1)\n\n  const triangleCenterX = (p2.x + p0.x + p1.x) / 3\n  const triangleCenterY = (p2.y + p0.y + p1.y) / 3\n\n  return {\n    area: triangleArea,\n    centroid: {\n      x: triangleCenterX,\n      y: triangleCenterY,\n    },\n  }\n}\n\nfunction getNailPolygonCentroid({\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n}: GetNailPolygonCentroidParams) {\n  const tempPointArray = new Array()\n  const fixPoint = {\n    x: keyPoints.get(7).x * cameraWidth - cameraWidth / 2,\n    y: keyPoints.get(7).y * cameraHeight - cameraHeight / 2,\n    z: -10,\n  }\n  let result\n  let nailArea = 0\n  let nailCentroidX = 0\n  let nailCentroidY = 0\n\n  for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n    const point = keyPoints.get(i)\n\n    tempPointArray.push({\n      x: point.x * cameraWidth - cameraWidth / 2,\n      y: point.y * cameraHeight - cameraHeight / 2,\n      z: -10,\n    })\n\n    if (i > 0 && i !== 7) {\n      result = getTriangleAreaAndCentroid({\n        p0: tempPointArray[i - 1],\n        p1: tempPointArray[i],\n        p2: fixPoint,\n      })\n      nailArea += result.area\n      nailCentroidX += result.centroid.x * result.area\n      nailCentroidY += result.centroid.y * result.area\n    }\n  }\n  nailCentroidX /= nailArea\n  nailCentroidY /= nailArea\n  return {\n    x: nailCentroidX,\n    y: nailCentroidY,\n  }\n}\n\nfunction updateNailModel({\n  nailModel,\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelParams): void {\n  const nailCentroid = getNailPolygonCentroid({\n    keyPoints,\n    cameraWidth,\n    cameraHeight,\n  })\n\n  const positionArray = new Float32Array(\n    nailModel.geometry.attributes.position.array.length\n  )\n\n  // move nail convex polygon vertices so that the convex polygon wraps the nail\n  if (nailModel.geometry.attributes.position instanceof THREE.BufferAttribute) {\n    for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n      const point = {\n        x: keyPoints.get(i).x * cameraWidth - cameraWidth / 2,\n        y: keyPoints.get(i).y * cameraHeight - cameraHeight / 2,\n      }\n      const offsetX = point.x - nailCentroid.x\n      const offsetY = point.y - nailCentroid.y\n      positionArray[i * 3] = point.x + 0.2 * offsetX\n      positionArray[i * 3 + 1] = point.y + 0.2 * offsetY\n      positionArray[i * 3 + 2] = -10\n    }\n    nailModel.geometry.attributes.position.array = positionArray\n  }\n\n  nailModel.visible = true\n  nailModel.geometry.attributes.position.needsUpdate = true\n}\n\nfunction updateNailModelGroup({\n  algResult,\n  nailModelGroup,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelGroupParams) {\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.children[i].visible = false\n  }\n  for (let i = 0; i < algResult.nailMaskResult.nailNum; i++) {\n    const nailType = algResult.nailKeypointResults[i].nailType - 1\n    const { keyPoints } = algResult.nailKeypointResults[i]\n    if (nailType < 0) continue\n    updateNailModel({\n      nailModel: nailModelGroup.children[nailType] as THREE.Mesh,\n      keyPoints,\n      cameraWidth,\n      cameraHeight,\n      THREE,\n    })\n  }\n}\n\ninterface ArNailProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: NailAlgResult\n  models: THREE.Group\n  cameraWidth: number\n  cameraHeight: number\n}\n\nexport class ArNailProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.reveal\n\n  constructor({ three }: ArNailProcessorParams) {\n    this.name = 'ArNailProcessor'\n    this.three = three\n    this.threshold = 0.5\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n    this.maskTextures[0].needsUpdate = true\n  }\n\n  public updateModels({\n    algResult,\n    models,\n    cameraWidth,\n    cameraHeight,\n  }: UpdateModelsParams) {\n    if (algResult == null) {\n      return\n    }\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.nailMaskResult.nailMask,\n          algResult.nailMaskResult.width,\n          algResult.nailMaskResult.height,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.nailMaskResult.nailMask)\n    }\n    this.maskTextures[0].needsUpdate = true\n\n    updateNailModelGroup({\n      algResult,\n      nailModelGroup: models,\n      cameraWidth,\n      cameraHeight,\n      THREE: this.three,\n    })\n  }\n}\n","import type THREE from 'three'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n// Texture Coordinates used to generate highlights\nconst NAIL_UV_ARRAY = new Float32Array([\n  1 / 6,\n  1 / 4,\n  7 / 24,\n  1 / 8,\n  1 / 2,\n  1 / 12,\n  17 / 24,\n  1 / 8,\n  5 / 6,\n  1 / 4,\n  17 / 24,\n  5 / 6,\n  1 / 2,\n  11 / 12,\n  7 / 24,\n  5 / 6,\n])\nconst HIGHLIGHT_TEXTURE_WIDTH = 512\nconst HIGHLIGHT_TEXTURE_HEIGHT = 512\n// Index used to generate highlight polygon\nconst HIGHLIGHT_GEOMETRY_INDEX = [0, 1, 4, 1, 2, 4, 2, 3, 4]\n// Index used to generate nail polygon\nconst NAIL_GEOMETRY_INDEX = [\n  7, 0, 6, 0, 1, 6, 1, 2, 6, 2, 3, 6, 3, 4, 6, 4, 5, 6,\n]\n\ninterface GetHighLightTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color\n}\n\ninterface GetNailModelParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\ninterface GetNailModelGroupParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\nfunction getHighLightTexture({\n  THREE,\n  renderer,\n  color,\n}: GetHighLightTextureParams) {\n  // Highlight polygon\n  const highLightVertices = new Float32Array([\n    -0.17 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.25 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.07 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.03 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.16 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.22 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.14 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.02 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n  ])\n  const highLightScene = new THREE.Scene()\n  const highLightCamera = new THREE.OrthographicCamera(\n    HIGHLIGHT_TEXTURE_WIDTH / -2,\n    HIGHLIGHT_TEXTURE_WIDTH / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / -2,\n    1,\n    1000\n  )\n  const highLightRenderTarget = new THREE.WebGLRenderTarget(\n    HIGHLIGHT_TEXTURE_WIDTH,\n    HIGHLIGHT_TEXTURE_HEIGHT\n  )\n  const highLightGeometry = new THREE.BufferGeometry()\n  highLightGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(highLightVertices, 3)\n  )\n  highLightGeometry.setIndex(HIGHLIGHT_GEOMETRY_INDEX)\n  const highLightMaterial = new THREE.MeshBasicMaterial({\n    color: new THREE.Color(0xffffff),\n  })\n\n  const highLightModel = new THREE.Mesh(highLightGeometry, highLightMaterial)\n  highLightModel.position.z = -10\n\n  // set nail color\n  highLightScene.add(highLightModel)\n  renderer.setRenderTarget(highLightRenderTarget)\n  const originColor = new THREE.Color()\n  renderer.getClearColor(originColor)\n  renderer.setClearColor(color)\n  renderer.render(highLightScene, highLightCamera)\n  renderer.setClearColor(originColor, renderer.getClearAlpha())\n  renderer.setRenderTarget(null)\n\n  return highLightRenderTarget.texture\n}\n\nfunction getNailModel({ THREE, highLightTexture }: GetNailModelParams) {\n  const nailVSCode = `\n    varying vec2 vUv;\n\n    void main()\n    {\n        vUv = uv;\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n  `\n\n  const nailFSCode = `\n    uniform sampler2D highLightTexture;\n\n    varying vec2 vUv;\n    void main(void) {\n        vec4 tex = texture2D(highLightTexture, vUv);\n        gl_FragColor = vec4(tex.r, tex.g, tex.b, 1.0);\n    }\n  `\n  const nailKeyPointsConponentCount = 3\n  const positionArray = new Float32Array(\n    nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT\n  )\n\n  for (\n    let i = 0;\n    i < nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT;\n    i++\n  ) {\n    positionArray[i] = i\n  }\n  const nailGeometry = new THREE.BufferGeometry()\n  nailGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(positionArray, nailKeyPointsConponentCount)\n  )\n  nailGeometry.setAttribute('uv', new THREE.BufferAttribute(NAIL_UV_ARRAY, 2))\n  nailGeometry.setIndex(NAIL_GEOMETRY_INDEX)\n\n  const nailShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      highLightTexture: { value: highLightTexture },\n    },\n    vertexShader: nailVSCode,\n    fragmentShader: nailFSCode,\n  })\n  nailShaderMaterial.side = THREE.DoubleSide\n\n  return new THREE.Mesh(nailGeometry, nailShaderMaterial)\n}\n\nfunction getNailModelGroup({\n  THREE,\n  highLightTexture,\n}: GetNailModelGroupParams) {\n  const nailModelGroup = new THREE.Group()\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.add(getNailModel({ THREE, highLightTexture }))\n  }\n  return nailModelGroup\n}\n\ninterface GetNailModelGroupByColorParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color | string | number\n}\n\ninterface GetNailModelGroupByTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  texture: THREE.Texture\n}\n\nconst ArNailUtils = {\n  getNailModelGroupByColor: ({\n    THREE,\n    renderer,\n    color,\n  }: GetNailModelGroupByColorParams) => {\n    if (!(color instanceof THREE.Color)) {\n      color = new THREE.Color(color)\n    }\n    const highLightTexture = getHighLightTexture({ THREE, renderer, color })\n    const nailModelGroup = getNailModelGroup({ THREE, highLightTexture })\n    return nailModelGroup\n  },\n\n  getNailModelGroupByTexture: ({\n    THREE,\n    texture,\n  }: GetNailModelGroupByTextureParams) => {\n    const nailModelGroup = getNailModelGroup({\n      THREE,\n      highLightTexture: texture,\n    })\n    return nailModelGroup\n  },\n}\n\nexport { ArNailUtils }\n"],"mappings":"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","ignoreList":[]}