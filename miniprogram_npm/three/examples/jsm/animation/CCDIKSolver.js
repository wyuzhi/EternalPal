import{BufferAttribute,BufferGeometry,Color,Line,LineBasicMaterial,Matrix4,Mesh,MeshBasicMaterial,Object3D,Quaternion,SphereGeometry,Vector3}from"three";const _quaternion=new Quaternion,_targetPos=new Vector3,_targetVec=new Vector3,_effectorPos=new Vector3,_effectorVec=new Vector3,_linkPos=new Vector3,_invLinkQ=new Quaternion,_linkScale=new Vector3,_axis=new Vector3,_vector=new Vector3,_matrix=new Matrix4;class CCDIKSolver{constructor(e,t=[]){this.mesh=e,this.iks=t,this._initialQuaternions=[],this._workingQuaternion=new Quaternion;for(const e of t){const t=[];for(let i=0;i<e.links.length;i++)t.push(new Quaternion);this._initialQuaternions.push(t)}this._valid()}update(e=1){const t=this.iks;for(let i=0,r=t.length;i<r;i++)this.updateOne(t[i],e);return this}updateOne(e,t=1){const i=void 0!==e.blendFactor?e.blendFactor:t,r=this.mesh.skeleton.bones,o=this.iks.indexOf(e),n=this._initialQuaternions[o],s=Math,a=r[e.effector],l=r[e.target];_targetPos.setFromMatrixPosition(l.matrixWorld);const c=e.links,h=void 0!==e.iteration?e.iteration:1;if(i<1)for(let e=0;e<c.length;e++){const t=c[e].index;n[e].copy(r[t].quaternion)}for(let t=0;t<h;t++){let t=!1;for(let i=0,o=c.length;i<o;i++){const o=r[c[i].index];if(!1===c[i].enabled)break;const n=c[i].limitation,l=c[i].rotationMin,h=c[i].rotationMax;o.matrixWorld.decompose(_linkPos,_invLinkQ,_linkScale),_invLinkQ.invert(),_effectorPos.setFromMatrixPosition(a.matrixWorld),_effectorVec.subVectors(_effectorPos,_linkPos),_effectorVec.applyQuaternion(_invLinkQ),_effectorVec.normalize(),_targetVec.subVectors(_targetPos,_linkPos),_targetVec.applyQuaternion(_invLinkQ),_targetVec.normalize();let p=_targetVec.dot(_effectorVec);if(p>1?p=1:p<-1&&(p=-1),p=s.acos(p),!(p<1e-5)){if(void 0!==e.minAngle&&p<e.minAngle&&(p=e.minAngle),void 0!==e.maxAngle&&p>e.maxAngle&&(p=e.maxAngle),_axis.crossVectors(_effectorVec,_targetVec),_axis.normalize(),_quaternion.setFromAxisAngle(_axis,p),o.quaternion.multiply(_quaternion),void 0!==n){let e=o.quaternion.w;e>1&&(e=1);const t=s.sqrt(1-e*e);o.quaternion.set(n.x*t,n.y*t,n.z*t,e)}void 0!==l&&o.rotation.setFromVector3(_vector.setFromEuler(o.rotation).max(l)),void 0!==h&&o.rotation.setFromVector3(_vector.setFromEuler(o.rotation).min(h)),o.updateMatrixWorld(!0),t=!0}}if(!t)break}if(i<1)for(let e=0;e<c.length;e++){const t=r[c[e].index];this._workingQuaternion.copy(n[e]).slerp(t.quaternion,i),t.quaternion.copy(this._workingQuaternion),t.updateMatrixWorld(!0)}return this}createHelper(e){return new CCDIKHelper(this.mesh,this.iks,e)}_valid(){const e=this.iks,t=this.mesh.skeleton.bones;for(let i=0,r=e.length;i<r;i++){const r=e[i],o=t[r.effector],n=r.links;let s,a;s=o;for(let e=0,i=n.length;e<i;e++)a=t[n[e].index],s.parent!==a&&console.warn("THREE.CCDIKSolver: bone "+s.name+" is not the child of bone "+a.name),s=a}}}function getPosition(e,t){return _vector.setFromMatrixPosition(e.matrixWorld).applyMatrix4(t)}function setPositionOfBoneToAttributeArray(e,t,i,r){const o=getPosition(i,r);e[3*t+0]=o.x,e[3*t+1]=o.y,e[3*t+2]=o.z}class CCDIKHelper extends Object3D{constructor(e,t=[],i=.25){super(),this.root=e,this.iks=t,this.matrix.copy(e.matrixWorld),this.matrixAutoUpdate=!1,this.sphereGeometry=new SphereGeometry(i,16,8),this.targetSphereMaterial=new MeshBasicMaterial({color:new Color(16746632),depthTest:!1,depthWrite:!1,transparent:!0}),this.effectorSphereMaterial=new MeshBasicMaterial({color:new Color(8978312),depthTest:!1,depthWrite:!1,transparent:!0}),this.linkSphereMaterial=new MeshBasicMaterial({color:new Color(8947967),depthTest:!1,depthWrite:!1,transparent:!0}),this.lineMaterial=new LineBasicMaterial({color:new Color(16711680),depthTest:!1,depthWrite:!1,transparent:!0}),this._init()}updateMatrixWorld(e){const t=this.root;if(this.visible){let e=0;const i=this.iks,r=t.skeleton.bones;_matrix.copy(t.matrixWorld).invert();for(let t=0,o=i.length;t<o;t++){const o=i[t],n=r[o.target],s=r[o.effector],a=this.children[e++],l=this.children[e++];a.position.copy(getPosition(n,_matrix)),l.position.copy(getPosition(s,_matrix));for(let t=0,i=o.links.length;t<i;t++){const i=r[o.links[t].index];this.children[e++].position.copy(getPosition(i,_matrix))}const c=this.children[e++],h=c.geometry.attributes.position.array;setPositionOfBoneToAttributeArray(h,0,n,_matrix),setPositionOfBoneToAttributeArray(h,1,s,_matrix);for(let e=0,t=o.links.length;e<t;e++){setPositionOfBoneToAttributeArray(h,e+2,r[o.links[e].index],_matrix)}c.geometry.attributes.position.needsUpdate=!0}}this.matrix.copy(t.matrixWorld),super.updateMatrixWorld(e)}dispose(){this.sphereGeometry.dispose(),this.targetSphereMaterial.dispose(),this.effectorSphereMaterial.dispose(),this.linkSphereMaterial.dispose(),this.lineMaterial.dispose();const e=this.children;for(let t=0;t<e.length;t++){const i=e[t];i.isLine&&i.geometry.dispose()}}_init(){const e=this,t=this.iks;function i(t){return new Line(function(e){const t=new BufferGeometry,i=new Float32Array(3*(2+e.links.length));return t.setAttribute("position",new BufferAttribute(i,3)),t}(t),e.lineMaterial)}for(let r=0,o=t.length;r<o;r++){const o=t[r];this.add(new Mesh(e.sphereGeometry,e.targetSphereMaterial)),this.add(new Mesh(e.sphereGeometry,e.effectorSphereMaterial));for(let t=0,i=o.links.length;t<i;t++)this.add(new Mesh(e.sphereGeometry,e.linkSphereMaterial));this.add(i(o))}}}export{CCDIKSolver,CCDIKHelper};
//# sourceMappingURL=CCDIKSolver.js.map