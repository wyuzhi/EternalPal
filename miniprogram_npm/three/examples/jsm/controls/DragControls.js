import{Controls,Matrix4,Plane,Raycaster,Vector2,Vector3,MOUSE,TOUCH}from"three";const _plane=new Plane,_pointer=new Vector2,_offset=new Vector3,_diff=new Vector2,_previousPointer=new Vector2,_intersection=new Vector3,_worldPosition=new Vector3,_inverseMatrix=new Matrix4,_up=new Vector3,_right=new Vector3;let _selected=null,_hovered=null;const _intersections=[],STATE={NONE:-1,PAN:0,ROTATE:1};class DragControls extends Controls{constructor(e,t,o=null){super(t,o),this.objects=e,this.recursive=!0,this.transformGroup=!1,this.rotateSpeed=1,this.raycaster=new Raycaster,this.mouseButtons={LEFT:MOUSE.PAN,MIDDLE:MOUSE.PAN,RIGHT:MOUSE.ROTATE},this.touches={ONE:TOUCH.PAN},this._onPointerMove=onPointerMove.bind(this),this._onPointerDown=onPointerDown.bind(this),this._onPointerCancel=onPointerCancel.bind(this),this._onContextMenu=onContextMenu.bind(this),null!==o&&this.connect(o)}connect(e){super.connect(e),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointerup",this._onPointerCancel),this.domElement.addEventListener("pointerleave",this._onPointerCancel),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointerup",this._onPointerCancel),this.domElement.removeEventListener("pointerleave",this._onPointerCancel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="auto",this.domElement.style.cursor=""}dispose(){this.disconnect()}_updatePointer(e){const t=this.domElement.getBoundingClientRect();_pointer.x=(e.clientX-t.left)/t.width*2-1,_pointer.y=-(e.clientY-t.top)/t.height*2+1}_updateState(e){let t;if("touch"===e.pointerType)t=this.touches.ONE;else switch(e.button){case 0:t=this.mouseButtons.LEFT;break;case 1:t=this.mouseButtons.MIDDLE;break;case 2:t=this.mouseButtons.RIGHT;break;default:t=null}switch(t){case MOUSE.PAN:case TOUCH.PAN:this.state=STATE.PAN;break;case MOUSE.ROTATE:case TOUCH.ROTATE:this.state=STATE.ROTATE;break;default:this.state=STATE.NONE}}getRaycaster(){return console.warn("THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead."),this.raycaster}setObjects(e){console.warn("THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead."),this.objects=e}getObjects(){return console.warn("THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead."),this.objects}activate(){console.warn("THREE.DragControls: activate() has been renamed to connect()."),this.connect()}deactivate(){console.warn("THREE.DragControls: deactivate() has been renamed to disconnect()."),this.disconnect()}set mode(e){console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.")}get mode(){console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.")}}function onPointerMove(e){const t=this.object,o=this.domElement,n=this.raycaster;if(!1!==this.enabled){if(this._updatePointer(e),n.setFromCamera(_pointer,t),_selected)this.state===STATE.PAN?n.ray.intersectPlane(_plane,_intersection)&&_selected.position.copy(_intersection.sub(_offset).applyMatrix4(_inverseMatrix)):this.state===STATE.ROTATE&&(_diff.subVectors(_pointer,_previousPointer).multiplyScalar(this.rotateSpeed),_selected.rotateOnWorldAxis(_up,_diff.x),_selected.rotateOnWorldAxis(_right.normalize(),-_diff.y)),this.dispatchEvent({type:"drag",object:_selected}),_previousPointer.copy(_pointer);else if("mouse"===e.pointerType||"pen"===e.pointerType)if(_intersections.length=0,n.setFromCamera(_pointer,t),n.intersectObjects(this.objects,this.recursive,_intersections),_intersections.length>0){const e=_intersections[0].object;_plane.setFromNormalAndCoplanarPoint(t.getWorldDirection(_plane.normal),_worldPosition.setFromMatrixPosition(e.matrixWorld)),_hovered!==e&&null!==_hovered&&(this.dispatchEvent({type:"hoveroff",object:_hovered}),o.style.cursor="auto",_hovered=null),_hovered!==e&&(this.dispatchEvent({type:"hoveron",object:e}),o.style.cursor="pointer",_hovered=e)}else null!==_hovered&&(this.dispatchEvent({type:"hoveroff",object:_hovered}),o.style.cursor="auto",_hovered=null);_previousPointer.copy(_pointer)}}function onPointerDown(e){const t=this.object,o=this.domElement,n=this.raycaster;!1!==this.enabled&&(this._updatePointer(e),this._updateState(e),_intersections.length=0,n.setFromCamera(_pointer,t),n.intersectObjects(this.objects,this.recursive,_intersections),_intersections.length>0&&(_selected=!0===this.transformGroup?findGroup(_intersections[0].object):_intersections[0].object,_plane.setFromNormalAndCoplanarPoint(t.getWorldDirection(_plane.normal),_worldPosition.setFromMatrixPosition(_selected.matrixWorld)),n.ray.intersectPlane(_plane,_intersection)&&(this.state===STATE.PAN?(_inverseMatrix.copy(_selected.parent.matrixWorld).invert(),_offset.copy(_intersection).sub(_worldPosition.setFromMatrixPosition(_selected.matrixWorld))):this.state===STATE.ROTATE&&(_up.set(0,1,0).applyQuaternion(t.quaternion).normalize(),_right.set(1,0,0).applyQuaternion(t.quaternion).normalize())),o.style.cursor="move",this.dispatchEvent({type:"dragstart",object:_selected})),_previousPointer.copy(_pointer))}function onPointerCancel(){!1!==this.enabled&&(_selected&&(this.dispatchEvent({type:"dragend",object:_selected}),_selected=null),this.domElement.style.cursor=_hovered?"pointer":"auto",this.state=STATE.NONE)}function onContextMenu(e){!1!==this.enabled&&e.preventDefault()}function findGroup(e,t=null){return e.isGroup&&(t=e),null===e.parent?t:findGroup(e.parent,t)}export{DragControls};
//# sourceMappingURL=DragControls.js.map