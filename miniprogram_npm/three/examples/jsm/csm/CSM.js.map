{"version":3,"file":"node_modules/three/examples/jsm/csm/CSM.js","names":["Vector2","Vector3","DirectionalLight","MathUtils","ShaderChunk","Matrix4","Box3","CSMFrustum","CSMShader","_cameraToLightMatrix","_lightSpaceFrustum","webGL","_center","_bbox","_uniformArray","_logArray","_lightOrientationMatrix","_lightOrientationMatrixInverse","_up","CSM","constructor","data","this","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","_createLights","updateFrustums","_injectInclude","i","light","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","_initCascades","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","_updateShadowBounds","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","pow","left","right","top","bottom","_getBreaks","min","uniformSplit","logarithmicSplit","amount","lambda","lerp","practicalSplit","undefined","console","error","update","lookAt","copy","invert","texelWidth","texelHeight","multiplyMatrices","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","lights_fragment_begin","lights_pars_begin","setupMaterial","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","_getExtendedBreaks","uniforms","CSM_cascades","value","cameraNear","shadowFar","set","_updateUniforms","forEach","needsUpdate","prev","remove","dispose","clear"],"sources":["node_modules/three/examples/jsm/csm/CSM.js"],"sourcesContent":["import {\n\tVector2,\n\tVector3,\n\tDirectionalLight,\n\tMathUtils,\n\tShaderChunk,\n\tMatrix4,\n\tBox3\n} from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\nconst _lightSpaceFrustum = new CSMFrustum( { webGL: true } );\nconst _center = new Vector3();\nconst _bbox = new Box3();\nconst _uniformArray = [];\nconst _logArray = [];\nconst _lightOrientationMatrix = new Matrix4();\nconst _lightOrientationMatrixInverse = new Matrix4();\nconst _up = new Vector3( 0, 1, 0 );\n\n/**\n * An implementation of Cascade Shadow Maps (CSM).\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * use {@link CSMShadowNode} instead.\n *\n * @three_import import { CSM } from 'three/addons/csm/CSM.js';\n */\nexport class CSM {\n\n\t/**\n\t * Constructs a new CSM instance.\n\t *\n\t * @param {CSM~Data} data - The CSM data.\n\t */\n\tconstructor( data ) {\n\n\t\t/**\n\t\t * The scene's camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = data.camera;\n\n\t\t/**\n\t\t * The parent object, usually the scene.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.parent = data.parent;\n\n\t\t/**\n\t\t * The number of cascades.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.cascades = data.cascades || 3;\n\n\t\t/**\n\t\t * The maximum far value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 100000\n\t\t */\n\t\tthis.maxFar = data.maxFar || 100000;\n\n\t\t/**\n\t\t * The frustum split mode.\n\t\t *\n\t\t * @type {('practical'|'uniform'|'logarithmic'|'custom')}\n\t\t * @default 'practical'\n\t\t */\n\t\tthis.mode = data.mode || 'practical';\n\n\t\t/**\n\t\t * The shadow map size.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2048\n\t\t */\n\t\tthis.shadowMapSize = data.shadowMapSize || 2048;\n\n\t\t/**\n\t\t * The shadow bias.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.000001\n\t\t */\n\t\tthis.shadowBias = data.shadowBias || 0.000001;\n\n\t\t/**\n\t\t * The light direction.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();\n\n\t\t/**\n\t\t * The light intensity.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.lightIntensity = data.lightIntensity || 3;\n\n\t\t/**\n\t\t * The light near value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.lightNear = data.lightNear || 1;\n\n\t\t/**\n\t\t * The light far value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2000\n\t\t */\n\t\tthis.lightFar = data.lightFar || 2000;\n\n\t\t/**\n\t\t * The light margin.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 200\n\t\t */\n\t\tthis.lightMargin = data.lightMargin || 200;\n\n\t\t/**\n\t\t * Custom split callback when using `mode='custom'`.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.customSplitsCallback = data.customSplitsCallback;\n\n\t\t/**\n\t\t * Whether to fade between cascades or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.fade = false;\n\n\t\t/**\n\t\t * The main frustum.\n\t\t *\n\t\t * @type {CSMFrustum}\n\t\t */\n\t\tthis.mainFrustum = new CSMFrustum( { webGL: true } );\n\n\t\t/**\n\t\t * An array of frustums representing the cascades.\n\t\t *\n\t\t * @type {Array<CSMFrustum>}\n\t\t */\n\t\tthis.frustums = [];\n\n\t\t/**\n\t\t * An array of numbers in the range `[0,1]` the defines how the\n\t\t * mainCSM frustum should be split up.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.breaks = [];\n\n\t\t/**\n\t\t * An array of directional lights which cast the shadows for\n\t\t * the different cascades. There is one directional light for each\n\t\t * cascade.\n\t\t *\n\t\t * @type {Array<DirectionalLight>}\n\t\t */\n\t\tthis.lights = [];\n\n\t\t/**\n\t\t * A Map holding enhanced material shaders.\n\t\t *\n\t\t * @type {Map<Material,Object>}\n\t\t */\n\t\tthis.shaders = new Map();\n\n\t\tthis._createLights();\n\t\tthis.updateFrustums();\n\t\tthis._injectInclude();\n\n\t}\n\n\t/**\n\t * Creates the directional lights of this CSM instance.\n\t *\n\t * @private\n\t */\n\t_createLights() {\n\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\tconst light = new DirectionalLight( 0xffffff, this.lightIntensity );\n\t\t\tlight.castShadow = true;\n\t\t\tlight.shadow.mapSize.width = this.shadowMapSize;\n\t\t\tlight.shadow.mapSize.height = this.shadowMapSize;\n\n\t\t\tlight.shadow.camera.near = this.lightNear;\n\t\t\tlight.shadow.camera.far = this.lightFar;\n\t\t\tlight.shadow.bias = this.shadowBias;\n\n\t\t\tthis.parent.add( light );\n\t\t\tthis.parent.add( light.target );\n\t\t\tthis.lights.push( light );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits the cascades according to the scene's camera and breaks configuration.\n\t *\n\t * @private\n\t */\n\t_initCascades() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateProjectionMatrix();\n\t\tthis.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );\n\t\tthis.mainFrustum.split( this.breaks, this.frustums );\n\n\t}\n\n\t/**\n\t * Updates the shadow bounds of this CSM instance.\n\t *\n\t * @private\n\t */\n\t_updateShadowBounds() {\n\n\t\tconst frustums = this.frustums;\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst light = this.lights[ i ];\n\t\t\tconst shadowCam = light.shadow.camera;\n\t\t\tconst frustum = this.frustums[ i ];\n\n\t\t\t// Get the two points that represent that furthest points on the frustum assuming\n\t\t\t// that's either the diagonal across the far plane or the diagonal across the whole\n\t\t\t// frustum itself.\n\t\t\tconst nearVerts = frustum.vertices.near;\n\t\t\tconst farVerts = frustum.vertices.far;\n\t\t\tconst point1 = farVerts[ 0 ];\n\t\t\tlet point2;\n\t\t\tif ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {\n\n\t\t\t\tpoint2 = farVerts[ 2 ];\n\n\t\t\t} else {\n\n\t\t\t\tpoint2 = nearVerts[ 2 ];\n\n\t\t\t}\n\n\t\t\tlet squaredBBWidth = point1.distanceTo( point2 );\n\t\t\tif ( this.fade ) {\n\n\t\t\t\t// expand the shadow extents by the fade margin if fade is enabled.\n\t\t\t\tconst camera = this.camera;\n\t\t\t\tconst far = Math.max( camera.far, this.maxFar );\n\t\t\t\tconst linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );\n\t\t\t\tconst margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );\n\n\t\t\t\tsquaredBBWidth += margin;\n\n\t\t\t}\n\n\t\t\tshadowCam.left = - squaredBBWidth / 2;\n\t\t\tshadowCam.right = squaredBBWidth / 2;\n\t\t\tshadowCam.top = squaredBBWidth / 2;\n\t\t\tshadowCam.bottom = - squaredBBWidth / 2;\n\t\t\tshadowCam.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the breaks of this CSM instance based on the scene's camera, number of cascades\n\t * and the selected split mode.\n\t *\n\t * @private\n\t */\n\t_getBreaks() {\n\n\t\tconst camera = this.camera;\n\t\tconst far = Math.min( camera.far, this.maxFar );\n\t\tthis.breaks.length = 0;\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'uniform':\n\t\t\t\tuniformSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'logarithmic':\n\t\t\t\tlogarithmicSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'practical':\n\t\t\t\tpracticalSplit( this.cascades, camera.near, far, 0.5, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'custom':\n\t\t\t\tif ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );\n\t\t\t\tthis.customSplitsCallback( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tfunction uniformSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near + ( far - near ) * i / amount ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction logarithmicSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near * ( far / near ) ** ( i / amount ) ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction practicalSplit( amount, near, far, lambda, target ) {\n\n\t\t\t_uniformArray.length = 0;\n\t\t\t_logArray.length = 0;\n\t\t\tlogarithmicSplit( amount, near, far, _logArray );\n\t\t\tuniformSplit( amount, near, far, _uniformArray );\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the CSM. This method must be called in your animation loop before\n\t * calling `renderer.render()`.\n\t */\n\tupdate() {\n\n\t\tconst camera = this.camera;\n\t\tconst frustums = this.frustums;\n\n\t\t// for each frustum we need to find its min-max box aligned with the light orientation\n\t\t// the position in _lightOrientationMatrix does not matter, as we transform there and back\n\t\t_lightOrientationMatrix.lookAt( new Vector3(), this.lightDirection, _up );\n\t\t_lightOrientationMatrixInverse.copy( _lightOrientationMatrix ).invert();\n\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst light = this.lights[ i ];\n\t\t\tconst shadowCam = light.shadow.camera;\n\t\t\tconst texelWidth = ( shadowCam.right - shadowCam.left ) / this.shadowMapSize;\n\t\t\tconst texelHeight = ( shadowCam.top - shadowCam.bottom ) / this.shadowMapSize;\n\t\t\t_cameraToLightMatrix.multiplyMatrices( _lightOrientationMatrixInverse, camera.matrixWorld );\n\t\t\tfrustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );\n\n\t\t\tconst nearVerts = _lightSpaceFrustum.vertices.near;\n\t\t\tconst farVerts = _lightSpaceFrustum.vertices.far;\n\t\t\t_bbox.makeEmpty();\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t_bbox.expandByPoint( nearVerts[ j ] );\n\t\t\t\t_bbox.expandByPoint( farVerts[ j ] );\n\n\t\t\t}\n\n\t\t\t_bbox.getCenter( _center );\n\t\t\t_center.z = _bbox.max.z + this.lightMargin;\n\t\t\t_center.x = Math.floor( _center.x / texelWidth ) * texelWidth;\n\t\t\t_center.y = Math.floor( _center.y / texelHeight ) * texelHeight;\n\t\t\t_center.applyMatrix4( _lightOrientationMatrix );\n\n\t\t\tlight.position.copy( _center );\n\t\t\tlight.target.position.copy( _center );\n\n\t\t\tlight.target.position.x += this.lightDirection.x;\n\t\t\tlight.target.position.y += this.lightDirection.y;\n\t\t\tlight.target.position.z += this.lightDirection.z;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Injects the CSM shader enhancements into the built-in materials.\n\t *\n\t * @private\n\t */\n\t_injectInclude() {\n\n\t\tShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n\t\tShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n\n\t}\n\n\t/**\n\t * Applications must call this method for all materials that should be affected by CSM.\n\t *\n\t * @param {Material} material - The material to setup for CSM support.\n\t */\n\tsetupMaterial( material ) {\n\n\t\tmaterial.defines = material.defines || {};\n\t\tmaterial.defines.USE_CSM = 1;\n\t\tmaterial.defines.CSM_CASCADES = this.cascades;\n\n\t\tif ( this.fade ) {\n\n\t\t\tmaterial.defines.CSM_FADE = '';\n\n\t\t}\n\n\t\tconst breaksVec2 = [];\n\t\tconst scope = this;\n\t\tconst shaders = this.shaders;\n\n\t\tmaterial.onBeforeCompile = function ( shader ) {\n\n\t\t\tconst far = Math.min( scope.camera.far, scope.maxFar );\n\t\t\tscope._getExtendedBreaks( breaksVec2 );\n\n\t\t\tshader.uniforms.CSM_cascades = { value: breaksVec2 };\n\t\t\tshader.uniforms.cameraNear = { value: scope.camera.near };\n\t\t\tshader.uniforms.shadowFar = { value: far };\n\n\t\t\tshaders.set( material, shader );\n\n\t\t};\n\n\t\tshaders.set( material, null );\n\n\t}\n\n\t/**\n\t * Updates the CSM uniforms.\n\t *\n\t * @private\n\t */\n\t_updateUniforms() {\n\n\t\tconst far = Math.min( this.camera.far, this.maxFar );\n\t\tconst shaders = this.shaders;\n\n\t\tshaders.forEach( function ( shader, material ) {\n\n\t\t\tif ( shader !== null ) {\n\n\t\t\t\tconst uniforms = shader.uniforms;\n\t\t\t\tthis._getExtendedBreaks( uniforms.CSM_cascades.value );\n\t\t\t\tuniforms.cameraNear.value = this.camera.near;\n\t\t\t\tuniforms.shadowFar.value = far;\n\n\t\t\t}\n\n\t\t\tif ( ! this.fade && 'CSM_FADE' in material.defines ) {\n\n\t\t\t\tdelete material.defines.CSM_FADE;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( this.fade && ! ( 'CSM_FADE' in material.defines ) ) {\n\n\t\t\t\tmaterial.defines.CSM_FADE = '';\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}, this );\n\n\t}\n\n\t/**\n\t * Computes the extended breaks for the CSM uniforms.\n\t *\n\t * @private\n\t * @param {Array<Vector2>} target - The target array that holds the extended breaks.\n\t */\n\t_getExtendedBreaks( target ) {\n\n\t\twhile ( target.length < this.breaks.length ) {\n\n\t\t\ttarget.push( new Vector2() );\n\n\t\t}\n\n\t\ttarget.length = this.breaks.length;\n\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\tconst amount = this.breaks[ i ];\n\t\t\tconst prev = this.breaks[ i - 1 ] || 0;\n\t\t\ttarget[ i ].x = prev;\n\t\t\ttarget[ i ].y = amount;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applications must call this method every time they change camera or CSM settings.\n\t */\n\tupdateFrustums() {\n\n\t\tthis._getBreaks();\n\t\tthis._initCascades();\n\t\tthis._updateShadowBounds();\n\t\tthis._updateUniforms();\n\n\t}\n\n\t/**\n\t * Applications must call this method when they remove the CSM usage from their scene.\n\t */\n\tremove() {\n\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\n\n\t\t\tthis.parent.remove( this.lights[ i ].target );\n\t\t\tthis.parent.remove( this.lights[ i ] );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tconst shaders = this.shaders;\n\t\tshaders.forEach( function ( shader, material ) {\n\n\t\t\tdelete material.onBeforeCompile;\n\t\t\tdelete material.defines.USE_CSM;\n\t\t\tdelete material.defines.CSM_CASCADES;\n\t\t\tdelete material.defines.CSM_FADE;\n\n\t\t\tif ( shader !== null ) {\n\n\t\t\t\tdelete shader.uniforms.CSM_cascades;\n\t\t\t\tdelete shader.uniforms.cameraNear;\n\t\t\t\tdelete shader.uniforms.shadowFar;\n\n\t\t\t}\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t} );\n\t\tshaders.clear();\n\n\t}\n\n}\n\n/**\n * Constructor data of `CSM`.\n *\n * @typedef {Object} CSM~Data\n * @property {Camera} camera - The scene's camera.\n * @property {Object3D} parent - The parent object, usually the scene.\n * @property {number} [cascades=3] - The number of cascades.\n * @property {number} [maxFar=100000] - The maximum far value.\n * @property {('practical'|'uniform'|'logarithmic'|'custom')} [mode='practical'] - The frustum split mode.\n * @property {Function} [customSplitsCallback] - Custom split callback when using `mode='custom'`.\n * @property {number} [shadowMapSize=2048] - The shadow map size.\n * @property {number} [shadowBias=0.000001] - The shadow bias.\n * @property {Vector3} [lightDirection] - The light direction.\n * @property {number} [lightIntensity=3] - The light intensity.\n * @property {number} [lightNear=1] - The light near value.\n * @property {number} [lightNear=2000] - The light far value.\n * @property {number} [lightMargin=200] - The light margin.\n **/\n"],"mappings":"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","ignoreList":[]}