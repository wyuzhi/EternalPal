{"version":3,"file":"node_modules/three/examples/jsm/csm/CSMFrustum.js","names":["Vector3","Matrix4","inverseProjectionMatrix","CSMFrustum","constructor","data","this","zNear","webGL","vertices","near","far","undefined","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"sources":["node_modules/three/examples/jsm/csm/CSMFrustum.js"],"sourcesContent":["import { Vector3, Matrix4 } from 'three';\n\nconst inverseProjectionMatrix = new Matrix4();\n\n/**\n * Represents the frustum of a CSM instance.\n *\n * @three_import import { CSMFrustum } from 'three/addons/csm/CSMFrustum.js';\n */\nclass CSMFrustum {\n\n\t/**\n\t * Constructs a new CSM frustum.\n\t *\n\t * @param {CSMFrustum~Data} [data] - The CSM data.\n\t */\n\tconstructor( data ) {\n\n\t\tdata = data || {};\n\n\t\t/**\n\t\t * The zNear value. This value depends on whether the CSM\n\t\t * is used with WebGL or WebGPU. Both API use different\n\t\t * conventions for their projection matrices.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.zNear = data.webGL === true ? - 1 : 0;\n\n\t\t/**\n\t\t * An object representing the vertices of the near and\n\t\t * far plane in view space.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.vertices = {\n\t\t\tnear: [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t],\n\t\t\tfar: [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t]\n\t\t};\n\n\t\tif ( data.projectionMatrix !== undefined ) {\n\n\t\t\tthis.setFromProjectionMatrix( data.projectionMatrix, data.maxFar || 10000 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups this CSM frustum from the given projection matrix and max far value.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix, usually of the scene's camera.\n\t * @param {number} maxFar - The maximum far value.\n\t * @returns {Object} An object representing the vertices of the near and far plane in view space.\n\t */\n\tsetFromProjectionMatrix( projectionMatrix, maxFar ) {\n\n\t\tconst zNear = this.zNear;\n\t\tconst isOrthographic = projectionMatrix.elements[ 2 * 4 + 3 ] === 0;\n\n\t\tinverseProjectionMatrix.copy( projectionMatrix ).invert();\n\n\t\t// 3 --- 0  vertices.near/far order\n\t\t// |     |\n\t\t// 2 --- 1\n\t\t// clip space spans from [-1, 1]\n\n\t\tthis.vertices.near[ 0 ].set( 1, 1, zNear );\n\t\tthis.vertices.near[ 1 ].set( 1, - 1, zNear );\n\t\tthis.vertices.near[ 2 ].set( - 1, - 1, zNear );\n\t\tthis.vertices.near[ 3 ].set( - 1, 1, zNear );\n\t\tthis.vertices.near.forEach( function ( v ) {\n\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\n\n\t\t} );\n\n\t\tthis.vertices.far[ 0 ].set( 1, 1, 1 );\n\t\tthis.vertices.far[ 1 ].set( 1, - 1, 1 );\n\t\tthis.vertices.far[ 2 ].set( - 1, - 1, 1 );\n\t\tthis.vertices.far[ 3 ].set( - 1, 1, 1 );\n\t\tthis.vertices.far.forEach( function ( v ) {\n\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\n\n\t\t\tconst absZ = Math.abs( v.z );\n\t\t\tif ( isOrthographic ) {\n\n\t\t\t\tv.z *= Math.min( maxFar / absZ, 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.multiplyScalar( Math.min( maxFar / absZ, 1.0 ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.vertices;\n\n\t}\n\n\t/**\n\t * Splits the CSM frustum by the given array. The new CSM frustum are pushed into the given\n\t * target array.\n\t *\n\t * @param {Array<number>} breaks - An array of numbers in the range `[0,1]` the defines how the\n\t * CSM frustum should be split up.\n\t * @param {Array<CSMFrustum>} target - The target array that holds the new CSM frustums.\n\t */\n\tsplit( breaks, target ) {\n\n\t\twhile ( breaks.length > target.length ) {\n\n\t\t\ttarget.push( new CSMFrustum() );\n\n\t\t}\n\n\t\ttarget.length = breaks.length;\n\n\t\tfor ( let i = 0; i < breaks.length; i ++ ) {\n\n\t\t\tconst cascade = target[ i ];\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.near[ j ].copy( this.vertices.near[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.near[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( i === breaks.length - 1 ) {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.far[ j ].copy( this.vertices.far[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.far[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Transforms the given target CSM frustum into the different coordinate system defined by the\n\t * given camera matrix.\n\t *\n\t * @param {Matrix4} cameraMatrix - The matrix that defines the new coordinate system.\n\t * @param {CSMFrustum} target - The CSM to convert.\n\t */\n\ttoSpace( cameraMatrix, target ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\ttarget.vertices.near[ i ]\n\t\t\t\t.copy( this.vertices.near[ i ] )\n\t\t\t\t.applyMatrix4( cameraMatrix );\n\n\t\t\ttarget.vertices.far[ i ]\n\t\t\t\t.copy( this.vertices.far[ i ] )\n\t\t\t\t.applyMatrix4( cameraMatrix );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Constructor data of `CSMFrustum`.\n *\n * @typedef {Object} CSMFrustum~Data\n * @property {boolean} [webGL] - Whether this CSM frustum is used with WebGL or WebGPU.\n * @property {Matrix4} [projectionMatrix] - A projection matrix usually of the scene's camera.\n * @property {number} [maxFar] - The maximum far value.\n **/\n\nexport { CSMFrustum };\n"],"mappings":"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","ignoreList":[]}