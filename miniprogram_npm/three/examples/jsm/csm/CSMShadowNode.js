import{Vector2,Vector3,MathUtils,Matrix4,Box3,Object3D,WebGLCoordinateSystem,ShadowBaseNode}from"three/webgpu";import{CSMFrustum}from"./CSMFrustum.js";import{viewZToOrthographicDepth,reference,uniform,float,vec4,vec2,If,Fn,min,renderGroup,positionView,shadow}from"three/tsl";const _cameraToLightMatrix=new Matrix4,_lightSpaceFrustum=new CSMFrustum,_center=new Vector3,_bbox=new Box3,_uniformArray=[],_logArray=[],_lightDirection=new Vector3,_lightOrientationMatrix=new Matrix4,_lightOrientationMatrixInverse=new Matrix4,_up=new Vector3(0,1,0);class LwLight extends Object3D{constructor(){super(),this.target=new Object3D}}class CSMShadowNode extends ShadowBaseNode{constructor(t,e={}){super(t),this.camera=null,this.cascades=e.cascades||3,this.maxFar=e.maxFar||1e5,this.mode=e.mode||"practical",this.lightMargin=e.lightMargin||200,this.customSplitsCallback=e.customSplitsCallback,this.fade=!1,this.breaks=[],this._cascades=[],this.mainFrustum=null,this.frustums=[],this.lights=[],this._shadowNodes=[]}_init({camera:t,renderer:e}){this.camera=t;const s={webGL:e.coordinateSystem===WebGLCoordinateSystem};this.mainFrustum=new CSMFrustum(s);const a=this.light;for(let t=0;t<this.cascades;t++){const e=new LwLight;e.castShadow=!0;const s=a.shadow.clone();s.bias=s.bias*(t+1),this.lights.push(e),e.shadow=s,this._shadowNodes.push(shadow(e,s)),this._cascades.push(new Vector2)}this.updateFrustums()}_initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}_getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":s(this.cascades,t.near,e,this.breaks);break;case"logarithmic":a(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,r,i,o){_uniformArray.length=0,_logArray.length=0,a(t,e,r,_logArray),s(t,e,r,_uniformArray);for(let e=1;e<t;e++)o.push(MathUtils.lerp(_uniformArray[e-1],_logArray[e-1],i));o.push(1)}(this.cascades,t.near,e,.5,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function s(t,e,s,a){for(let r=1;r<t;r++)a.push((e+(s-e)*r/t)/s);a.push(1)}function a(t,e,s,a){for(let r=1;r<t;r++)a.push(e*(s/e)**(r/t)/s);a.push(1)}}_setLightBreaks(){for(let t=0,e=this.cascades;t<e;t++){const e=this.breaks[t],s=this.breaks[t-1]||0;this._cascades[t].set(s,e)}}_updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,s=this.frustums[e],a=s.vertices.near,r=s.vertices.far,i=r[0];let o;o=i.distanceTo(r[2])>i.distanceTo(a[2])?r[2]:a[2];let n=i.distanceTo(o);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),a=s.vertices.far[0].z/(e-t.near);n+=.25*Math.pow(a,2)*(e-t.near)}t.left=-n/2,t.right=n/2,t.top=n/2,t.bottom=-n/2,t.updateProjectionMatrix()}}updateFrustums(){this._getBreaks(),this._initCascades(),this._updateShadowBounds(),this._setLightBreaks()}_setupFade(){const t=reference("camera.near","float",this).setGroup(renderGroup),e=reference("_cascades","vec2",this).setGroup(renderGroup).setName("cascades"),s=uniform("float").setGroup(renderGroup).setName("shadowFar").onRenderUpdate((()=>Math.min(this.maxFar,this.camera.far))),a=viewZToOrthographicDepth(positionView.z,t,s).toVar("linearDepth"),r=this.cascades-1;return Fn((t=>{this.setupShadowPosition(t);const s=vec4(1,1,1,1).toVar("shadowValue"),i=vec2().toVar("cascade"),o=float().toVar("cascadeCenter"),n=float().toVar("margin"),h=float().toVar("csmX"),c=float().toVar("csmY");for(let t=0;t<this.cascades;t++){const l=t===r;i.assign(e.element(t)),o.assign(i.x.add(i.y).div(2));const u=a.lessThan(o).select(i.x,i.y);n.assign(float(.25).mul(u.pow(2))),h.assign(i.x.sub(n.div(2))),l?c.assign(i.y):c.assign(i.y.add(n.div(2)));const d=a.greaterThanEqual(h).and(a.lessThanEqual(c));If(d,(()=>{let e=min(a.sub(h),c.sub(a)).toVar().div(n).clamp(0,1);0===t&&(e=a.greaterThan(o).select(e,1)),s.subAssign(this._shadowNodes[t].oneMinus().mul(e))}))}return s}))()}_setupStandard(){const t=reference("camera.near","float",this).setGroup(renderGroup),e=reference("_cascades","vec2",this).setGroup(renderGroup).setName("cascades"),s=uniform("float").setGroup(renderGroup).setName("shadowFar").onRenderUpdate((()=>Math.min(this.maxFar,this.camera.far))),a=viewZToOrthographicDepth(positionView.z,t,s).toVar("linearDepth");return Fn((t=>{this.setupShadowPosition(t);const s=vec4(1,1,1,1).toVar("shadowValue"),r=vec2().toVar("cascade");for(let t=0;t<this.cascades;t++)r.assign(e.element(t)),If(a.greaterThanEqual(r.x).and(a.lessThanEqual(r.y)),(()=>{s.assign(this._shadowNodes[t])}));return s}))()}setup(t){return null===this.camera&&this._init(t),!0===this.fade?this._setupFade():this._setupStandard()}updateBefore(){const t=this.light,e=t.parent,s=this.camera,a=this.frustums;for(let t=0;t<this.lights.length;t++){const s=this.lights[t];null===s.parent&&(e.add(s.target),e.add(s))}_lightDirection.subVectors(t.target.position,t.position).normalize(),_lightOrientationMatrix.lookAt(t.position,t.target.position,_up),_lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();for(let t=0;t<a.length;t++){const e=this.lights[t],r=e.shadow,i=r.camera,o=(i.right-i.left)/r.mapSize.width,n=(i.top-i.bottom)/r.mapSize.height;_cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse,s.matrixWorld),a[t].toSpace(_cameraToLightMatrix,_lightSpaceFrustum);const h=_lightSpaceFrustum.vertices.near,c=_lightSpaceFrustum.vertices.far;_bbox.makeEmpty();for(let t=0;t<4;t++)_bbox.expandByPoint(h[t]),_bbox.expandByPoint(c[t]);_bbox.getCenter(_center),_center.z=_bbox.max.z+this.lightMargin,_center.x=Math.floor(_center.x/o)*o,_center.y=Math.floor(_center.y/n)*n,_center.applyMatrix4(_lightOrientationMatrix),e.position.copy(_center),e.target.position.copy(_center),e.target.position.add(_lightDirection)}}dispose(){for(let t=0;t<this.lights.length;t++){const e=this.lights[t],s=e.parent;s.remove(e.target),s.remove(e)}super.dispose()}}export{CSMShadowNode};
//# sourceMappingURL=CSMShadowNode.js.map