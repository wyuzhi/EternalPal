{"version":3,"file":"node_modules/three/examples/jsm/csm/CSMShadowNode.js","names":["Vector2","Vector3","MathUtils","Matrix4","Box3","Object3D","WebGLCoordinateSystem","ShadowBaseNode","CSMFrustum","viewZToOrthographicDepth","reference","uniform","float","vec4","vec2","If","Fn","min","renderGroup","positionView","shadow","_cameraToLightMatrix","_lightSpaceFrustum","_center","_bbox","_uniformArray","_logArray","_lightDirection","_lightOrientationMatrix","_lightOrientationMatrixInverse","_up","LwLight","constructor","super","this","target","CSMShadowNode","light","data","camera","cascades","maxFar","mode","lightMargin","customSplitsCallback","fade","breaks","_cascades","mainFrustum","frustums","lights","_shadowNodes","_init","renderer","webGL","coordinateSystem","i","lwLight","castShadow","lShadow","clone","bias","push","updateFrustums","_initCascades","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","_getBreaks","far","Math","length","uniformSplit","near","logarithmicSplit","amount","lambda","lerp","practicalSplit","undefined","console","error","_setLightBreaks","l","prev","set","_updateShadowBounds","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","max","linearDepth","z","pow","left","right","top","bottom","_setupFade","cameraNear","setGroup","setName","shadowFar","onRenderUpdate","toVar","lastCascade","builder","setupShadowPosition","ret","cascade","cascadeCenter","margin","csmX","csmY","isLastCascade","assign","element","x","add","y","div","closestEdge","lessThan","select","mul","sub","inRange","greaterThanEqual","and","lessThanEqual","ratio","clamp","greaterThan","subAssign","oneMinus","_setupStandard","setup","updateBefore","parent","subVectors","position","normalize","lookAt","copy","invert","texelWidth","mapSize","width","texelHeight","height","multiplyMatrices","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","floor","applyMatrix4","dispose","remove"],"sources":["node_modules/three/examples/jsm/csm/CSMShadowNode.js"],"sourcesContent":["import {\n\tVector2,\n\tVector3,\n\tMathUtils,\n\tMatrix4,\n\tBox3,\n\tObject3D,\n\tWebGLCoordinateSystem,\n\tShadowBaseNode\n} from 'three/webgpu';\n\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { viewZToOrthographicDepth, reference, uniform, float, vec4, vec2, If, Fn, min, renderGroup, positionView, shadow } from 'three/tsl';\n\nconst _cameraToLightMatrix = new Matrix4();\nconst _lightSpaceFrustum = new CSMFrustum();\nconst _center = new Vector3();\nconst _bbox = new Box3();\nconst _uniformArray = [];\nconst _logArray = [];\nconst _lightDirection = new Vector3();\nconst _lightOrientationMatrix = new Matrix4();\nconst _lightOrientationMatrixInverse = new Matrix4();\nconst _up = new Vector3( 0, 1, 0 );\n\nclass LwLight extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.target = new Object3D();\n\n\t}\n\n}\n\n/**\n * An implementation of Cascade Shadow Maps (CSM).\n *\n * This module can only be used with {@link WebGPURenderer}. When using {@link WebGLRenderer},\n * use {@link CSM} instead.\n *\n * @augments ShadowBaseNode\n * @three_import import { CSMShadowNode } from 'three/addons/csm/CSMShadowNode.js';\n */\nclass CSMShadowNode extends ShadowBaseNode {\n\n\t/**\n\t * Constructs a new CSM shadow node.\n\t *\n\t * @param {DirectionalLight} light - The CSM light.\n\t * @param {CSMShadowNode~Data} [data={}] - The CSM data.\n\t */\n\tconstructor( light, data = {} ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * The scene's camera.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * The number of cascades.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.cascades = data.cascades || 3;\n\n\t\t/**\n\t\t * The maximum far value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 100000\n\t\t */\n\t\tthis.maxFar = data.maxFar || 100000;\n\n\t\t/**\n\t\t * The frustum split mode.\n\t\t *\n\t\t * @type {('practical'|'uniform'|'logarithmic'|'custom')}\n\t\t * @default 'practical'\n\t\t */\n\t\tthis.mode = data.mode || 'practical';\n\n\t\t/**\n\t\t * The light margin.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 200\n\t\t */\n\t\tthis.lightMargin = data.lightMargin || 200;\n\n\t\t/**\n\t\t * Custom split callback when using `mode='custom'`.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.customSplitsCallback = data.customSplitsCallback;\n\n\t\t/**\n\t\t * Whether to fade between cascades or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.fade = false;\n\n\t\t/**\n\t\t * An array of numbers in the range `[0,1]` the defines how the\n\t\t * mainCSM frustum should be split up.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.breaks = [];\n\n\t\tthis._cascades = [];\n\n\t\t/**\n\t\t * The main frustum.\n\t\t *\n\t\t * @type {?CSMFrustum}\n\t\t * @default null\n\t\t */\n\t\tthis.mainFrustum = null;\n\n\t\t/**\n\t\t * An array of frustums representing the cascades.\n\t\t *\n\t\t * @type {Array<CSMFrustum>}\n\t\t */\n\t\tthis.frustums = [];\n\n\t\t/**\n\t\t * An array of directional lights which cast the shadows for\n\t\t * the different cascades. There is one directional light for each\n\t\t * cascade.\n\t\t *\n\t\t * @type {Array<DirectionalLight>}\n\t\t */\n\t\tthis.lights = [];\n\n\t\tthis._shadowNodes = [];\n\n\t}\n\n\t/**\n\t * Inits the CSM shadow node.\n\t *\n\t * @private\n\t * @param {NodeBuilder} builder - The node builder.\n\t */\n\t_init( { camera, renderer } ) {\n\n\t\tthis.camera = camera;\n\n\t\tconst data = { webGL: renderer.coordinateSystem === WebGLCoordinateSystem };\n\t\tthis.mainFrustum = new CSMFrustum( data );\n\n\t\tconst light = this.light;\n\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\tconst lwLight = new LwLight();\n\t\t\tlwLight.castShadow = true;\n\n\t\t\tconst lShadow = light.shadow.clone();\n\t\t\tlShadow.bias = lShadow.bias * ( i + 1 );\n\n\t\t\tthis.lights.push( lwLight );\n\n\t\t\tlwLight.shadow = lShadow;\n\n\t\t\tthis._shadowNodes.push( shadow( lwLight, lShadow ) );\n\n\t\t\tthis._cascades.push( new Vector2() );\n\n\t\t}\n\n\t\tthis.updateFrustums();\n\n\t}\n\n\t/**\n\t * Inits the cascades according to the scene's camera and breaks configuration.\n\t *\n\t * @private\n\t */\n\t_initCascades() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateProjectionMatrix();\n\n\t\tthis.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );\n\t\tthis.mainFrustum.split( this.breaks, this.frustums );\n\n\t}\n\n\t/**\n\t * Computes the breaks of this CSM instance based on the scene's camera, number of cascades\n\t * and the selected split mode.\n\t *\n\t * @private\n\t */\n\t_getBreaks() {\n\n\t\tconst camera = this.camera;\n\t\tconst far = Math.min( camera.far, this.maxFar );\n\n\t\tthis.breaks.length = 0;\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'uniform':\n\t\t\t\tuniformSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\n\t\t\tcase 'logarithmic':\n\t\t\t\tlogarithmicSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\n\t\t\tcase 'practical':\n\t\t\t\tpracticalSplit( this.cascades, camera.near, far, 0.5, this.breaks );\n\t\t\t\tbreak;\n\n\t\t\tcase 'custom':\n\t\t\t\tif ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );\n\t\t\t\tthis.customSplitsCallback( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tfunction uniformSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near + ( far - near ) * i / amount ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction logarithmicSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near * ( far / near ) ** ( i / amount ) ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction practicalSplit( amount, near, far, lambda, target ) {\n\n\t\t\t_uniformArray.length = 0;\n\t\t\t_logArray.length = 0;\n\t\t\tlogarithmicSplit( amount, near, far, _logArray );\n\t\t\tuniformSplit( amount, near, far, _uniformArray );\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the light breaks.\n\t *\n\t * @private\n\t */\n\t_setLightBreaks() {\n\n\t\tfor ( let i = 0, l = this.cascades; i < l; i ++ ) {\n\n\t\t\tconst amount = this.breaks[ i ];\n\t\t\tconst prev = this.breaks[ i - 1 ] || 0;\n\n\t\t\tthis._cascades[ i ].set( prev, amount );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the shadow bounds of this CSM instance.\n\t *\n\t * @private\n\t */\n\t_updateShadowBounds() {\n\n\t\tconst frustums = this.frustums;\n\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst shadowCam = this.lights[ i ].shadow.camera;\n\t\t\tconst frustum = this.frustums[ i ];\n\n\t\t\t// Get the two points that represent that furthest points on the frustum assuming\n\t\t\t// that's either the diagonal across the far plane or the diagonal across the whole\n\t\t\t// frustum itself.\n\t\t\tconst nearVerts = frustum.vertices.near;\n\t\t\tconst farVerts = frustum.vertices.far;\n\t\t\tconst point1 = farVerts[ 0 ];\n\n\t\t\tlet point2;\n\n\t\t\tif ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {\n\n\t\t\t\tpoint2 = farVerts[ 2 ];\n\n\t\t\t} else {\n\n\t\t\t\tpoint2 = nearVerts[ 2 ];\n\n\t\t\t}\n\n\t\t\tlet squaredBBWidth = point1.distanceTo( point2 );\n\n\t\t\tif ( this.fade ) {\n\n\t\t\t\t// expand the shadow extents by the fade margin if fade is enabled.\n\t\t\t\tconst camera = this.camera;\n\t\t\t\tconst far = Math.max( camera.far, this.maxFar );\n\t\t\t\tconst linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );\n\t\t\t\tconst margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );\n\n\t\t\t\tsquaredBBWidth += margin;\n\n\t\t\t}\n\n\t\t\tshadowCam.left = - squaredBBWidth / 2;\n\t\t\tshadowCam.right = squaredBBWidth / 2;\n\t\t\tshadowCam.top = squaredBBWidth / 2;\n\t\t\tshadowCam.bottom = - squaredBBWidth / 2;\n\t\t\tshadowCam.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applications must call this method every time they change camera or CSM settings.\n\t */\n\tupdateFrustums() {\n\n\t\tthis._getBreaks();\n\t\tthis._initCascades();\n\t\tthis._updateShadowBounds();\n\t\tthis._setLightBreaks();\n\n\t}\n\n\t/**\n\t * Setups the TSL when using fading.\n\t *\n\t * @private\n\t * @return {ShaderCallNodeInternal}\n\t */\n\t_setupFade() {\n\n\t\tconst cameraNear = reference( 'camera.near', 'float', this ).setGroup( renderGroup );\n\t\tconst cascades = reference( '_cascades', 'vec2', this ).setGroup( renderGroup ).setName( 'cascades' );\n\n\t\tconst shadowFar = uniform( 'float' ).setGroup( renderGroup ).setName( 'shadowFar' )\n\t\t\t.onRenderUpdate( () => Math.min( this.maxFar, this.camera.far ) );\n\n\t\tconst linearDepth = viewZToOrthographicDepth( positionView.z, cameraNear, shadowFar ).toVar( 'linearDepth' );\n\t\tconst lastCascade = this.cascades - 1;\n\n\t\treturn Fn( ( builder ) => {\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tconst ret = vec4( 1, 1, 1, 1 ).toVar( 'shadowValue' );\n\n\t\t\tconst cascade = vec2().toVar( 'cascade' );\n\t\t\tconst cascadeCenter = float().toVar( 'cascadeCenter' );\n\n\t\t\tconst margin = float().toVar( 'margin' );\n\n\t\t\tconst csmX = float().toVar( 'csmX' );\n\t\t\tconst csmY = float().toVar( 'csmY' );\n\n\t\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\t\tconst isLastCascade = i === lastCascade;\n\n\t\t\t\tcascade.assign( cascades.element( i ) );\n\n\t\t\t\tcascadeCenter.assign( cascade.x.add( cascade.y ).div( 2.0 ) );\n\n\t\t\t\tconst closestEdge = linearDepth.lessThan( cascadeCenter ).select( cascade.x, cascade.y );\n\n\t\t\t\tmargin.assign( float( 0.25 ).mul( closestEdge.pow( 2.0 ) ) );\n\n\t\t\t\tcsmX.assign( cascade.x.sub( margin.div( 2.0 ) ) );\n\n\t\t\t\tif ( isLastCascade ) {\n\n\t\t\t\t\tcsmY.assign( cascade.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcsmY.assign( cascade.y.add( margin.div( 2.0 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst inRange = linearDepth.greaterThanEqual( csmX ).and( linearDepth.lessThanEqual( csmY ) );\n\n\t\t\t\tIf( inRange, () => {\n\n\t\t\t\t\tconst dist = min( linearDepth.sub( csmX ), csmY.sub( linearDepth ) ).toVar();\n\n\t\t\t\t\tlet ratio = dist.div( margin ).clamp( 0.0, 1.0 );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t// don't fade at nearest edge\n\t\t\t\t\t\tratio = linearDepth.greaterThan( cascadeCenter ).select( ratio, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tret.subAssign( this._shadowNodes[ i ].oneMinus().mul( ratio ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups the TSL when no fading (default).\n\t *\n\t * @private\n\t * @return {ShaderCallNodeInternal}\n\t */\n\t_setupStandard() {\n\n\t\tconst cameraNear = reference( 'camera.near', 'float', this ).setGroup( renderGroup );\n\t\tconst cascades = reference( '_cascades', 'vec2', this ).setGroup( renderGroup ).setName( 'cascades' );\n\n\t\tconst shadowFar = uniform( 'float' ).setGroup( renderGroup ).setName( 'shadowFar' )\n\t\t\t.onRenderUpdate( () => Math.min( this.maxFar, this.camera.far ) );\n\n\t\tconst linearDepth = viewZToOrthographicDepth( positionView.z, cameraNear, shadowFar ).toVar( 'linearDepth' );\n\n\t\treturn Fn( ( builder ) => {\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tconst ret = vec4( 1, 1, 1, 1 ).toVar( 'shadowValue' );\n\t\t\tconst cascade = vec2().toVar( 'cascade' );\n\n\t\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\t\tcascade.assign( cascades.element( i ) );\n\n\t\t\t\tIf( linearDepth.greaterThanEqual( cascade.x ).and( linearDepth.lessThanEqual( cascade.y ) ), () => {\n\n\t\t\t\t\tret.assign( this._shadowNodes[ i ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t} )();\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.camera === null ) this._init( builder );\n\n\t\treturn this.fade === true ? this._setupFade() : this._setupStandard();\n\n\t}\n\n\tupdateBefore( /*builder*/ ) {\n\n\t\tconst light = this.light;\n\t\tconst parent = light.parent;\n\t\tconst camera = this.camera;\n\t\tconst frustums = this.frustums;\n\n\t\t// make sure the placeholder light objects which represent the\n\t\t// multiple cascade shadow casters are part of the scene graph\n\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\n\n\t\t\tconst lwLight = this.lights[ i ];\n\n\t\t\tif ( lwLight.parent === null ) {\n\n\t\t\t\tparent.add( lwLight.target );\n\t\t\t\tparent.add( lwLight );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lightDirection.subVectors( light.target.position, light.position ).normalize();\n\n\t\t// for each frustum we need to find its min-max box aligned with the light orientation\n\t\t// the position in _lightOrientationMatrix does not matter, as we transform there and back\n\t\t_lightOrientationMatrix.lookAt( light.position, light.target.position, _up );\n\t\t_lightOrientationMatrixInverse.copy( _lightOrientationMatrix ).invert();\n\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst lwLight = this.lights[ i ];\n\t\t\tconst shadow = lwLight.shadow;\n\t\t\tconst shadowCam = shadow.camera;\n\t\t\tconst texelWidth = ( shadowCam.right - shadowCam.left ) / shadow.mapSize.width;\n\t\t\tconst texelHeight = ( shadowCam.top - shadowCam.bottom ) / shadow.mapSize.height;\n\n\t\t\t_cameraToLightMatrix.multiplyMatrices( _lightOrientationMatrixInverse, camera.matrixWorld );\n\t\t\tfrustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );\n\n\t\t\tconst nearVerts = _lightSpaceFrustum.vertices.near;\n\t\t\tconst farVerts = _lightSpaceFrustum.vertices.far;\n\n\t\t\t_bbox.makeEmpty();\n\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t_bbox.expandByPoint( nearVerts[ j ] );\n\t\t\t\t_bbox.expandByPoint( farVerts[ j ] );\n\n\t\t\t}\n\n\t\t\t_bbox.getCenter( _center );\n\t\t\t_center.z = _bbox.max.z + this.lightMargin;\n\t\t\t_center.x = Math.floor( _center.x / texelWidth ) * texelWidth;\n\t\t\t_center.y = Math.floor( _center.y / texelHeight ) * texelHeight;\n\t\t\t_center.applyMatrix4( _lightOrientationMatrix );\n\n\t\t\tlwLight.position.copy( _center );\n\t\t\tlwLight.target.position.copy( _center );\n\t\t\tlwLight.target.position.add( _lightDirection );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\n\n\t\t\tconst light = this.lights[ i ];\n\t\t\tconst parent = light.parent;\n\n\t\t\tparent.remove( light.target );\n\t\t\tparent.remove( light );\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\n/**\n * Constructor data of `CSMShadowNode`.\n *\n * @typedef {Object} CSMShadowNode~Data\n * @property {number} [cascades=3] - The number of cascades.\n * @property {number} [maxFar=100000] - The maximum far value.\n * @property {('practical'|'uniform'|'logarithmic'|'custom')} [mode='practical'] - The frustum split mode.\n * @property {Function} [customSplitsCallback] - Custom split callback when using `mode='custom'`.\n * @property {number} [lightMargin=200] - The light margin.\n **/\n\nexport { CSMShadowNode };\n"],"mappings":"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","ignoreList":[]}