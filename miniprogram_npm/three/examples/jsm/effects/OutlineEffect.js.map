{"version":3,"file":"node_modules/three/examples/jsm/effects/OutlineEffect.js","names":["BackSide","Color","ShaderMaterial","UniformsLib","UniformsUtils","OutlineEffect","constructor","renderer","parameters","this","enabled","defaultThickness","undefined","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","getOutlineMaterial","originalMaterial","outlineMaterial","data","uuid","material","type","uniforms","merge","side","used","keepAlive","count","getOutlineMaterialFromCache","name","outlineParameters","userData","fog","toneMapped","premultipliedAlpha","displacementMap","visible","transparent","alpha","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","scene","camera","opacity","thickness","color","displacementScale","displacementBias","updateUniforms","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","keys","Object","key","cleanupCache","setSize","width","height"],"sources":["node_modules/three/examples/jsm/effects/OutlineEffect.js"],"sourcesContent":["import {\n\tBackSide,\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils\n} from 'three';\n\n/**\n * An outline effect for toon shaders.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ToonOutlinePassNode}.\n *\n * ```js\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n * ```\n *\n * @three_import import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';\n */\nclass OutlineEffect {\n\n\t/**\n\t * Constructs a new outline effect.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {OutlineEffect~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( renderer, parameters = {} ) {\n\n\t\tthis.enabled = true;\n\n\t\tconst defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\t\tconst defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\t\tconst defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\t\tconst defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t\t// object.material.uuid -> outlineMaterial or\n\t\t// object.material[ n ].uuid -> outlineMaterial\n\t\t// save at the outline material creation and release\n\t\t// if it's unused removeThresholdCount frames\n\t\t// unless keepAlive is true.\n\t\tconst cache = {};\n\n\t\tconst removeThresholdCount = 60;\n\n\t\t// outlineMaterial.uuid -> object.material or\n\t\t// outlineMaterial.uuid -> object.material[ n ]\n\t\t// save before render and release after render.\n\t\tconst originalMaterials = {};\n\n\t\t// object.uuid -> originalOnBeforeRender\n\t\t// save before render and release after render.\n\t\tconst originalOnBeforeRenders = {};\n\n\t\t//this.cache = cache;  // for debug\n\n\t\tconst uniformsOutline = {\n\t\t\toutlineThickness: { value: defaultThickness },\n\t\t\toutlineColor: { value: defaultColor },\n\t\t\toutlineAlpha: { value: defaultAlpha }\n\t\t};\n\n\t\tconst vertexShader = [\n\t\t\t'#include <common>',\n\t\t\t'#include <uv_pars_vertex>',\n\t\t\t'#include <displacementmap_pars_vertex>',\n\t\t\t'#include <fog_pars_vertex>',\n\t\t\t'#include <morphtarget_pars_vertex>',\n\t\t\t'#include <skinning_pars_vertex>',\n\t\t\t'#include <logdepthbuf_pars_vertex>',\n\t\t\t'#include <clipping_planes_pars_vertex>',\n\n\t\t\t'uniform float outlineThickness;',\n\n\t\t\t'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n\t\t\t'\tfloat thickness = outlineThickness;',\n\t\t\t'\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n\t\t\t'\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\t'\tvec4 norm = normalize( pos - pos2 );',\n\t\t\t'\treturn pos + norm * thickness * pos.w * ratio;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <uv_vertex>',\n\n\t\t\t'\t#include <beginnormal_vertex>',\n\t\t\t'\t#include <morphnormal_vertex>',\n\t\t\t'\t#include <skinbase_vertex>',\n\t\t\t'\t#include <skinnormal_vertex>',\n\n\t\t\t'\t#include <begin_vertex>',\n\t\t\t'\t#include <morphtarget_vertex>',\n\t\t\t'\t#include <skinning_vertex>',\n\t\t\t'\t#include <displacementmap_vertex>',\n\t\t\t'\t#include <project_vertex>',\n\n\t\t\t'\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n\t\t\t'\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n\t\t\t'\t#include <logdepthbuf_vertex>',\n\t\t\t'\t#include <clipping_planes_vertex>',\n\t\t\t'\t#include <fog_vertex>',\n\n\t\t\t'}',\n\n\t\t].join( '\\n' );\n\n\t\tconst fragmentShader = [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_fragment>',\n\t\t\t'#include <logdepthbuf_pars_fragment>',\n\t\t\t'#include <clipping_planes_pars_fragment>',\n\n\t\t\t'uniform vec3 outlineColor;',\n\t\t\t'uniform float outlineAlpha;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <clipping_planes_fragment>',\n\t\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t\t'\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t'\t#include <colorspace_fragment>',\n\t\t\t'\t#include <fog_fragment>',\n\t\t\t'\t#include <premultiplied_alpha_fragment>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' );\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new ShaderMaterial( {\n\t\t\t\ttype: 'OutlineEffect',\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\t\tUniformsLib[ 'displacementmap' ],\n\t\t\t\t\tuniformsOutline\n\t\t\t\t] ),\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: BackSide\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\t\tlet data = cache[ originalMaterial.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tdata = {\n\t\t\t\t\tmaterial: createMaterial(),\n\t\t\t\t\tused: true,\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t\t}\n\n\t\t\tdata.used = true;\n\n\t\t\treturn data.material;\n\n\t\t}\n\n\t\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\t\tconst outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\t\treturn outlineMaterial;\n\n\t\t}\n\n\t\tfunction isCompatible( object ) {\n\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst hasNormals = ( geometry !== undefined ) && ( geometry.attributes.normal !== undefined );\n\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\n\n\t\t}\n\n\t\tfunction setOutlineMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t\t}\n\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\t\tobject.onBeforeRender = onBeforeRender;\n\n\t\t}\n\n\t\tfunction restoreOriginalMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t\t}\n\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t\t}\n\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\n\n\t\t\tconst originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t\t// just in case\n\t\t\tif ( originalMaterial === undefined ) return;\n\n\t\t\tupdateUniforms( material, originalMaterial );\n\n\t\t}\n\n\t\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.displacementMap ) {\n\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\t\tif ( material.name === 'invisible' ) return;\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.fog = originalMaterial.fog;\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\t\tmaterial.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t\t\tif ( originalMaterial.clippingPlanes ) {\n\n\t\t\t\tmaterial.clipping = true;\n\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\n\n\t\t\t}\n\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\n\n\t\t}\n\n\t\tfunction cleanupCache() {\n\n\t\t\tlet keys;\n\n\t\t\t// clear originalMaterials\n\t\t\tkeys = Object.keys( originalMaterials );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// clear originalOnBeforeRenders\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// remove unused outlineMaterial from cache\n\t\t\tkeys = Object.keys( cache );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tconst key = keys[ i ];\n\n\t\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache[ key ].used = false;\n\t\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * When using this effect, this method should be called instead of the\n\t\t * default {@link WebGLRenderer#render}.\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( this.enabled === false ) {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = this.autoClear;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\tthis.renderOutline( scene, camera );\n\n\t\t};\n\n\t\t/**\n\t\t * This method can be used to render outlines in VR.\n\t\t *\n\t\t * ```js\n\t\t * const effect = new OutlineEffect( renderer );\n\t\t * let renderingOutline = false;\n\t\t *\n\t\t * scene.onAfterRender = function () {\n\t\t *\n\t\t * \tif ( renderingOutline ) return;\n\t\t *\n\t\t * \trenderingOutline = true;\n\t\t * \teffect.renderOutline( scene, camera );\n\t\t * \trenderingOutline = false;\n\t\t * };\n\t\t *\n\t\t * function render() {\n\t\t * \trenderer.render( scene, camera );\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.renderOutline = function ( scene, camera ) {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\tconst currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n\t\t\tconst currentSceneBackground = scene.background;\n\t\t\tconst currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\t\tscene.matrixWorldAutoUpdate = false;\n\t\t\tscene.background = null;\n\t\t\trenderer.autoClear = false;\n\t\t\trenderer.shadowMap.enabled = false;\n\n\t\t\tscene.traverse( setOutlineMaterial );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\t\tcleanupCache();\n\n\t\t\tscene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n\t\t\tscene.background = currentSceneBackground;\n\t\t\trenderer.autoClear = currentAutoClear;\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t\t};\n\n\t\t/**\n\t\t * Resizes the effect.\n\t\t *\n\t\t * @param {number} width - The width of the effect in logical pixels.\n\t\t * @param {number} height - The height of the effect in logical pixels.\n\t\t */\n\t\tthis.setSize = function ( width, height ) {\n\n\t\t\trenderer.setSize( width, height );\n\n\t\t};\n\n\t}\n\n}\n\n/**\n * This type represents configuration settings of `OutlineEffect`.\n *\n * @typedef {Object} OutlineEffect~Options\n * @property {number} [defaultThickness=0.003] - The outline thickness.\n * @property {Array<number>} [defaultColor=[0,0,0]] - The outline color.\n * @property {number} [defaultAlpha=1] - The outline alpha value.\n * @property {boolean} [defaultKeepAlive=false] - Whether to keep alive cached internal materials or not.\n **/\n\n\nexport { OutlineEffect };\n"],"mappings":"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","ignoreList":[]}