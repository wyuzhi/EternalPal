{"version":3,"file":"node_modules/three/examples/jsm/effects/ParallaxBarrierEffect.js","names":["LinearFilter","NearestFilter","RGBAFormat","ShaderMaterial","StereoCamera","WebGLRenderTarget","FullScreenQuad","ParallaxBarrierEffect","constructor","renderer","_stereo","_params","minFilter","magFilter","format","_renderTargetL","_renderTargetR","_material","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","_quad","this","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","currentRenderTarget","getRenderTarget","matrixWorldAutoUpdate","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR","dispose"],"sources":["node_modules/three/examples/jsm/effects/ParallaxBarrierEffect.js"],"sourcesContent":["import {\n\tLinearFilter,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tStereoCamera,\n\tWebGLRenderTarget\n} from 'three';\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * A class that creates an parallax barrier effect.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ParallaxBarrierPassNode}.\n *\n * @three_import import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';\n */\nclass ParallaxBarrierEffect {\n\n\t/**\n\t * Constructs a new parallax barrier effect.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( renderer ) {\n\n\t\tconst _stereo = new StereoCamera();\n\n\t\tconst _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\tconst _renderTargetL = new WebGLRenderTarget( 512, 512, _params );\n\t\tconst _renderTargetR = new WebGLRenderTarget( 512, 512, _params );\n\n\t\tconst _material = new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\n\t\t\t\t'mapLeft': { value: _renderTargetL.texture },\n\t\t\t\t'mapRight': { value: _renderTargetR.texture }\n\n\t\t\t},\n\n\t\t\tvertexShader: [\n\n\t\t\t\t'varying vec2 vUv;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUv = vec2( uv.x, uv.y );',\n\t\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t'uniform sampler2D mapLeft;',\n\t\t\t\t'uniform sampler2D mapRight;',\n\t\t\t\t'varying vec2 vUv;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvec2 uv = vUv;',\n\n\t\t\t\t'\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',\n\n\t\t\t\t'\t\tgl_FragColor = texture2D( mapLeft, uv );',\n\n\t\t\t\t'\t} else {',\n\n\t\t\t\t'\t\tgl_FragColor = texture2D( mapRight, uv );',\n\n\t\t\t\t'\t}',\n\n\t\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t\t'\t#include <colorspace_fragment>',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' )\n\n\t\t} );\n\n\t\tconst _quad = new FullScreenQuad( _material );\n\n\t\t/**\n\t\t * Resizes the effect.\n\t\t *\n\t\t * @param {number} width - The width of the effect in logical pixels.\n\t\t * @param {number} height - The height of the effect in logical pixels.\n\t\t */\n\t\tthis.setSize = function ( width, height ) {\n\n\t\t\trenderer.setSize( width, height );\n\n\t\t\tconst pixelRatio = renderer.getPixelRatio();\n\n\t\t\t_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );\n\t\t\t_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );\n\n\t\t};\n\n\t\t/**\n\t\t * When using this effect, this method should be called instead of the\n\t\t * default {@link WebGLRenderer#render}.\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\t_stereo.update( camera );\n\n\t\t\trenderer.setRenderTarget( _renderTargetL );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( scene, _stereo.cameraL );\n\n\t\t\trenderer.setRenderTarget( _renderTargetR );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( scene, _stereo.cameraR );\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\t_quad.render( renderer );\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t/**\n\t\t * Frees internal resources. This method should be called\n\t\t * when the effect is no longer required.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\t_renderTargetL.dispose();\n\t\t\t_renderTargetR.dispose();\n\n\t\t\t_material.dispose();\n\t\t\t_quad.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nexport { ParallaxBarrierEffect };\n"],"mappings":"OACCA,aACAC,cACAC,WACAC,eACAC,aACAC,sBACM,eACEC,mBAAsB,4BAU/B,MAAMC,sBAOL,WAAAC,CAAaC,GAEZ,MAAMC,EAAU,IAAIN,aAEdO,EAAU,CAAEC,UAAWZ,aAAca,UAAWZ,cAAea,OAAQZ,YAEvEa,EAAiB,IAAIV,kBAAmB,IAAK,IAAKM,GAClDK,EAAiB,IAAIX,kBAAmB,IAAK,IAAKM,GAElDM,EAAY,IAAId,eAAgB,CAErCe,SAAU,CAETC,QAAW,CAAEC,MAAOL,EAAeM,SACnCC,SAAY,CAAEF,MAAOJ,EAAeK,UAIrCE,aAAc,CAEb,oBAEA,gBAEA,8BACA,8EAEA,KAECC,KAAM,MAERC,eAAgB,CAEf,6BACA,8BACA,oBAEA,gBAEA,mBAEA,mDAEA,+CAEA,aAEA,gDAEA,MAEA,oCACA,mCAEA,KAECD,KAAM,QAIHE,EAAQ,IAAIpB,eAAgBW,GAQlCU,KAAKC,QAAU,SAAWC,EAAOC,GAEhCrB,EAASmB,QAASC,EAAOC,GAEzB,MAAMC,EAAatB,EAASuB,gBAE5BjB,EAAea,QAASC,EAAQE,EAAYD,EAASC,GACrDf,EAAeY,QAASC,EAAQE,EAAYD,EAASC,EAEtD,EASAJ,KAAKM,OAAS,SAAWC,EAAOC,GAE/B,MAAMC,EAAsB3B,EAAS4B,mBAEA,IAAhCH,EAAMI,uBAAiCJ,EAAMK,oBAE3B,OAAlBJ,EAAOK,SAAoD,IAAjCL,EAAOG,uBAAiCH,EAAOI,oBAE9E7B,EAAQ+B,OAAQN,GAEhB1B,EAASiC,gBAAiB3B,GAC1BN,EAASkC,QACTlC,EAASwB,OAAQC,EAAOxB,EAAQkC,SAEhCnC,EAASiC,gBAAiB1B,GAC1BP,EAASkC,QACTlC,EAASwB,OAAQC,EAAOxB,EAAQmC,SAEhCpC,EAASiC,gBAAiB,MAC1BhB,EAAMO,OAAQxB,GAEdA,EAASiC,gBAAiBN,EAE3B,EAMAT,KAAKmB,QAAU,WAEd/B,EAAe+B,UACf9B,EAAe8B,UAEf7B,EAAU6B,UACVpB,EAAMoB,SAEP,CAED,SAIQvC","ignoreList":[]}