import{Color,ColorManagement,SRGBColorSpace}from"three";class DRACOExporter{parse(e,o={}){if(o=Object.assign({decodeSpeed:5,encodeSpeed:5,encoderMethod:DRACOExporter.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1},o),void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");const t=e.geometry,r=DracoEncoderModule(),n=new r.Encoder;let i,d;if(!0===e.isMesh){i=new r.MeshBuilder,d=new r.Mesh;const e=t.getAttribute("position");i.AddFloatAttributeToMesh(d,r.POSITION,e.count,e.itemSize,e.array);const n=t.getIndex();if(null!==n)i.AddFacesToMesh(d,n.count/3,n.array);else{const o=new(e.count>65535?Uint32Array:Uint16Array)(e.count);for(let e=0;e<o.length;e++)o[e]=e;i.AddFacesToMesh(d,e.count,o)}if(!0===o.exportNormals){const e=t.getAttribute("normal");void 0!==e&&i.AddFloatAttributeToMesh(d,r.NORMAL,e.count,e.itemSize,e.array)}if(!0===o.exportUvs){const e=t.getAttribute("uv");void 0!==e&&i.AddFloatAttributeToMesh(d,r.TEX_COORD,e.count,e.itemSize,e.array)}if(!0===o.exportColor){const e=t.getAttribute("color");if(void 0!==e){const o=createVertexColorSRGBArray(e);i.AddFloatAttributeToMesh(d,r.COLOR,e.count,e.itemSize,o)}}}else{if(!0!==e.isPoints)throw new Error("DRACOExporter: Unsupported object type.");{i=new r.PointCloudBuilder,d=new r.PointCloud;const e=t.getAttribute("position");if(i.AddFloatAttribute(d,r.POSITION,e.count,e.itemSize,e.array),!0===o.exportColor){const e=t.getAttribute("color");if(void 0!==e){const o=createVertexColorSRGBArray(e);i.AddFloatAttribute(d,r.COLOR,e.count,e.itemSize,o)}}}}const a=new r.DracoInt8Array,c=void 0!==o.encodeSpeed?o.encodeSpeed:5,A=void 0!==o.decodeSpeed?o.decodeSpeed:5;if(n.SetSpeedOptions(c,A),void 0!==o.encoderMethod&&n.SetEncodingMethod(o.encoderMethod),void 0!==o.quantization)for(let e=0;e<5;e++)void 0!==o.quantization[e]&&n.SetAttributeQuantization(e,o.quantization[e]);let s;if(s=!0===e.isMesh?n.EncodeMeshToDracoBuffer(d,a):n.EncodePointCloudToDracoBuffer(d,!0,a),r.destroy(d),0===s)throw new Error("THREE.DRACOExporter: Draco encoding failed.");const E=new Int8Array(new ArrayBuffer(s));for(let e=0;e<s;e++)E[e]=a.GetValue(e);return r.destroy(a),r.destroy(n),r.destroy(i),E}}function createVertexColorSRGBArray(e){const o=new Color,t=e.count,r=e.itemSize,n=new Float32Array(t*r);for(let i=0,d=t;i<d;i++)o.fromBufferAttribute(e,i),ColorManagement.workingToColorSpace(o,SRGBColorSpace),n[i*r]=o.r,n[i*r+1]=o.g,n[i*r+2]=o.b,4===r&&(n[i*r+3]=e.getW(i));return n}DRACOExporter.MESH_EDGEBREAKER_ENCODING=1,DRACOExporter.MESH_SEQUENTIAL_ENCODING=0,DRACOExporter.POINT_CLOUD=0,DRACOExporter.TRIANGULAR_MESH=1,DRACOExporter.INVALID=-1,DRACOExporter.POSITION=0,DRACOExporter.NORMAL=1,DRACOExporter.COLOR=2,DRACOExporter.TEX_COORD=3,DRACOExporter.GENERIC=4;export{DRACOExporter};
//# sourceMappingURL=DRACOExporter.js.map