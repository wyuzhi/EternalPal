{"version":3,"file":"node_modules/three/examples/jsm/exporters/DRACOExporter.js","names":["Color","ColorManagement","SRGBColorSpace","DRACOExporter","parse","object","options","Object","assign","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","undefined","DracoEncoderModule","Error","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","Mesh","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","createVertexColorSRGBArray","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","attribute","_color","Float32Array","il","fromBufferAttribute","workingToColorSpace","r","g","b","getW","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC"],"sources":["node_modules/three/examples/jsm/exporters/DRACOExporter.js"],"sourcesContent":["import { Color, ColorManagement, SRGBColorSpace } from 'three';\n\n/* global DracoEncoderModule */\n\n/**\n * An exporter to compress geometry with the Draco library.\n *\n * [Draco]{@link https://google.github.io/draco/} is an open source library for compressing and\n * decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,\n * at the cost of additional decoding time on the client device.\n *\n * Standalone Draco files have a `.drc` extension, and contain vertex positions,\n * normals, colors, and other attributes. Draco files *do not* contain materials,\n * textures, animation, or node hierarchies â€“ to use these features, embed Draco geometry\n * inside of a glTF file. A normal glTF file can be converted to a Draco-compressed glTF file\n * using [glTF-Pipeline]{@link https://github.com/AnalyticalGraphicsInc/gltf-pipeline}.\n *\n * ```js\n * const exporter = new DRACOExporter();\n * const data = exporter.parse( mesh, options );\n * ```\n *\n * @three_import import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';\n */\nclass DRACOExporter {\n\n\t/**\n\t * Parses the given mesh or point cloud and generates the Draco output.\n\t *\n\t * @param {(Mesh|Points)} object - The mesh or point cloud to export.\n\t * @param {DRACOExporter~Options} options - The export options.\n\t * @return {Int8Array} The exported Draco.\n\t */\n\tparse( object, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tdecodeSpeed: 5,\n\t\t\tencodeSpeed: 5,\n\t\t\tencoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n\t\t\tquantization: [ 16, 8, 8, 8, 8 ],\n\t\t\texportUvs: true,\n\t\t\texportNormals: true,\n\t\t\texportColor: false,\n\t\t}, options );\n\n\t\tif ( DracoEncoderModule === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOExporter: required the draco_encoder to work.' );\n\n\t\t}\n\n\t\tconst geometry = object.geometry;\n\n\t\tconst dracoEncoder = DracoEncoderModule();\n\t\tconst encoder = new dracoEncoder.Encoder();\n\t\tlet builder;\n\t\tlet dracoObject;\n\n\t\tif ( object.isMesh === true ) {\n\n\t\t\tbuilder = new dracoEncoder.MeshBuilder();\n\t\t\tdracoObject = new dracoEncoder.Mesh();\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tconst faces = geometry.getIndex();\n\n\t\t\tif ( faces !== null ) {\n\n\t\t\t\tbuilder.AddFacesToMesh( dracoObject, faces.count / 3, faces.array );\n\n\t\t\t} else {\n\n\t\t\t\tconst faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );\n\n\t\t\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\t\tfaces[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.AddFacesToMesh( dracoObject, vertices.count, faces );\n\n\t\t\t}\n\n\t\t\tif ( options.exportNormals === true ) {\n\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportUvs === true ) {\n\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tconst array = createVertexColorSRGBArray( colors );\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints === true ) {\n\n\t\t\tbuilder = new dracoEncoder.PointCloudBuilder();\n\t\t\tdracoObject = new dracoEncoder.PointCloud();\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttribute( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tconst array = createVertexColorSRGBArray( colors );\n\n\t\t\t\t\tbuilder.AddFloatAttribute( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'DRACOExporter: Unsupported object type.' );\n\n\t\t}\n\n\t\t//Compress using draco encoder\n\n\t\tconst encodedData = new dracoEncoder.DracoInt8Array();\n\n\t\t//Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n\t\tconst encodeSpeed = ( options.encodeSpeed !== undefined ) ? options.encodeSpeed : 5;\n\t\tconst decodeSpeed = ( options.decodeSpeed !== undefined ) ? options.decodeSpeed : 5;\n\n\t\tencoder.SetSpeedOptions( encodeSpeed, decodeSpeed );\n\n\t\t// Sets the desired encoding method for a given geometry.\n\n\t\tif ( options.encoderMethod !== undefined ) {\n\n\t\t\tencoder.SetEncodingMethod( options.encoderMethod );\n\n\t\t}\n\n\t\t// Sets the quantization (number of bits used to represent) compression options for a named attribute.\n\t\t// The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\t\tif ( options.quantization !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < 5; i ++ ) {\n\n\t\t\t\tif ( options.quantization[ i ] !== undefined ) {\n\n\t\t\t\t\tencoder.SetAttributeQuantization( i, options.quantization[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet length;\n\n\t\tif ( object.isMesh === true ) {\n\n\t\t\tlength = encoder.EncodeMeshToDracoBuffer( dracoObject, encodedData );\n\n\t\t} else {\n\n\t\t\tlength = encoder.EncodePointCloudToDracoBuffer( dracoObject, true, encodedData );\n\n\t\t}\n\n\t\tdracoEncoder.destroy( dracoObject );\n\n\t\tif ( length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOExporter: Draco encoding failed.' );\n\n\t\t}\n\n\t\t//Copy encoded data to buffer.\n\t\tconst outputData = new Int8Array( new ArrayBuffer( length ) );\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\toutputData[ i ] = encodedData.GetValue( i );\n\n\t\t}\n\n\t\tdracoEncoder.destroy( encodedData );\n\t\tdracoEncoder.destroy( encoder );\n\t\tdracoEncoder.destroy( builder );\n\n\t\treturn outputData;\n\n\t}\n\n}\n\nfunction createVertexColorSRGBArray( attribute ) {\n\n\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB is expected\n\t// for .drc files, but note that Draco buffers embedded in glTF files will\n\t// be Linear-sRGB instead.\n\n\tconst _color = new Color();\n\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst array = new Float32Array( count * itemSize );\n\n\tfor ( let i = 0, il = count; i < il; i ++ ) {\n\n\t\t_color.fromBufferAttribute( attribute, i );\n\n\t\tColorManagement.workingToColorSpace( _color, SRGBColorSpace );\n\n\t\tarray[ i * itemSize ] = _color.r;\n\t\tarray[ i * itemSize + 1 ] = _color.g;\n\t\tarray[ i * itemSize + 2 ] = _color.b;\n\n\t\tif ( itemSize === 4 ) {\n\n\t\t\tarray[ i * itemSize + 3 ] = attribute.getW( i );\n\n\t\t}\n\n\t}\n\n\treturn array;\n\n}\n\n// Encoder methods\n\n/**\n * Edgebreaker encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 1\n */\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\n/**\n * Sequential encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 0\n */\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n// Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1;\n\n// Attribute type\n\nDRACOExporter.INVALID = - 1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n\n/**\n * Export options of `DRACOExporter`.\n *\n * @typedef {Object} DRACOExporter~Options\n * @property {number} [decodeSpeed=5] - Indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality).\n * @property {number} [encodeSpeed=5] - Indicates how to tune the encoder parameters (0 gives better speed but worst quality).\n * @property {number} [encoderMethod=1] - Either sequential (very little compression) or Edgebreaker. Edgebreaker traverses the triangles of the mesh in a deterministic, spiral-like way which provides most of the benefits of this data format.\n * @property {Array<number>} [quantization=[ 16, 8, 8, 8, 8 ]] - Indicates the precision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC).\n * @property {boolean} [exportUvs=true] - Whether to export UVs or not.\n * @property {boolean} [exportNormals=true] - Whether to export normals or not.\n * @property {boolean} [exportColor=false] - Whether to export colors or not.\n **/\n\nexport { DRACOExporter };\n"],"mappings":"OAASA,MAAOC,gBAAiBC,mBAAsB,QAwBvD,MAAMC,cASL,KAAAC,CAAOC,EAAQC,EAAU,CAAC,GAYzB,GAVAA,EAAUC,OAAOC,OAAQ,CACxBC,YAAa,EACbC,YAAa,EACbC,cAAeR,cAAcS,0BAC7BC,aAAc,CAAE,GAAI,EAAG,EAAG,EAAG,GAC7BC,WAAW,EACXC,eAAe,EACfC,aAAa,GACXV,QAEyBW,IAAvBC,mBAEJ,MAAM,IAAIC,MAAO,4DAIlB,MAAMC,EAAWf,EAAOe,SAElBC,EAAeH,qBACfI,EAAU,IAAID,EAAaE,QACjC,IAAIC,EACAC,EAEJ,IAAuB,IAAlBpB,EAAOqB,OAAkB,CAE7BF,EAAU,IAAIH,EAAaM,YAC3BF,EAAc,IAAIJ,EAAaO,KAE/B,MAAMC,EAAWT,EAASU,aAAc,YACxCN,EAAQO,wBAAyBN,EAAaJ,EAAaW,SAAUH,EAASI,MAAOJ,EAASK,SAAUL,EAASM,OAEjH,MAAMC,EAAQhB,EAASiB,WAEvB,GAAe,OAAVD,EAEJZ,EAAQc,eAAgBb,EAAaW,EAAMH,MAAQ,EAAGG,EAAMD,WAEtD,CAEN,MAAMC,EAAQ,IAAMP,EAASI,MAAQ,MAAQM,YAAcC,aAAeX,EAASI,OAEnF,IAAM,IAAIQ,EAAI,EAAGA,EAAIL,EAAMM,OAAQD,IAElCL,EAAOK,GAAMA,EAIdjB,EAAQc,eAAgBb,EAAaI,EAASI,MAAOG,EAEtD,CAEA,IAA+B,IAA1B9B,EAAQS,cAAyB,CAErC,MAAM4B,EAAUvB,EAASU,aAAc,eAEtBb,IAAZ0B,GAEJnB,EAAQO,wBAAyBN,EAAaJ,EAAauB,OAAQD,EAAQV,MAAOU,EAAQT,SAAUS,EAAQR,MAI9G,CAEA,IAA2B,IAAtB7B,EAAQQ,UAAqB,CAEjC,MAAM+B,EAAMzB,EAASU,aAAc,WAEtBb,IAAR4B,GAEJrB,EAAQO,wBAAyBN,EAAaJ,EAAayB,UAAWD,EAAIZ,MAAOY,EAAIX,SAAUW,EAAIV,MAIrG,CAEA,IAA6B,IAAxB7B,EAAQU,YAAuB,CAEnC,MAAM+B,EAAS3B,EAASU,aAAc,SAEtC,QAAgBb,IAAX8B,EAAuB,CAE3B,MAAMZ,EAAQa,2BAA4BD,GAE1CvB,EAAQO,wBAAyBN,EAAaJ,EAAa4B,MAAOF,EAAOd,MAAOc,EAAOb,SAAUC,EAElG,CAED,CAED,KAAO,KAAyB,IAApB9B,EAAO6C,SAwBlB,MAAM,IAAI/B,MAAO,2CAxBqB,CAEtCK,EAAU,IAAIH,EAAa8B,kBAC3B1B,EAAc,IAAIJ,EAAa+B,WAE/B,MAAMvB,EAAWT,EAASU,aAAc,YAGxC,GAFAN,EAAQ6B,kBAAmB5B,EAAaJ,EAAaW,SAAUH,EAASI,MAAOJ,EAASK,SAAUL,EAASM,QAE9E,IAAxB7B,EAAQU,YAAuB,CAEnC,MAAM+B,EAAS3B,EAASU,aAAc,SAEtC,QAAgBb,IAAX8B,EAAuB,CAE3B,MAAMZ,EAAQa,2BAA4BD,GAE1CvB,EAAQ6B,kBAAmB5B,EAAaJ,EAAa4B,MAAOF,EAAOd,MAAOc,EAAOb,SAAUC,EAE5F,CAED,CAED,CAIA,CAIA,MAAMmB,EAAc,IAAIjC,EAAakC,eAI/B7C,OAAwCO,IAAxBX,EAAQI,YAA8BJ,EAAQI,YAAc,EAC5ED,OAAwCQ,IAAxBX,EAAQG,YAA8BH,EAAQG,YAAc,EAclF,GAZAa,EAAQkC,gBAAiB9C,EAAaD,QAIPQ,IAA1BX,EAAQK,eAEZW,EAAQmC,kBAAmBnD,EAAQK,oBAMNM,IAAzBX,EAAQO,aAEZ,IAAM,IAAI4B,EAAI,EAAGA,EAAI,EAAGA,SAEYxB,IAA9BX,EAAQO,aAAc4B,IAE1BnB,EAAQoC,yBAA0BjB,EAAGnC,EAAQO,aAAc4B,IAQ9D,IAAIC,EAcJ,GAVCA,GAFsB,IAAlBrC,EAAOqB,OAEFJ,EAAQqC,wBAAyBlC,EAAa6B,GAI9ChC,EAAQsC,8BAA+BnC,GAAa,EAAM6B,GAIpEjC,EAAawC,QAASpC,GAEN,IAAXiB,EAEJ,MAAM,IAAIvB,MAAO,+CAKlB,MAAM2C,EAAa,IAAIC,UAAW,IAAIC,YAAatB,IAEnD,IAAM,IAAID,EAAI,EAAGA,EAAIC,EAAQD,IAE5BqB,EAAYrB,GAAMa,EAAYW,SAAUxB,GAQzC,OAJApB,EAAawC,QAASP,GACtBjC,EAAawC,QAASvC,GACtBD,EAAawC,QAASrC,GAEfsC,CAER,EAID,SAASd,2BAA4BkB,GAOpC,MAAMC,EAAS,IAAInE,MAEbiC,EAAQiC,EAAUjC,MAClBC,EAAWgC,EAAUhC,SACrBC,EAAQ,IAAIiC,aAAcnC,EAAQC,GAExC,IAAM,IAAIO,EAAI,EAAG4B,EAAKpC,EAAOQ,EAAI4B,EAAI5B,IAEpC0B,EAAOG,oBAAqBJ,EAAWzB,GAEvCxC,gBAAgBsE,oBAAqBJ,EAAQjE,gBAE7CiC,EAAOM,EAAIP,GAAaiC,EAAOK,EAC/BrC,EAAOM,EAAIP,EAAW,GAAMiC,EAAOM,EACnCtC,EAAOM,EAAIP,EAAW,GAAMiC,EAAOO,EAEjB,IAAbxC,IAEJC,EAAOM,EAAIP,EAAW,GAAMgC,EAAUS,KAAMlC,IAM9C,OAAON,CAER,CAYAhC,cAAcS,0BAA4B,EAU1CT,cAAcyE,yBAA2B,EAIzCzE,cAAc0E,YAAc,EAC5B1E,cAAc2E,gBAAkB,EAIhC3E,cAAc4E,SAAY,EAC1B5E,cAAc6B,SAAW,EACzB7B,cAAcyC,OAAS,EACvBzC,cAAc8C,MAAQ,EACtB9C,cAAc2C,UAAY,EAC1B3C,cAAc6E,QAAU,SAef7E","ignoreList":[]}