import{FloatType,HalfFloatType,RGBAFormat,DataUtils}from"three";import*as fflate from"../libs/fflate.module.js";const textEncoder=new TextEncoder,NO_COMPRESSION=0,ZIPS_COMPRESSION=2,ZIP_COMPRESSION=3;class EXRExporter{async parse(t,e,a){if(!t||!(t.isWebGLRenderer||t.isWebGPURenderer||t.isDataTexture))throw Error("EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer, WebGPURenderer or DataTexture.");if(t.isWebGLRenderer||t.isWebGPURenderer){const r=t,n=e,i=a;supportedRTT(n);const o=buildInfoRTT(n,i);return fillData(compressData(reorganizeDataBuffer(await getPixelData(r,n,o),o),o),o)}if(t.isDataTexture){const a=t,r=e;supportedDT(a);const n=buildInfoDT(a,r);return fillData(compressData(reorganizeDataBuffer(a.image.data,n),n),n)}}}function supportedRTT(t){if(!t||!t.isRenderTarget)throw Error("EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.");if(t.isWebGLCubeRenderTarget||t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)throw Error("EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.");if(t.texture.type!==FloatType&&t.texture.type!==HalfFloatType)throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture type.");if(t.texture.format!==RGBAFormat)throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.")}function supportedDT(t){if(t.type!==FloatType&&t.type!==HalfFloatType)throw Error("EXRExporter.parse: Unsupported DataTexture texture type.");if(t.format!==RGBAFormat)throw Error("EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.");if(!t.image.data)throw Error("EXRExporter.parse: Invalid DataTexture image data.");if(t.type===FloatType&&"Float32Array"!==t.image.data.constructor.name)throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Float32Array'.");if(t.type===HalfFloatType&&"Uint16Array"!==t.image.data.constructor.name)throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Uint16Array'.")}function buildInfoRTT(t,e={}){const a=t.width,r=t.height,n=t.texture.type,i=t.texture.format,o=void 0!==e.compression?e.compression:3,s=(void 0!==e.type?e.type:HalfFloatType)===FloatType?2:1,l={0:1,2:1,3:16}[o];return{width:a,height:r,type:n,format:i,compression:o,blockLines:l,dataType:s,dataSize:2*s,numBlocks:Math.ceil(r/l),numInputChannels:4,numOutputChannels:4}}function buildInfoDT(t,e={}){const a=t.image.width,r=t.image.height,n=t.type,i=t.format,o=void 0!==e.compression?e.compression:3,s=(void 0!==e.type?e.type:HalfFloatType)===FloatType?2:1,l={0:1,2:1,3:16}[o];return{width:a,height:r,type:n,format:i,compression:o,blockLines:l,dataType:s,dataSize:2*s,numBlocks:Math.ceil(r/l),numInputChannels:4,numOutputChannels:4}}async function getPixelData(t,e,a){let r;return t.isWebGLRenderer?(r=a.type===FloatType?new Float32Array(a.width*a.height*a.numInputChannels):new Uint16Array(a.width*a.height*a.numInputChannels),await t.readRenderTargetPixelsAsync(e,0,0,a.width,a.height,r)):r=await t.readRenderTargetPixelsAsync(e,0,0,a.width,a.height),r}function reorganizeDataBuffer(t,e){const a=e.width,r=e.height,n={r:0,g:0,b:0,a:0},i={value:0},o=4==e.numOutputChannels?1:0,s=e.type==FloatType?getFloat32:getFloat16,l=1==e.dataType?setFloat16:setFloat32,u=new Uint8Array(e.width*e.height*e.numOutputChannels*e.dataSize),p=new DataView(u.buffer);for(let u=0;u<r;++u)for(let d=0;d<a;++d){const c=u*a*4+4*d,f=s(t,c),h=s(t,c+1),g=s(t,c+2),m=s(t,c+3),U=(r-u-1)*a*(3+o)*e.dataSize;decodeLinear(n,f,h,g,m),i.value=U+d*e.dataSize,l(p,n.a,i),i.value=U+o*a*e.dataSize+d*e.dataSize,l(p,n.b,i),i.value=U+(1+o)*a*e.dataSize+d*e.dataSize,l(p,n.g,i),i.value=U+(2+o)*a*e.dataSize+d*e.dataSize,l(p,n.r,i)}return u}function compressData(t,e){let a,r,n=0;const i={data:new Array,totalSize:0},o=e.width*e.numOutputChannels*e.blockLines*e.dataSize;switch(e.compression){case 0:a=compressNONE;break;case 2:case 3:a=compressZIP}0!==e.compression&&(r=new Uint8Array(o));for(let s=0;s<e.numBlocks;++s){const e=a(t.subarray(o*s,o*(s+1)),r);n+=e.length,i.data.push({dataChunk:e,size:e.length})}return i.totalSize=n,i}function compressNONE(t){return t}function compressZIP(t,e){let a=0,r=Math.floor((t.length+1)/2),n=0;const i=t.length-1;for(;!(n>i||(e[a++]=t[n++],n>i));)e[r++]=t[n++];let o=e[0];for(let t=1;t<e.length;t++){const a=e[t]-o+384;o=e[t],e[t]=a}return fflate.zlibSync(e)}function fillHeader(t,e,a){const r={value:0},n=new DataView(t.buffer);setUint32(n,20000630,r),setUint32(n,2,r),setString(n,"compression",r),setString(n,"compression",r),setUint32(n,1,r),setUint8(n,a.compression,r),setString(n,"screenWindowCenter",r),setString(n,"v2f",r),setUint32(n,8,r),setUint32(n,0,r),setUint32(n,0,r),setString(n,"screenWindowWidth",r),setString(n,"float",r),setUint32(n,4,r),setFloat32(n,1,r),setString(n,"pixelAspectRatio",r),setString(n,"float",r),setUint32(n,4,r),setFloat32(n,1,r),setString(n,"lineOrder",r),setString(n,"lineOrder",r),setUint32(n,1,r),setUint8(n,0,r),setString(n,"dataWindow",r),setString(n,"box2i",r),setUint32(n,16,r),setUint32(n,0,r),setUint32(n,0,r),setUint32(n,a.width-1,r),setUint32(n,a.height-1,r),setString(n,"displayWindow",r),setString(n,"box2i",r),setUint32(n,16,r),setUint32(n,0,r),setUint32(n,0,r),setUint32(n,a.width-1,r),setUint32(n,a.height-1,r),setString(n,"channels",r),setString(n,"chlist",r),setUint32(n,18*a.numOutputChannels+1,r),setString(n,"A",r),setUint32(n,a.dataType,r),r.value+=4,setUint32(n,1,r),setUint32(n,1,r),setString(n,"B",r),setUint32(n,a.dataType,r),r.value+=4,setUint32(n,1,r),setUint32(n,1,r),setString(n,"G",r),setUint32(n,a.dataType,r),r.value+=4,setUint32(n,1,r),setUint32(n,1,r),setString(n,"R",r),setUint32(n,a.dataType,r),r.value+=4,setUint32(n,1,r),setUint32(n,1,r),setUint8(n,0,r),setUint8(n,0,r);let i=r.value+8*a.numBlocks;for(let t=0;t<e.data.length;++t)setUint64(n,i,r),i+=e.data[t].size+8}function fillData(t,e){const a=8*e.numBlocks,r=259+18*e.numOutputChannels,n={value:r+a},i=new Uint8Array(r+a+t.totalSize+8*e.numBlocks),o=new DataView(i.buffer);fillHeader(i,t,e);for(let a=0;a<t.data.length;++a){const r=t.data[a].dataChunk,s=t.data[a].size;setUint32(o,a*e.blockLines,n),setUint32(o,s,n),i.set(r,n.value),n.value+=s}return i}function decodeLinear(t,e,a,r,n){t.r=e,t.g=a,t.b=r,t.a=n}function setUint8(t,e,a){t.setUint8(a.value,e),a.value+=1}function setUint32(t,e,a){t.setUint32(a.value,e,!0),a.value+=4}function setFloat16(t,e,a){t.setUint16(a.value,DataUtils.toHalfFloat(e),!0),a.value+=2}function setFloat32(t,e,a){t.setFloat32(a.value,e,!0),a.value+=4}function setUint64(t,e,a){t.setBigUint64(a.value,BigInt(e),!0),a.value+=8}function setString(t,e,a){const r=textEncoder.encode(e+"\0");for(let e=0;e<r.length;++e)setUint8(t,r[e],a)}function decodeFloat16(t){const e=(31744&t)>>10,a=1023&t;return(t>>15?-1:1)*(e?31===e?a?NaN:1/0:Math.pow(2,e-15)*(1+a/1024):a/1024*6103515625e-14)}function getFloat16(t,e){return decodeFloat16(t[e])}function getFloat32(t,e){return t[e]}export{EXRExporter,NO_COMPRESSION,ZIP_COMPRESSION,ZIPS_COMPRESSION};
//# sourceMappingURL=EXRExporter.js.map