{"version":3,"file":"node_modules/three/examples/jsm/exporters/GLTFExporter.js","names":["BufferAttribute","ClampToEdgeWrapping","Color","DoubleSide","InterpolateDiscrete","InterpolateLinear","NoColorSpace","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","SRGBColorSpace","CompressedTexture","Vector3","Quaternion","REVISION","ImageUtils","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","constructor","this","textureUtils","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsBumpExtension","GLTFMeshGpuInstancing","callback","indexOf","push","unregister","splice","setTextureUtils","utils","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","writeAsync","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","normalized","normalize","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","undefined","toBlob","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","maxTextureSize","Infinity","animations","includeCustomExtensions","processInputAsync","all","blob","Blob","extensionsUsedList","keys","extensionsRequiredList","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","name","message","getUID","isRelativeCopy","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTextureAsync","metalnessMap","roughnessMap","getEncodingConversion","map","colorSpace","c","pow","decompressTextureAsync","metalness","image","roughness","width","height","context","getContext","willReadFrequently","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","source","channel","Error","decompress","processBuffer","processBufferView","componentType","target","componentSize","bufferViews","byteStride","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","id","processBufferViewImage","processAccessor","geometry","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","HTMLImageElement","HTMLCanvasElement","ImageBitmap","then","bufferViewIndex","getDataURL","processSampler","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTextureAsync","textureDef","sampler","_invokeAllAsync","async","ext","writeTexture","processMaterialAsync","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","texCoord","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterialAsync","processMeshAsync","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","uv1","uv2","uv3","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","test","startsWith","Utils","toFloat32BufferAttribute","accessor","detectMeshQuantization","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setY","setZ","setW","isMultiMaterial","groups","didForceIndices","indices","setIndex","materialIndex","primitive","cacheKey","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","tracks","mergeMorphTargetTracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","interpolation","outputItemSize","values","times","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNodeAsync","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","nodeIndex","children","child","visible","childNodeIndex","writeNode","processSceneAsync","scene","scenes","sceneDef","processObjectsAsync","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalScale","clearcoatNormalTexture","dispersion","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorMap","specularIntensityMapDef","specularTexture","specularColorMapDef","specularColorTexture","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength","bumpScale","bumpMap","bumpMapDef","bumpTexture","bumpFactor","isInstancedMesh","translationAttr","rotationAttr","scaleAttr","getMatrixAt","decompose","TRANSLATION","ROTATION","SCALE","instanceColor","_COLOR_0","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex","srcAttribute","dstAttribute","isInterleavedBufferAttribute","setComponent","getComponent"],"sources":["node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3,\n\tQuaternion,\n\tREVISION,\n\tImageUtils\n} from 'three';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n/**\n * An exporter for `glTF` 2.0.\n *\n * glTF (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0}\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)\n * or binary (.glb) format. External files store textures (.jpg, .png) and additional binary\n * data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,\n * textures, skins, skeletons, morph targets, animations, lights, and/or cameras.\n *\n * GLTFExporter supports the [glTF 2.0 extensions]{@link https://github.com/KhronosGroup/glTF/tree/master/extensions/}:\n *\n * - KHR_lights_punctual\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_emissive_strength\n * - KHR_materials_ior\n * - KHR_materials_iridescence\n * - KHR_materials_specular\n * - KHR_materials_sheen\n * - KHR_materials_transmission\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_texture_transform\n * - EXT_materials_bump\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n *\n * - [KHR_materials_variants]{@link https://github.com/takahirox/three-gltf-extensions}\n *\n * ```js\n * const exporter = new GLTFExporter();\n * const data = await exporter.parseAsync( scene, options );\n * ```\n *\n * @three_import import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';\n */\nclass GLTFExporter {\n\n\t/**\n\t * Constructs a new glTF exporter.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A reference to a texture utils module.\n\t\t *\n\t\t * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Registers a plugin callback. This API is internally used to implement the various\n\t * glTF extensions but can also used by third-party code to add additional logic\n\t * to the exporter.\n\t *\n\t * @param {function(writer:GLTFWriter)} callback - The callback function to register.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Unregisters a plugin callback.\n\t *\n\t * @param {Function} callback - The callback function to unregister.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n\t *\n\t * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n\t * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n\t *\n\t * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given scenes and generates the glTF output.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {GLTFExporter~OnError} onError - A callback function that is executed when an error happens.\n\t * @param {GLTFExporter~Options} options - options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.setTextureUtils( this.textureUtils );\n\t\twriter.writeAsync( input, onDone, options ).catch( onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link GLTFExporter#parse}.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~Options} options - options.\n\t * @return {Promise<ArrayBuffer|string>} A Promise that resolved with the exported glTF data.\n\t */\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n *\n * @private\n * @param {Array} array1 Array 1 to compare\n * @param {Array} array2 Array 2 to compare\n * @return {boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @private\n * @param {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @private\n * @param {Matrix4} matrix\n * @returns {boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n *\n * @private\n * @param {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param {number} start Start index\n * @param {number} count Range to cover\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @private\n * @param {number} bufferSize The size the original buffer. Should be an integer.\n * @returns {number} new buffer size with required padding as an integer.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {number} [paddingByte=0] Should be an integer\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n *\n * @private\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t\tthis.textureUtils = null;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t *\n\t * @param {Scene|Array<Scene>} input Scene or Array of THREE.Scenes\n\t * @param {Function} onDone Callback on completed\n\t * @param {Object} options options\n\t */\n\tasync writeAsync( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tawait this.processInputAsync( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t *\n\t * @param {Object} attribute\n\t * @param {boolean} [isRelativeCopy=false]\n\t * @return {number} An integer\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tasync buildMetalRoughTextureAsync( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = await this.decompressTextureAsync( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = await this.decompressTextureAsync( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d', {\n\t\t\twillReadFrequently: true,\n\t\t} );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\treturn texture;\n\n\t}\n\n\n\tasync decompressTextureAsync( texture, maxTextureSize = Infinity ) {\n\n\t\tif ( this.textureUtils === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.' );\n\n\t\t}\n\n\t\treturn await this.textureUtils.decompress( texture, maxTextureSize );\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param {ArrayBuffer} buffer\n\t * @return {0}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param {BufferAttribute} attribute\n\t * @param {number} componentType\n\t * @param {number} start\n\t * @param {number} count\n\t * @param {number} [target] Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tlet byteStride = attribute.itemSize * componentSize;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n\t\t\t// inside a bufferView\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\n\n\t\t\t\toffset += byteStride - ( offset % byteStride );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = byteStride;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<number>} An integer\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param {BufferAttribute} attribute Attribute to process\n\t * @param {?BufferGeometry} [geometry] Geometry used for truncated draw range\n\t * @param {number} [start=0]\n\t * @param {number} [count=Infinity]\n\t * @return {?number} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param {Image} image to process\n\t * @param {number} format Identifier of the format (RGBAFormat)\n\t * @param {boolean} flipY before writing out the image\n\t * @param {string} mimeType export format\n\t * @return {number}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\twillReadFrequently: true,\n\t\t\t} );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\timageDef.uri = ImageUtils.getDataURL( canvas, mimeType );\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param {Texture} map Texture to process\n\t * @return {number}      Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param {Texture} map Map to process\n\t * @return {Promise<number>} Index of the processed texture in the \"textures\" array\n\t */\n\tasync processTextureAsync( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = await this.decompressTextureAsync( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeTexture && await ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param {THREE.Material} material Material to process\n\t * @return {Promise<number|null>} Index of the processed material in the \"materials\" array\n\t */\n\tasync processMaterialAsync( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 1;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = await this.buildMetalRoughTextureAsync( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( metalRoughTexture ),\n\t\t\t\ttexCoord: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: await this.processTextureAsync( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeMaterialAsync && await ext.writeMaterialAsync( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param {THREE.Mesh} mesh Mesh to process\n\t * @return {Promise<number|null>} Index of the processed mesh in the \"meshes\" array\n\t */\n\tasync processMeshAsync( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tuv2: 'TEXCOORD_2',\n\t\t\tuv3: 'TEXCOORD_3',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Enforce glTF vertex attribute requirements:\n\t\t\t// - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\n\t\t\t// - Only custom attributes may be INT or UNSIGNED_INT\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t} else if ( ( array instanceof Uint32Array || array instanceof Int32Array ) && ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\tconsole.warn( `GLTFExporter: Attribute \"${ attributeName }\" converted to type FLOAT.` );\n\t\t\t\tmodifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tlet didForceIndices = false;\n\n\t\tif ( isMultiMaterial && geometry.index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\tindices[ i ] = i;\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tdidForceIndices = true;\n\n\t\t}\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = await this.processMaterialAsync( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tif ( didForceIndices === true ) {\n\n\t\t\tgeometry.setIndex( null );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param {THREE.Camera} camera Camera to process\n\t * @return {number} Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param {THREE.Object3D} object Object3D to processNodeAsync\n\t * @return {Promise<number>} Index of the node in the nodes list\n\t */\n\tasync processNodeAsync( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = await this.processMeshAsync( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst childNodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\t\tif ( childNodeIndex !== null ) children.push( childNodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param {Scene} scene Scene to process\n\t */\n\tasync processSceneAsync( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param {Array<THREE.Object3D>} objects List of objects to process\n\t */\n\tasync processObjectsAsync( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tawait this.processSceneAsync( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tasync processInputAsync( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tawait this.processSceneAsync( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\tawait this.processObjectsAsync( objectsWithoutScene );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\tasync _invokeAllAsync( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tawait func( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_dispersion';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.dispersion = material.dispersion;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\tif ( material.attenuationDistance !== Infinity ) {\n\n\t\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\n\t\t}\n\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: await writer.processTextureAsync( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_materials_bump';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || (\n\t\t       material.bumpScale === 1 &&\n\t\t     ! material.bumpMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tconst bumpMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.bumpMap ),\n\t\t\t\ttexCoord: material.bumpMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\n\t\t\textensionDef.bumpTexture = bumpMapDef;\n\n\t\t}\n\n\t\textensionDef.bumpFactor = material.bumpScale;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\n\n\t}\n\n\twriteNode( object, nodeDef ) {\n\n\t\tif ( ! object.isInstancedMesh ) return;\n\n\t\tconst writer = this.writer;\n\n\t\tconst mesh = object;\n\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\n\n\t\tconst matrix = new Matrix4();\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tmesh.getMatrixAt( i, matrix );\n\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\tposition.toArray( translationAttr, i * 3 );\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\n\t\t\tscale.toArray( scaleAttr, i * 3 );\n\n\t\t}\n\n\t\tconst attributes = {\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\n\t\t};\n\n\t\tif ( mesh.instanceColor )\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { attributes };\n\n\t\twriter.extensionsUsed[ this.name ] = true;\n\t\twriter.extensionsRequired[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n *\n * @private\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t},\n\n\ttoFloat32BufferAttribute: function ( srcAttribute ) {\n\n\t\tconst dstAttribute = new BufferAttribute( new Float32Array( srcAttribute.count * srcAttribute.itemSize ), srcAttribute.itemSize, false );\n\n\t\tif ( ! srcAttribute.normalized && ! srcAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\tdstAttribute.array.set( srcAttribute.array );\n\n\t\t\treturn dstAttribute;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = srcAttribute.count; i < il; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < srcAttribute.itemSize; j ++ ) {\n\n\t\t\t\tdstAttribute.setComponent( i, j, srcAttribute.getComponent( i, j ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dstAttribute;\n\n\t}\n\n};\n\n/**\n * Export options of `GLTFExporter`.\n *\n * @typedef {Object} GLTFExporter~Options\n * @property {boolean} [trs=false] - Export position, rotation and scale instead of matrix per node.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {boolean} [binary=false] - Export in binary (.glb) format, returning an ArrayBuffer.\n * @property {number} [maxTextureSize=Infinity] - Restricts the image maximum size (both width and height) to the given value.\n * @property {Array<AnimationClip>} [animations=[]] - List of animations to be included in the export.\n * @property {boolean} [includeCustomExtensions=false] - Export custom glTF extensions defined on an object's `userData.gltfExtensions` property.\n **/\n\n/**\n * onDone callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnDone\n * @param {ArrayBuffer|string} result - The generated .gltf (JSON) or .glb (binary).\n */\n\n/**\n * onError callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { GLTFExporter };\n"],"mappings":"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","ignoreList":[]}