{"version":3,"file":"node_modules/three/examples/jsm/exporters/OBJExporter.js","names":["Color","ColorManagement","Matrix3","SRGBColorSpace","Vector2","Vector3","OBJExporter","parse","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","face","traverse","child","isMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","i","l","count","fromBufferAttribute","applyMatrix4","matrixWorld","x","y","z","getNormalMatrix","applyMatrix3","normalize","m","j","getX","join","parseMesh","isLine","line","type","k","parseLine","isPoints","points","colors","workingToColorSpace","r","g","b","parsePoints"],"sources":["node_modules/three/examples/jsm/exporters/OBJExporter.js"],"sourcesContent":["import {\n\tColor,\n\tColorManagement,\n\tMatrix3,\n\tSRGBColorSpace,\n\tVector2,\n\tVector3\n} from 'three';\n\n/**\n * An exporter for OBJ.\n *\n * `OBJExporter` is not able to export material data into MTL files so only geometry data are supported.\n *\n * ```js\n * const exporter = new OBJExporter();\n * const data = exporter.parse( scene );\n * ```\n *\n * @three_import import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';\n */\nclass OBJExporter {\n\n\t/**\n\t * Parses the given 3D object and generates the OBJ output.\n\t *\n\t * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n\t *\n\t * @param {Object3D} object - The 3D object to export.\n\t * @return {string} The exported OBJ.\n\t */\n\tparse( object ) {\n\n\t\tlet output = '';\n\n\t\tlet indexVertex = 0;\n\t\tlet indexVertexUvs = 0;\n\t\tlet indexNormals = 0;\n\n\t\tconst vertex = new Vector3();\n\t\tconst color = new Color();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\tconst face = [];\n\n\t\tfunction parseMesh( mesh ) {\n\n\t\t\tlet nbVertex = 0;\n\t\t\tlet nbNormals = 0;\n\t\t\tlet nbVertexUvs = 0;\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst normalMatrixWorld = new Matrix3();\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t// name of the mesh object\n\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t// name of the mesh material\n\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\tuv.fromBufferAttribute( uvs, i );\n\n\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\tnormal.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t// transform the normal to world space\n\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tif ( indices !== null ) {\n\n\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = i + m + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\n\t\t}\n\n\t\tfunction parseLine( line ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = line.geometry;\n\t\t\tconst type = line.type;\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\n\t\t\t// name of the line object\n\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\toutput += 'l ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\tfor ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tfunction parsePoints( points ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = points.geometry;\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\toutput += 'o ' + points.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\t\t\t\t\tvertex.applyMatrix4( points.matrixWorld );\n\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\t\tcolor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\tColorManagement.workingToColorSpace( color, SRGBColorSpace );\n\n\t\t\t\t\t\toutput += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t}\n\n\t\t\t\toutput += 'p ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tparseMesh( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isLine === true ) {\n\n\t\t\t\tparseLine( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isPoints === true ) {\n\n\t\t\t\tparsePoints( child );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport { OBJExporter };\n"],"mappings":"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","ignoreList":[]}