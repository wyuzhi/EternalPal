{"version":3,"file":"node_modules/three/examples/jsm/exporters/PLYExporter.js","names":["Matrix3","Vector3","Color","ColorManagement","SRGBColorSpace","PLYExporter","parse","object","onDone","options","traverseMeshes","cb","traverse","child","isMesh","isPoints","mesh","geometry","hasAttribute","excludeAttributes","Object","assign","binary","littleEndian","includeIndices","includeNormals","includeColors","includeUVs","vertexCount","faceCount","vertices","getAttribute","normals","uvs","colors","indices","getIndex","undefined","count","tempColor","indexOf","Math","floor","console","error","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","fromBufferAttribute","applyMatrix4","setFloat32","x","y","z","applyMatrix3","normalize","getX","getY","workingToColorSpace","setUint8","r","g","b","setUint32","vertexList","faceList","line","requestAnimationFrame"],"sources":["node_modules/three/examples/jsm/exporters/PLYExporter.js"],"sourcesContent":["import {\n\tMatrix3,\n\tVector3,\n\tColor,\n\tColorManagement,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * An exporter for PLY.\n *\n * PLY (Polygon or Stanford Triangle Format) is a file format for efficient delivery and\n * loading of simple, static 3D content in a dense format. Both binary and ascii formats are\n * supported. PLY can store vertex positions, colors, normals and uv coordinates. No textures\n * or texture references are saved.\n *\n * ```js\n * const exporter = new PLYExporter();\n * const data = exporter.parse( scene, options );\n * ```\n *\n * @three_import import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';\n */\nclass PLYExporter {\n\n\t/**\n\t * Parses the given 3D object and generates the PLY output.\n\t *\n\t * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n\t *\n\t * @param {Object3D} object - The 3D object to export.\n\t * @param {PLYExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {PLYExporter~Options} options - The export options.\n\t * @return {?string|ArrayBuffer} The exported PLY.\n\t */\n\tparse( object, onDone, options = {} ) {\n\n\t\t// reference https://github.com/gkjohnson/ply-exporter-js\n\n\t\t// Iterate over the valid meshes in the object\n\t\tfunction traverseMeshes( cb ) {\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true || child.isPoints ) {\n\n\t\t\t\t\tconst mesh = child;\n\t\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.hasAttribute( 'position' ) === true ) {\n\n\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Default options\n\t\tconst defaultOptions = {\n\t\t\tbinary: false,\n\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\tlittleEndian: false\n\t\t};\n\n\t\toptions = Object.assign( defaultOptions, options );\n\n\t\tconst excludeAttributes = options.excludeAttributes;\n\t\tlet includeIndices = true;\n\t\tlet includeNormals = false;\n\t\tlet includeColors = false;\n\t\tlet includeUVs = false;\n\n\t\t// count the vertices, check which properties are used,\n\t\t// and cache the BufferGeometry\n\t\tlet vertexCount = 0;\n\t\tlet faceCount = 0;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvertexCount += vertices.count;\n\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t} else if ( child.isPoints ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tvertexCount += vertices.count;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t\tincludeIndices = false;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst tempColor = new Color();\n\t\tincludeIndices = includeIndices && excludeAttributes.indexOf( 'index' ) === - 1;\n\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t// number of vertices that is divisible by 3 (and therefore representable\n\t\t\t// as triangles)\n\t\t\tconsole.error(\n\n\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t);\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst indexByteCount = 4;\n\n\t\tlet header =\n\t\t\t'ply\\n' +\n\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t// position\n\t\t\t'property float x\\n' +\n\t\t\t'property float y\\n' +\n\t\t\t'property float z\\n';\n\n\t\tif ( includeNormals === true ) {\n\n\t\t\t// normal\n\t\t\theader +=\n\t\t\t\t'property float nx\\n' +\n\t\t\t\t'property float ny\\n' +\n\t\t\t\t'property float nz\\n';\n\n\t\t}\n\n\t\tif ( includeUVs === true ) {\n\n\t\t\t// uvs\n\t\t\theader +=\n\t\t\t\t'property float s\\n' +\n\t\t\t\t'property float t\\n';\n\n\t\t}\n\n\t\tif ( includeColors === true ) {\n\n\t\t\t// colors\n\t\t\theader +=\n\t\t\t\t'property uchar red\\n' +\n\t\t\t\t'property uchar green\\n' +\n\t\t\t\t'property uchar blue\\n';\n\n\t\t}\n\n\t\tif ( includeIndices === true ) {\n\n\t\t\t// faces\n\t\t\theader +=\n\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t'property list uchar int vertex_index\\n';\n\n\t\t}\n\n\t\theader += 'end_header\\n';\n\n\n\t\t// Generate attribute data\n\t\tconst vertex = new Vector3();\n\t\tconst normalMatrixWorld = new Matrix3();\n\t\tlet result = null;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// Binary File Generation\n\t\t\tconst headerBin = new TextEncoder().encode( header );\n\n\t\t\t// 3 position values at 4 bytes\n\t\t\t// 3 normal values at 4 bytes\n\t\t\t// 3 color channels with 1 byte\n\t\t\t// 2 uv values at 4 bytes\n\t\t\tconst vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t// 1 byte shape descriptor\n\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\tconst faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\tconst output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\tlet vOffset = headerBin.length;\n\t\t\tlet fOffset = headerBin.length + vertexListLength;\n\t\t\tlet writtenVertices = 0;\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\ttempColor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\t\tColorManagement.workingToColorSpace( tempColor, SRGBColorSpace );\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.r * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.g * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.b * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t// Create the face list\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t// the face index on the next mesh\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = output.buffer;\n\n\t\t} else {\n\n\t\t\t// Ascii File Generation\n\t\t\t// count the number of vertices\n\t\t\tlet writtenVertices = 0;\n\t\t\tlet vertexList = '';\n\t\t\tlet faceList = '';\n\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t// form each line\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\tlet line =\n\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\ttempColor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\t\tColorManagement.workingToColorSpace( tempColor, SRGBColorSpace );\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.r * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.g * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.b * 255 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\t// Create the face list\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t}\n\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t}\n\n\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * Export options of `PLYExporter`.\n *\n * @typedef {Object} PLYExporter~Options\n * @property {boolean} [binary=false] - Whether to export in binary format or ASCII.\n * @property {Array<string>} [excludeAttributes] - Which properties to explicitly exclude from\n * the exported PLY file. Valid values are `'color'`, `'normal'`, `'uv'`, and `'index'`. If triangle\n * indices are excluded, then a point cloud is exported.\n * @property {boolean} [littleEndian=false] - Whether the binary export uses little or big endian.\n **/\n\n/**\n * onDone callback of `PLYExporter`.\n *\n * @callback PLYExporter~OnDone\n * @param {string|ArrayBuffer} result - The generated PLY ascii or binary.\n */\n\nexport { PLYExporter };\n"],"mappings":"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","ignoreList":[]}