import{NoColorSpace,DoubleSide,Color}from"three";import{strToU8,zipSync}from"../libs/fflate.module.js";class USDNode{constructor(t,e="",r=[],o=[]){this.name=t,this.type=e,this.metadata=r,this.properties=o,this.children=[]}addMetadata(t,e){this.metadata.push({key:t,value:e})}addProperty(t,e=[]){this.properties.push({property:t,metadata:e})}addChild(t){this.children.push(t)}toString(t=0){const e="\t".repeat(t),r=this.metadata.map((t=>{const r=t.key,o=t.value;if(Array.isArray(o)){const t=[];return t.push(`${r} = {`),o.forEach((r=>{t.push(`${e}\t\t${r}`)})),t.push(`${e}\t}`),t.join("\n")}return`${r} = ${o}`})),o=r.length?` (\n${r.map((t=>`${e}\t${t}`)).join("\n")}\n${e})`:"",a=this.properties.map((t=>{const r=t.property,o=t.metadata.length?` (\n${t.metadata.map((t=>`${e}\t\t${t}`)).join("\n")}\n${e}\t)`:"";return`${e}\t${r}${o}`})),n=this.children.map((e=>e.toString(t+1))),i=[];if(a.length>0&&i.push(...a),n.length>0){a.length>0&&i.push("");for(let t=0;t<n.length;t++)i.push(n[t]),t<n.length-1&&i.push("")}const s=i.join("\n"),d=this.type?this.type+" ":"";return`${e}def ${d}"${this.name}"${o}\n${e}{\n${s}\n${e}}`}}class USDZExporter{constructor(){this.textureUtils=null}setTextureUtils(t){this.textureUtils=t}parse(t,e,r,o){this.parseAsync(t,o).then(e).catch(r)}async parseAsync(t,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,onlyVisible:!0,quickLookCompatible:!1,maxTextureSize:1024},e);const r=new Set,o={},a="model.usda";o[a]=null;const n=new USDNode("Root","Xform"),i=new USDNode("Scenes","Scope");i.addMetadata("kind",'"sceneLibrary"'),n.addChild(i);const s="Scene",d=new USDNode(s,"Xform");let l;d.addMetadata("customData",["bool preliminary_collidesWithEnvironment = 0",`string sceneName = "${s}"`]),d.addMetadata("sceneName",`"${s}"`),e.includeAnchoringProperties&&(d.addProperty(`token preliminary:anchoring:type = "${e.ar.anchoring.type}"`),d.addProperty(`token preliminary:planeAnchoring:alignment = "${e.ar.planeAnchoring.alignment}"`)),i.addChild(d);const u={},c={};buildHierarchy(t,d,u,r,o,e);const p=buildMaterials(u,c,e.quickLookCompatible);l=buildHeader()+"\n"+n.toString()+"\n\n"+p.toString(),o[a]=strToU8(l),l=null;for(const t in c){let r=c[t];if(!0===r.isCompressedTexture){if(null===this.textureUtils)throw new Error("THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.");r=await this.textureUtils.decompress(r)}const a=imageToCanvas(r.image,r.flipY,e.maxTextureSize),n=await new Promise((t=>a.toBlob(t,"image/png",1)));o[`textures/Texture_${t}.png`]=new Uint8Array(await n.arrayBuffer())}let f=0;for(const t in o){const e=o[t];f+=34+t.length;const r=63&f;if(4!==r){const a=new Uint8Array(64-r);o[t]=[e,{extra:{12345:a}}]}f=e.length}return zipSync(o,{level:0})}}function getName(t,e){let r=t.name;return r=r.replace(/[^A-Za-z0-9_]/g,""),/^[0-9]/.test(r)&&(r="_"+r),""===r&&(r=t.isCamera?"Camera":"Object"),e.has(r)&&(r=r+"_"+t.id),e.add(r),r}function imageToCanvas(t,e,r){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const o=r/Math.max(t.width,t.height),a=document.createElement("canvas");a.width=t.width*Math.min(1,o),a.height=t.height*Math.min(1,o);const n=a.getContext("2d");return!0===e&&(n.translate(0,a.height),n.scale(1,-1)),n.drawImage(t,0,0,a.width,a.height),a}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n'}function buildHierarchy(t,e,r,o,a,n){for(let i=0,s=t.children.length;i<s;i++){const s=t.children[i];if(!1===s.visible&&!0===n.onlyVisible)continue;let d;if(s.isMesh){const t=s.geometry,e=s.material;if(e.isMeshStandardMaterial){const n="geometries/Geometry_"+t.id+".usda";if(!(n in a)){const e=buildMeshObject(t);a[n]=strToU8(buildHeader()+"\n"+e.toString())}e.uuid in r||(r[e.uuid]=e),d=buildMesh(s,t,r[e.uuid],o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",s)}else d=s.isCamera?buildCamera(s,o):buildXform(s,o);d&&(e.addChild(d),buildHierarchy(s,d,r,o,a,n))}}function buildXform(t,e){const r=getName(t,e),o=buildMatrix(t.matrix);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const a=new USDNode(r,"Xform");return a.addProperty(`matrix4d xformOp:transform = ${o}`),a.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]'),a}function buildMesh(t,e,r,o){const a=buildXform(t,o);return a.addMetadata("prepend references",`@./geometries/Geometry_${e.id}.usda@</Geometry>`),a.addMetadata("prepend apiSchemas",'["MaterialBindingAPI"]'),a.addProperty(`rel material:binding = </Materials/Material_${r.id}>`),a}function buildMatrix(t){const e=t.elements;return`( ${buildMatrixRow(e,0)}, ${buildMatrixRow(e,4)}, ${buildMatrixRow(e,8)}, ${buildMatrixRow(e,12)} )`}function buildMatrixRow(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function buildMeshObject(t){const e=new USDNode("Geometry"),r=buildMeshNode(t);return e.addChild(r),e}function buildMeshNode(t){const e=t.attributes,r=e.position.count,o=new USDNode("Geometry","Mesh");o.addProperty(`int[] faceVertexCounts = [${buildMeshVertexCount(t)}]`),o.addProperty(`int[] faceVertexIndices = [${buildMeshVertexIndices(t)}]`),o.addProperty(`normal3f[] normals = [${buildVector3Array(e.normal,r)}]`,['interpolation = "vertex"']),o.addProperty(`point3f[] points = [${buildVector3Array(e.position,r)}]`);for(let t=0;t<4;t++){const r=t>0?t:"",a=e["uv"+r];void 0!==a&&o.addProperty(`texCoord2f[] primvars:st${r} = [${buildVector2Array(a)}]`,['interpolation = "vertex"'])}const a=e.color;return void 0!==a&&o.addProperty(`color3f[] primvars:displayColor = [${buildVector3Array(a,r)}]`,['interpolation = "vertex"']),o.addProperty('uniform token subdivisionScheme = "none"'),o}function buildMeshVertexCount(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const e=t.index,r=[];if(null!==e)for(let t=0;t<e.count;t++)r.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)r.push(t)}return r.join(", ")}function buildVector3Array(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const r=[];for(let e=0;e<t.count;e++){const o=t.getX(e),a=t.getY(e),n=t.getZ(e);r.push(`(${o.toPrecision(PRECISION)}, ${a.toPrecision(PRECISION)}, ${n.toPrecision(PRECISION)})`)}return r.join(", ")}function buildVector2Array(t){const e=[];for(let r=0;r<t.count;r++){const o=t.getX(r),a=t.getY(r);e.push(`(${o.toPrecision(PRECISION)}, ${1-a.toPrecision(PRECISION)})`)}return e.join(", ")}function buildMaterials(t,e,r=!1){const o=new USDNode("Materials");for(const a in t){const n=t[a];o.addChild(buildMaterial(n,e,r))}return o}function buildMaterial(t,e,r=!1){const o=new USDNode(`Material_${t.id}`,"Material");function a(o,a,n){const i=o.source.id+"_"+o.flipY;e[i]=o;const s=o.channel>0?"st"+o.channel:"st",d={1e3:"repeat",1001:"clamp",1002:"mirror"},l=o.repeat.clone(),u=o.offset.clone(),c=o.rotation,p=Math.sin(c),f=Math.cos(c);u.y=1-u.y-l.y,r?(u.x=u.x/l.x,u.y=u.y/l.y,u.x+=p/l.x,u.y+=f-1):(u.x+=p*l.x,u.y+=(1-f)*l.y);const h=new USDNode(`PrimvarReader_${a}`,"Shader");h.addProperty('uniform token info:id = "UsdPrimvarReader_float2"'),h.addProperty("float2 inputs:fallback = (0.0, 0.0)"),h.addProperty(`token inputs:varname = "${s}"`),h.addProperty("float2 outputs:result");const m=new USDNode(`Transform2d_${a}`,"Shader");m.addProperty('uniform token info:id = "UsdTransform2d"'),m.addProperty(`token inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${a}.outputs:result>`),m.addProperty(`float inputs:rotation = ${(c*(180/Math.PI)).toFixed(PRECISION)}`),m.addProperty(`float2 inputs:scale = ${buildVector2(l)}`),m.addProperty(`float2 inputs:translation = ${buildVector2(u)}`),m.addProperty("float2 outputs:result");const y=new USDNode(`Texture_${o.id}_${a}`,"Shader");return y.addProperty('uniform token info:id = "UsdUVTexture"'),y.addProperty(`asset inputs:file = @textures/Texture_${i}.png@`),y.addProperty(`float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${a}.outputs:result>`),void 0!==n&&y.addProperty(`float4 inputs:scale = ${buildColor4(n)}`),y.addProperty(`token inputs:sourceColorSpace = "${o.colorSpace===NoColorSpace?"raw":"sRGB"}"`),y.addProperty(`token inputs:wrapS = "${d[o.wrapS]}"`),y.addProperty(`token inputs:wrapT = "${d[o.wrapT]}"`),y.addProperty("float outputs:r"),y.addProperty("float outputs:g"),y.addProperty("float outputs:b"),y.addProperty("float3 outputs:rgb"),(t.transparent||t.alphaTest>0)&&y.addProperty("float outputs:a"),[h,m,y]}t.side===DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t);const n=new USDNode("PreviewSurface","Shader");if(n.addProperty('uniform token info:id = "UsdPreviewSurface"'),null!==t.map){n.addProperty(`color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?n.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(n.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),n.addProperty(`float inputs:opacityThreshold = ${t.alphaTest}`));a(t.map,"diffuse",t.color).forEach((t=>o.addChild(t)))}else n.addProperty(`color3f inputs:diffuseColor = ${buildColor(t.color)}`);if(null!==t.emissiveMap){n.addProperty(`color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`);const e=new Color(t.emissive.r*t.emissiveIntensity,t.emissive.g*t.emissiveIntensity,t.emissive.b*t.emissiveIntensity);a(t.emissiveMap,"emissive",e).forEach((t=>o.addChild(t)))}else t.emissive.getHex()>0&&n.addProperty(`color3f inputs:emissiveColor = ${buildColor(t.emissive)}`);if(null!==t.normalMap){n.addProperty(`normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`);a(t.normalMap,"normal").forEach((t=>o.addChild(t)))}if(null!==t.aoMap){n.addProperty(`float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`);const e=new Color(t.aoMapIntensity,t.aoMapIntensity,t.aoMapIntensity);a(t.aoMap,"occlusion",e).forEach((t=>o.addChild(t)))}if(null!==t.roughnessMap){n.addProperty(`float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`);const e=new Color(t.roughness,t.roughness,t.roughness);a(t.roughnessMap,"roughness",e).forEach((t=>o.addChild(t)))}else n.addProperty(`float inputs:roughness = ${t.roughness}`);if(null!==t.metalnessMap){n.addProperty(`float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`);const e=new Color(t.metalness,t.metalness,t.metalness);a(t.metalnessMap,"metallic",e).forEach((t=>o.addChild(t)))}else n.addProperty(`float inputs:metallic = ${t.metalness}`);if(null!==t.alphaMap){n.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),n.addProperty("float inputs:opacityThreshold = 0.0001");a(t.alphaMap,"opacity").forEach((t=>o.addChild(t)))}else n.addProperty(`float inputs:opacity = ${t.opacity}`);if(t.isMeshPhysicalMaterial){if(null!==t.clearcoatMap){n.addProperty(`float inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`);const e=new Color(t.clearcoat,t.clearcoat,t.clearcoat);a(t.clearcoatMap,"clearcoat",e).forEach((t=>o.addChild(t)))}else n.addProperty(`float inputs:clearcoat = ${t.clearcoat}`);if(null!==t.clearcoatRoughnessMap){n.addProperty(`float inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);const e=new Color(t.clearcoatRoughness,t.clearcoatRoughness,t.clearcoatRoughness);a(t.clearcoatRoughnessMap,"clearcoatRoughness",e).forEach((t=>o.addChild(t)))}else n.addProperty(`float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`);n.addProperty(`float inputs:ior = ${t.ior}`)}return n.addProperty("int inputs:useSpecularWorkflow = 0"),n.addProperty("token outputs:surface"),o.addChild(n),o.addProperty(`token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>`),o}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildColor4(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t,e){const r=getName(t,e),o=buildMatrix(t.matrix);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const a=new USDNode(r,"Camera");a.addProperty(`matrix4d xformOp:transform = ${o}`),a.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]');const n=t.isOrthographicCamera?"orthographic":"perspective";a.addProperty(`token projection = "${n}"`);const i=`(${t.near.toPrecision(PRECISION)}, ${t.far.toPrecision(PRECISION)})`;let s,d;if(a.addProperty(`float2 clippingRange = ${i}`),s=t.isOrthographicCamera?(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(PRECISION):t.getFilmWidth().toPrecision(PRECISION),a.addProperty(`float horizontalAperture = ${s}`),d=t.isOrthographicCamera?(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(PRECISION):t.getFilmHeight().toPrecision(PRECISION),a.addProperty(`float verticalAperture = ${d}`),t.isPerspectiveCamera){const e=t.getFocalLength().toPrecision(PRECISION);a.addProperty(`float focalLength = ${e}`);const r=t.focus.toPrecision(PRECISION);a.addProperty(`float focusDistance = ${r}`)}return a}export{USDZExporter};
//# sourceMappingURL=USDZExporter.js.map