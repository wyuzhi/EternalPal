import{BufferGeometry,Euler,Float32BufferAttribute,Matrix3,Matrix4,Mesh,Vector3}from"three";class DecalGeometry extends BufferGeometry{constructor(t=new Mesh,o=new Vector3,e=new Euler,n=new Vector3(1,1,1)){super();const r=[],s=[],i=[],l=new Vector3,u=(new Matrix3).getNormalMatrix(t.matrixWorld),p=new Matrix4;p.makeRotationFromEuler(e),p.setPosition(o);const a=new Matrix4;function c(o,e,n=null){e.applyMatrix4(t.matrixWorld),e.applyMatrix4(a),n?(n.applyNormalMatrix(u),o.push(new DecalVertex(e.clone(),n.clone()))):o.push(new DecalVertex(e.clone()))}function h(t,o){const e=[],r=.5*Math.abs(n.dot(o));for(let n=0;n<t.length;n+=3){let s,i,l,u,p=0;const a=t[n+0].position.dot(o)-r>0,c=t[n+1].position.dot(o)-r>0,h=t[n+2].position.dot(o)-r>0;switch(p=(a?1:0)+(c?1:0)+(h?1:0),p){case 0:e.push(t[n]),e.push(t[n+1]),e.push(t[n+2]);break;case 1:if(a&&(s=t[n+1],i=t[n+2],l=m(t[n],s,o,r),u=m(t[n],i,o,r)),c){s=t[n],i=t[n+2],l=m(t[n+1],s,o,r),u=m(t[n+1],i,o,r),e.push(l),e.push(i.clone()),e.push(s.clone()),e.push(i.clone()),e.push(l.clone()),e.push(u);break}h&&(s=t[n],i=t[n+1],l=m(t[n+2],s,o,r),u=m(t[n+2],i,o,r)),e.push(s.clone()),e.push(i.clone()),e.push(l),e.push(u),e.push(l.clone()),e.push(i.clone());break;case 2:a||(s=t[n].clone(),i=m(s,t[n+1],o,r),l=m(s,t[n+2],o,r),e.push(s),e.push(i),e.push(l)),c||(s=t[n+1].clone(),i=m(s,t[n+2],o,r),l=m(s,t[n],o,r),e.push(s),e.push(i),e.push(l)),h||(s=t[n+2].clone(),i=m(s,t[n],o,r),l=m(s,t[n+1],o,r),e.push(s),e.push(i),e.push(l))}}return e}function m(t,o,e,n){const r=t.position.dot(e)-n,s=r/(r-(o.position.dot(e)-n)),i=new Vector3(t.position.x+s*(o.position.x-t.position.x),t.position.y+s*(o.position.y-t.position.y),t.position.z+s*(o.position.z-t.position.z));let l=null;null!==t.normal&&null!==o.normal&&(l=new Vector3(t.normal.x+s*(o.normal.x-t.normal.x),t.normal.y+s*(o.normal.y-t.normal.y),t.normal.z+s*(o.normal.z-t.normal.z)));return new DecalVertex(i,l)}a.copy(p).invert(),function(){let o=[];const e=new Vector3,u=new Vector3,a=t.geometry,m=a.attributes.position,f=a.attributes.normal;if(null!==a.index){const t=a.index;for(let n=0;n<t.count;n++)e.fromBufferAttribute(m,t.getX(n)),f?(u.fromBufferAttribute(f,t.getX(n)),c(o,e,u)):c(o,e)}else{if(void 0===m)return;for(let t=0;t<m.count;t++)e.fromBufferAttribute(m,t),f?(u.fromBufferAttribute(f,t),c(o,e,u)):c(o,e)}o=h(o,l.set(1,0,0)),o=h(o,l.set(-1,0,0)),o=h(o,l.set(0,1,0)),o=h(o,l.set(0,-1,0)),o=h(o,l.set(0,0,1)),o=h(o,l.set(0,0,-1));for(let t=0;t<o.length;t++){const e=o[t];i.push(.5+e.position.x/n.x,.5+e.position.y/n.y),e.position.applyMatrix4(p),r.push(e.position.x,e.position.y,e.position.z),null!==e.normal&&s.push(e.normal.x,e.normal.y,e.normal.z)}}(),this.setAttribute("position",new Float32BufferAttribute(r,3)),this.setAttribute("uv",new Float32BufferAttribute(i,2)),s.length>0&&this.setAttribute("normal",new Float32BufferAttribute(s,3))}}class DecalVertex{constructor(t,o=null){this.position=t,this.normal=o}clone(){const t=this.position.clone(),o=null!==this.normal?this.normal.clone():null;return new this.constructor(t,o)}}export{DecalGeometry,DecalVertex};
//# sourceMappingURL=DecalGeometry.js.map