{"version":3,"file":"node_modules/three/examples/jsm/geometries/DecalGeometry.js","names":["BufferGeometry","Euler","Float32BufferAttribute","Matrix3","Matrix4","Mesh","Vector3","DecalGeometry","constructor","mesh","position","orientation","size","super","vertices","normals","uvs","plane","normalMatrix","getNormalMatrix","matrixWorld","projectorMatrix","makeRotationFromEuler","setPosition","projectorMatrixInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","applyNormalMatrix","push","DecalVertex","clone","clipGeometry","inVertices","outVertices","s","Math","abs","dot","i","length","nV1","nV2","nV3","nV4","total","v1Out","v2Out","v3Out","clip","v0","v1","p","d0","s0","x","y","z","copy","invert","geometry","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","undefined","set","decalVertex","generate","this","setAttribute"],"sources":["node_modules/three/examples/jsm/geometries/DecalGeometry.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tEuler,\n\tFloat32BufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tMesh,\n\tVector3\n} from 'three';\n\n/**\n * This class can be used to create a decal mesh that serves different kinds of purposes e.g.\n * adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Please not that decal projections can be distorted when used around corners. More information at\n * this GitHub issue: [Decal projections without distortions]{@link https://github.com/mrdoob/three.js/issues/21187}.\n *\n * Reference: [How to project decals]{@link http://blog.wolfire.com/2009/06/how-to-project-decals/}\n *\n * ```js\n * const geometry = new DecalGeometry( mesh, position, orientation, size );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n * ```\n *\n * @augments BufferGeometry\n * @three_import import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';\n */\nclass DecalGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new decal geometry.\n\t *\n\t * @param {Mesh} [mesh] - The base mesh the decal should be projected on.\n\t * @param {Vector3} [position] - The position of the decal projector.\n\t * @param {Euler} [orientation] - The orientation of the decal projector.\n\t * @param {Vector3} [size] - Tje scale of the decal projector.\n\t */\n\tconstructor( mesh = new Mesh(), position = new Vector3(), orientation = new Euler(), size = new Vector3( 1, 1, 1 ) ) {\n\n\t\tsuper();\n\n\t\t// buffers\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helpers\n\n\t\tconst plane = new Vector3();\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( mesh.matrixWorld );\n\n\t\t// this matrix represents the transformation of the decal projector\n\n\t\tconst projectorMatrix = new Matrix4();\n\t\tprojectorMatrix.makeRotationFromEuler( orientation );\n\t\tprojectorMatrix.setPosition( position );\n\n\t\tconst projectorMatrixInverse = new Matrix4();\n\t\tprojectorMatrixInverse.copy( projectorMatrix ).invert();\n\n\t\t// generate buffers\n\n\t\tgenerate();\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tif ( normals.length > 0 ) {\n\n\t\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction generate() {\n\n\t\t\tlet decalVertices = [];\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\n\t\t\t// handle different geometry types\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst normalAttribute = geometry.attributes.normal;\n\n\t\t\t// first, create an array of 'DecalVertex' objects\n\t\t\t// three consecutive 'DecalVertex' objects represent a single face\n\t\t\t//\n\t\t\t// this data structure will be later used to perform the clipping\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst index = geometry.index;\n\n\t\t\t\tfor ( let i = 0; i < index.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, index.getX( i ) );\n\n\t\t\t\t\tif ( normalAttribute ) {\n\n\t\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, index.getX( i ) );\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( positionAttribute === undefined ) return; // empty geometry\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tif ( normalAttribute ) {\n\n\t\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, i );\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// second, clip the geometry so that it doesn't extend out from the projector\n\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );\n\n\t\t\t// third, generate final vertices, normals and uvs\n\n\t\t\tfor ( let i = 0; i < decalVertices.length; i ++ ) {\n\n\t\t\t\tconst decalVertex = decalVertices[ i ];\n\n\t\t\t\t// create texture coordinates (we are still in projector space)\n\n\t\t\t\tuvs.push(\n\t\t\t\t\t0.5 + ( decalVertex.position.x / size.x ),\n\t\t\t\t\t0.5 + ( decalVertex.position.y / size.y )\n\t\t\t\t);\n\n\t\t\t\t// transform the vertex back to world space\n\n\t\t\t\tdecalVertex.position.applyMatrix4( projectorMatrix );\n\n\t\t\t\t// now create vertex and normal buffer data\n\n\t\t\t\tvertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );\n\n\t\t\t\tif ( decalVertex.normal !== null ) {\n\n\t\t\t\t\tnormals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushDecalVertex( decalVertices, vertex, normal = null ) {\n\n\t\t\t// transform the vertex to world space, then to projector space\n\n\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\t\t\tvertex.applyMatrix4( projectorMatrixInverse );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\t\t\t\tdecalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );\n\n\t\t\t} else {\n\n\t\t\t\tdecalVertices.push( new DecalVertex( vertex.clone() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction clipGeometry( inVertices, plane ) {\n\n\t\t\tconst outVertices = [];\n\n\t\t\tconst s = 0.5 * Math.abs( size.dot( plane ) );\n\n\t\t\t// a single iteration clips one face,\n\t\t\t// which consists of three consecutive 'DecalVertex' objects\n\n\t\t\tfor ( let i = 0; i < inVertices.length; i += 3 ) {\n\n\t\t\t\tlet total = 0;\n\t\t\t\tlet nV1;\n\t\t\t\tlet nV2;\n\t\t\t\tlet nV3;\n\t\t\t\tlet nV4;\n\n\t\t\t\tconst d1 = inVertices[ i + 0 ].position.dot( plane ) - s;\n\t\t\t\tconst d2 = inVertices[ i + 1 ].position.dot( plane ) - s;\n\t\t\t\tconst d3 = inVertices[ i + 2 ].position.dot( plane ) - s;\n\n\t\t\t\tconst v1Out = d1 > 0;\n\t\t\t\tconst v2Out = d2 > 0;\n\t\t\t\tconst v3Out = d3 > 0;\n\n\t\t\t\t// calculate, how many vertices of the face lie outside of the clipping plane\n\n\t\t\t\ttotal = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );\n\n\t\t\t\tswitch ( total ) {\n\n\t\t\t\t\tcase 0: {\n\n\t\t\t\t\t\t// the entire face lies inside of the plane, no clipping needed\n\n\t\t\t\t\t\toutVertices.push( inVertices[ i ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 1 ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 1: {\n\n\t\t\t\t\t\t// one vertex lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 1 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 1 ], nV2, plane, s );\n\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 2 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 2 ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 2: {\n\n\t\t\t\t\t\t// two vertices lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( ! v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 2 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 3: {\n\n\t\t\t\t\t\t// the entire face lies outside of the plane, so let's discard the corresponding vertices\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn outVertices;\n\n\t\t}\n\n\t\tfunction clip( v0, v1, p, s ) {\n\n\t\t\tconst d0 = v0.position.dot( p ) - s;\n\t\t\tconst d1 = v1.position.dot( p ) - s;\n\n\t\t\tconst s0 = d0 / ( d0 - d1 );\n\n\t\t\tconst position = new Vector3(\n\t\t\t\tv0.position.x + s0 * ( v1.position.x - v0.position.x ),\n\t\t\t\tv0.position.y + s0 * ( v1.position.y - v0.position.y ),\n\t\t\t\tv0.position.z + s0 * ( v1.position.z - v0.position.z )\n\t\t\t);\n\n\t\t\tlet normal = null;\n\n\t\t\tif ( v0.normal !== null && v1.normal !== null ) {\n\n\t\t\t\tnormal = new Vector3(\n\t\t\t\t\tv0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),\n\t\t\t\t\tv0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),\n\t\t\t\t\tv0.normal.z + s0 * ( v1.normal.z - v0.normal.z )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tconst v = new DecalVertex( position, normal );\n\n\t\t\t// need to clip more values (texture coordinates)? do it this way:\n\t\t\t// intersectpoint.value = a.value + s * ( b.value - a.value );\n\n\t\t\treturn v;\n\n\t\t}\n\n\t}\n\n}\n\n// helper\n\nclass DecalVertex {\n\n\tconstructor( position, normal = null ) {\n\n\t\tthis.position = position;\n\t\tthis.normal = normal;\n\n\t}\n\n\tclone() {\n\n\t\tconst position = this.position.clone();\n\t\tconst normal = ( this.normal !== null ) ? this.normal.clone() : null;\n\n\t\treturn new this.constructor( position, normal );\n\n\t}\n\n}\n\nexport { DecalGeometry, DecalVertex };\n"],"mappings":"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","ignoreList":[]}