{"version":3,"file":"node_modules/three/examples/jsm/geometries/ParametricGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","ParametricGeometry","constructor","func","u","v","target","set","Math","cos","sin","slices","stacks","super","this","type","parameters","indices","vertices","normals","uvs","EPS","normal","p0","p1","pu","pv","sliceCount","i","j","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute","copy","source","Object","assign"],"sources":["node_modules/three/examples/jsm/geometries/ParametricGeometry.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector3\n} from 'three';\n\n/**\n * This class can be used to generate a geometry based on a parametric surface.\n *\n * Reference: [Mesh Generation with Python]{@link https://prideout.net/blog/old/blog/index.html@p=44.html}\n *\n * ```js\n * const geometry = new THREE.ParametricGeometry( klein, 25, 25 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const klein = new THREE.Mesh( geometry, material );\n * scene.add( klein );\n * ```\n *\n * @augments BufferGeometry\n * @three_import import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';\n */\nclass ParametricGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new parametric geometry.\n\t *\n\t * @param {ParametricGeometry~Func} func - The parametric function. Default is a function that generates a curved plane surface.\n\t * @param {number} [slices=8] - The number of slices to use for the parametric function.\n\t * @param {number} [stacks=8] - The stacks of slices to use for the parametric function.\n\t */\n\tconstructor( func = ( u, v, target ) => target.set( u, v, Math.cos( u ) * Math.sin( v ) ), slices = 8, stacks = 8 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tconst EPS = 0.00001;\n\n\t\tconst normal = new Vector3();\n\n\t\tconst p0 = new Vector3(), p1 = new Vector3();\n\t\tconst pu = new Vector3(), pv = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tconst sliceCount = slices + 1;\n\n\t\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\t\tconst v = i / stacks;\n\n\t\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tconst u = j / slices;\n\n\t\t\t\t// vertex\n\n\t\t\t\tfunc( u, v, p0 );\n\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t\t// normal\n\n\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Parametric function definition of `ParametricGeometry`.\n *\n * @callback ParametricGeometry~Func\n * @param {number} u - The `u` coordinate on the surface in the range `[0,1]`.\n * @param {number} v - The `v` coordinate on the surface in the range `[0,1]`.\n * @param {Vector3} target - The target vector that is used to store the method's result.\n */\n\nexport { ParametricGeometry };\n"],"mappings":"OACCA,eACAC,uBACAC,YACM,QAiBP,MAAMC,2BAA2BH,eAShC,WAAAI,CAAaC,EAAO,EAAEC,EAAGC,EAAGC,IAAYA,EAAOC,IAAKH,EAAGC,EAAGG,KAAKC,IAAKL,GAAMI,KAAKE,IAAKL,KAAOM,EAAS,EAAGC,EAAS,GAE/GC,QAEAC,KAAKC,KAAO,qBASZD,KAAKE,WAAa,CACjBb,KAAMA,EACNQ,OAAQA,EACRC,OAAQA,GAKT,MAAMK,EAAU,GACVC,EAAW,GACXC,EAAU,GACVC,EAAM,GAENC,EAAM,KAENC,EAAS,IAAItB,QAEbuB,EAAK,IAAIvB,QAAWwB,EAAK,IAAIxB,QAC7ByB,EAAK,IAAIzB,QAAW0B,EAAK,IAAI1B,QAI7B2B,EAAahB,EAAS,EAE5B,IAAM,IAAIiB,EAAI,EAAGA,GAAKhB,EAAQgB,IAAO,CAEpC,MAAMvB,EAAIuB,EAAIhB,EAEd,IAAM,IAAIiB,EAAI,EAAGA,GAAKlB,EAAQkB,IAAO,CAEpC,MAAMzB,EAAIyB,EAAIlB,EAIdR,EAAMC,EAAGC,EAAGkB,GACZL,EAASY,KAAMP,EAAGQ,EAAGR,EAAGS,EAAGT,EAAGU,GAMzB7B,EAAIiB,GAAO,GAEflB,EAAMC,EAAIiB,EAAKhB,EAAGmB,GAClBC,EAAGS,WAAYX,EAAIC,KAInBrB,EAAMC,EAAIiB,EAAKhB,EAAGmB,GAClBC,EAAGS,WAAYV,EAAID,IAIflB,EAAIgB,GAAO,GAEflB,EAAMC,EAAGC,EAAIgB,EAAKG,GAClBE,EAAGQ,WAAYX,EAAIC,KAInBrB,EAAMC,EAAGC,EAAIgB,EAAKG,GAClBE,EAAGQ,WAAYV,EAAID,IAMpBD,EAAOa,aAAcV,EAAIC,GAAKU,YAC9BjB,EAAQW,KAAMR,EAAOS,EAAGT,EAAOU,EAAGV,EAAOW,GAIzCb,EAAIU,KAAM1B,EAAGC,EAEd,CAED,CAIA,IAAM,IAAIuB,EAAI,EAAGA,EAAIhB,EAAQgB,IAE5B,IAAM,IAAIC,EAAI,EAAGA,EAAIlB,EAAQkB,IAAO,CAEnC,MAAMQ,EAAIT,EAAID,EAAaE,EACrBS,EAAIV,EAAID,EAAaE,EAAI,EACzBU,GAAMX,EAAI,GAAMD,EAAaE,EAAI,EACjCW,GAAMZ,EAAI,GAAMD,EAAaE,EAInCZ,EAAQa,KAAMO,EAAGC,EAAGE,GACpBvB,EAAQa,KAAMQ,EAAGC,EAAGC,EAErB,CAMD1B,KAAK2B,SAAUxB,GACfH,KAAK4B,aAAc,WAAY,IAAI3C,uBAAwBmB,EAAU,IACrEJ,KAAK4B,aAAc,SAAU,IAAI3C,uBAAwBoB,EAAS,IAClEL,KAAK4B,aAAc,KAAM,IAAI3C,uBAAwBqB,EAAK,GAE3D,CAEA,IAAAuB,CAAMC,GAML,OAJA/B,MAAM8B,KAAMC,GAEZ9B,KAAKE,WAAa6B,OAAOC,OAAQ,CAAC,EAAGF,EAAO5B,YAErCF,IAER,SAaQb","ignoreList":[]}