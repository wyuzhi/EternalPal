import{BoxGeometry,Vector3}from"three";const _tempNormal=new Vector3;function getUv(t,e,r,a,s,o){const i=2*Math.PI*s/4,n=Math.max(o-2*s,0),h=Math.PI/4;_tempNormal.copy(e),_tempNormal[a]=0,_tempNormal.normalize();const m=.5*i/(i+n),c=1-_tempNormal.angleTo(t)/h;if(1===Math.sign(_tempNormal[r]))return c*m;return n/(i+n)+m+m*(1-c)}class RoundedBoxGeometry extends BoxGeometry{constructor(t=1,e=1,r=1,a=2,s=.1){const o=2*a+1;if(s=Math.min(t/2,e/2,r/2,s),super(1,1,1,o,o,o),this.type="RoundedBoxGeometry",this.parameters={width:t,height:e,depth:r,segments:a,radius:s},1===o)return;const i=this.toNonIndexed();this.index=null,this.attributes.position=i.attributes.position,this.attributes.normal=i.attributes.normal,this.attributes.uv=i.attributes.uv;const n=new Vector3,h=new Vector3,m=new Vector3(t,e,r).divideScalar(2).subScalar(s),c=this.attributes.position.array,g=this.attributes.normal.array,u=this.attributes.uv.array,y=c.length/6,x=new Vector3,l=.5/o;for(let a=0,o=0;a<c.length;a+=3,o+=2){n.fromArray(c,a),h.copy(n),h.x-=Math.sign(h.x)*l,h.y-=Math.sign(h.y)*l,h.z-=Math.sign(h.z)*l,h.normalize(),c[a+0]=m.x*Math.sign(n.x)+h.x*s,c[a+1]=m.y*Math.sign(n.y)+h.y*s,c[a+2]=m.z*Math.sign(n.z)+h.z*s,g[a+0]=h.x,g[a+1]=h.y,g[a+2]=h.z;switch(Math.floor(a/y)){case 0:x.set(1,0,0),u[o+0]=getUv(x,h,"z","y",s,r),u[o+1]=1-getUv(x,h,"y","z",s,e);break;case 1:x.set(-1,0,0),u[o+0]=1-getUv(x,h,"z","y",s,r),u[o+1]=1-getUv(x,h,"y","z",s,e);break;case 2:x.set(0,1,0),u[o+0]=1-getUv(x,h,"x","z",s,t),u[o+1]=getUv(x,h,"z","x",s,r);break;case 3:x.set(0,-1,0),u[o+0]=1-getUv(x,h,"x","z",s,t),u[o+1]=1-getUv(x,h,"z","x",s,r);break;case 4:x.set(0,0,1),u[o+0]=1-getUv(x,h,"x","y",s,t),u[o+1]=1-getUv(x,h,"y","x",s,e);break;case 5:x.set(0,0,-1),u[o+0]=getUv(x,h,"x","y",s,t),u[o+1]=1-getUv(x,h,"y","x",s,e)}}}static fromJSON(t){return new RoundedBoxGeometry(t.width,t.height,t.depth,t.segments,t.radius)}}export{RoundedBoxGeometry};
//# sourceMappingURL=RoundedBoxGeometry.js.map