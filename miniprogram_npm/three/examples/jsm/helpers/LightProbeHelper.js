import{Mesh,ShaderMaterial,SphereGeometry}from"three";class LightProbeHelper extends Mesh{constructor(t,e=1){const n=new ShaderMaterial({type:"LightProbeHelperMaterial",uniforms:{sh:{value:t.sh.coefficients},intensity:{value:t.intensity}},vertexShader:"\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvNormal = normalize( normalMatrix * normal );\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\n\t\t\t\t#define RECIPROCAL_PI 0.318309886\n\n\t\t\t\tvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n\t\t\t\t\t// matrix is assumed to be orthogonal\n\n\t\t\t\t\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\t// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf,\n\t\t\t\tvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t\t\t\t\t// normal is assumed to have unit length,\n\n\t\t\t\t\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t\t\t\t\t// band 0,\n\t\t\t\t\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t\t\t\t\t// band 1,\n\t\t\t\t\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\t\t\t\t\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\t\t\t\t\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t\t\t\t\t// band 2,\n\t\t\t\t\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\t\t\t\t\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\t\t\t\t\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\t\t\t\t\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\t\t\t\t\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\tuniform vec3 sh[ 9 ]; // sh coefficients\n\n\t\t\t\tuniform float intensity; // light probe intensity\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 normal = normalize( vNormal );\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\n\t\t\t\t\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\n\n\t\t\t\t}\n\n\t\t\t"});super(new SphereGeometry(1,32,16),n),this.lightProbe=t,this.size=e,this.type="LightProbeHelper",this.onBeforeRender()}dispose(){this.geometry.dispose(),this.material.dispose()}onBeforeRender(){this.position.copy(this.lightProbe.position),this.scale.set(1,1,1).multiplyScalar(this.size),this.material.uniforms.intensity.value=this.lightProbe.intensity}}export{LightProbeHelper};
//# sourceMappingURL=LightProbeHelper.js.map