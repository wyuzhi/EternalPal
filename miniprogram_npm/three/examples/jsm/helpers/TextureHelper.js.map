{"version":3,"file":"node_modules/three/examples/jsm/helpers/TextureHelper.js","names":["BoxGeometry","BufferAttribute","DoubleSide","Mesh","PlaneGeometry","ShaderMaterial","Vector3","mergeGeometries","TextureHelper","constructor","texture","width","height","depth","material","type","side","transparent","uniforms","map","value","alpha","getAlpha","vertexShader","join","fragmentShader","replace","getSamplerType","super","isCubeTexture","createCubeGeometry","createSliceGeometry","this","dispose","geometry","isDataArrayTexture","isCompressedArrayTexture","isData3DTexture","isCompressed3DTexture","getImageCount","image","Math","max","position","attributes","uv","uvw","Float32Array","count","_direction","j","jl","fromBufferAttribute","normalize","u","x","v","y","w","z","setXYZ","deleteAttribute","setAttribute","sliceCount","geometries","i","translate","getX","flipY","getY","push"],"sources":["node_modules/three/examples/jsm/helpers/TextureHelper.js"],"sourcesContent":["import {\n\tBoxGeometry,\n\tBufferAttribute,\n\tDoubleSide,\n\tMesh,\n\tPlaneGeometry,\n\tShaderMaterial,\n\tVector3,\n} from 'three';\nimport { mergeGeometries } from '../utils/BufferGeometryUtils.js';\n\n/**\n * A helper that can be used to display any type of texture for\n * debugging purposes. Depending on the type of texture (2D, 3D, Array),\n * the helper becomes a plane or box mesh.\n *\n * This helper can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `TextureHelperGPU.js`.\n *\n * @augments Mesh\n * @three_import import { TextureHelper } from 'three/addons/helpers/TextureHelper.js';\n */\nclass TextureHelper extends Mesh {\n\n\t/**\n\t * Constructs a new texture helper.\n\t *\n\t * @param {Texture} texture - The texture to visualize.\n\t * @param {number} [width=1] - The helper's width.\n\t * @param {number} [height=1] - The helper's height.\n\t * @param {number} [depth=1] - The helper's depth.\n\t */\n\tconstructor( texture, width = 1, height = 1, depth = 1 ) {\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\ttype: 'TextureHelperMaterial',\n\n\t\t\tside: DoubleSide,\n\t\t\ttransparent: true,\n\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: texture },\n\t\t\t\talpha: { value: getAlpha( texture ) },\n\n\t\t\t},\n\n\t\t\tvertexShader: [\n\n\t\t\t\t'attribute vec3 uvw;',\n\n\t\t\t\t'varying vec3 vUvw;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUvw = uvw;',\n\n\t\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t\t'}',\n\n\t\t\t].join( '\\n' ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'precision highp sampler2DArray;',\n\n\t\t\t\t'precision highp sampler3D;',\n\n\t\t\t\t'uniform {samplerType} map;',\n\n\t\t\t\t'uniform float alpha;',\n\n\t\t\t\t'varying vec3 vUvw;',\n\n\t\t\t\t'vec4 textureHelper( in sampler2D map ) { return texture( map, vUvw.xy ); }',\n\n\t\t\t\t'vec4 textureHelper( in sampler2DArray map ) { return texture( map, vUvw ); }',\n\n\t\t\t\t'vec4 textureHelper( in sampler3D map ) { return texture( map, vUvw ); }',\n\n\t\t\t\t'vec4 textureHelper( in samplerCube map ) { return texture( map, vUvw ); }',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = linearToOutputTexel( vec4( textureHelper( map ).xyz, alpha ) );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ).replace( '{samplerType}', getSamplerType( texture ) )\n\n\t\t} );\n\n\t\tconst geometry = texture.isCubeTexture\n\t\t\t? createCubeGeometry( width, height, depth )\n\t\t\t: createSliceGeometry( texture, width, height, depth );\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * The texture to visualize.\n\t\t *\n\t\t * @type {Texture}\n\t\t */\n\t\tthis.texture = texture;\n\t\tthis.type = 'TextureHelper';\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nfunction getSamplerType( texture ) {\n\n\tif ( texture.isCubeTexture ) {\n\n\t\treturn 'samplerCube';\n\n\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\treturn 'sampler2DArray';\n\n\t} else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {\n\n\t\treturn 'sampler3D';\n\n\t} else {\n\n\t\treturn 'sampler2D';\n\n\t}\n\n}\n\nfunction getImageCount( texture ) {\n\n\tif ( texture.isCubeTexture ) {\n\n\t\treturn 6;\n\n\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\treturn texture.image.depth;\n\n\t} else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {\n\n\t\treturn texture.image.depth;\n\n\t} else {\n\n\t\treturn 1;\n\n\t}\n\n}\n\nfunction getAlpha( texture ) {\n\n\tif ( texture.isCubeTexture ) {\n\n\t\treturn 1;\n\n\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\treturn Math.max( 1 / texture.image.depth, 0.25 );\n\n\t} else if ( texture.isData3DTexture || texture.isCompressed3DTexture ) {\n\n\t\treturn Math.max( 1 / texture.image.depth, 0.25 );\n\n\t} else {\n\n\t\treturn 1;\n\n\t}\n\n}\n\nfunction createCubeGeometry( width, height, depth ) {\n\n\tconst geometry = new BoxGeometry( width, height, depth );\n\n\tconst position = geometry.attributes.position;\n\tconst uv = geometry.attributes.uv;\n\tconst uvw = new BufferAttribute( new Float32Array( uv.count * 3 ), 3 );\n\n\tconst _direction = new Vector3();\n\n\tfor ( let j = 0, jl = uv.count; j < jl; ++ j ) {\n\n\t\t_direction.fromBufferAttribute( position, j ).normalize();\n\n\t\tconst u = _direction.x;\n\t\tconst v = _direction.y;\n\t\tconst w = _direction.z;\n\n\t\tuvw.setXYZ( j, u, v, w );\n\n\t}\n\n\tgeometry.deleteAttribute( 'uv' );\n\tgeometry.setAttribute( 'uvw', uvw );\n\n\treturn geometry;\n\n}\n\nfunction createSliceGeometry( texture, width, height, depth ) {\n\n\tconst sliceCount = getImageCount( texture );\n\n\tconst geometries = [];\n\n\tfor ( let i = 0; i < sliceCount; ++ i ) {\n\n\t\tconst geometry = new PlaneGeometry( width, height );\n\n\t\tif ( sliceCount > 1 ) {\n\n\t\t\tgeometry.translate( 0, 0, depth * ( i / ( sliceCount - 1 ) - 0.5 ) );\n\n\t\t}\n\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uvw = new BufferAttribute( new Float32Array( uv.count * 3 ), 3 );\n\n\t\tfor ( let j = 0, jl = uv.count; j < jl; ++ j ) {\n\n\t\t\tconst u = uv.getX( j );\n\t\t\tconst v = texture.flipY ? uv.getY( j ) : 1 - uv.getY( j );\n\t\t\tconst w = sliceCount === 1\n\t\t\t\t? 1\n\t\t\t\t: texture.isDataArrayTexture || texture.isCompressedArrayTexture\n\t\t\t\t\t? i\n\t\t\t\t\t: i / ( sliceCount - 1 );\n\n\t\t\tuvw.setXYZ( j, u, v, w );\n\n\t\t}\n\n\t\tgeometry.deleteAttribute( 'uv' );\n\t\tgeometry.setAttribute( 'uvw', uvw );\n\n\t\tgeometries.push( geometry );\n\n\t}\n\n\treturn mergeGeometries( geometries );\n\n}\n\nexport { TextureHelper };\n"],"mappings":"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","ignoreList":[]}