{"version":3,"file":"node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js","names":["BufferGeometry","Float32BufferAttribute","LineSegments","LineBasicMaterial","Matrix3","Vector3","_v1","_v2","_normalMatrix","VertexNormalsHelper","constructor","object","size","color","geometry","nNormals","attributes","normal","count","positions","setAttribute","super","toneMapped","this","type","matrixAutoUpdate","isVertexNormalsHelper","update","updateMatrixWorld","getNormalMatrix","matrixWorld","position","objGeometry","objPos","objNorm","idx","j","jl","fromBufferAttribute","applyMatrix4","applyMatrix3","normalize","multiplyScalar","add","setXYZ","x","y","z","needsUpdate","dispose","material"],"sources":["node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tLineSegments,\n\tLineBasicMaterial,\n\tMatrix3,\n\tVector3\n} from 'three';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\n/**\n * Visualizes an object's vertex normals.\n *\n * Requires that normals have been specified in the geometry as a buffer attribute or\n * have been calculated using {@link BufferGeometry#computeVertexNormals}.\n * ```js\n * const geometry = new THREE.BoxGeometry( 10, 10, 10, 2, 2, 2 );\n * const material = new THREE.MeshStandardMaterial();\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n *\n * const helper = new VertexNormalsHelper( mesh, 1, 0xff0000 );\n * scene.add( helper );\n * ```\n *\n * @augments LineSegments\n * @three_import import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';\n */\nclass VertexNormalsHelper extends LineSegments {\n\n\t/**\n\t * Constructs a new vertex normals helper.\n\t *\n\t * @param {Object3D} object - The object for which to visualize vertex normals.\n\t * @param {number} [size=1] - The helper's size.\n\t * @param {number|Color|string} [color=0xff0000] - The helper's color.\n\t */\n\tconstructor( object, size = 1, color = 0xff0000 ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst nNormals = object.geometry.attributes.normal.count;\n\t\tconst positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.setAttribute( 'position', positions );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color, toneMapped: false } ) );\n\n\t\t/**\n\t\t * The object for which to visualize vertex normals.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The helper's size.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.size = size;\n\n\t\tthis.type = 'VertexNormalsHelper';\n\n\t\t/**\n\t\t * Overwritten and set to `false` since the object's world transformation\n\t\t * is encoded in the helper's geometry data.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVertexNormalsHelper = true;\n\n\t\tthis.update();\n\n\t}\n\n\t/**\n\t * Updates the vertex normals preview based on the object's world transform.\n\t */\n\tupdate() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\t_normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tconst matrixWorld = this.object.matrixWorld;\n\n\t\tconst position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tconst objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry ) {\n\n\t\t\tconst objPos = objGeometry.attributes.position;\n\n\t\t\tconst objNorm = objGeometry.attributes.normal;\n\n\t\t\tlet idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( let j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t_v1.fromBufferAttribute( objPos, j ).applyMatrix4( matrixWorld );\n\n\t\t\t\t_v2.fromBufferAttribute( objNorm, j );\n\n\t\t\t\t_v2.applyMatrix3( _normalMatrix ).normalize().multiplyScalar( this.size ).add( _v1 );\n\n\t\t\t\tposition.setXYZ( idx, _v1.x, _v1.y, _v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, _v2.x, _v2.y, _v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nexport { VertexNormalsHelper };\n"],"mappings":"OACCA,eACAC,uBACAC,aACAC,kBACAC,QACAC,YACM,QAEP,MAAMC,IAAM,IAAID,QACVE,IAAM,IAAIF,QACVG,cAAgB,IAAIJ,QAoB1B,MAAMK,4BAA4BP,aASjC,WAAAQ,CAAaC,EAAQC,EAAO,EAAGC,EAAQ,UAEtC,MAAMC,EAAW,IAAId,eAEfe,EAAWJ,EAAOG,SAASE,WAAWC,OAAOC,MAC7CC,EAAY,IAAIlB,uBAAmC,EAAXc,EAAe,EAAG,GAEhED,EAASM,aAAc,WAAYD,GAEnCE,MAAOP,EAAU,IAAIX,kBAAmB,CAAEU,QAAOS,YAAY,KAO7DC,KAAKZ,OAASA,EAQdY,KAAKX,KAAOA,EAEZW,KAAKC,KAAO,sBASZD,KAAKE,kBAAmB,EASxBF,KAAKG,uBAAwB,EAE7BH,KAAKI,QAEN,CAKA,MAAAA,GAECJ,KAAKZ,OAAOiB,mBAAmB,GAE/BpB,cAAcqB,gBAAiBN,KAAKZ,OAAOmB,aAE3C,MAAMA,EAAcP,KAAKZ,OAAOmB,YAE1BC,EAAWR,KAAKT,SAASE,WAAWe,SAIpCC,EAAcT,KAAKZ,OAAOG,SAEhC,GAAKkB,EAAc,CAElB,MAAMC,EAASD,EAAYhB,WAAWe,SAEhCG,EAAUF,EAAYhB,WAAWC,OAEvC,IAAIkB,EAAM,EAIV,IAAM,IAAIC,EAAI,EAAGC,EAAKJ,EAAOf,MAAOkB,EAAIC,EAAID,IAE3C9B,IAAIgC,oBAAqBL,EAAQG,GAAIG,aAAcT,GAEnDvB,IAAI+B,oBAAqBJ,EAASE,GAElC7B,IAAIiC,aAAchC,eAAgBiC,YAAYC,eAAgBnB,KAAKX,MAAO+B,IAAKrC,KAE/EyB,EAASa,OAAQT,EAAK7B,IAAIuC,EAAGvC,IAAIwC,EAAGxC,IAAIyC,GAExCZ,GAAY,EAEZJ,EAASa,OAAQT,EAAK5B,IAAIsC,EAAGtC,IAAIuC,EAAGvC,IAAIwC,GAExCZ,GAAY,CAId,CAEAJ,EAASiB,aAAc,CAExB,CAMA,OAAAC,GAEC1B,KAAKT,SAASmC,UACd1B,KAAK2B,SAASD,SAEf,SAIQxC","ignoreList":[]}