{"version":3,"file":"node_modules/three/examples/jsm/interactive/HTMLMesh.js","names":["CanvasTexture","LinearFilter","Mesh","MeshBasicMaterial","PlaneGeometry","SRGBColorSpace","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","super","this","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","colorSpace","minFilter","magFilter","generateMipmaps","observer","MutationObserver","scheduleUpdate","setTimeout","update","observe","attributes","childList","subtree","characterData","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","drawText","style","string","textTransform","toUpperCase","context","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","beginPath","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","offset","getBoundingClientRect","canvas","get","undefined","createElement","set","getContext","clipper","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","rect","add","push","remove","pop","clearRect","drawElement","nodeType","Node","COMMENT_NODE","nodeName","display","TEXT_NODE","selectNode","left","top","nodeValue","trim","HTMLCanvasElement","dpr","window","devicePixelRatio","scale","drawImage","HTMLImageElement","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","accentTextColor","sqrt","g","b","checked","currentTextAlign","textAlign","value","property","position","displayValue","repeat","parseInt","paddingLeft","paddingTop","overflow","childNodes","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","proportion","InputEvent","bubbles","focus"],"sources":["node_modules/three/examples/jsm/interactive/HTMLMesh.js"],"sourcesContent":["import {\n\tCanvasTexture,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tSRGBColorSpace,\n\tColor\n} from 'three';\n\n/**\n * This class can be used to render a DOM element onto a canvas and use it as a texture\n * for a plane mesh.\n *\n * A typical use case for this class is to render the GUI of `lil-gui` as a texture so it\n * is compatible for VR.\n *\n * ```js\n * const gui = new GUI( { width: 300 } ); // create lil-gui instance\n *\n * const mesh = new HTMLMesh( gui.domElement );\n * scene.add( mesh );\n * ```\n *\n * @augments Mesh\n * @three_import import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';\n */\nclass HTMLMesh extends Mesh {\n\n\t/**\n\t * Constructs a new HTML mesh.\n\t *\n\t * @param {HTMLElement} dom - The DOM element to display as a plane mesh.\n\t */\n\tconstructor( dom ) {\n\n\t\tconst texture = new HTMLTexture( dom );\n\n\t\tconst geometry = new PlaneGeometry( texture.image.width * 0.001, texture.image.height * 0.001 );\n\t\tconst material = new MeshBasicMaterial( { map: texture, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tfunction onEvent( event ) {\n\n\t\t\tmaterial.map.dispatchDOMEvent( event );\n\n\t\t}\n\n\t\tthis.addEventListener( 'mousedown', onEvent );\n\t\tthis.addEventListener( 'mousemove', onEvent );\n\t\tthis.addEventListener( 'mouseup', onEvent );\n\t\tthis.addEventListener( 'click', onEvent );\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance and removes all event listeners.\n\t\t * Call this method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tgeometry.dispose();\n\t\t\tmaterial.dispose();\n\n\t\t\tmaterial.map.dispose();\n\n\t\t\tcanvases.delete( dom );\n\n\t\t\tthis.removeEventListener( 'mousedown', onEvent );\n\t\t\tthis.removeEventListener( 'mousemove', onEvent );\n\t\t\tthis.removeEventListener( 'mouseup', onEvent );\n\t\t\tthis.removeEventListener( 'click', onEvent );\n\n\t\t};\n\n\t}\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n\n\tconstructor( dom ) {\n\n\t\tsuper( html2canvas( dom ) );\n\n\t\tthis.dom = dom;\n\n\t\tthis.anisotropy = 16;\n\t\tthis.colorSpace = SRGBColorSpace;\n\t\tthis.minFilter = LinearFilter;\n\t\tthis.magFilter = LinearFilter;\n\t\tthis.generateMipmaps = false;\n\n\t\t// Create an observer on the DOM, and run html2canvas update in the next loop\n\t\tconst observer = new MutationObserver( () => {\n\n\t\t\tif ( ! this.scheduleUpdate ) {\n\n\t\t\t\t// ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n\t\t\t\tthis.scheduleUpdate = setTimeout( () => this.update(), 16 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst config = { attributes: true, childList: true, subtree: true, characterData: true };\n\t\tobserver.observe( dom, config );\n\n\t\tthis.observer = observer;\n\n\t}\n\n\tdispatchDOMEvent( event ) {\n\n\t\tif ( event.data ) {\n\n\t\t\thtmlevent( this.dom, event.type, event.data.x, event.data.y );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.image = html2canvas( this.dom );\n\t\tthis.needsUpdate = true;\n\n\t\tthis.scheduleUpdate = null;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.observer ) {\n\n\t\t\tthis.observer.disconnect();\n\n\t\t}\n\n\t\tthis.scheduleUpdate = clearTimeout( this.scheduleUpdate );\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\n\n//\n\nconst canvases = new WeakMap();\n\nfunction html2canvas( element ) {\n\n\tconst range = document.createRange();\n\tconst color = new Color();\n\n\tfunction Clipper( context ) {\n\n\t\tconst clips = [];\n\t\tlet isClipping = false;\n\n\t\tfunction doClip() {\n\n\t\t\tif ( isClipping ) {\n\n\t\t\t\tisClipping = false;\n\t\t\t\tcontext.restore();\n\n\t\t\t}\n\n\t\t\tif ( clips.length === 0 ) return;\n\n\t\t\tlet minX = - Infinity, minY = - Infinity;\n\t\t\tlet maxX = Infinity, maxY = Infinity;\n\n\t\t\tfor ( let i = 0; i < clips.length; i ++ ) {\n\n\t\t\t\tconst clip = clips[ i ];\n\n\t\t\t\tminX = Math.max( minX, clip.x );\n\t\t\t\tminY = Math.max( minY, clip.y );\n\t\t\t\tmaxX = Math.min( maxX, clip.x + clip.width );\n\t\t\t\tmaxY = Math.min( maxY, clip.y + clip.height );\n\n\t\t\t}\n\n\t\t\tcontext.save();\n\t\t\tcontext.beginPath();\n\t\t\tcontext.rect( minX, minY, maxX - minX, maxY - minY );\n\t\t\tcontext.clip();\n\n\t\t\tisClipping = true;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tadd: function ( clip ) {\n\n\t\t\t\tclips.push( clip );\n\t\t\t\tdoClip();\n\n\t\t\t},\n\n\t\t\tremove: function () {\n\n\t\t\t\tclips.pop();\n\t\t\t\tdoClip();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction drawText( style, x, y, string ) {\n\n\t\tif ( string !== '' ) {\n\n\t\t\tif ( style.textTransform === 'uppercase' ) {\n\n\t\t\t\tstring = string.toUpperCase();\n\n\t\t\t}\n\n\t\t\tcontext.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n\t\t\tcontext.textBaseline = 'top';\n\t\t\tcontext.fillStyle = style.color;\n\t\t\tcontext.fillText( string, x, y + parseFloat( style.fontSize ) * 0.1 );\n\n\t\t}\n\n\t}\n\n\tfunction buildRectPath( x, y, w, h, r ) {\n\n\t\tif ( w < 2 * r ) r = w / 2;\n\t\tif ( h < 2 * r ) r = h / 2;\n\n\t\tcontext.beginPath();\n\t\tcontext.moveTo( x + r, y );\n\t\tcontext.arcTo( x + w, y, x + w, y + h, r );\n\t\tcontext.arcTo( x + w, y + h, x, y + h, r );\n\t\tcontext.arcTo( x, y + h, x, y, r );\n\t\tcontext.arcTo( x, y, x + w, y, r );\n\t\tcontext.closePath();\n\n\t}\n\n\tfunction drawBorder( style, which, x, y, width, height ) {\n\n\t\tconst borderWidth = style[ which + 'Width' ];\n\t\tconst borderStyle = style[ which + 'Style' ];\n\t\tconst borderColor = style[ which + 'Color' ];\n\n\t\tif ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\tcontext.strokeStyle = borderColor;\n\t\t\tcontext.lineWidth = parseFloat( borderWidth );\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo( x, y );\n\t\t\tcontext.lineTo( x + width, y + height );\n\t\t\tcontext.stroke();\n\n\t\t}\n\n\t}\n\n\tfunction drawElement( element, style ) {\n\n\t\t// Do not render invisible elements, comments and scripts.\n\t\tif ( element.nodeType === Node.COMMENT_NODE || element.nodeName === 'SCRIPT' || ( element.style && element.style.display === 'none' ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet x = 0, y = 0, width = 0, height = 0;\n\n\t\tif ( element.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t// text\n\n\t\t\trange.selectNode( element );\n\n\t\t\tconst rect = range.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tdrawText( style, x, y, element.nodeValue.trim() );\n\n\t\t} else if ( element instanceof HTMLCanvasElement ) {\n\n\t\t\t// Canvas element\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\n\t\t        context.save();\n\t\t\tconst dpr = window.devicePixelRatio;\n\t\t\tcontext.scale( 1 / dpr, 1 / dpr );\n\t\t\tcontext.drawImage( element, x, y );\n\t\t\tcontext.restore();\n\n\t\t} else if ( element instanceof HTMLImageElement ) {\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tcontext.drawImage( element, x, y, width, height );\n\n\t\t} else {\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tstyle = window.getComputedStyle( element );\n\n\t\t\t// Get the border of the element used for fill and border\n\n\t\t\tbuildRectPath( x, y, width, height, parseFloat( style.borderRadius ) );\n\n\t\t\tconst backgroundColor = style.backgroundColor;\n\n\t\t\tif ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\t\tcontext.fillStyle = backgroundColor;\n\t\t\t\tcontext.fill();\n\n\t\t\t}\n\n\t\t\t// If all the borders match then stroke the round rectangle\n\n\t\t\tconst borders = [ 'borderTop', 'borderLeft', 'borderBottom', 'borderRight' ];\n\n\t\t\tlet match = true;\n\t\t\tlet prevBorder = null;\n\n\t\t\tfor ( const border of borders ) {\n\n\t\t\t\tif ( prevBorder !== null ) {\n\n\t\t\t\t\tmatch = ( style[ border + 'Width' ] === style[ prevBorder + 'Width' ] ) &&\n\t\t\t\t\t( style[ border + 'Color' ] === style[ prevBorder + 'Color' ] ) &&\n\t\t\t\t\t( style[ border + 'Style' ] === style[ prevBorder + 'Style' ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( match === false ) break;\n\n\t\t\t\tprevBorder = border;\n\n\t\t\t}\n\n\t\t\tif ( match === true ) {\n\n\t\t\t\t// They all match so stroke the rectangle from before allows for border-radius\n\n\t\t\t\tconst width = parseFloat( style.borderTopWidth );\n\n\t\t\t\tif ( style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\t\t\tcontext.strokeStyle = style.borderTopColor;\n\t\t\t\t\tcontext.lineWidth = width;\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise draw individual borders\n\n\t\t\t\tdrawBorder( style, 'borderTop', x, y, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderLeft', x, y, 0, height );\n\t\t\t\tdrawBorder( style, 'borderBottom', x, y + height, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderRight', x + width, y, 0, height );\n\n\t\t\t}\n\n\t\t\tif ( element instanceof HTMLInputElement ) {\n\n\t\t\t\tlet accentColor = style.accentColor;\n\n\t\t\t\tif ( accentColor === undefined || accentColor === 'auto' ) accentColor = style.color;\n\n\t\t\t\tcolor.set( accentColor );\n\n\t\t\t\tconst luminance = Math.sqrt( 0.299 * ( color.r ** 2 ) + 0.587 * ( color.g ** 2 ) + 0.114 * ( color.b ** 2 ) );\n\t\t\t\tconst accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n\t\t\t\tif ( element.type === 'radio' ) {\n\n\t\t\t\t\tbuildRectPath( x, y, width, height, height );\n\n\t\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.fill();\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\tif ( element.checked ) {\n\n\t\t\t\t\t\tbuildRectPath( x + 2, y + 2, width - 4, height - 4, height );\n\n\t\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\t\tcontext.strokeStyle = accentTextColor;\n\t\t\t\t\t\tcontext.lineWidth = 2;\n\t\t\t\t\t\tcontext.fill();\n\t\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'checkbox' ) {\n\n\t\t\t\t\tbuildRectPath( x, y, width, height, 2 );\n\n\t\t\t\t\tcontext.fillStyle = element.checked ? accentColor : 'white';\n\t\t\t\t\tcontext.strokeStyle = element.checked ? accentTextColor : accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t\tif ( element.checked ) {\n\n\t\t\t\t\t\tconst currentTextAlign = context.textAlign;\n\n\t\t\t\t\t\tcontext.textAlign = 'center';\n\n\t\t\t\t\t\tconst properties = {\n\t\t\t\t\t\t\tcolor: accentTextColor,\n\t\t\t\t\t\t\tfontFamily: style.fontFamily,\n\t\t\t\t\t\t\tfontSize: height + 'px',\n\t\t\t\t\t\t\tfontWeight: 'bold'\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tdrawText( properties, x + ( width / 2 ), y, 'âœ”' );\n\n\t\t\t\t\t\tcontext.textAlign = currentTextAlign;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'range' ) {\n\n\t\t\t\t\tconst [ min, max, value ] = [ 'min', 'max', 'value' ].map( property => parseFloat( element[ property ] ) );\n\t\t\t\t\tconst position = ( ( value - min ) / ( max - min ) ) * ( width - height );\n\n\t\t\t\t\tbuildRectPath( x, y + ( height / 4 ), width, height / 2, height / 4 );\n\t\t\t\t\tcontext.fillStyle = accentTextColor;\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.fill();\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\tbuildRectPath( x, y + ( height / 4 ), position + ( height / 2 ), height / 2, height / 4 );\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t\tbuildRectPath( x + position, y, height, height, height / 2 );\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'color' || element.type === 'text' || element.type === 'number' || element.type === 'email' || element.type === 'password' ) {\n\n\t\t\t\t\tclipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\t\t\t\tconst displayValue = element.type === 'password' ? '*'.repeat( element.value.length ) : element.value;\n\n\t\t\t\t\tdrawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), displayValue );\n\n\t\t\t\t\tclipper.remove();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t// debug\n\t\tcontext.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n\t\tcontext.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n\t\t*/\n\n\t\tconst isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n\n\t\tif ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tdrawElement( element.childNodes[ i ], style );\n\n\t\t}\n\n\t\tif ( isClipping ) clipper.remove();\n\n\t}\n\n\tconst offset = element.getBoundingClientRect();\n\n\tlet canvas = canvases.get( element );\n\n\tif ( canvas === undefined ) {\n\n\t\tcanvas = document.createElement( 'canvas' );\n\t\tcanvas.width = offset.width;\n\t\tcanvas.height = offset.height;\n\t\tcanvases.set( element, canvas );\n\n\t}\n\n\tconst context = canvas.getContext( '2d'/*, { alpha: false }*/ );\n\n\tconst clipper = new Clipper( context );\n\n\t// console.time( 'drawElement' );\n\n\tcontext.clearRect( 0, 0, canvas.width, canvas.height );\n\n\tdrawElement( element );\n\n\t// console.timeEnd( 'drawElement' );\n\n\treturn canvas;\n\n}\n\nfunction htmlevent( element, event, x, y ) {\n\n\tconst mouseEventInit = {\n\t\tclientX: ( x * element.offsetWidth ) + element.offsetLeft,\n\t\tclientY: ( y * element.offsetHeight ) + element.offsetTop,\n\t\tview: element.ownerDocument.defaultView\n\t};\n\n\twindow.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\tconst rect = element.getBoundingClientRect();\n\n\tx = x * rect.width + rect.left;\n\ty = y * rect.height + rect.top;\n\n\tfunction traverse( element ) {\n\n\t\tif ( element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE ) {\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tif ( x > rect.left && x < rect.right && y > rect.top && y < rect.bottom ) {\n\n\t\t\t\telement.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\t\t\t\tif ( element instanceof HTMLInputElement && element.type === 'range' && ( event === 'mousedown' || event === 'click' ) ) {\n\n\t\t\t\t\tconst [ min, max ] = [ 'min', 'max' ].map( property => parseFloat( element[ property ] ) );\n\n\t\t\t\t\tconst width = rect.width;\n\t\t\t\t\tconst offsetX = x - rect.x;\n\t\t\t\t\tconst proportion = offsetX / width;\n\t\t\t\t\telement.value = min + ( max - min ) * proportion;\n\t\t\t\t\telement.dispatchEvent( new InputEvent( 'input', { bubbles: true } ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( element instanceof HTMLInputElement && ( element.type === 'text' || element.type === 'number' || element.type === 'email' || element.type === 'password' ) && ( event === 'mousedown' || event === 'click' ) ) {\n\n\t\t\t\t\telement.focus();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\t\ttraverse( element.childNodes[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( element );\n\n}\n\nexport { HTMLMesh };\n"],"mappings":"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","ignoreList":[]}