{"version":3,"file":"node_modules/three/examples/jsm/libs/surfaceNet.js","names":["surfaceNet","dims","potential","bounds","cube_edges","Int32Array","edge_table","k","i","j","p","em","buffer","Array","length","scale","shift","vertices","faces","x","R","grid","buf_no","ol","m","mask","g","edge_mask","v","e_count","e0","e1","g0","t","Math","abs","a","b","s","push","iu","iv","du","dv","positions","cells"],"sources":["node_modules/three/examples/jsm/libs/surfaceNet.js"],"sourcesContent":["/**\n * SurfaceNets in JavaScript\n *\n * Written by Mikola Lysenko (C) 2012\n *\n * MIT License\n *\n * Based on: S.F. Gibson, 'Constrained Elastic Surface Nets'. (1998) MERL Tech Report.\n * from https://github.com/mikolalysenko/isosurface/tree/master\n * \n */\n\nlet surfaceNet = ( dims, potential, bounds ) => {\n\t\t\n\t\n\t//Precompute edge table, like Paul Bourke does.\n\t// This saves a bit of time when computing the centroid of each boundary cell\n\tvar cube_edges = new Int32Array(24) , edge_table = new Int32Array(256);\n\t(function() {\n\n\t\t//Initialize the cube_edges table\n\t\t// This is just the vertex number of each cube\n\t\tvar k = 0;\n\t\tfor(var i=0; i<8; ++i) {\n\t\t\tfor(var j=1; j<=4; j<<=1) {\n\t\t\t\tvar p = i^j;\n\t\t\t\tif(i <= p) {\n\t\t\t\t\tcube_edges[k++] = i;\n\t\t\t\t\tcube_edges[k++] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Initialize the intersection table.\n\t\t//  This is a 2^(cube configuration) ->  2^(edge configuration) map\n\t\t//  There is one entry for each possible cube configuration, and the output is a 12-bit vector enumerating all edges crossing the 0-level.\n\t\tfor(var i=0; i<256; ++i) {\n\t\t\tvar em = 0;\n\t\t\tfor(var j=0; j<24; j+=2) {\n\t\t\t\tvar a = !!(i & (1<<cube_edges[j]))\n\t\t\t\t\t, b = !!(i & (1<<cube_edges[j+1]));\n\t\t\t\tem |= a !== b ? (1 << (j >> 1)) : 0;\n\t\t\t}\n\t\t\tedge_table[i] = em;\n\t\t}\n\t})();\n\n\t//Internal buffer, this may get resized at run time\n\tvar buffer = new Array(4096);\n\t(function() {\n\t\tfor(var i=0; i<buffer.length; ++i) {\n\t\t\tbuffer[i] = 0;\n\t\t}\n\t})();\n\n\tif(!bounds) {\n\t\tbounds = [[0,0,0],dims];\n\t}\n\t\n\tvar scale     = [0,0,0];\n\tvar shift     = [0,0,0];\n\tfor(var i=0; i<3; ++i) {\n\t\tscale[i] = (bounds[1][i] - bounds[0][i]) / dims[i];\n\t\tshift[i] = bounds[0][i];\n\t}\n\t\n\tvar vertices = []\n\t\t, faces = []\n\t\t, n = 0\n\t\t, x = [0, 0, 0]\n\t\t, R = [1, (dims[0]+1), (dims[0]+1)*(dims[1]+1)]\n\t\t, grid = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\t\t, buf_no = 1;\n\t\n\t\t\n\t//Resize buffer if necessary \n\tif(R[2] * 2 > buffer.length) {\n\t\tvar ol = buffer.length;\n\t\tbuffer.length = R[2] * 2;\n\t\twhile(ol < buffer.length) {\n\t\t\tbuffer[ol++] = 0;\n\t\t}\n\t}\n\t\n\t//March over the voxel grid\n\tfor(x[2]=0; x[2]<dims[2]-1; ++x[2], n+=dims[0], buf_no ^= 1, R[2]=-R[2]) {\n\t\n\t\t//m is the pointer into the buffer we are going to use.  \n\t\t//This is slightly obtuse because javascript does not have good support for packed data structures, so we must use typed arrays :(\n\t\t//The contents of the buffer will be the indices of the vertices on the previous x/y slice of the volume\n\t\tvar m = 1 + (dims[0]+1) * (1 + buf_no * (dims[1]+1));\n\t\t\n\t\tfor(x[1]=0; x[1]<dims[1]-1; ++x[1], ++n, m+=2)\n\t\tfor(x[0]=0; x[0]<dims[0]-1; ++x[0], ++n, ++m) {\n\t\t\n\t\t\t//Read in 8 field values around this vertex and store them in an array\n\t\t\t//Also calculate 8-bit mask, like in marching cubes, so we can speed up sign checks later\n\t\t\tvar mask = 0, g = 0;\n\t\t\tfor(var k=0; k<2; ++k)\n\t\t\tfor(var j=0; j<2; ++j)      \n\t\t\tfor(var i=0; i<2; ++i, ++g) {\n\t\t\t\tvar p = potential(\n\t\t\t\t\tscale[0]*(x[0]+i)+shift[0],\n\t\t\t\t\tscale[1]*(x[1]+j)+shift[1],\n\t\t\t\t\tscale[2]*(x[2]+k)+shift[2]);\n\t\t\t\tgrid[g] = p;\n\t\t\t\tmask |= (p < 0) ? (1<<g) : 0;\n\t\t\t}\n\t\t\t\n\t\t\t//Check for early termination if cell does not intersect boundary\n\t\t\tif(mask === 0 || mask === 0xff) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//Sum up edge intersections\n\t\t\tvar edge_mask = edge_table[mask]\n\t\t\t\t, v = [0.0,0.0,0.0]\n\t\t\t\t, e_count = 0;\n\t\t\t\t\n\t\t\t//For every edge of the cube...\n\t\t\tfor(var i=0; i<12; ++i) {\n\t\t\t\n\t\t\t\t//Use edge mask to check if it is crossed\n\t\t\t\tif(!(edge_mask & (1<<i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//If it did, increment number of edge crossings\n\t\t\t\t++e_count;\n\t\t\t\t\n\t\t\t\t//Now find the point of intersection\n\t\t\t\tvar e0 = cube_edges[ i<<1 ]       //Unpack vertices\n\t\t\t\t\t, e1 = cube_edges[(i<<1)+1]\n\t\t\t\t\t, g0 = grid[e0]                 //Unpack grid values\n\t\t\t\t\t, g1 = grid[e1]\n\t\t\t\t\t, t  = g0 - g1;                 //Compute point of intersection\n\t\t\t\tif(Math.abs(t) > 1e-6) {\n\t\t\t\t\tt = g0 / t;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Interpolate vertices and add up intersections (this can be done without multiplying)\n\t\t\t\tfor(var j=0, k=1; j<3; ++j, k<<=1) {\n\t\t\t\t\tvar a = e0 & k\n\t\t\t\t\t\t, b = e1 & k;\n\t\t\t\t\tif(a !== b) {\n\t\t\t\t\t\tv[j] += a ? 1.0 - t : t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[j] += a ? 1.0 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Now we just average the edge intersections and add them to coordinate\n\t\t\tvar s = 1.0 / e_count;\n\t\t\tfor(var i=0; i<3; ++i) {\n\t\t\t\tv[i] = scale[i] * (x[i] + s * v[i]) + shift[i];\n\t\t\t}\n\t\t\t\n\t\t\t//Add vertex to buffer, store pointer to vertex index in buffer\n\t\t\tbuffer[m] = vertices.length;\n\t\t\tvertices.push(v);\n\t\t\t\n\t\t\t//Now we need to add faces together, to do this we just loop over 3 basis components\n\t\t\tfor(var i=0; i<3; ++i) {\n\t\t\t\t//The first three entries of the edge_mask count the crossings along the edge\n\t\t\t\tif(!(edge_mask & (1<<i)) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// i = axes we are point along.  iu, iv = orthogonal axes\n\t\t\t\tvar iu = (i+1)%3\n\t\t\t\t\t, iv = (i+2)%3;\n\t\t\t\t\t\n\t\t\t\t//If we are on a boundary, skip it\n\t\t\t\tif(x[iu] === 0 || x[iv] === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Otherwise, look up adjacent edges in buffer\n\t\t\t\tvar du = R[iu]\n\t\t\t\t\t, dv = R[iv];\n\t\t\t\t\n\t\t\t\t//Remember to flip orientation depending on the sign of the corner.\n\t\t\t\tif(mask & 1) {\n\t\t\t\t\tfaces.push([buffer[m],    buffer[m-du],    buffer[m-dv]]);\n\t\t\t\t\tfaces.push([buffer[m-dv], buffer[m-du],    buffer[m-du-dv]]);\n\t\t\t\t} else {\n\t\t\t\t\tfaces.push([buffer[m],    buffer[m-dv],    buffer[m-du]]);\n\t\t\t\t\tfaces.push([buffer[m-du], buffer[m-dv],    buffer[m-du-dv]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//All done!  Return the result\n\treturn { positions: vertices, cells: faces };\n}\n\nexport { surfaceNet }"],"mappings":"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","ignoreList":[]}