{"version":3,"file":"node_modules/three/examples/jsm/lights/LightProbeGenerator.js","names":["Color","LightProbe","LinearSRGBColorSpace","SphericalHarmonics3","Vector3","SRGBColorSpace","NoColorSpace","HalfFloatType","DataUtils","WebGLCoordinateSystem","FloatType","LightProbeGenerator","fromCubeTexture","cubeTexture","totalWeight","coord","dir","color","shBasis","sh","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","convertColorToLinear","colorSpace","pixelIndex","col","row","Math","floor","set","lengthSq","weight","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","norm","PI","fromCubeRenderTarget","renderer","cubeRenderTarget","flip","coordinateSystem","dataType","texture","type","isWebGLRenderer","Float32Array","Uint16Array","Uint8Array","readRenderTargetPixelsAsync","fromHalfFloat","convertSRGBToLinear","console","warn"],"sources":["node_modules/three/examples/jsm/lights/LightProbeGenerator.js"],"sourcesContent":["import {\n\tColor,\n\tLightProbe,\n\tLinearSRGBColorSpace,\n\tSphericalHarmonics3,\n\tVector3,\n\tSRGBColorSpace,\n\tNoColorSpace,\n\tHalfFloatType,\n\tDataUtils,\n\tWebGLCoordinateSystem,\n\tFloatType\n} from 'three';\n\n/**\n * Utility class for creating instances of {@link LightProbe}.\n *\n * @hideconstructor\n * @three_import import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n */\nclass LightProbeGenerator {\n\n\t/**\n\t * Creates a light probe from the given (radiance) environment map.\n\t * The method expects that the environment map is represented as a cube texture.\n\t *\n\t * @param {CubeTexture} cubeTexture - The environment map.\n\t * @return {LightProbe} The created light probe.\n\t */\n\tstatic fromCubeTexture( cubeTexture ) {\n\n\t\t// https://www.ppsloan.org/publications/StupidSH36.pdf\n\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tconst image = cubeTexture.image[ faceIndex ];\n\n\t\t\tconst width = image.width;\n\t\t\tconst height = image.height;\n\n\t\t\tconst canvas = document.createElement( 'canvas' );\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\n\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, width, height );\n\n\t\t\tconst data = imageData.data;\n\n\t\t\tconst imageWidth = imageData.width; // assumed to be square\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeTexture.colorSpace );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( - 1, row, - col ); break;\n\n\t\t\t\t\tcase 1: coord.set( 1, row, col ); break;\n\n\t\t\t\t\tcase 2: coord.set( - col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( - col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( - col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accumulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n\t/**\n\t * Creates a light probe from the given (radiance) environment map.\n\t * The method expects that the environment map is represented as a cube render target.\n\t *\n\t * The cube render target must be in RGBA so `cubeRenderTarget.texture.format` must be\n\t * set to {@link RGBAFormat}.\n\t *\n\t * @async\n\t * @param {WebGPURenderer|WebGLRenderer} renderer - The renderer.\n\t * @param {CubeRenderTarget|WebGLCubeRenderTarget} cubeRenderTarget - The environment map.\n\t * @return {Promise<LightProbe>} A Promise that resolves with the created light probe.\n\t */\n\tstatic async fromCubeRenderTarget( renderer, cubeRenderTarget ) {\n\n\t\tconst flip = renderer.coordinateSystem === WebGLCoordinateSystem ? - 1 : 1;\n\n\t\t// The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tconst dataType = cubeRenderTarget.texture.type;\n\t\tconst imageWidth = cubeRenderTarget.width; // assumed to be square\n\n\t\tlet data;\n\n\t\tif ( renderer.isWebGLRenderer ) {\n\n\t\t\tif ( dataType === FloatType ) {\n\n\t\t\t\tdata = new Float32Array( imageWidth * imageWidth * 4 );\n\n\t\t\t} else if ( dataType === HalfFloatType ) {\n\n\t\t\t\tdata = new Uint16Array( imageWidth * imageWidth * 4 );\n\n\t\t\t} else {\n\n\t\t\t\t// assuming UnsignedByteType\n\n\t\t\t\tdata = new Uint8Array( imageWidth * imageWidth * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tif ( renderer.isWebGLRenderer ) {\n\n\t\t\t\tawait renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tdata = await renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, 0, faceIndex );\n\n\t\t\t}\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\tlet r, g, b;\n\n\t\t\t\tif ( dataType === FloatType ) {\n\n\t\t\t\t\tr = data[ i ];\n\t\t\t\t\tg = data[ i + 1 ];\n\t\t\t\t\tb = data[ i + 2 ];\n\n\t\t\t\t} else if ( dataType === HalfFloatType ) {\n\n\t\t\t\t\tr = DataUtils.fromHalfFloat( data[ i ] );\n\t\t\t\t\tg = DataUtils.fromHalfFloat( data[ i + 1 ] );\n\t\t\t\t\tb = DataUtils.fromHalfFloat( data[ i + 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr = data[ i ] / 255;\n\t\t\t\t\tg = data[ i + 1 ] / 255;\n\t\t\t\t\tb = data[ i + 2 ] / 255;\n\n\t\t\t\t}\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeRenderTarget.texture.colorSpace );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = ( 1 - ( pixelIndex % imageWidth + 0.5 ) * pixelSize ) * flip;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( - 1 * flip, row, col * flip ); break;\n\n\t\t\t\t\tcase 1: coord.set( 1 * flip, row, - col * flip ); break;\n\n\t\t\t\t\tcase 2: coord.set( col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( - col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accumulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n}\n\nfunction convertColorToLinear( color, colorSpace ) {\n\n\tswitch ( colorSpace ) {\n\n\t\tcase SRGBColorSpace:\n\n\t\t\tcolor.convertSRGBToLinear();\n\t\t\tbreak;\n\n\t\tcase LinearSRGBColorSpace:\n\t\tcase NoColorSpace:\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tconsole.warn( 'WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.' );\n\t\t\tbreak;\n\n\t}\n\n\treturn color;\n\n}\n\nexport { LightProbeGenerator };\n"],"mappings":"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","ignoreList":[]}