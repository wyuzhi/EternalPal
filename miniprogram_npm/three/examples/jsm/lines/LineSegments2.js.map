{"version":3,"file":"node_modules/three/examples/jsm/lines/LineSegments2.js","names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","_viewport","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","attributes","instanceEnd","i","l","min","instanceCount","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","distanceTo","push","origin","object","face","faceIndex","uv","uv1","raycastScreenSpace","material","segmentCount","near","at","matrixWorldInverse","z","copy","multiplyMatrices","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","LineSegments2","constructor","color","random","super","this","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycast","raycaster","worldUnits","console","error","threshold","undefined","params","Line2","ray","sphereMargin","boxMargin","linewidth","boundingSphere","computeBoundingSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","expandByScalar","intersectsBox","onBeforeRender","renderer","uniforms","getViewport","value"],"sources":["node_modules/three/examples/jsm/lines/LineSegments2.js"],"sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A series of lines drawn between pairs of vertices.\n *\n * This adds functionality beyond {@link LineSegments}, like arbitrary line width and changing width\n * to be in world units. {@link Line2} extends this object, forming a polyline instead of individual\n * segments.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `lines/webgpu/LineSegments2.js`.\n *\n *  ```js\n * const geometry = new LineSegmentsGeometry();\n * geometry.setPositions( positions );\n * geometry.setColors( colors );\n *\n * const material = new LineMaterial( { linewidth: 5, vertexColors: true } };\n *\n * const lineSegments = new LineSegments2( geometry, material );\n * scene.add( lineSegments );\n * ```\n *\n * @augments Mesh\n * @three_import import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';\n */\nclass LineSegments2 extends Mesh {\n\n\t/**\n\t * Constructs a new wide line.\n\t *\n\t * @param {LineSegmentsGeometry} [geometry] - The line geometry.\n\t * @param {LineMaterial} [material] - The line material.\n\t */\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t/**\n\t * Computes an array of distance values which are necessary for rendering dashed lines.\n\t * For each vertex in the geometry, the method calculates the cumulative length from the\n\t * current point to the very beginning of the line.\n\t *\n\t * @return {LineSegments2} A reference to this instance.\n\t */\n\tcomputeLineDistances() {\n\n\t\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this instance.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n"],"mappings":"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","ignoreList":[]}