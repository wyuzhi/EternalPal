{"version":3,"file":"node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","names":["Box3","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","_box","_vector","LineSegmentsGeometry","constructor","super","this","isLineSegmentsGeometry","type","setIndex","setAttribute","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","instanceCount","count","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegments","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON"],"sources":["node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js"],"sourcesContent":["import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\n/**\n * A series of vertex pairs, forming line segments.\n *\n * This is used in {@link LineSegments2} to describe the shape.\n *\n * @augments InstancedBufferGeometry\n * @three_import import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';\n */\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\t/**\n\t * Constructs a new line segments geometry.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 transformation matrix to the geometry.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {LineSegmentsGeometry} A reference to this instance.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given line positions for this geometry. The length must be a multiple of six since\n\t * each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.\n\t *\n\t * @param {Float32Array|Array<number>} array - The position data to set.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\tthis.instanceCount = this.attributes.instanceStart.count;\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given line colors for this geometry. The length must be a multiple of six since\n\t * each line segment is defined by a start end color in the pattern `(rgb rgb)`.\n\t *\n\t * @param {Float32Array|Array<number>} array - The position data to set.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups this line segments geometry from the given wireframe geometry.\n\t *\n\t * @param {WireframeGeometry} geometry - The geometry that should be used as a data source for this geometry.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups this line segments geometry from the given edges geometry.\n\t *\n\t * @param {EdgesGeometry} geometry - The geometry that should be used as a data source for this geometry.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups this line segments geometry from the given mesh.\n\t *\n\t * @param {Mesh} mesh - The mesh geometry that should be used as a data source for this geometry.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups this line segments geometry from the given line segments.\n\t *\n\t * @param {LineSegments} lineSegments - The line segments that should be used as a data source for this geometry.\n\t * Assumes the source geometry is not using indices.\n\t * @return {LineSegmentsGeometry} A reference to this geometry.\n\t */\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n"],"mappings":"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","ignoreList":[]}