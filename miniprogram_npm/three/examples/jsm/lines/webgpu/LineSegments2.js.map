{"version":3,"file":"node_modules/three/examples/jsm/lines/webgpu/LineSegments2.js","names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","Line2NodeMaterial","Vector2","LineSegmentsGeometry","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_viewport","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","attributes","instanceEnd","i","l","min","instanceCount","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","distanceTo","push","origin","object","face","faceIndex","uv","uv1","raycastScreenSpace","_resolution","segmentCount","near","at","matrixWorldInverse","z","copy","multiplyMatrices","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","LineSegments2","constructor","material","color","random","super","this","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","onBeforeRender","renderer","getViewport","raycast","raycaster","worldUnits","console","error","threshold","undefined","params","Line2","ray","sphereMargin","boxMargin","linewidth","boundingSphere","computeBoundingSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","expandByScalar","intersectsBox"],"sources":["node_modules/three/examples/jsm/lines/webgpu/LineSegments2.js"],"sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4,\n\tLine2NodeMaterial,\n\tVector2\n} from 'three/webgpu';\nimport { LineSegmentsGeometry } from '../../lines/LineSegmentsGeometry.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\nconst _viewport = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst resolution = lineSegments._resolution;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A series of lines drawn between pairs of vertices.\n *\n * This adds functionality beyond {@link LineSegments}, like arbitrary line width and changing width\n * to be in world units. {@link Line2} extends this object, forming a polyline instead of individual\n * segments.\n *\n * This module can only be used with {@link WebGPURenderer}. When using {@link WebGLRenderer},\n * import the class from `lines/LineSegments2.js`.\n *\n * @augments Mesh\n * @three_import import { LineSegments2 } from 'three/addons/lines/webgpu/LineSegments2.js';\n */\nclass LineSegments2 extends Mesh {\n\n\t/**\n\t * Constructs a new wide line.\n\t *\n\t * @param {LineSegmentsGeometry} [geometry] - The line geometry.\n\t * @param {Line2NodeMaterial} [material] - The line material.\n\t */\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new Line2NodeMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t\tthis._resolution = new Vector2();\n\n\t}\n\n\t/**\n\t * Computes an array of distance values which are necessary for rendering dashed lines.\n\t * For each vertex in the geometry, the method calculates the cumulative length from the\n\t * current point to the very beginning of the line.\n\t *\n\t * @return {LineSegments2} A reference to this instance.\n\t */\n\tcomputeLineDistances() {\n\n\t\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\trenderer.getViewport( _viewport );\n\t\tthis._resolution.set( _viewport.z, _viewport.w );\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this instance.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, this._resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, this._resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n"],"mappings":"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","ignoreList":[]}