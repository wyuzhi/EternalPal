{"version":3,"file":"node_modules/three/examples/jsm/loaders/BVHLoader.js","names":["AnimationClip","Bone","FileLoader","Loader","Quaternion","QuaternionKeyframeTrack","Skeleton","Vector3","VectorKeyframeTrack","BVHLoader","constructor","manager","super","this","animateBonePositions","animateBoneRotations","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","readFrameData","data","frameTime","bone","type","keyframe","time","position","rotation","frames","push","quat","vx","vy","vz","i","channels","length","x","parseFloat","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","warn","children","readNode","lines","firstline","list","node","name","tokens","split","toUpperCase","nextLine","offset","isNaN","numChannels","parseInt","splice","line","bones","root","numFrames","readBvh","threeBones","toTHREEBone","source","add","threeClip","tracks","times","positions","rotations","j","frame","w","toTHREEAnimation","skeleton","clip"],"sources":["node_modules/three/examples/jsm/loaders/BVHLoader.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tBone,\n\tFileLoader,\n\tLoader,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeleton,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * A loader for the BVH format.\n *\n * Imports BVH files and outputs a single {@link Skeleton} and {@link AnimationClip}.\n * The loader only supports BVH files containing a single root right now.\n *\n * ```js\n * const loader = new BVHLoader();\n * const result = await loader.loadAsync( 'models/bvh/pirouette.bvh' );\n *\n * // visualize skeleton\n * const skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );\n * scene.add( result.skeleton.bones[ 0 ] );\n * scene.add( skeletonHelper );\n *\n * // play animation clip\n * mixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );\n * mixer.clipAction( result.clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';\n */\nclass BVHLoader extends Loader {\n\n\t/**\n\t * Constructs a new BVH loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether to animate bone positions or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.animateBonePositions = true;\n\n\t\t/**\n\t\t * Whether to animate bone rotations or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.animateBoneRotations = true;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded BVH asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({skeleton:Skeleton,clip:AnimationClip})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given BVH data and returns the resulting data.\n\t *\n\t * @param {string} text - The raw BVH data as a string.\n\t * @return {{skeleton:Skeleton,clip:AnimationClip}} An object representing the parsed asset.\n\t */\n\tparse( text ) {\n\n\t\t// reads a string array (lines) from a BVH file\n\t\t// and outputs a skeleton structure including motion data\n\n\t\t// returns thee root node:\n\t\t// { name: '', channels: [], children: [] }\n\t\tfunction readBvh( lines ) {\n\n\t\t\t// read model structure\n\n\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: HIERARCHY expected.' );\n\n\t\t\t}\n\n\t\t\tconst list = []; // collects flat array of all bones\n\t\t\tconst root = readNode( lines, nextLine( lines ), list );\n\n\t\t\t// read motion data\n\n\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: MOTION expected.' );\n\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tlet tokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst numFrames = parseInt( tokens[ 1 ] );\n\n\t\t\tif ( isNaN( numFrames ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read number of frames.' );\n\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst frameTime = parseFloat( tokens[ 2 ] );\n\n\t\t\tif ( isNaN( frameTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read frame time.' );\n\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor ( let i = 0; i < numFrames; i ++ ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\treadFrameData( tokens, i * frameTime, root );\n\n\t\t\t}\n\n\t\t\treturn list;\n\n\t\t}\n\n\t\t/*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n\t\tfunction readFrameData( data, frameTime, bone ) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif ( bone.type === 'ENDSITE' ) return;\n\n\t\t\t// add keyframe\n\n\t\t\tconst keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new Vector3(),\n\t\t\t\trotation: new Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push( keyframe );\n\n\t\t\tconst quat = new Quaternion();\n\n\t\t\tconst vx = new Vector3( 1, 0, 0 );\n\t\t\tconst vy = new Vector3( 0, 1, 0 );\n\t\t\tconst vz = new Vector3( 0, 0, 1 );\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor ( let i = 0; i < bone.channels.length; i ++ ) {\n\n\t\t\t\tswitch ( bone.channels[ i ] ) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.BVHLoader: Invalid channel type.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor ( let i = 0; i < bone.children.length; i ++ ) {\n\n\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t Recursively parses the HIERARCHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n\t\tfunction readNode( lines, firstline, list ) {\n\n\t\t\tconst node = { name: '', type: '', frames: [] };\n\t\t\tlist.push( node );\n\n\t\t\t// parse node type and name\n\n\t\t\tlet tokens = firstline.split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[ 1 ];\n\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\n\n\t\t\t}\n\n\t\t\tif ( nextLine( lines ) !== '{' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected opening { after type & name' );\n\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( tokens.length !== 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );\n\n\t\t\t}\n\n\t\t\tconst offset = new Vector3(\n\t\t\t\tparseFloat( tokens[ 1 ] ),\n\t\t\t\tparseFloat( tokens[ 2 ] ),\n\t\t\t\tparseFloat( tokens[ 3 ] )\n\t\t\t);\n\n\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );\n\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif ( node.type !== 'ENDSITE' ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst numChannels = parseInt( tokens[ 1 ] );\n\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\n\t\t\t\tnode.children = [];\n\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tconst line = nextLine( lines );\n\n\t\t\t\tif ( line === '}' ) {\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n\t\tfunction toTHREEBone( source, list ) {\n\n\t\t\tconst bone = new Bone();\n\t\t\tlist.push( bone );\n\n\t\t\tbone.position.add( source.offset );\n\t\t\tbone.name = source.name;\n\n\t\t\tif ( source.type !== 'ENDSITE' ) {\n\n\t\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\t/*\n\t\t\tbuilds an AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: an AnimationClip containing position and quaternion tracks\n\t\t*/\n\t\tfunction toTHREEAnimation( bones ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\tconst bone = bones[ i ];\n\n\t\t\t\tif ( bone.type === 'ENDSITE' )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// track data\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst positions = [];\n\t\t\t\tconst rotations = [];\n\n\t\t\t\tfor ( let j = 0; j < bone.frames.length; j ++ ) {\n\n\t\t\t\t\tconst frame = bone.frames[ j ];\n\n\t\t\t\t\ttimes.push( frame.time );\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\n\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\n\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\n\n\t\t\t\t\trotations.push( frame.rotation.x );\n\t\t\t\t\trotations.push( frame.rotation.y );\n\t\t\t\t\trotations.push( frame.rotation.z );\n\t\t\t\t\trotations.push( frame.rotation.w );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBonePositions ) {\n\n\t\t\t\t\ttracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBoneRotations ) {\n\n\t\t\t\t\ttracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( 'animation', - 1, tracks );\n\n\t\t}\n\n\t\t/*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n\t\tfunction nextLine( lines ) {\n\n\t\t\tlet line;\n\t\t\t// skip empty lines\n\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\n\n\t\t\treturn line;\n\n\t\t}\n\n\t\tconst scope = this;\n\n\t\tconst lines = text.split( /[\\r\\n]+/g );\n\n\t\tconst bones = readBvh( lines );\n\n\t\tconst threeBones = [];\n\t\ttoTHREEBone( bones[ 0 ], threeBones );\n\n\t\tconst threeClip = toTHREEAnimation( bones );\n\n\t\treturn {\n\t\t\tskeleton: new Skeleton( threeBones ),\n\t\t\tclip: threeClip\n\t\t};\n\n\t}\n\n}\n\nexport { BVHLoader };\n"],"mappings":"OACCA,cACAC,KACAC,WACAC,OACAC,WACAC,wBACAC,SACAC,QACAC,wBACM,QAyBP,MAAMC,kBAAkBN,OAOvB,WAAAO,CAAaC,GAEZC,MAAOD,GAQPE,KAAKC,sBAAuB,EAQ5BD,KAAKE,sBAAuB,CAE7B,CAWA,IAAAC,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQR,KAERS,EAAS,IAAIpB,WAAYmB,EAAMV,SACrCW,EAAOC,QAASF,EAAMG,MACtBF,EAAOG,iBAAkBJ,EAAMK,eAC/BJ,EAAOK,mBAAoBN,EAAMO,iBACjCN,EAAON,KAAMC,GAAK,SAAWY,GAE5B,IAECX,EAAQG,EAAMS,MAAOD,GAEtB,CAAE,MAAQE,GAEJX,EAEJA,EAASW,GAITC,QAAQC,MAAOF,GAIhBV,EAAMV,QAAQuB,UAAWjB,EAE1B,CAED,GAAGE,EAAYC,EAEhB,CAQA,KAAAU,CAAOD,GAyEN,SAASM,EAAeC,EAAMC,EAAWC,GAIxC,GAAmB,YAAdA,EAAKC,KAAqB,OAI/B,MAAMC,EAAW,CAChBC,KAAMJ,EACNK,SAAU,IAAInC,QACdoC,SAAU,IAAIvC,YAGfkC,EAAKM,OAAOC,KAAML,GAElB,MAAMM,EAAO,IAAI1C,WAEX2C,EAAK,IAAIxC,QAAS,EAAG,EAAG,GACxByC,EAAK,IAAIzC,QAAS,EAAG,EAAG,GACxB0C,EAAK,IAAI1C,QAAS,EAAG,EAAG,GAI9B,IAAM,IAAI2C,EAAI,EAAGA,EAAIZ,EAAKa,SAASC,OAAQF,IAE1C,OAASZ,EAAKa,SAAUD,IAEvB,IAAK,YACJV,EAASE,SAASW,EAAIC,WAAYlB,EAAKmB,QAAQC,QAC/C,MACD,IAAK,YACJhB,EAASE,SAASe,EAAIH,WAAYlB,EAAKmB,QAAQC,QAC/C,MACD,IAAK,YACJhB,EAASE,SAASgB,EAAIJ,WAAYlB,EAAKmB,QAAQC,QAC/C,MACD,IAAK,YACJV,EAAKa,iBAAkBZ,EAAIO,WAAYlB,EAAKmB,QAAQC,QAAWI,KAAKC,GAAK,KACzErB,EAASG,SAASmB,SAAUhB,GAC5B,MACD,IAAK,YACJA,EAAKa,iBAAkBX,EAAIM,WAAYlB,EAAKmB,QAAQC,QAAWI,KAAKC,GAAK,KACzErB,EAASG,SAASmB,SAAUhB,GAC5B,MACD,IAAK,YACJA,EAAKa,iBAAkBV,EAAIK,WAAYlB,EAAKmB,QAAQC,QAAWI,KAAKC,GAAK,KACzErB,EAASG,SAASmB,SAAUhB,GAC5B,MACD,QACCd,QAAQ+B,KAAM,0CAQjB,IAAM,IAAIb,EAAI,EAAGA,EAAIZ,EAAK0B,SAASZ,OAAQF,IAE1Cf,EAAeC,EAAMC,EAAWC,EAAK0B,SAAUd,GAIjD,CAWA,SAASe,EAAUC,EAAOC,EAAWC,GAEpC,MAAMC,EAAO,CAAEC,KAAM,GAAI/B,KAAM,GAAIK,OAAQ,IAC3CwB,EAAKvB,KAAMwB,GAIX,IAAIE,EAASJ,EAAUK,MAAO,SAEK,QAA9BD,EAAQ,GAAIE,eAAyD,SAA9BF,EAAQ,GAAIE,eAEvDJ,EAAK9B,KAAO,UACZ8B,EAAKC,KAAO,YAIZD,EAAKC,KAAOC,EAAQ,GACpBF,EAAK9B,KAAOgC,EAAQ,GAAIE,eAIE,MAAtBC,EAAUR,IAEdlC,QAAQC,MAAO,yDAMhBsC,EAASG,EAAUR,GAAQM,MAAO,SAEb,WAAhBD,EAAQ,IAEZvC,QAAQC,MAAO,6CAA+CsC,EAAQ,IAIhD,IAAlBA,EAAOnB,QAEXpB,QAAQC,MAAO,yDAIhB,MAAM0C,EAAS,IAAIpE,QAClB+C,WAAYiB,EAAQ,IACpBjB,WAAYiB,EAAQ,IACpBjB,WAAYiB,EAAQ,KAarB,IAVKK,MAAOD,EAAOtB,IAAOuB,MAAOD,EAAOlB,IAAOmB,MAAOD,EAAOjB,KAE5D1B,QAAQC,MAAO,8CAIhBoC,EAAKM,OAASA,EAIK,YAAdN,EAAK9B,KAAqB,CAE9BgC,EAASG,EAAUR,GAAQM,MAAO,SAEb,aAAhBD,EAAQ,IAEZvC,QAAQC,MAAO,kDAIhB,MAAM4C,EAAcC,SAAUP,EAAQ,IACtCF,EAAKlB,SAAWoB,EAAOQ,OAAQ,EAAGF,GAClCR,EAAKL,SAAW,EAEjB,CAIA,OAAe,CAEd,MAAMgB,EAAON,EAAUR,GAEvB,GAAc,MAATc,EAEJ,OAAOX,EAIPA,EAAKL,SAASnB,KAAMoB,EAAUC,EAAOc,EAAMZ,GAI7C,CAED,CAmGA,SAASM,EAAUR,GAElB,IAAIc,EAEJ,KAAmD,KAAzCA,EAAOd,EAAMX,QAAQC,QAASJ,SAExC,OAAO4B,CAER,CAEA,MAAM3D,EAAQR,KAIRoE,EA3VN,SAAkBf,GAIU,cAAtBQ,EAAUR,IAEdlC,QAAQC,MAAO,wCAIhB,MAAMmC,EAAO,GACPc,EAAOjB,EAAUC,EAAOQ,EAAUR,GAASE,GAItB,WAAtBM,EAAUR,IAEdlC,QAAQC,MAAO,qCAMhB,IAAIsC,EAASG,EAAUR,GAAQM,MAAO,SACtC,MAAMW,EAAYL,SAAUP,EAAQ,IAE/BK,MAAOO,IAEXnD,QAAQC,MAAO,qDAMhBsC,EAASG,EAAUR,GAAQM,MAAO,SAClC,MAAMnC,EAAYiB,WAAYiB,EAAQ,IAEjCK,MAAOvC,IAEXL,QAAQC,MAAO,+CAMhB,IAAM,IAAIiB,EAAI,EAAGA,EAAIiC,EAAWjC,IAE/BqB,EAASG,EAAUR,GAAQM,MAAO,SAClCrC,EAAeoC,EAAQrB,EAAIb,EAAW6C,GAIvC,OAAOd,CAER,CAqScgB,CAFAvD,EAAK2C,MAAO,aAIpBa,EAAa,IAzGnB,SAASC,EAAaC,EAAQnB,GAE7B,MAAM9B,EAAO,IAAIrC,KAMjB,GALAmE,EAAKvB,KAAMP,GAEXA,EAAKI,SAAS8C,IAAKD,EAAOZ,QAC1BrC,EAAKgC,KAAOiB,EAAOjB,KAEE,YAAhBiB,EAAOhD,KAEX,IAAM,IAAIW,EAAI,EAAGA,EAAIqC,EAAOvB,SAASZ,OAAQF,IAE5CZ,EAAKkD,IAAKF,EAAaC,EAAOvB,SAAUd,GAAKkB,IAM/C,OAAO9B,CAER,CAsFAgD,CAAaL,EAAO,GAAKI,GAEzB,MAAMI,EA/EN,SAA2BR,GAE1B,MAAMS,EAAS,GAIf,IAAM,IAAIxC,EAAI,EAAGA,EAAI+B,EAAM7B,OAAQF,IAAO,CAEzC,MAAMZ,EAAO2C,EAAO/B,GAEpB,GAAmB,YAAdZ,EAAKC,KACT,SAID,MAAMoD,EAAQ,GACRC,EAAY,GACZC,EAAY,GAElB,IAAM,IAAIC,EAAI,EAAGA,EAAIxD,EAAKM,OAAOQ,OAAQ0C,IAAO,CAE/C,MAAMC,EAAQzD,EAAKM,OAAQkD,GAE3BH,EAAM9C,KAAMkD,EAAMtD,MAKlBmD,EAAU/C,KAAMkD,EAAMrD,SAASW,EAAIf,EAAKqC,OAAOtB,GAC/CuC,EAAU/C,KAAMkD,EAAMrD,SAASe,EAAInB,EAAKqC,OAAOlB,GAC/CmC,EAAU/C,KAAMkD,EAAMrD,SAASgB,EAAIpB,EAAKqC,OAAOjB,GAE/CmC,EAAUhD,KAAMkD,EAAMpD,SAASU,GAC/BwC,EAAUhD,KAAMkD,EAAMpD,SAASc,GAC/BoC,EAAUhD,KAAMkD,EAAMpD,SAASe,GAC/BmC,EAAUhD,KAAMkD,EAAMpD,SAASqD,EAEhC,CAEK3E,EAAMP,sBAEV4E,EAAO7C,KAAM,IAAIrC,oBAAqB8B,EAAKgC,KAAO,YAAaqB,EAAOC,IAIlEvE,EAAMN,sBAEV2E,EAAO7C,KAAM,IAAIxC,wBAAyBiC,EAAKgC,KAAO,cAAeqB,EAAOE,GAI9E,CAEA,OAAO,IAAI7F,cAAe,aAAe,EAAG0F,EAE7C,CAwBkBO,CAAkBhB,GAEpC,MAAO,CACNiB,SAAU,IAAI5F,SAAU+E,GACxBc,KAAMV,EAGR,SAIQhF","ignoreList":[]}