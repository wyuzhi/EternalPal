{"version":3,"file":"node_modules/three/examples/jsm/loaders/ColladaLoader.js","names":["AmbientLight","AnimationClip","Bone","BufferGeometry","ClampToEdgeWrapping","Color","ColorManagement","DirectionalLight","DoubleSide","FileLoader","Float32BufferAttribute","FrontSide","Group","Line","LineBasicMaterial","LineSegments","Loader","LoaderUtils","MathUtils","Matrix4","Mesh","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","OrthographicCamera","PerspectiveCamera","PointLight","Quaternion","QuaternionKeyframeTrack","RepeatWrapping","Scene","Skeleton","SkinnedMesh","SpotLight","TextureLoader","Vector2","Vector3","VectorKeyframeTrack","SRGBColorSpace","TGALoader","ColladaLoader","load","url","onLoad","onProgress","onError","scope","this","path","extractUrlBase","loader","manager","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","isEmpty","object","Object","keys","parseAssetUnit","undefined","hasAttribute","getAttribute","parseAssetUpAxis","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimationSampler","inputs","nodeType","id","semantic","parseAnimationChannel","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","channels","samplers","sources","target","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","createKeyframeTracks","buildAnimationChannel","getAnimation","animations","inputSource","outputSource","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","sort","ascending","transformAnimationData","a","b","prepareAnimationData","uuid","position","scale","quaternion","animation","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","prev","next","getPrev","getNext","interpolate","createMissingKeyframes","key","buildAnimationClip","duration","end","start","animationTracks","getAnimationClip","clips","parseSkin","bindShapeMatrix","parseSource","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","skin","BONE_LIMIT","weights","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","buildSkin","skinIndices","skinWeights","buildImage","init_from","getImage","images","parseEffectProfileCOMMON","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","buildMaterial","effect","effects","profile","material","getTexture","textureObject","colorSpace","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","getTextureLoader","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","colorSpaceToWorking","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","materials","parseCameraOptics","parseCameraTechnique","parseCameraParameters","buildCamera","camera","optics","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","cameras","parseLightTechnique","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","lights","accessor","parseGeometryVertices","parseGeometryPrimitive","primitive","count","hasUV","inputname","max","p","checkUVCoordinates","primitives","uvsNeedsFix","buildGeometry","vertices","groupedPrimitives","groupPrimitives","primitiveType","buildGeometryType","normal","uv","uv1","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","isColor","pushVector","sourceStride","sourceArray","startIndex","tempColor","setRGB","r","c","kl","getGeometry","buildKinematicsModel","parseKinematicsTechniqueCommon","parseKinematicsJoint","links","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsRigidBody","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsBindJointAxis","param","tmpJointIndex","jointIndex","buildKinematicsScene","buildTransformList","collada","querySelector","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","multiply","makeTranslation","makeRotationAxis","log","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","visualScenes","children","bone","processed","bones","boneInverses","traverse","isBone","buildNode","objects","instanceCamera","controller","controllers","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","DEFAULT_MATERIAL_NAME","resolveMaterialBinding","instanceMaterials","isMeshPhongMaterial","isMeshLambertMaterial","lineMaterial","skinning","attributes","buildVisualScene","group","getVisualScene","scene","DOMParser","parseFromString","parserError","errorElement","errorText","result","stack","Node","TEXT_NODE","parserErrorToText","version","debug","asset","unit","upAxis","parseAsset","resourcePath","setCrossOrigin","crossOrigin","kinematics","kinematicsModels","physicsModels","kinematicsScenes","parseAnimation","hasChildren","generateUUID","mesh","element","prepareNodes","rigidBodies","bindJointAxis","setupAnimations","kinematicsModelId","kinematicsSceneId","visualSceneId","kinematicsModel","kinematicsScene","getKinematicsScene","visualScene","jointMap","targetElement","parentVisualElement","parentElement","connect","visualElement","visualElementName","m0","getJointValue","jointData","setJointValue","setupKinematics","parseScene","rotation","PI","multiplyScalar"],"sources":["node_modules/three/examples/jsm/loaders/ColladaLoader.js"],"sourcesContent":["import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tScene,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTextureLoader,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace\n} from 'three';\nimport { TGALoader } from '../loaders/TGALoader.js';\n\n/**\n * A loader for the Collada format.\n *\n * The Collada format is very complex so this loader only supports a subset of what\n * is defined in the [official specification]{@link https://www.khronos.org/files/collada_spec_1_5.pdf}.\n *\n * Assets with a Z-UP coordinate system are transformed it into Y-UP by a simple rotation.\n * The vertex data are not converted.\n *\n * ```js\n * const loader = new ColladaLoader();\n *\n * const result = await loader.loadAsync( './models/collada/elf/elf.dae' );\n * scene.add( result.scene );\n * ```\n *\n * @augments Loader\n * @three_import import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';\n */\nclass ColladaLoader extends Loader {\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded Collada asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({scene:Group,animations:Array<AnimationClip>,kinematics:Object})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given Collada data and returns a result object holding the parsed scene,\n\t * an array of animation clips and kinematics.\n\t *\n\t * @param {string} text - The raw Collada data as a string.\n\t * @param {string} path - The asset path.\n\t * @return {{scene:Group,animations:Array<AnimationClip>,kinematics:Object}} An object representing the parsed asset.\n\t */\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unique assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new Vector3();\n\t\tconst scale = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// process skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only proceed the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechniqueBump( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject, colorSpace = null ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is available\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( colorSpace !== null ) {\n\n\t\t\t\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tColorManagement.colorSpaceToWorking( material.color, SRGBColorSpace );\n\t\t\tif ( material.specular ) ColorManagement.colorSpaceToWorking( material.specular, SRGBColorSpace );\n\t\t\tif ( material.emissive ) ColorManagement.colorSpaceToWorking( material.emissive, SRGBColorSpace );\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\n\t\t\tif ( technique.extra !== undefined && technique.extra.technique !== undefined ) {\n\n\t\t\t\tconst techniques = technique.extra.technique;\n\n\t\t\t\tfor ( const k in techniques ) {\n\n\t\t\t\t\tconst v = techniques[ k ];\n\n\t\t\t\t\tswitch ( k ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tmaterial.side = ( v === 1 ? DoubleSide : FrontSide );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tmaterial.normalMap = getTexture( v.texture );\n\t\t\t\t\t\t\tmaterial.normalScale = new Vector2( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new Color().fromArray( array );\n\t\t\t\t\t\tColorManagement.colorSpaceToWorking( data.color, SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv1 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv1.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv1.array );\n\t\t\t\t\t\t\tuv1.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv1.array.length > 0 ) geometry.setAttribute( 'uv1', new Float32BufferAttribute( uv1.array, uv1.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array, isColor = false ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isColor ) {\n\n\t\t\t\t\t// convert the vertex colors from srgb to linear if present\n\t\t\t\t\tconst startIndex = array.length - sourceStride - 1;\n\t\t\t\t\ttempColor.setRGB(\n\t\t\t\t\t\tarray[ startIndex + 0 ],\n\t\t\t\t\t\tarray[ startIndex + 1 ],\n\t\t\t\t\t\tarray[ startIndex + 2 ],\n\t\t\t\t\t\tSRGBColorSpace\n\t\t\t\t\t);\n\n\t\t\t\t\tarray[ startIndex + 0 ] = tempColor.r;\n\t\t\t\t\tarray[ startIndex + 1 ] = tempColor.g;\n\t\t\t\t\tarray[ startIndex + 2 ] = tempColor.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new Matrix4();\n\t\tconst vector = new Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new MeshBasicMaterial( {\n\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\tcolor: 0xff00ff\n\t\t} );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.\n\n\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\t\t\tconst lineMaterial = new LineBasicMaterial();\n\n\t\t\t\t\t\t\t// copy compatible properties\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\t\t\t\tlineMaterial.opacity = material.opacity;\n\t\t\t\t\t\t\tlineMaterial.transparent = material.transparent;\n\n\t\t\t\t\t\t\t// replace material\n\n\t\t\t\t\t\t\tmaterials[ i ] = lineMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push( ...node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.debug( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst tempColor = new Color();\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.' );\n\t\t\tscene.rotation.set( - Math.PI / 2, 0, 0 );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\nexport { ColladaLoader };\n"],"mappings":"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","ignoreList":[]}