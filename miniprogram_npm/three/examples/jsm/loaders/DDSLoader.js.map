{"version":3,"file":"node_modules/three/examples/jsm/loaders/DDSLoader.js","names":["CompressedTextureLoader","RGBAFormat","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_S3TC_DXT1_Format","RGB_BPTC_SIGNED_Format","RGB_BPTC_UNSIGNED_Format","DDSLoader","constructor","manager","super","parse","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","fourCCToInt32","value","charCodeAt","loadARGBMip","dataOffset","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","loadRGBMip","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","FOURCC_DX10","header","Int32Array","console","error","blockBytes","fourCC","isRGBAUncompressed","isRGBUncompressed","extendedHeaderLengthInt","dxgiFormat","String","fromCharCode","Math","max","caps2","isCubemap","faces","face","i","length","mipmap","data","push"],"sources":["node_modules/three/examples/jsm/loaders/DDSLoader.js"],"sourcesContent":["import {\n\tCompressedTextureLoader,\n\tRGBAFormat,\n\tRGBA_S3TC_DXT3_Format,\n\tRGBA_S3TC_DXT5_Format,\n\tRGB_ETC1_Format,\n\tRGB_S3TC_DXT1_Format,\n\tRGB_BPTC_SIGNED_Format,\n\tRGB_BPTC_UNSIGNED_Format\n} from 'three';\n\n/**\n * A loader for the S3TC texture compression format.\n *\n * ```js\n * const loader = new DDSLoader();\n *\n * const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );\n * map.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments CompressedTextureLoader\n * @three_import import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';\n */\nclass DDSLoader extends CompressedTextureLoader {\n\n\t/**\n\t * Constructs a new DDS loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Parses the given S3TC texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {boolean} loadMipmaps - Whether to load mipmaps or not.\n\t * @return {CompressedTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tconst DDS_MAGIC = 0x20534444;\n\n\t\t// const DDSD_CAPS = 0x1;\n\t\t// const DDSD_HEIGHT = 0x2;\n\t\t// const DDSD_WIDTH = 0x4;\n\t\t// const DDSD_PITCH = 0x8;\n\t\t// const DDSD_PIXELFORMAT = 0x1000;\n\t\tconst DDSD_MIPMAPCOUNT = 0x20000;\n\t\t// const DDSD_LINEARSIZE = 0x80000;\n\t\t// const DDSD_DEPTH = 0x800000;\n\n\t\t// const DDSCAPS_COMPLEX = 0x8;\n\t\t// const DDSCAPS_MIPMAP = 0x400000;\n\t\t// const DDSCAPS_TEXTURE = 0x1000;\n\n\t\tconst DDSCAPS2_CUBEMAP = 0x200;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n\t\t// const DDSCAPS2_VOLUME = 0x200000;\n\n\t\t// const DDPF_ALPHAPIXELS = 0x1;\n\t\t// const DDPF_ALPHA = 0x2;\n\t\t// const DDPF_FOURCC = 0x4;\n\t\t// const DDPF_RGB = 0x40;\n\t\t// const DDPF_YUV = 0x200;\n\t\t// const DDPF_LUMINANCE = 0x20000;\n\n\t\tconst DXGI_FORMAT_BC6H_UF16 = 95;\n\t\tconst DXGI_FORMAT_BC6H_SF16 = 96;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t);\n\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 4;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( dataLength );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst a = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tfunction loadRGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 3;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( width * height * 4 );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = 255; dst ++; //a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tconst FOURCC_DXT1 = fourCCToInt32( 'DXT1' );\n\t\tconst FOURCC_DXT3 = fourCCToInt32( 'DXT3' );\n\t\tconst FOURCC_DXT5 = fourCCToInt32( 'DXT5' );\n\t\tconst FOURCC_ETC1 = fourCCToInt32( 'ETC1' );\n\t\tconst FOURCC_DX10 = fourCCToInt32( 'DX10' );\n\n\t\tconst headerLengthInt = 31; // The header length in 32 bit ints\n\t\tconst extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tconst off_magic = 0;\n\n\t\tconst off_size = 1;\n\t\tconst off_flags = 2;\n\t\tconst off_height = 3;\n\t\tconst off_width = 4;\n\n\t\tconst off_mipmapCount = 7;\n\n\t\t// const off_pfFlags = 20;\n\t\tconst off_pfFourCC = 21;\n\t\tconst off_RGBBitCount = 22;\n\t\tconst off_RBitMask = 23;\n\t\tconst off_GBitMask = 24;\n\t\tconst off_BBitMask = 25;\n\t\tconst off_ABitMask = 26;\n\n\t\t// const off_caps = 27;\n\t\tconst off_caps2 = 28;\n\t\t// const off_caps3 = 29;\n\t\t// const off_caps4 = 30;\n\n\t\t// If fourCC = DX10, the extended header starts after 32\n\t\tconst off_dxgiFormat = 0;\n\n\t\t// Parse header\n\n\t\tconst header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tlet blockBytes;\n\n\t\tconst fourCC = header[ off_pfFourCC ];\n\n\t\tlet isRGBAUncompressed = false;\n\t\tlet isRGBUncompressed = false;\n\n\t\tlet dataOffset = header[ off_size ] + 4;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_ETC1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DX10:\n\n\t\t\t\tdataOffset += extendedHeaderLengthInt * 4;\n\t\t\t\tconst extendedHeader = new Int32Array( buffer, ( headerLengthInt + 1 ) * 4, extendedHeaderLengthInt );\n\t\t\t\tconst dxgiFormat = extendedHeader[ off_dxgiFormat ];\n\t\t\t\tswitch ( dxgiFormat ) {\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_SF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_SIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_UF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_UNSIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else if ( header[ off_RGBBitCount ] === 24\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff ) {\n\n\t\t\t\t    \tisRGBUncompressed = true;\n                    \t\t\tblockBytes = 64;\n                    \t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\n\t\t\t\t}\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\tconst caps2 = header[ off_caps2 ];\n\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\tif ( dds.isCubemap && (\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t) ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\t// Extract mipmaps buffers\n\n\t\tconst faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\tlet width = dds.width;\n\t\t\tlet height = dds.height;\n\n\t\t\tfor ( let i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tlet byteArray, dataLength;\n\n\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = byteArray.length;\n\n\t\t\t\t} else if ( isRGBUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadRGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = width * height * 3;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tbyteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t}\n\n\t\t\t\tconst mipmap = { 'data': byteArray, 'width': width, 'height': height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dds;\n\n\t}\n\n}\n\nexport { DDSLoader };\n"],"mappings":"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","ignoreList":[]}