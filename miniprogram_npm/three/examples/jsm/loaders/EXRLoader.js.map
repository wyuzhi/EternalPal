{"version":3,"file":"node_modules/three/examples/jsm/loaders/EXRLoader.js","names":["DataTextureLoader","DataUtils","FloatType","HalfFloatType","LinearFilter","LinearSRGBColorSpace","RedFormat","RGFormat","RGBAFormat","fflate","EXRLoader","constructor","manager","super","this","type","outputFormat","parse","buffer","USHORT_RANGE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","logBase","Math","pow","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","ni","im","iM","hcode","p","value","Error","zerun","i","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","n","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufUncompress","inDataView","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","len","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctChannelDecode","channelIndex","rowPtrs","channelData","acBuffer","dcBuffer","dataView","cd","width","height","numBlocksX","ceil","numBlocksY","numFullBlocksX","leftoverX","leftoverY","currAcComp","currDcComp","dctData","Float32Array","halfZigBlock","Uint16Array","rowBlock","blocky","maxY","blockx","fill","unRleAC","unZigZag","dctInverse","convertToHalf","y","offset","src","x","setUint16","decoded","acValue","dctComp","dst","decodeFloat16","data","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","csc709Inverse","cb","cr","idx","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","unzlibSync","uncompressPIZ","columns","lines","inputChannels","bitmap","outBufferEnd","pizChannelData","il","minNonZero","parseUint16","maxNonZero","parseUint8","lut","maxValue","k","reverseLutFromBitmap","start","nData","applyLut","tmpOffset","cp","end","set","uncompressPXR","byteSize","totalBytes","ArrayBuffer","tmpBufferEnd","writePtr","ptr","pixel","pixelType","setUint32","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","index","Int8Array","channels","channel","pLinear","cscSet","rule","rleBuffer","zlibInfo","rowOffsets","chan","undefined","comp","maxX","halfRow","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseInt32","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseEnvmap","xSize","ySize","modes","levelMode","roundingMode","parseTiledesc","parseLineOrder","parseV2f","parseV3f","parseRational","parseTimecode","calculateTileLevels","tiledesc","w","num","mode","log2","roundLog2","max","calculateTiles","dataSize","tiles","parseTiles","EXRDecoder","tile","tileCount","tileX","tileY","startX","blockWidth","startY","blockHeight","bytesBlockLine","uncompress","line","lineOffset","channelID","lOff","channelByteOffsets","cOff","decodeChannels","outLineOffset","outLineWidth","outIndex","outputChannels","byteArray","getter","parseScanline","scanlineBlockIdx","dataWindow","bytesPerLine","line_y","scan_y","true_y","scanOrder","bufferDataView","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeValue","console","warn","error","parseHeader","outputType","shouldExpand","format","colorSpace","fillAlpha","invalidOutput","R","G","B","Y","A","byteOffset","lineOrder","numXLevels","numXTiles","numYTiles","bind","blockCount","setupDecoder","header","setDataType","setOutputFormat","load","url","onLoad","onProgress","onError","texture","texData","minFilter","magFilter","generateMipmaps","flipY"],"sources":["node_modules/three/examples/jsm/loaders/EXRLoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace,\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n// Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n// implementation, so I have preserved their copyright notices.\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n\n/**\n * A loader for the OpenEXR texture format.\n *\n * `EXRLoader` currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * ```js\n * const loader = new EXRLoader();\n * const texture = await loader.loadAsync( 'textures/memorial.exr' );\n * ```\n *\n * @augments DataTextureLoader\n * @three_import import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n */\nclass EXRLoader extends DataTextureLoader {\n\n\t/**\n\t * Constructs a new EXR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t\t/**\n\t\t * Texture output format.\n\t\t *\n\t\t * @type {(RGBAFormat|RGFormat|RedFormat)}\n\t\t * @default RGBAFormat\n\t\t */\n\t\tthis.outputFormat = RGBAFormat;\n\n\t}\n\n\t/**\n\t * Parses the given EXR texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @return {DataTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer ) {\n\n\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\tconst NBITS = 16;\n\t\tconst A_OFFSET = 1 << ( NBITS - 1 );\n\t\tconst MOD_MASK = ( 1 << NBITS ) - 1;\n\n\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\tconst ULONG_SIZE = 8;\n\t\tconst FLOAT32_SIZE = 4;\n\t\tconst INT32_SIZE = 4;\n\t\tconst INT16_SIZE = 2;\n\t\tconst INT8_SIZE = 1;\n\n\t\tconst STATIC_HUFFMAN = 0;\n\t\tconst DEFLATE = 1;\n\n\t\tconst UNKNOWN = 0;\n\t\tconst LOSSY_DCT = 1;\n\t\tconst RLE = 2;\n\n\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\n\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\tlet k = 0;\n\n\t\t\tfor ( let i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst n = k - 1;\n\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\treturn n;\n\n\t\t}\n\n\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\tfor ( let i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\thdec[ i ] = {};\n\t\t\t\thdec[ i ].len = 0;\n\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\thdec[ i ].p = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t}\n\n\t\t\tlc -= nBits;\n\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\tgetBitsReturn.c = c;\n\t\t\tgetBitsReturn.lc = lc;\n\n\t\t}\n\n\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\tfor ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\tlet c = 0;\n\n\t\t\tfor ( let i = 58; i > 0; -- i ) {\n\n\t\t\t\tconst nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\tc = nc;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\tconst l = hcode[ i ];\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {\n\n\t\t\tconst p = inOffset;\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\tconst l = getBitsReturn.l;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\thcode[ im ] = l;\n\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\tlet zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\tlet zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t}\n\n\t\tfunction hufLength( code ) {\n\n\t\t\treturn code & 63;\n\n\t\t}\n\n\t\tfunction hufCode( code ) {\n\n\t\t\treturn code >> 6;\n\n\t\t}\n\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tconst c = hufCode( hcode[ im ] );\n\t\t\t\tconst l = hufLength( hcode[ im ] );\n\n\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\tconst pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\tconst p = pl.p;\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\tfor ( let i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\tlet plOffset = 0;\n\n\t\t\t\t\tfor ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\tconst pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\tlc += 8;\n\n\t\t\tgetCharReturn.c = c;\n\t\t\tgetCharReturn.lc = lc;\n\n\t\t}\n\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\tif ( po == rlc ) {\n\n\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= 8;\n\n\t\t\t\tlet cs = ( c >> lc );\n\t\t\t\tcs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t}\n\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tgetCodeReturn.c = c;\n\t\t\tgetCodeReturn.lc = lc;\n\n\t\t}\n\n\t\tfunction UInt16( value ) {\n\n\t\t\treturn ( value & 0xFFFF );\n\n\t\t}\n\n\t\tfunction Int16( value ) {\n\n\t\t\tconst ref = UInt16( value );\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t}\n\n\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\tfunction wdec14( l, h ) {\n\n\t\t\tconst ls = Int16( l );\n\t\t\tconst hs = Int16( h );\n\n\t\t\tconst hi = hs;\n\t\t\tconst ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\tconst as = ai;\n\t\t\tconst bs = ai - hi;\n\n\t\t\twdec14Return.a = as;\n\t\t\twdec14Return.b = bs;\n\n\t\t}\n\n\t\tfunction wdec16( l, h ) {\n\n\t\t\tconst m = UInt16( l );\n\t\t\tconst d = UInt16( h );\n\n\t\t\tconst bb = ( m - ( d >> 1 ) ) & MOD_MASK;\n\t\t\tconst aa = ( d + bb - A_OFFSET ) & MOD_MASK;\n\n\t\t\twdec14Return.a = aa;\n\t\t\twdec14Return.b = bb;\n\n\t\t}\n\n\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {\n\n\t\t\tconst w14 = mx < ( 1 << 14 );\n\t\t\tconst n = ( nx > ny ) ? ny : nx;\n\t\t\tlet p = 1;\n\t\t\tlet p2;\n\t\t\tlet py;\n\n\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\tp >>= 1;\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\n\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\tpy = 0;\n\t\t\t\tconst ey = py + oy * ( ny - p2 );\n\t\t\t\tconst oy1 = oy * p;\n\t\t\t\tconst oy2 = oy * p2;\n\t\t\t\tconst ox1 = ox * p;\n\t\t\t\tconst ox2 = ox * p2;\n\t\t\t\tlet i00, i01, i10, i11;\n\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\t\t\t\t\t\tconst p10 = px + oy1;\n\t\t\t\t\t\tconst p11 = p10 + ox1;\n\n\t\t\t\t\t\tif ( w14 ) {\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\tconst p10 = px + oy1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t}\n\n\t\t\treturn py;\n\n\t\t}\n\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\t\t\tconst outBufferEndOffset = no;\n\t\t\tconst inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\tconst index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\tconst pl = decodingTable[ index ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet j;\n\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\tconst l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst i = ( 8 - ni ) & 7;\n\n\t\t\tc >>= i;\n\t\t\tlc -= i;\n\n\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\tconst pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\n\n\t\t\tconst outOffset = { value: 0 };\n\t\t\tconst initialInOffset = inOffset.value;\n\n\t\t\tconst im = parseUint32( inDataView, inOffset );\n\t\t\tconst iM = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tconst nBits = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with HUF_ENCSIZE' );\n\n\t\t\t}\n\n\t\t\tconst freq = new Array( HUF_ENCSIZE );\n\t\t\tconst hdec = new Array( HUF_DECSIZE );\n\n\t\t\thufClearDecTable( hdec );\n\n\t\t\tconst ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\thufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );\n\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with hufUncompress' );\n\n\t\t\t}\n\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\thufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t}\n\n\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\tfor ( let i = 0; i < nData; ++ i ) {\n\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction predictor( source ) {\n\n\t\t\tfor ( let t = 1; t < source.length; t ++ ) {\n\n\t\t\t\tconst d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\tsource[ t ] = d;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\tlet t1 = 0;\n\t\t\tlet t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\tlet s = 0;\n\t\t\tconst stop = source.length - 1;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction decodeRunLength( source ) {\n\n\t\t\tlet size = source.byteLength;\n\t\t\tconst out = new Array();\n\t\t\tlet p = 0;\n\n\t\t\tconst reader = new DataView( source );\n\n\t\t\twhile ( size > 0 ) {\n\n\t\t\t\tconst l = reader.getInt8( p ++ );\n\n\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\tconst count = - l;\n\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst count = l;\n\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\tconst value = reader.getUint8( p ++ );\n\n\t\t\t\t\tfor ( let i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn out;\n\n\t\t}\n\n\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\tlet dataView = new DataView( outBuffer.buffer );\n\n\t\t\tconst width = channelData[ cscSet.idx[ 0 ] ].width;\n\t\t\tconst height = channelData[ cscSet.idx[ 0 ] ].height;\n\n\t\t\tconst numComp = 3;\n\n\t\t\tconst numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\tconst numBlocksX = Math.ceil( width / 8.0 );\n\t\t\tconst numBlocksY = Math.ceil( height / 8.0 );\n\t\t\tconst leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\tconst leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\tconst currAcComp = { value: 0 };\n\t\t\tconst currDcComp = new Array( numComp );\n\t\t\tconst dctData = new Array( numComp );\n\t\t\tconst halfZigBlock = new Array( numComp );\n\t\t\tconst rowBlock = new Array( numComp );\n\t\t\tconst rowOffsets = new Array( numComp );\n\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\n\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\n\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\n\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\n\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\n\n\t\t\t}\n\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\tlet maxY = 8;\n\n\t\t\t\tif ( blocky == numBlocksY - 1 )\n\t\t\t\t\tmaxY = leftoverY;\n\n\t\t\t\tlet maxX = 8;\n\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\tif ( blockx == numBlocksX - 1 )\n\t\t\t\t\t\tmaxX = leftoverX;\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\n\n\t\t\t\t\t\t// set block DC component\n\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\n\t\t\t\t\t\t// set block AC components\n\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\n\n\t\t\t\t\t\t// UnZigZag block to float\n\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\n\t\t\t\t\t\t// decode float dct\n\t\t\t\t\t\tdctInverse( dctData[ comp ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( numComp == 3 ) {\n\n\t\t\t\t\t\tcsc709Inverse( dctData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // blockx\n\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\t\tconst src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\n\n\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle partial X blocks\n\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\n\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\n\t\t\t\t\t\t\tconst src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // comp\n\n\t\t\t} // blocky\n\n\t\t\tconst halfRow = new Uint16Array( width );\n\t\t\tdataView = new DataView( outBuffer.buffer );\n\n\t\t\t// convert channels back to float, if needed\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\n\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\n\n\t\t\t\tfor ( let y = 0; y < height; ++ y ) {\n\n\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction lossyDctChannelDecode( channelIndex, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\tconst dataView = new DataView( outBuffer.buffer );\n\t\t\tconst cd = channelData[ channelIndex ];\n\t\t\tconst width = cd.width;\n\t\t\tconst height = cd.height;\n\n\t\t\tconst numBlocksX = Math.ceil( width / 8.0 );\n\t\t\tconst numBlocksY = Math.ceil( height / 8.0 );\n\t\t\tconst numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\tconst leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\tconst leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\tconst currAcComp = { value: 0 };\n\t\t\tlet currDcComp = 0;\n\t\t\tconst dctData = new Float32Array( 64 );\n\t\t\tconst halfZigBlock = new Uint16Array( 64 );\n\t\t\tconst rowBlock = new Uint16Array( numBlocksX * 64 );\n\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\tlet maxY = 8;\n\n\t\t\t\tif ( blocky == numBlocksY - 1 ) maxY = leftoverY;\n\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\thalfZigBlock.fill( 0 );\n\t\t\t\t\thalfZigBlock[ 0 ] = dcBuffer[ currDcComp ++ ];\n\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock );\n\t\t\t\t\tunZigZag( halfZigBlock, dctData );\n\t\t\t\t\tdctInverse( dctData );\n\t\t\t\t\tconvertToHalf( dctData, rowBlock, blockx * 64 );\n\n\t\t\t\t}\n\n\t\t\t\t// Write decoded data to output buffer\n\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\tlet offset = rowPtrs[ channelIndex ][ y ];\n\n\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\tconst src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\tfor ( let x = 0; x < 8; ++ x ) {\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * cd.type, rowBlock[ src + x ], true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toffset += 8 * INT16_SIZE * cd.type;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( numBlocksX != numFullBlocksX ) {\n\n\t\t\t\t\t\tconst src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\tfor ( let x = 0; x < leftoverX; ++ x ) {\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * cd.type, rowBlock[ src + x ], true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcd.decoded = true;\n\n\t\t}\n\n\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\n\n\t\t\tlet acValue;\n\t\t\tlet dctComp = 1;\n\n\t\t\twhile ( dctComp < 64 ) {\n\n\t\t\t\tacValue = acBuffer[ currAcComp.value ];\n\n\t\t\t\tif ( acValue == 0xff00 ) {\n\n\t\t\t\t\tdctComp = 64;\n\n\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\n\n\t\t\t\t\tdctComp += acValue & 0xff;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\n\t\t\t\t\tdctComp ++;\n\n\t\t\t\t}\n\n\t\t\t\tcurrAcComp.value ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unZigZag( src, dst ) {\n\n\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\n\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\n\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\n\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\n\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\n\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\n\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\n\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\n\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\n\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\n\n\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\n\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\n\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\n\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\n\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\n\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\n\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\n\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\n\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\n\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\n\n\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\n\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\n\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\n\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\n\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\n\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\n\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\n\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\n\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\n\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\n\n\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\n\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\n\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\n\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\n\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\n\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\n\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\n\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\n\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\n\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\n\n\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\n\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\n\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\n\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\n\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\n\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\n\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\n\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\n\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\n\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\n\n\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\n\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\n\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\n\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\n\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\n\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\n\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\n\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\n\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\n\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\n\n\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\n\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\n\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\n\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\n\n\t\t}\n\n\t\tfunction dctInverse( data ) {\n\n\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\n\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\n\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\n\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\n\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\n\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\n\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\n\n\t\t\tconst alpha = new Array( 4 );\n\t\t\tconst beta = new Array( 4 );\n\t\t\tconst theta = new Array( 4 );\n\t\t\tconst gamma = new Array( 4 );\n\n\t\t\tfor ( let row = 0; row < 8; ++ row ) {\n\n\t\t\t\tconst rowPtr = row * 8;\n\n\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\n\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t\tfor ( let column = 0; column < 8; ++ column ) {\n\n\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\n\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\n\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\n\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\n\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\n\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\n\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\n\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction csc709Inverse( data ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tconst y = data[ 0 ][ i ];\n\t\t\t\tconst cb = data[ 1 ][ i ];\n\t\t\t\tconst cr = data[ 2 ][ i ];\n\n\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\n\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\n\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction convertToHalf( src, dst, idx ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tdst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction toLinear( float ) {\n\n\t\t\tif ( float <= 1 ) {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uncompressRAW( info ) {\n\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t}\n\n\t\tfunction uncompressRLE( info ) {\n\n\t\t\tconst compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressZIP( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPIZ( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\n\t\t\tconst outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );\n\t\t\tconst bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\t// Setup channel info\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst pizChannelData = new Array( info.inputChannels.length );\n\t\t\tfor ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {\n\n\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.columns;\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\n\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t}\n\n\t\t\t// Read range compression data\n\n\t\t\tconst minNonZero = parseUint16( inDataView, inOffset );\n\t\t\tconst maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\tthrow new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );\n\n\t\t\t}\n\n\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\tfor ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Reverse LUT\n\t\t\tconst lut = new Uint16Array( USHORT_RANGE );\n\t\t\tconst maxValue = reverseLutFromBitmap( bitmap, lut );\n\n\t\t\tconst length = parseUint32( inDataView, inOffset );\n\n\t\t\t// Huffman decoding\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\n\n\t\t\t// Wavelet decoding\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\n\n\t\t\t\tconst cd = pizChannelData[ i ];\n\n\t\t\t\tfor ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\twav2Decode(\n\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\tcd.start + j,\n\t\t\t\t\t\tcd.nx,\n\t\t\t\t\t\tcd.size,\n\t\t\t\t\t\tcd.ny,\n\t\t\t\t\t\tcd.nx * cd.size,\n\t\t\t\t\t\tmaxValue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Expand the pixel data to their original range\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\t// Rearrange the pixel data into the format expected by the caller.\n\t\t\tlet tmpOffset = 0;\n\t\t\tconst tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\n\n\t\t\t\t\tconst cd = pizChannelData[ c ];\n\n\t\t\t\t\tconst n = cd.nx * cd.size;\n\t\t\t\t\tconst cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\n\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\ttmpOffset += n * INT16_SIZE;\n\t\t\t\t\tcd.end += n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPXR( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\n\n\t\t\tconst byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;\n\t\t\tconst tmpBuffer = new ArrayBuffer( byteSize );\n\t\t\tconst viewer = new DataView( tmpBuffer );\n\n\t\t\tlet tmpBufferEnd = 0;\n\t\t\tlet writePtr = 0;\n\t\t\tconst ptr = new Array( 4 );\n\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\n\n\t\t\t\t\tlet pixel = 0;\n\n\t\t\t\t\tconst type = info.inputChannels[ c ].pixelType;\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 1:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 1 ] + info.columns;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\tviewer.setUint16( writePtr, pixel, true );\n\t\t\t\t\t\t\t\twritePtr += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\n\t\t\t\t\t\t\tptr[ 2 ] = ptr[ 1 ] + info.columns;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 2 ] + info.columns;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\tviewer.setUint32( writePtr, pixel, true );\n\t\t\t\t\t\t\t\twritePtr += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn viewer;\n\n\t\t}\n\n\t\tfunction uncompressDWA( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\t\t\tconst outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );\n\n\t\t\t// Read compression header information\n\t\t\tconst dwaHeader = {\n\n\t\t\t\tversion: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\n\n\t\t\t};\n\n\t\t\tif ( dwaHeader.version < 2 )\n\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );\n\n\t\t\t// Read channel ruleset information\n\t\t\tconst channelRules = new Array();\n\t\t\tlet ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\n\n\t\t\twhile ( ruleSize > 0 ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( inDataView.buffer, inOffset );\n\t\t\t\tconst value = parseUint8( inDataView, inOffset );\n\t\t\t\tconst compression = ( value >> 2 ) & 3;\n\t\t\t\tconst csc = ( value >> 4 ) - 1;\n\t\t\t\tconst index = new Int8Array( [ csc ] )[ 0 ];\n\t\t\t\tconst type = parseUint8( inDataView, inOffset );\n\n\t\t\t\tchannelRules.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tindex: index,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcompression: compression,\n\t\t\t\t} );\n\n\t\t\t\truleSize -= name.length + 3;\n\n\t\t\t}\n\n\t\t\t// Classify channels\n\t\t\tconst channels = EXRHeader.channels;\n\t\t\tconst channelData = new Array( info.inputChannels.length );\n\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ] = {};\n\t\t\t\tconst channel = channels[ i ];\n\n\t\t\t\tcd.name = channel.name;\n\t\t\t\tcd.compression = UNKNOWN;\n\t\t\t\tcd.decoded = false;\n\t\t\t\tcd.type = channel.pixelType;\n\t\t\t\tcd.pLinear = channel.pLinear;\n\t\t\t\tcd.width = info.columns;\n\t\t\t\tcd.height = info.lines;\n\n\t\t\t}\n\n\t\t\tconst cscSet = {\n\t\t\t\tidx: new Array( 3 )\n\t\t\t};\n\n\t\t\tfor ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {\n\n\t\t\t\tconst cd = channelData[ offset ];\n\n\t\t\t\tfor ( let i = 0; i < channelRules.length; ++ i ) {\n\n\t\t\t\t\tconst rule = channelRules[ i ];\n\n\t\t\t\t\tif ( cd.name == rule.name ) {\n\n\t\t\t\t\t\tcd.compression = rule.compression;\n\n\t\t\t\t\t\tif ( rule.index >= 0 ) {\n\n\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcd.offset = offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet acBuffer, dcBuffer, rleBuffer;\n\n\t\t\t// Read DCT - AC component data\n\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\n\n\t\t\t\tswitch ( dwaHeader.acCompression ) {\n\n\t\t\t\t\tcase STATIC_HUFFMAN:\n\n\t\t\t\t\t\tacBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DEFLATE:\n\n\t\t\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tconst data = fflate.unzlibSync( compressed );\n\t\t\t\t\t\tacBuffer = new Uint16Array( data.buffer );\n\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\t// Read DCT - DC component data\n\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\n\n\t\t\t\tconst zlibInfo = {\n\t\t\t\t\tarray: info.array,\n\t\t\t\t\toffset: inOffset,\n\t\t\t\t\tsize: dwaHeader.dcCompressedSize\n\t\t\t\t};\n\t\t\t\tdcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\n\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Read RLE compressed data\n\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\n\n\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\n\t\t\t\tconst data = fflate.unzlibSync( compressed );\n\t\t\t\trleBuffer = decodeRunLength( data.buffer );\n\n\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Prepare outbuffer data offset\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst rowOffsets = new Array( channelData.length );\n\t\t\tfor ( let i = 0; i < rowOffsets.length; ++ i ) {\n\n\t\t\t\trowOffsets[ i ] = new Array();\n\n\t\t\t}\n\n\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\tfor ( let chan = 0; chan < channelData.length; ++ chan ) {\n\n\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\n\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Decode lossy DCT data if we have a valid color space conversion set with the first RGB channel present\n\t\t\tif ( cscSet.idx[ 0 ] !== undefined && channelData[ cscSet.idx[ 0 ] ] ) {\n\n\t\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t}\n\n\t\t\t// Decode other channels\n\t\t\tfor ( let i = 0; i < channelData.length; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ];\n\n\t\t\t\tif ( cd.decoded ) continue;\n\n\t\t\t\tswitch ( cd.compression ) {\n\n\t\t\t\t\tcase RLE:\n\n\t\t\t\t\t\tlet row = 0;\n\t\t\t\t\t\tlet rleOffset = 0;\n\n\t\t\t\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\t\t\tlet rowOffsetBytes = rowOffsets[ i ][ row ];\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < cd.width; ++ x ) {\n\n\t\t\t\t\t\t\t\tfor ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\n\n\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trleOffset ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trow ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LOSSY_DCT:\n\n\t\t\t\t\t\tlossyDctChannelDecode( i, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported channel compression' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( outBuffer.buffer );\n\n\t\t}\n\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\tconst uintBuffer = new Uint8Array( buffer );\n\t\t\tlet endOffset = 0;\n\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\tendOffset += 1;\n\n\t\t\t}\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + size;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseRational( dataView, offset ) {\n\n\t\t\tconst x = parseInt32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseTimecode( dataView, offset ) {\n\n\t\t\tconst x = parseUint32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseInt32( dataView, offset ) {\n\n\t\t\tconst Int32 = dataView.getInt32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Int32;\n\n\t\t}\n\n\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\tconst Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Uint32;\n\n\t\t}\n\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\tconst Uint8 = uInt8Array[ offset.value ];\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\tconst Uint8 = dataView.getUint8( offset.value );\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tconst parseInt64 = function ( dataView, offset ) {\n\n\t\t\tlet int;\n\n\t\t\tif ( 'getBigInt64' in DataView.prototype ) {\n\n\t\t\t\tint = Number( dataView.getBigInt64( offset.value, true ) );\n\n\t\t\t} else {\n\n\t\t\t\tint = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );\n\n\t\t\t}\n\n\t\t\toffset.value += ULONG_SIZE;\n\n\t\t\treturn int;\n\n\t\t};\n\n\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\tconst float = dataView.getFloat32( offset.value, true );\n\n\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\treturn float;\n\n\t\t}\n\n\t\tfunction decodeFloat32( dataView, offset ) {\n\n\t\t\treturn DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );\n\n\t\t}\n\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\tfunction decodeFloat16( binary ) {\n\n\t\t\tconst exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\texponent ?\n\t\t\t\t\t(\n\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t) :\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t);\n\n\t\t}\n\n\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\tconst Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\toffset.value += INT16_SIZE;\n\n\t\t\treturn Uint16;\n\n\t\t}\n\n\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t}\n\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\tconst startOffset = offset.value;\n\t\t\tconst channels = [];\n\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( buffer, offset );\n\t\t\t\tconst pixelType = parseInt32( dataView, offset );\n\t\t\t\tconst pLinear = parseUint8( dataView, offset );\n\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\tconst xSampling = parseInt32( dataView, offset );\n\t\t\t\tconst ySampling = parseInt32( dataView, offset );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\tySampling: ySampling\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\toffset.value += 1;\n\n\t\t\treturn channels;\n\n\t\t}\n\n\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\tconst redX = parseFloat32( dataView, offset );\n\t\t\tconst redY = parseFloat32( dataView, offset );\n\t\t\tconst greenX = parseFloat32( dataView, offset );\n\t\t\tconst greenY = parseFloat32( dataView, offset );\n\t\t\tconst blueX = parseFloat32( dataView, offset );\n\t\t\tconst blueY = parseFloat32( dataView, offset );\n\t\t\tconst whiteX = parseFloat32( dataView, offset );\n\t\t\tconst whiteY = parseFloat32( dataView, offset );\n\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t}\n\n\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\tconst compressionCodes = [\n\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t];\n\n\t\t\tconst compression = parseUint8( dataView, offset );\n\n\t\t\treturn compressionCodes[ compression ];\n\n\t\t}\n\n\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\tconst xMin = parseInt32( dataView, offset );\n\t\t\tconst yMin = parseInt32( dataView, offset );\n\t\t\tconst xMax = parseInt32( dataView, offset );\n\t\t\tconst yMax = parseInt32( dataView, offset );\n\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t}\n\n\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\tconst lineOrders = [\n\t\t\t\t'INCREASING_Y',\n\t\t\t\t'DECREASING_Y',\n\t\t\t\t'RANDOM_Y',\n\t\t\t];\n\n\t\t\tconst lineOrder = parseUint8( dataView, offset );\n\n\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t}\n\n\t\tfunction parseEnvmap( dataView, offset ) {\n\n\t\t\tconst envmaps = [\n\t\t\t\t'ENVMAP_LATLONG',\n\t\t\t\t'ENVMAP_CUBE'\n\t\t\t];\n\n\t\t\tconst envmap = parseUint8( dataView, offset );\n\n\t\t\treturn envmaps[ envmap ];\n\n\t\t}\n\n\t\tfunction parseTiledesc( dataView, offset ) {\n\n\t\t\tconst levelModes = [\n\t\t\t\t'ONE_LEVEL',\n\t\t\t\t'MIPMAP_LEVELS',\n\t\t\t\t'RIPMAP_LEVELS',\n\t\t\t];\n\n\t\t\tconst roundingModes = [\n\t\t\t\t'ROUND_DOWN',\n\t\t\t\t'ROUND_UP',\n\t\t\t];\n\n\t\t\tconst xSize = parseUint32( dataView, offset );\n\t\t\tconst ySize = parseUint32( dataView, offset );\n\t\t\tconst modes = parseUint8( dataView, offset );\n\n\t\t\treturn {\n\t\t\t\txSize: xSize,\n\t\t\t\tySize: ySize,\n\t\t\t\tlevelMode: levelModes[ modes & 0xf ],\n\t\t\t\troundingMode: roundingModes[ modes >> 4 ]\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseV3f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\t\t\tconst z = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y, z ];\n\n\t\t}\n\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t} else if ( type === 'envmap' ) {\n\n\t\t\t\treturn parseEnvmap( dataView, offset );\n\n\t\t\t} else if ( type === 'tiledesc' ) {\n\n\t\t\t\treturn parseTiledesc( dataView, offset );\n\n\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t} else if ( type === 'v3f' ) {\n\n\t\t\t\treturn parseV3f( dataView, offset );\n\n\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\treturn parseInt32( dataView, offset );\n\n\t\t\t} else if ( type === 'rational' ) {\n\n\t\t\t\treturn parseRational( dataView, offset );\n\n\t\t\t} else if ( type === 'timecode' ) {\n\n\t\t\t\treturn parseTimecode( dataView, offset );\n\n\t\t\t} else if ( type === 'preview' ) {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn 'skipped';\n\n\t\t\t} else {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction roundLog2( x, mode ) {\n\n\t\t\tconst log2 = Math.log2( x );\n\t\t\treturn mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );\n\n\t\t}\n\n\t\tfunction calculateTileLevels( tiledesc, w, h ) {\n\n\t\t\tlet num = 0;\n\n\t\t\tswitch ( tiledesc.levelMode ) {\n\n\t\t\t\tcase 'ONE_LEVEL':\n\t\t\t\t\tnum = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MIPMAP_LEVELS':\n\t\t\t\t\tnum = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIPMAP_LEVELS':\n\t\t\t\t\tthrow new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );\n\n\t\t\t}\n\n\t\t\treturn num;\n\n\t\t}\n\n\t\tfunction calculateTiles( count, dataSize, size, roundingMode ) {\n\n\t\t\tconst tiles = new Array( count );\n\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst b = ( 1 << i );\n\t\t\t\tlet s = ( dataSize / b ) | 0;\n\n\t\t\t\tif ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;\n\n\t\t\t\tconst l = Math.max( s, 1 );\n\n\t\t\t\ttiles[ i ] = ( ( l + size - 1 ) / size ) | 0;\n\n\t\t\t}\n\n\t\t\treturn tiles;\n\n\t\t}\n\n\t\tfunction parseTiles() {\n\n\t\t\tconst EXRDecoder = this;\n\t\t\tconst offset = EXRDecoder.offset;\n\t\t\tconst tmpOffset = { value: 0 };\n\n\t\t\tfor ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {\n\n\t\t\t\tconst tileX = parseInt32( EXRDecoder.viewer, offset );\n\t\t\t\tconst tileY = parseInt32( EXRDecoder.viewer, offset );\n\t\t\t\toffset.value += 8; // skip levels - only parsing top-level\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );\n\n\t\t\t\tconst startX = tileX * EXRDecoder.blockWidth;\n\t\t\t\tconst startY = tileY * EXRDecoder.blockHeight;\n\t\t\t\tEXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;\n\t\t\t\tEXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;\n\n\t\t\t\tconst bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\n\n\t\t\t\toffset.value += EXRDecoder.size;\n\n\t\t\t\tfor ( let line = 0; line < EXRDecoder.lines; line ++ ) {\n\n\t\t\t\t\tconst lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;\n\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\n\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\n\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\n\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\n\t\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;\n\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\n\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseScanline() {\n\n\t\t\tconst EXRDecoder = this;\n\t\t\tconst offset = EXRDecoder.offset;\n\t\t\tconst tmpOffset = { value: 0 };\n\n\t\t\tfor ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {\n\n\t\t\t\tconst line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len\n\t\t\t\tEXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );\n\n\t\t\t\tconst bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\n\n\t\t\t\toffset.value += EXRDecoder.size;\n\n\t\t\t\tfor ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {\n\n\t\t\t\t\tconst scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;\n\t\t\t\t\tconst true_y = line_y + EXRDecoder.scanOrder( scan_y );\n\t\t\t\t\tif ( true_y >= EXRDecoder.height ) continue;\n\n\t\t\t\t\tconst lineOffset = line_y * bytesPerLine;\n\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;\n\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\n\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\n\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\n\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\n\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\n\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseHeader( dataView, buffer, offset ) {\n\n\t\t\tconst EXRHeader = {};\n\n\t\t\tif ( dataView.getUint32( 0, true ) != 20000630 ) { // magic\n\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file doesn\\'t appear to be in OpenEXR format.' );\n\n\t\t\t}\n\n\t\t\tEXRHeader.version = dataView.getUint8( 4 );\n\n\t\t\tconst spec = dataView.getUint8( 5 ); // fullMask\n\n\t\t\tEXRHeader.spec = {\n\t\t\t\tsingleTile: !! ( spec & 2 ),\n\t\t\t\tlongName: !! ( spec & 4 ),\n\t\t\t\tdeepFormat: !! ( spec & 8 ),\n\t\t\t\tmultiPart: !! ( spec & 16 ),\n\t\t\t};\n\n\t\t\t// start of header\n\n\t\t\toffset.value = 8; // start at 8 - after pre-amble\n\n\t\t\tlet keepReading = true;\n\n\t\t\twhile ( keepReading ) {\n\n\t\t\t\tconst attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\t\tif ( attributeName === '' ) {\n\n\t\t\t\t\tkeepReading = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\t\tconst attributeSize = parseUint32( dataView, offset );\n\t\t\t\t\tconst attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\t\tif ( attributeValue === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( `THREE.EXRLoader: Skipped unknown header attribute type \\'${attributeType}\\'.` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( spec & ~ 0x06 ) != 0 ) { // unsupported deep-image, multi-part\n\n\t\t\t\tconsole.error( 'THREE.EXRHeader:', EXRHeader );\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );\n\n\t\t\t}\n\n\t\t\treturn EXRHeader;\n\n\t\t}\n\n\t\tfunction setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType, outputFormat ) {\n\n\t\t\tconst EXRDecoder = {\n\t\t\t\tsize: 0,\n\t\t\t\tviewer: dataView,\n\t\t\t\tarray: uInt8Array,\n\t\t\t\toffset: offset,\n\t\t\t\twidth: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n\t\t\t\theight: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n\t\t\t\tinputChannels: EXRHeader.channels,\n\t\t\t\tchannelByteOffsets: {},\n\t\t\t\tshouldExpand: false,\n\t\t\t\tscanOrder: null,\n\t\t\t\ttotalBytes: null,\n\t\t\t\tcolumns: null,\n\t\t\t\tlines: null,\n\t\t\t\ttype: null,\n\t\t\t\tuncompress: null,\n\t\t\t\tgetter: null,\n\t\t\t\tformat: null,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t};\n\n\t\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\t\tcase 'NO_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRAW;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RLE_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIPS_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIP_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PIZ_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPIZ;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PXR24_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPXR;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAA_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAB_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 256;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );\n\n\t\t\t}\n\n\t\t\tconst channels = {};\n\t\t\tfor ( const channel of EXRHeader.channels ) {\n\n\t\t\t\tswitch ( channel.name ) {\n\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\tcase 'R':\n\t\t\t\t\tcase 'G':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tchannels[ channel.name ] = true;\n\t\t\t\t\t\tEXRDecoder.type = channel.pixelType;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\t\t\tlet fillAlpha = false;\n\t\t\tlet invalidOutput = false;\n\n\t\t\t// Validate if input texture contain supported channels\n\t\t\tif ( channels.R && channels.G && channels.B ) {\n\n\t\t\t\tEXRDecoder.outputChannels = 4;\n\n\t\t\t} else if ( channels.Y ) {\n\n\t\t\t\tEXRDecoder.outputChannels = 1;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'EXRLoader.parse: file contains unsupported data channels.' );\n\n\t\t\t}\n\n\t\t\t// Setup output texture configuration\n\t\t\tswitch ( EXRDecoder.outputChannels ) {\n\n\t\t\t\tcase 4:\n\n\t\t\t\t\tif ( outputFormat == RGBAFormat ) {\n\n\t\t\t\t\t\tfillAlpha = ! channels.A;\n\t\t\t\t\t\tEXRDecoder.format = RGBAFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 4;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\n\n\t\t\t\t\t} else if ( outputFormat == RGFormat ) {\n\n\t\t\t\t\t\tEXRDecoder.format = RGFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 2;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { R: 0, G: 1 };\n\n\t\t\t\t\t} else if ( outputFormat == RedFormat ) {\n\n\t\t\t\t\t\tEXRDecoder.format = RedFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 1;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { R: 0 };\n\n\t\t\t\t\t} else  {\n\n\t\t\t\t\t\tinvalidOutput = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tif ( outputFormat == RGBAFormat ) {\n\n\t\t\t\t\t\tfillAlpha = true;\n\t\t\t\t\t\tEXRDecoder.format = RGBAFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 4;\n\t\t\t\t\t\tEXRDecoder.shouldExpand = true;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { Y: 0 };\n\n\t\t\t\t\t} else if ( outputFormat == RGFormat ) {\n\n\t\t\t\t\t\tEXRDecoder.format = RGFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 2;\n\t\t\t\t\t\tEXRDecoder.shouldExpand = true;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { Y: 0 };\n\n\t\t\t\t\t} else if ( outputFormat == RedFormat ) {\n\n\t\t\t\t\t\tEXRDecoder.format = RedFormat;\n\t\t\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\t\tEXRDecoder.outputChannels = 1;\n\t\t\t\t\t\tEXRDecoder.decodeChannels = { Y: 0 };\n\n\t\t\t\t\t} else  {\n\n\t\t\t\t\t\tinvalidOutput = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tinvalidOutput = true;\n\n\t\t\t}\n\n\t\t\tif (invalidOutput) throw new Error( 'EXRLoader.parse: invalid output format for specified file.' );\n\n\t\t\tif ( EXRDecoder.type == 1 ) {\n\n\t\t\t\t// half\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat16;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseUint16;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( EXRDecoder.type == 2 ) {\n\n\t\t\t\t// float\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat32;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = decodeFloat32;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );\n\n\t\t\t}\n\n\t\t\tEXRDecoder.columns = EXRDecoder.width;\n\t\t\tconst size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n\t\t\tswitch ( outputType ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Float32Array( size );\n\n\t\t\t\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\t\t\t\tif ( fillAlpha )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 1, 0, size );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Uint16Array( size );\n\n\t\t\t\t\tif ( fillAlpha )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', outputType );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlet byteOffset = 0;\n\t\t\tfor ( const channel of EXRHeader.channels ) {\n\n\t\t\t\tif ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {\n\n\t\t\t\t\tEXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += channel.pixelType * 2;\n\n\t\t\t}\n\n\t\t\tEXRDecoder.totalBytes = byteOffset;\n\t\t\tEXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;\n\n\t\t\tif ( EXRHeader.lineOrder === 'INCREASING_Y' ) {\n\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => y;\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;\n\n\t\t\t}\n\n\t\t\tif ( EXRHeader.spec.singleTile ) {\n\n\t\t\t\tEXRDecoder.blockHeight = EXRHeader.tiles.ySize;\n\t\t\t\tEXRDecoder.blockWidth = EXRHeader.tiles.xSize;\n\n\t\t\t\tconst numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\n\t\t\t\t// const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\n\n\t\t\t\tconst numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );\n\t\t\t\tconst numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );\n\n\t\t\t\tEXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];\n\n\t\t\t\tfor ( let l = 0; l < numXLevels; l ++ )\n\t\t\t\t\tfor ( let y = 0; y < numYTiles[ l ]; y ++ )\n\t\t\t\t\t\tfor ( let x = 0; x < numXTiles[ l ]; x ++ )\n\t\t\t\t\t\t\tparseInt64( dataView, offset ); // tileOffset\n\n\t\t\t\tEXRDecoder.decode = parseTiles.bind( EXRDecoder );\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.blockWidth = EXRDecoder.width;\n\t\t\t\tconst blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );\n\n\t\t\t\tfor ( let i = 0; i < blockCount; i ++ )\n\t\t\t\t\tparseInt64( dataView, offset ); // scanlineOffset\n\n\t\t\t\tEXRDecoder.decode = parseScanline.bind( EXRDecoder );\n\n\t\t\t}\n\n\t\t\treturn EXRDecoder;\n\n\t\t}\n\n\t\t// start parsing file [START]\n\t\tconst offset = { value: 0 };\n\t\tconst bufferDataView = new DataView( buffer );\n\t\tconst uInt8Array = new Uint8Array( buffer );\n\n\t\t// get header information and validate format.\n\t\tconst EXRHeader = parseHeader( bufferDataView, buffer, offset );\n\n\t\t// get input compression information and prepare decoding.\n\t\tconst EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type, this.outputFormat );\n\n\t\t// parse input data\n\t\tEXRDecoder.decode();\n\n\t\t// output texture post-processing\n\t\tif ( EXRDecoder.shouldExpand ) {\n\n\t\t\tconst byteArray = EXRDecoder.byteArray;\n\n\t\t\tif ( this.outputFormat == RGBAFormat ) {\n\n\t\t\t\tfor ( let i = 0; i < byteArray.length; i += 4 )\n\t\t\t\t\tbyteArray [i + 2 ] = ( byteArray [ i + 1 ] = byteArray[ i ] );\n\n\t\t\t} else if ( this.outputFormat == RGFormat ) {\n\n\t\t\t\tfor ( let i = 0; i < byteArray.length; i += 2 )\n\t\t\t\t\tbyteArray [ i + 1 ] = byteArray[ i ] ;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader: EXRHeader,\n\t\t\twidth: EXRDecoder.width,\n\t\t\theight: EXRDecoder.height,\n\t\t\tdata: EXRDecoder.byteArray,\n\t\t\tformat: EXRDecoder.format,\n\t\t\tcolorSpace: EXRDecoder.colorSpace,\n\t\t\ttype: this.type,\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {EXRLoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets texture output format. Defaults to `RGBAFormat`.\n\t *\n\t * @param {(RGBAFormat|RGFormat|RedFormat)} value - Texture output format.\n\t * @return {EXRLoader} A reference to this loader.\n\t */\n\tsetOutputFormat( value ) {\n\n\t\tthis.outputFormat = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\ttexture.colorSpace = texData.colorSpace;\n\t\t\ttexture.minFilter = LinearFilter;\n\t\t\ttexture.magFilter = LinearFilter;\n\t\t\ttexture.generateMipmaps = false;\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { EXRLoader };\n"],"mappings":"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AChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,IAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAEhCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAEhCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAEhCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAEhCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,IAAOC,EAAeP,EAAK,KAChCM,EAAK,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","ignoreList":[]}