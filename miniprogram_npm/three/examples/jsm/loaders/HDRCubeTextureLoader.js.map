{"version":3,"file":"node_modules/three/examples/jsm/loaders/HDRCubeTextureLoader.js","names":["CubeTexture","DataTexture","FileLoader","FloatType","HalfFloatType","LinearFilter","LinearSRGBColorSpace","Loader","RGBELoader","HDRCubeTextureLoader","constructor","manager","super","this","hdrLoader","type","load","urls","onLoad","onProgress","onError","texture","colorSpace","minFilter","magFilter","generateMipmaps","scope","loaded","loadHDRData","i","setPath","path","setResponseType","setWithCredentials","withCredentials","buffer","texData","parse","undefined","data","dataTexture","width","height","format","images","needsUpdate","length","setDataType","value"],"sources":["node_modules/three/examples/jsm/loaders/HDRCubeTextureLoader.js"],"sourcesContent":["import {\n\tCubeTexture,\n\tDataTexture,\n\tFileLoader,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace,\n\tLoader\n} from 'three';\nimport { RGBELoader } from '../loaders/RGBELoader.js';\n\n/**\n * A loader for loading HDR cube textures.\n *\n * ```js\n * const loader = new HDRCubeTextureLoader();\n * loader.setPath( 'textures/cube/pisaHDR/' );\n * const cubeTexture = await loader.loadAsync( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ] );\n *\n * scene.background = cubeTexture;\n * scene.environment = cubeTexture;\n * ```\n *\n * @augments Loader\n * @three_import import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';\n */\nclass HDRCubeTextureLoader extends Loader {\n\n\t/**\n\t * Constructs a new HDR cube texture loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The internal HDR loader that loads the\n\t\t * individual textures for each cube face.\n\t\t *\n\t\t * @type {RGBELoader}\n\t\t */\n\t\tthis.hdrLoader = new RGBELoader();\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URLs and passes the loaded HDR cube texture\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {Array<string>} urls - The paths/URLs of the files to be loaded. This can also be a data URIs.\n\t * @param {function(CubeTexture)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {CubeTexture} The HDR cube texture.\n\t */\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\n\t\ttexture.type = this.type;\n\n\t\tswitch ( texture.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst scope = this;\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadHDRData( i, onLoad, onProgress, onError ) {\n\n\t\t\tnew FileLoader( scope.manager )\n\t\t\t\t.setPath( scope.path )\n\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t.setWithCredentials( scope.withCredentials )\n\t\t\t\t.load( urls[ i ], function ( buffer ) {\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tconst texData = scope.hdrLoader.parse( buffer );\n\n\t\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\t\tif ( texData.data !== undefined ) {\n\n\t\t\t\t\t\tconst dataTexture = new DataTexture( texData.data, texData.width, texData.height );\n\n\t\t\t\t\t\tdataTexture.type = texture.type;\n\t\t\t\t\t\tdataTexture.colorSpace = texture.colorSpace;\n\t\t\t\t\t\tdataTexture.format = texture.format;\n\t\t\t\t\t\tdataTexture.minFilter = texture.minFilter;\n\t\t\t\t\t\tdataTexture.magFilter = texture.magFilter;\n\t\t\t\t\t\tdataTexture.generateMipmaps = texture.generateMipmaps;\n\n\t\t\t\t\t\ttexture.images[ i ] = dataTexture;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; i ++ ) {\n\n\t\t\tloadHDRData( i, onLoad, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBELoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\tthis.hdrLoader.setDataType( value );\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { HDRCubeTextureLoader };\n"],"mappings":"OACCA,YACAC,YACAC,WACAC,UACAC,cACAC,aACAC,qBACAC,WACM,eACEC,eAAkB,2BAiB3B,MAAMC,6BAA6BF,OAOlC,WAAAG,CAAaC,GAEZC,MAAOD,GAQPE,KAAKC,UAAY,IAAIN,WAQrBK,KAAKE,KAAOX,aAEb,CAYA,IAAAY,CAAMC,EAAMC,EAAQC,EAAYC,GAE/B,MAAMC,EAAU,IAAIrB,YAIpB,OAFAqB,EAAQN,KAAOF,KAAKE,KAEXM,EAAQN,MAEhB,KAAKZ,UAQL,KAAKC,cAEJiB,EAAQC,WAAahB,qBACrBe,EAAQE,UAAYlB,aACpBgB,EAAQG,UAAYnB,aACpBgB,EAAQI,iBAAkB,EAK5B,MAAMC,EAAQb,KAEd,IAAIc,EAAS,EAEb,SAASC,EAAaC,EAAGX,EAAQC,EAAYC,GAE5C,IAAIlB,WAAYwB,EAAMf,SACpBmB,QAASJ,EAAMK,MACfC,gBAAiB,eACjBC,mBAAoBP,EAAMQ,iBAC1BlB,KAAMC,EAAMY,IAAK,SAAWM,GAE5BR,IAEA,MAAMS,EAAUV,EAAMZ,UAAUuB,MAAOF,GAEvC,GAAOC,EAAP,CAEA,QAAsBE,IAAjBF,EAAQG,KAAqB,CAEjC,MAAMC,EAAc,IAAIvC,YAAamC,EAAQG,KAAMH,EAAQK,MAAOL,EAAQM,QAE1EF,EAAYzB,KAAOM,EAAQN,KAC3ByB,EAAYlB,WAAaD,EAAQC,WACjCkB,EAAYG,OAAStB,EAAQsB,OAC7BH,EAAYjB,UAAYF,EAAQE,UAChCiB,EAAYhB,UAAYH,EAAQG,UAChCgB,EAAYf,gBAAkBJ,EAAQI,gBAEtCJ,EAAQuB,OAAQf,GAAMW,CAEvB,CAEgB,IAAXb,IAEJN,EAAQwB,aAAc,EACjB3B,GAASA,EAAQG,GApBA,CAwBxB,GAAGF,EAAYC,EAEjB,CAEA,IAAM,IAAIS,EAAI,EAAGA,EAAIZ,EAAK6B,OAAQjB,IAEjCD,EAAaC,EAAGX,EAAQC,EAAYC,GAIrC,OAAOC,CAER,CAQA,WAAA0B,CAAaC,GAKZ,OAHAnC,KAAKE,KAAOiC,EACZnC,KAAKC,UAAUiC,YAAaC,GAErBnC,IAER,SAIQJ","ignoreList":[]}