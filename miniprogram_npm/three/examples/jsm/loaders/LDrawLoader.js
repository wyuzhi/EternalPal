import{BufferAttribute,BufferGeometry,Color,FileLoader,Group,LineBasicMaterial,LineSegments,Loader,Matrix4,Mesh,MeshStandardMaterial,SRGBColorSpace,Vector3,Ray}from"three";const FINISH_TYPE_DEFAULT=0,FINISH_TYPE_CHROME=1,FINISH_TYPE_PEARLESCENT=2,FINISH_TYPE_RUBBER=3,FINISH_TYPE_MATTE_METALLIC=4,FINISH_TYPE_METAL=5,FILE_LOCATION_TRY_PARTS=0,FILE_LOCATION_TRY_P=1,FILE_LOCATION_TRY_MODELS=2,FILE_LOCATION_AS_IS=3,FILE_LOCATION_TRY_RELATIVE=4,FILE_LOCATION_TRY_ABSOLUTE=5,FILE_LOCATION_NOT_FOUND=6,MAIN_COLOUR_CODE="16",MAIN_EDGE_COLOUR_CODE="24",COLOR_SPACE_LDRAW=SRGBColorSpace,_tempVec0=new Vector3,_tempVec1=new Vector3;class ConditionalLineSegments extends LineSegments{constructor(e,t){super(e,t),this.isConditionalLine=!0}}function generateFaceNormals(e){for(let t=0,a=e.length;t<a;t++){const a=e[t],r=a.vertices,n=r[0],i=r[1],s=r[2];_tempVec0.subVectors(i,n),_tempVec1.subVectors(s,i),a.faceNormal=(new Vector3).crossVectors(_tempVec0,_tempVec1).normalize()}}const _ray=new Ray;function smoothNormals(e,t,a=!1){const r=100*(1+1e-10);function n(e){return`${~~(e.x*r)},${~~(e.y*r)},${~~(e.z*r)}`}function i(e,t){return`${n(e)}_${n(t)}`}function s(e,t,a){a.direction.subVectors(t,e).normalize();const r=e.dot(a.direction);return a.origin.copy(e).addScaledVector(a.direction,-r),a}function o(e){return i(e.origin,e.direction)}const l=new Set,c=new Map,h={},d=[];for(let e=0,r=t.length;e<r;e++){const r=t[e].vertices,n=r[0],h=r[1];if(l.add(i(n,h)),l.add(i(h,n)),a){const e=s(n,h,new Ray),t=o(e);if(!c.has(t)){s(h,n,e);const a=o(e),r={ray:e,distances:[]};c.set(t,r),c.set(a,r)}const a=c.get(t);let r=a.ray.direction.dot(n),i=a.ray.direction.dot(h);r>i&&([r,i]=[i,r]),a.distances.push(r,i)}}for(let t=0,r=e.length;t<r;t++){const r=e[t],n=r.vertices,d=n.length;for(let e=0;e<d;e++){const t=e,u=(e+1)%d,g=n[t],m=n[u],p=i(g,m);if(l.has(p))continue;if(a){s(g,m,_ray);const e=o(_ray);if(c.has(e)){const t=c.get(e),{ray:a,distances:r}=t;let n=a.direction.dot(g),i=a.direction.dot(m);n>i&&([n,i]=[i,n]);let s=!1;for(let e=0,t=r.length;e<t;e+=2)if(n>=r[e]&&i<=r[e+1]){s=!0;break}if(s)continue}}const C={index:t,tri:r};h[p]=C}}for(;;){let e=null;for(const t in h){e=h[t];break}if(null===e)break;const t=[e];for(;t.length>0;){const e=t.pop().tri,a=e.vertices,r=e.normals,n=e.faceNormal,s=a.length;for(let o=0;o<s;o++){const l=o,c=(o+1)%s,u=a[l],g=a[c];delete h[i(u,g)];const m=i(g,u),p=h[m];if(p){const a=p.tri,i=p.index,s=a.normals,o=s.length,u=a.faceNormal;if(Math.abs(a.faceNormal.dot(e.faceNormal))<.25)continue;m in h&&(t.push(p),delete h[m]);const g=(i+1)%o;r[l]&&s[g]&&r[l]!==s[g]&&(s[g].norm.add(r[l].norm),r[l].norm=s[g].norm);let C=r[l]||s[g];null===C&&(C={norm:new Vector3},d.push(C.norm)),null===r[l]&&(r[l]=C,C.norm.add(n)),null===s[g]&&(s[g]=C,C.norm.add(u)),r[c]&&s[i]&&r[c]!==s[i]&&(s[i].norm.add(r[c].norm),r[c].norm=s[i].norm);let f=r[c]||s[i];null===f&&(f={norm:new Vector3},d.push(f.norm)),null===r[c]&&(r[c]=f,f.norm.add(n)),null===s[i]&&(s[i]=f,f.norm.add(u))}}}}for(let e=0,t=d.length;e<t;e++)d[e].normalize()}function isPartType(e){return"Part"===e||"Unofficial_Part"===e}function isPrimitiveType(e){return/primitive/i.test(e)||"Subpart"===e}class LineParser{constructor(e,t){this.line=e,this.lineLength=e.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=t}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const e=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const t=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(e,t)}getVector(){return new Vector3(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class LDrawParsedCache{constructor(e){this.loader=e,this._cache={}}cloneResult(e){const t={};return t.faces=e.faces.map((e=>({colorCode:e.colorCode,material:e.material,vertices:e.vertices.map((e=>e.clone())),normals:e.normals.map((()=>null)),faceNormal:null}))),t.conditionalSegments=e.conditionalSegments.map((e=>({colorCode:e.colorCode,material:e.material,vertices:e.vertices.map((e=>e.clone())),controlPoints:e.controlPoints.map((e=>e.clone()))}))),t.lineSegments=e.lineSegments.map((e=>({colorCode:e.colorCode,material:e.material,vertices:e.vertices.map((e=>e.clone()))}))),t.type=e.type,t.category=e.category,t.keywords=e.keywords,t.author=e.author,t.subobjects=e.subobjects,t.fileName=e.fileName,t.totalFaces=e.totalFaces,t.startingBuildingStep=e.startingBuildingStep,t.materials=e.materials,t.group=null,t}async fetchData(e){let t=!1,a=0;for(;6!==a;){let r=e;switch(a){case 3:a+=1;break;case 0:r="parts/"+r,a+=1;break;case 1:r="p/"+r,a+=1;break;case 2:r="models/"+r,a+=1;break;case 4:r=e.substring(0,e.lastIndexOf("/")+1)+r,a+=1;break;case 5:t?a=6:(r=e=e.toLowerCase(),t=!0,a=0)}const n=this.loader,i=new FileLoader(n.manager);i.setPath(n.partsLibraryPath),i.setRequestHeader(n.requestHeader),i.setWithCredentials(n.withCredentials);try{return await i.loadAsync(r)}catch(e){continue}}throw new Error('LDrawLoader: Subobject "'+e+'" could not be loaded.')}parse(e,t=null){const a=this.loader,r=[],n=[],i=[],s=[],o={},l=e=>o[e]||null;let c="Model",h=null,d=null,u=null,g=0;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n"));const m=e.split("\n"),p=m.length;let C=!1,f=null,L=null,M=!1,w=!0,E=!1,b=!0,y=!1;for(let e=0;e<p;e++){const t=m[e];if(0===t.length)continue;if(C){t.startsWith("0 FILE ")?(this.setData(f,L),f=t.substring(7),L=""):L+=t+"\n";continue}const p=new LineParser(t,e+1);if(p.seekNonSpace(),p.isAtTheEnd())continue;const T=p.getToken();let S,k,A,_,N,D,F,I,O,R,V;switch(T){case"0":const t=p.getToken();if(t)switch(t){case"!LDRAW_ORG":c=p.getToken();break;case"!COLOUR":S=a.parseColorMetaDirective(p),S?o[S.userData.code]=S:console.warn("LDrawLoader: Error parsing material"+p.getLineNumberString());break;case"!CATEGORY":h=p.getToken();break;case"!KEYWORDS":const t=p.getRemainingString().split(",");t.length>0&&(d||(d=[]),t.forEach((function(e){d.push(e.trim())})));break;case"FILE":e>0&&(C=!0,f=p.getRemainingString(),L="",M=!1,w=!0);break;case"BFC":for(;!p.isAtTheEnd();){const e=p.getToken();switch(e){case"CERTIFY":case"NOCERTIFY":M="CERTIFY"===e,w=!0;break;case"CW":case"CCW":w="CCW"===e;break;case"INVERTNEXT":E=!0;break;case"CLIP":case"NOCLIP":b="CLIP"===e;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+e+'" is unknown.')}}break;case"STEP":y=!0;break;case"Author:":u=p.getToken()}break;case"1":k=p.getToken(),S=l(k);const m=parseFloat(p.getToken()),P=parseFloat(p.getToken()),x=parseFloat(p.getToken()),v=parseFloat(p.getToken()),B=parseFloat(p.getToken()),W=parseFloat(p.getToken()),U=parseFloat(p.getToken()),G=parseFloat(p.getToken()),H=parseFloat(p.getToken()),z=parseFloat(p.getToken()),Y=parseFloat(p.getToken()),j=parseFloat(p.getToken()),q=(new Matrix4).set(v,B,W,m,U,G,H,P,z,Y,j,x,0,0,0,1);let $=p.getRemainingString().trim().replace(/\\/g,"/");a.fileMap[$]?$=a.fileMap[$]:$.startsWith("s/")?$="parts/"+$:$.startsWith("48/")&&($="p/"+$),s.push({material:S,colorCode:k,matrix:q,fileName:$,inverted:E,startingBuildingStep:y}),y=!1,E=!1;break;case"2":k=p.getToken(),S=l(k),D=p.getVector(),F=p.getVector(),A={material:S,colorCode:k,vertices:[D,F]},n.push(A);break;case"5":k=p.getToken(),S=l(k),D=p.getVector(),F=p.getVector(),R=p.getVector(),V=p.getVector(),A={material:S,colorCode:k,vertices:[D,F],controlPoints:[R,V]},i.push(A);break;case"3":k=p.getToken(),S=l(k),_=w,N=!M||!b,!0===_?(D=p.getVector(),F=p.getVector(),I=p.getVector()):(I=p.getVector(),F=p.getVector(),D=p.getVector()),r.push({material:S,colorCode:k,faceNormal:null,vertices:[D,F,I],normals:[null,null,null]}),g++,!0===N&&(r.push({material:S,colorCode:k,faceNormal:null,vertices:[I,F,D],normals:[null,null,null]}),g++);break;case"4":k=p.getToken(),S=l(k),_=w,N=!M||!b,!0===_?(D=p.getVector(),F=p.getVector(),I=p.getVector(),O=p.getVector()):(O=p.getVector(),I=p.getVector(),F=p.getVector(),D=p.getVector()),r.push({material:S,colorCode:k,faceNormal:null,vertices:[D,F,I,O],normals:[null,null,null,null]}),g+=2,!0===N&&(r.push({material:S,colorCode:k,faceNormal:null,vertices:[O,I,F,D],normals:[null,null,null,null]}),g+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+T+'"'+p.getLineNumberString()+".")}}return C&&this.setData(f,L),{faces:r,conditionalSegments:i,lineSegments:n,type:c,category:h,keywords:d,author:u,subobjects:s,totalFaces:g,startingBuildingStep:y,materials:o,fileName:t,group:null}}getData(e,t=!0){const a=e.toLowerCase(),r=this._cache[a];return null===r||r instanceof Promise?null:t?this.cloneResult(r):r}async ensureDataLoaded(e){const t=e.toLowerCase();t in this._cache||(this._cache[t]=this.fetchData(e).then((a=>{const r=this.parse(a,e);return this._cache[t]=r,r}))),await this._cache[t]}setData(e,t){const a=e.toLowerCase();this._cache[a]=this.parse(t,e)}}function getMaterialFromCode(e,t,a,r){return(!r&&"16"===e||r&&"24"===e)&&(e=t),a[e]||null}class LDrawPartsGeometryCache{constructor(e){this.loader=e,this.parseCache=new LDrawParsedCache(e),this._cache={}}async processIntoMesh(e){const t=this.loader,a=this.parseCache,r=new Set,n=async(e,i=null)=>{const s=e.subobjects,o=[];for(let e=0,t=s.length;e<t;e++){const t=s[e],r=a.ensureDataLoaded(t.fileName).then((()=>isPrimitiveType(a.getData(t.fileName,!1).type)?n(a.getData(t.fileName),t):this.loadModel(t.fileName).catch((e=>(console.warn(e),null)))));o.push(r)}const l=new Group;l.userData.category=e.category,l.userData.keywords=e.keywords,l.userData.author=e.author,l.userData.type=e.type,l.userData.fileName=e.fileName,e.group=l;const c=await Promise.all(o);for(let a=0,n=c.length;a<n;a++){const n=e.subobjects[a],i=c[a];if(null===i)continue;if(i.isGroup){const a=i;n.matrix.decompose(a.position,a.quaternion,a.scale),a.userData.startingBuildingStep=n.startingBuildingStep,a.name=n.fileName,t.applyMaterialsToMesh(a,n.colorCode,e.materials),a.userData.colorCode=n.colorCode,l.add(a);continue}i.group.children.length&&l.add(i.group);const s=e.lineSegments,o=e.conditionalSegments,h=e.faces,d=i.lineSegments,u=i.conditionalSegments,g=i.faces,m=n.matrix,p=n.inverted,C=m.determinant()<0,f=n.colorCode,L="16"===f?"24":f;for(let t=0,a=d.length;t<a;t++){const a=d[t],r=a.vertices;r[0].applyMatrix4(m),r[1].applyMatrix4(m),a.colorCode="24"===a.colorCode?L:a.colorCode,a.material=a.material||getMaterialFromCode(a.colorCode,a.colorCode,e.materials,!0),s.push(a)}for(let t=0,a=u.length;t<a;t++){const a=u[t],r=a.vertices,n=a.controlPoints;r[0].applyMatrix4(m),r[1].applyMatrix4(m),n[0].applyMatrix4(m),n[1].applyMatrix4(m),a.colorCode="24"===a.colorCode?L:a.colorCode,a.material=a.material||getMaterialFromCode(a.colorCode,a.colorCode,e.materials,!0),o.push(a)}for(let t=0,a=g.length;t<a;t++){const a=g[t],n=a.vertices;for(let e=0,t=n.length;e<t;e++)n[e].applyMatrix4(m);a.colorCode="16"===a.colorCode?f:a.colorCode,a.material=a.material||getMaterialFromCode(a.colorCode,f,e.materials,!1),r.add(a.colorCode),C!==p&&n.reverse(),h.push(a)}e.totalFaces+=i.totalFaces}return i&&(t.applyMaterialsToMesh(l,i.colorCode,e.materials),l.userData.colorCode=i.colorCode),e};for(let t=0,a=e.faces;t<a;t++)r.add(e.faces[t].colorCode);if(await n(e),t.smoothNormals){const t=r.size>1;generateFaceNormals(e.faces),smoothNormals(e.faces,e.lineSegments,t)}const i=e.group;return e.faces.length>0&&i.add(createObject(this.loader,e.faces,3,!1,e.totalFaces)),e.lineSegments.length>0&&i.add(createObject(this.loader,e.lineSegments,2)),e.conditionalSegments.length>0&&i.add(createObject(this.loader,e.conditionalSegments,2,!0)),i}hasCachedModel(e){return null!==e&&e.toLowerCase()in this._cache}async getCachedModel(e){if(null!==e&&this.hasCachedModel(e)){const t=e.toLowerCase();return(await this._cache[t]).clone()}return null}async loadModel(e){const t=this.parseCache,a=e.toLowerCase();if(this.hasCachedModel(e))return this.getCachedModel(e);{await t.ensureDataLoaded(e);const r=t.getData(e),n=this.processIntoMesh(r);if(this.hasCachedModel(e))return this.getCachedModel(e);isPartType(r.type)&&(this._cache[a]=n);return(await n).clone()}}async parseModel(e){const t=this.parseCache.parse(e);return isPartType(t.type)&&this.hasCachedModel(t.fileName)?this.getCachedModel(t.fileName):this.processIntoMesh(t)}}function sortByMaterial(e,t){return e.colorCode===t.colorCode?0:e.colorCode<t.colorCode?-1:1}function createObject(e,t,a,r=!1,n=null){t.sort(sortByMaterial),null===n&&(n=t.length);const i=new Float32Array(a*n*3),s=3===a?new Float32Array(a*n*3):null,o=[],l=new Array(6),c=new BufferGeometry;let h=null,d=0,u=0,g=0;for(let n=0,m=t.length;n<m;n++){const m=t[n];let p=m.vertices;4===p.length&&(l[0]=p[0],l[1]=p[1],l[2]=p[2],l[3]=p[0],l[4]=p[2],l[5]=p[3],p=l);for(let e=0,t=p.length;e<t;e++){const t=p[e],a=g+3*e;i[a+0]=t.x,i[a+1]=t.y,i[a+2]=t.z}if(3===a){if(!m.faceNormal){const e=p[0],t=p[1],a=p[2];_tempVec0.subVectors(t,e),_tempVec1.subVectors(a,t),m.faceNormal=(new Vector3).crossVectors(_tempVec0,_tempVec1).normalize()}let e=m.normals;4===e.length&&(l[0]=e[0],l[1]=e[1],l[2]=e[2],l[3]=e[0],l[4]=e[2],l[5]=e[3],e=l);for(let t=0,a=e.length;t<a;t++){let a=m.faceNormal;e[t]&&(a=e[t].norm);const r=g+3*t;s[r+0]=a.x,s[r+1]=a.y,s[r+2]=a.z}}if(h!==m.colorCode){null!==h&&c.addGroup(d,u,o.length-1);const t=m.material;if(null!==t){if(3===a)o.push(t);else if(2===a)if(r){const a=e.edgeMaterialCache.get(t);o.push(e.conditionalEdgeMaterialCache.get(a))}else o.push(e.edgeMaterialCache.get(t))}else o.push(m.colorCode);h=m.colorCode,d=g/3,u=p.length}else u+=p.length;g+=3*p.length}u>0&&c.addGroup(d,1/0,o.length-1),c.setAttribute("position",new BufferAttribute(i,3)),null!==s&&c.setAttribute("normal",new BufferAttribute(s,3));let m=null;if(2===a?m=r?new ConditionalLineSegments(c,1===o.length?o[0]:o):new LineSegments(c,1===o.length?o[0]:o):3===a&&(m=new Mesh(c,1===o.length?o[0]:o)),r){m.isConditionalLine=!0;const e=new Float32Array(3*t.length*2),a=new Float32Array(3*t.length*2),r=new Float32Array(3*t.length*2);for(let n=0,i=t.length;n<i;n++){const i=t[n],s=i.vertices,o=i.controlPoints,l=o[0],c=o[1],h=s[0],d=s[1],u=3*n*2;e[u+0]=l.x,e[u+1]=l.y,e[u+2]=l.z,e[u+3]=l.x,e[u+4]=l.y,e[u+5]=l.z,a[u+0]=c.x,a[u+1]=c.y,a[u+2]=c.z,a[u+3]=c.x,a[u+4]=c.y,a[u+5]=c.z,r[u+0]=d.x-h.x,r[u+1]=d.y-h.y,r[u+2]=d.z-h.z,r[u+3]=d.x-h.x,r[u+4]=d.y-h.y,r[u+5]=d.z-h.z}c.setAttribute("control0",new BufferAttribute(e,3,!1)),c.setAttribute("control1",new BufferAttribute(a,3,!1)),c.setAttribute("direction",new BufferAttribute(r,3,!1))}return m}class LDrawLoader extends Loader{constructor(e){super(e),this.materials=[],this.materialLibrary={},this.edgeMaterialCache=new WeakMap,this.conditionalEdgeMaterialCache=new WeakMap,this.partsCache=new LDrawPartsGeometryCache(this),this.fileMap={},this.smoothNormals=!0,this.partsLibraryPath="",this.ConditionalLineMaterial=null,this.missingColorMaterial=new MeshStandardMaterial({name:Loader.DEFAULT_MATERIAL_NAME,color:16711935,roughness:.3,metalness:0}),this.missingEdgeColorMaterial=new LineBasicMaterial({name:Loader.DEFAULT_MATERIAL_NAME,color:16711935}),this.missingConditionalEdgeColorMaterial=null,this.edgeMaterialCache.set(this.missingColorMaterial,this.missingEdgeColorMaterial),this.conditionalEdgeMaterialCache.set(this.missingEdgeColorMaterial,this.missingConditionalEdgeColorMaterial)}setPartsLibraryPath(e){return this.partsLibraryPath=e,this}setConditionalLineMaterial(e){return this.ConditionalLineMaterial=e,this.missingConditionalEdgeColorMaterial=new this.ConditionalLineMaterial({name:Loader.DEFAULT_MATERIAL_NAME,fog:!0,color:16711935}),this}async preloadMaterials(e){const t=new FileLoader(this.manager);t.setPath(this.path),t.setRequestHeader(this.requestHeader),t.setWithCredentials(this.withCredentials);const a=/^0 !COLOUR/,r=(await t.loadAsync(e)).split(/[\n\r]/g),n=[];for(let e=0,t=r.length;e<t;e++){const t=r[e];if(a.test(t)){const e=t.replace(a,""),r=this.parseColorMetaDirective(new LineParser(e));n.push(r)}}this.addMaterials(n)}load(e,t,a,r){const n=new FileLoader(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(e,(a=>{this.addDefaultMaterials(),this.partsCache.parseModel(a).then((a=>{this.applyMaterialsToMesh(a,"16",this.materialLibrary,!0),this.computeBuildingSteps(a),a.userData.fileName=e,t(a)})).catch(r)}),a,r)}parse(e,t,a){this.partsCache.parseModel(e).then((e=>{this.applyMaterialsToMesh(e,"16",this.materialLibrary,!0),this.computeBuildingSteps(e),e.userData.fileName="",t(e)})).catch(a)}setMaterials(e){return this.clearMaterials(),this.addMaterials(e),this}clearMaterials(){return this.materialLibrary={},this.materials=[],this}addMaterials(e){for(let t=0,a=e.length;t<a;t++)this.addMaterial(e[t]);return this}addDefaultMaterials(){return this.addMaterial(this.parseColorMetaDirective(new LineParser("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new LineParser("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(e){return this.fileMap=e,this}addMaterial(e){const t=this.materialLibrary;return t[e.userData.code]||(this.materials.push(e),t[e.userData.code]=e),this}getMaterial(e){if(e.startsWith("0x2")){const t=e.substring(3);return this.parseColorMetaDirective(new LineParser("Direct_Color_"+t+" CODE -1 VALUE #"+t+" EDGE #"+t))}return this.materialLibrary[e]||null}applyMaterialsToMesh(e,t,a,r=!1){const n=this,i="16"===t;function s(e,s){if(i&&!(s in a)&&!r)return s;const o=e.isLineSegments||e.isConditionalLine;(!o&&"16"===s||o&&"24"===s)&&(s=t);let l=null;if(s in a)l=a[s];else{if(!r)return s;l=n.getMaterial(s),null===l&&(console.warn(`LDrawLoader: Material properties for code ${s} not available.`),l=n.missingColorMaterial)}return e.isLineSegments&&(l=n.edgeMaterialCache.get(l),e.isConditionalLine&&(l=n.conditionalEdgeMaterialCache.get(l))),l}e.traverse((e=>{if(e.isMesh||e.isLineSegments)if(Array.isArray(e.material))for(let t=0,a=e.material.length;t<a;t++)e.material[t].isMaterial||(e.material[t]=s(e,e.material[t]));else e.material.isMaterial||(e.material=s(e,e.material))}))}getMainMaterial(){return this.getMaterial("16")}getMainEdgeMaterial(){const e=this.getMaterial("24");return e?this.edgeMaterialCache.get(e):null}parseColorMetaDirective(e){let t=null,a="#FF00FF",r="#FF00FF",n=1,i=!1,s=0,o=0,l=null;const c=e.getToken();if(!c)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+e.getLineNumberString()+".");let h=null;for(;h=e.getToken(),h;)if(!u(h))switch(h.toUpperCase()){case"CODE":t=e.getToken();break;case"VALUE":if(a=e.getToken(),a.startsWith("0x"))a="#"+a.substring(2);else if(!a.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+e.getLineNumberString()+".");break;case"EDGE":if(r=e.getToken(),r.startsWith("0x"))r="#"+r.substring(2);else if(!r.startsWith("#")){if(l=this.getMaterial(r),!l)throw new Error("LDrawLoader: Invalid edge color while parsing material"+e.getLineNumberString()+".");l=this.edgeMaterialCache.get(l)}break;case"ALPHA":if(n=parseInt(e.getToken()),isNaN(n))throw new Error("LDrawLoader: Invalid alpha value in material definition"+e.getLineNumberString()+".");n=Math.max(0,Math.min(1,n/255)),n<1&&(i=!0);break;case"LUMINANCE":if(!u(e.getToken()))throw new Error("LDrawLoader: Invalid luminance value in material definition"+e.getLineNumberString()+".");break;case"CHROME":o=1;break;case"PEARLESCENT":o=2;break;case"RUBBER":o=3;break;case"MATTE_METALLIC":o=4;break;case"METAL":o=5;break;case"MATERIAL":e.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+h+'" while parsing material'+e.getLineNumberString()+".")}let d=null;switch(o){case 0:d=new MeshStandardMaterial({roughness:.3,metalness:0});break;case 2:d=new MeshStandardMaterial({roughness:.3,metalness:.25});break;case 1:d=new MeshStandardMaterial({roughness:0,metalness:1});break;case 3:d=new MeshStandardMaterial({roughness:.9,metalness:0});break;case 4:d=new MeshStandardMaterial({roughness:.8,metalness:.4});break;case 5:d=new MeshStandardMaterial({roughness:.2,metalness:.85})}if(d.color.setStyle(a,COLOR_SPACE_LDRAW),d.transparent=i,d.premultipliedAlpha=!0,d.opacity=n,d.depthWrite=!i,d.polygonOffset=!0,d.polygonOffsetFactor=1,0!==s&&d.emissive.setStyle(a,COLOR_SPACE_LDRAW).multiplyScalar(s),!l){if(l=new LineBasicMaterial({color:(new Color).setStyle(r,COLOR_SPACE_LDRAW),transparent:i,opacity:n,depthWrite:!i}),l.color,l.userData.code=t,l.name=c+" - Edge",null===this.ConditionalLineMaterial)throw new Error("THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().");const e=new this.ConditionalLineMaterial({fog:!0,transparent:i,depthWrite:!i,color:(new Color).setStyle(r,COLOR_SPACE_LDRAW),opacity:n});e.userData.code=t,e.name=c+" - Conditional Edge",this.conditionalEdgeMaterialCache.set(l,e)}return d.userData.code=t,d.name=c,this.edgeMaterialCache.set(d,l),this.addMaterial(d),d;function u(e){let t;return t=e.startsWith("LUMINANCE")?parseInt(e.substring(9)):parseInt(e),!isNaN(t)&&(s=Math.max(0,Math.min(1,t/255)),!0)}}computeBuildingSteps(e){let t=0;e.traverse((e=>{e.isGroup&&(e.userData.startingBuildingStep&&t++,e.userData.buildingStep=t)})),e.userData.numBuildingSteps=t+1}}export{LDrawLoader};
//# sourceMappingURL=LDrawLoader.js.map