{"version":3,"file":"node_modules/three/examples/jsm/loaders/LDrawLoader.js","names":["BufferAttribute","BufferGeometry","Color","FileLoader","Group","LineBasicMaterial","LineSegments","Loader","Matrix4","Mesh","MeshStandardMaterial","SRGBColorSpace","Vector3","Ray","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","COLOR_SPACE_LDRAW","_tempVec0","_tempVec1","ConditionalLineSegments","constructor","geometry","material","super","this","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","add","rh1","has","rh2","info","distances","set","get","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","author","subobjects","fileName","totalFaces","startingBuildingStep","materials","group","fetchData","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","_","Error","parse","text","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileMap","inverted","getData","Promise","ensureDataLoaded","then","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","LDrawPartsGeometryCache","parseCache","processIntoMesh","faceMaterials","processInfoSubobjects","async","subobject","promises","promise","loadModel","catch","error","subobjectInfos","all","subobjectInfo","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","ls","applyMatrix4","os","reverse","size","createObject","hasCachedModel","getCachedModel","parseModel","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","edgeMaterialCache","conditionalEdgeMaterialCache","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","WeakMap","partsCache","ConditionalLineMaterial","missingColorMaterial","DEFAULT_MATERIAL_NAME","color","roughness","metalness","missingEdgeColorMaterial","missingConditionalEdgeColorMaterial","setPartsLibraryPath","path","setConditionalLineMaterial","fog","preloadMaterials","url","colorLineRegex","directive","addMaterials","load","onLoad","onProgress","onError","addDefaultMaterials","computeBuildingSteps","setMaterials","clearMaterials","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","c","isLineSegments","traverse","isMesh","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mat","lineParser","fillColor","edgeColor","alpha","isTransparent","luminance","finishType","parseLuminance","toUpperCase","parseInt","isNaN","max","min","setStyle","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","conditionalEdgeMaterial","lum","model","stepNumber","buildingStep","numBuildingSteps"],"sources":["node_modules/three/examples/jsm/loaders/LDrawLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tSRGBColorSpace,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n/**\n * A loader for the LDraw format.\n *\n * [LDraw]{@link https://ldraw.org/} (LEGO Draw) is an [open format specification]{@link https://ldraw.org/article/218.html}\n * for describing LEGO and other construction set 3D models.\n *\n * An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction\n * piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are\n * loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,\n * extract to a folder and point setPartsLibraryPath to it.\n *\n * Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses\n * are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies\n * into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads\n * several packed files. The official parts library is not included due to its large size.\n *\n * `LDrawLoader` supports the following extensions:\n * - !COLOUR: Color and surface finish declarations.\n * - BFC: Back Face Culling specification.\n * - !CATEGORY: Model/part category declarations.\n * - !KEYWORDS: Model/part keywords declarations.\n *\n * ```js\n * const loader = new LDrawLoader();\n * loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer\n * const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n */\nclass LDrawLoader extends Loader {\n\n\t/**\n\t * Constructs a new LDraw loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// this material type must be injected via setConditionalLineMaterial()\n\t\tthis.ConditionalLineMaterial = null;\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = null;\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\t/**\n\t * This method must be called prior to `load()` unless the model to load does not reference\n\t * library parts (usually it will be a model with all its parts packed in a single file).\n\t *\n\t * @param {string} path - Path to library parts files to load referenced parts from.\n\t * This is different from Loader.setPath, which indicates the path to load the main asset from.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the conditional line material type which depends on the used renderer.\n\t * Use {@link LDrawConditionalLineMaterial} when using `WebGLRenderer` and\n\t * {@link LDrawConditionalLineNodeMaterial} when using `WebGPURenderer`.\n\t *\n\t * @param {(LDrawConditionalLineMaterial.constructor|LDrawConditionalLineNodeMaterial.constructor)} type - The conditional line material type.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetConditionalLineMaterial( type ) {\n\n\t\tthis.ConditionalLineMaterial = type;\n\t\tthis.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This async method preloads materials from a single LDraw file. In the official\n\t * parts library there is a special file which is loaded always the first (LDConfig.ldr)\n\t * and contains all the standard color codes. This method is intended to be used with\n\t * not packed files, for example in an editor where materials are preloaded and parts\n\t * are loaded on demand.\n\t *\n\t * @async\n\t * @param {string} url - Path of the LDraw materials asset.\n\t * @return {Promise} A Promise that resolves when the preload has finished.\n\t */\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMaterials( materials );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LDraw asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\t// Initializes the materials library with default materials\n\t\t\tthis.addDefaultMaterials();\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LDraw data and returns the resulting group.\n\t *\n\t * @param {string} text - The raw VRML data as a string.\n\t * @param {function(Group)} onLoad - Executed when the loading/parsing process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( text, onLoad, onError ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} )\n\t\t\t.catch( onError );\n\n\t}\n\n\t/**\n\t * Sets the loader's material library. This method clears existing\n\t * material definitions.\n\t *\n\t * @param {Array<Material>} materials - The materials to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetMaterials( materials ) {\n\n\t\tthis.clearMaterials();\n\t\tthis.addMaterials( materials );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the loader's material library.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tclearMaterials() {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a list of materials to the loader's material library.\n\t *\n\t * @param {Array<Material>} materials - The materials to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterials( materials ) {\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Initializes the loader with default materials.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddDefaultMaterials() {\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets a map which maps referenced library filenames to new filenames.\n\t * If a fileMap is not specified (the default), library parts will be accessed by trial and\n\t * error in subfolders 'parts', 'p' and 'models'.\n\t *\n\t * @param {Object<string,string>} fileMap - The file map to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a single material to the loader's material library.\n\t *\n\t * @param {Material} material - The material to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a material for the given color code.\n\t *\n\t * @param {string} colorCode - The color code.\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the Material for the main LDraw color.\n\t *\n\t * For an already loaded LDraw asset, returns the Material associated with the main color code.\n\t * This method can be useful to modify the main material of a model or part that exposes it.\n\t *\n\t * The main color code is the standard way to color an LDraw part. It is '16' for triangles and\n\t * '24' for edges. Usually a complete model will not expose the main color (that is, no part\n\t * uses the code '16' at the top level, because they are assigned other specific colors) An LDraw\n\t *  part file on the other hand will expose the code '16' to be colored, and can have additional\n\t * fixed colors.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\t/**\n\t * Returns the material for the edges main LDraw color.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\tif ( this.ConditionalLineMaterial === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().' );\n\n\t\t\t}\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new this.ConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n"],"mappings":"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","ignoreList":[]}