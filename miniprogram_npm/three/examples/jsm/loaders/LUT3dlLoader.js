import{ClampToEdgeWrapping,Data3DTexture,FileLoader,LinearFilter,Loader,RGBAFormat,UnsignedByteType}from"three";export class LUT3dlLoader extends Loader{constructor(e){super(e),this.type=UnsignedByteType}setType(e){return this.type=e,this}load(e,t,r,a){const n=new FileLoader(this.manager);n.setPath(this.path),n.setResponseType("text"),n.load(e,(r=>{try{t(this.parse(r))}catch(t){a?a(t):console.error(t),this.manager.itemError(e)}}),r,a)}parse(e){const t=/^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;let r=/^[\d ]+$/m.exec(e);if(null===r)throw new Error("LUT3dlLoader: Missing grid information");const a=r[0].trim().split(/\s+/g).map(Number),n=a[1]-a[0],i=a.length,o=i**2;for(let e=1,t=a.length;e<t;++e)if(n!==a[e]-a[e-1])throw new Error("LUT3dlLoader: Inconsistent grid size");const s=new Float32Array(i**3*4);let p=0,l=0;for(;null!==(r=t.exec(e));){const e=Number(r[1]),t=Number(r[2]),a=Number(r[3]);p=Math.max(p,e,t,a);const n=4*(l%i*o+Math.floor(l/i)%i*i+Math.floor(l/o)%i);s[n+0]=e,s[n+1]=t,s[n+2]=a,++l}const d=Math.ceil(Math.log2(p)),g=Math.pow(2,d),h=this.type===UnsignedByteType?new Uint8Array(s.length):s,m=this.type===UnsignedByteType?255:1;for(let e=0,t=h.length;e<t;e+=4){const t=e+1,r=e+2,a=e+3;h[e]=s[e]/g*m,h[t]=s[t]/g*m,h[r]=s[r]/g*m,h[a]=m}const c=new Data3DTexture;return c.image.data=h,c.image.width=i,c.image.height=i,c.image.depth=i,c.format=RGBAFormat,c.type=this.type,c.magFilter=LinearFilter,c.minFilter=LinearFilter,c.wrapS=ClampToEdgeWrapping,c.wrapT=ClampToEdgeWrapping,c.wrapR=ClampToEdgeWrapping,c.generateMipmaps=!1,c.needsUpdate=!0,{size:i,texture3D:c}}}
//# sourceMappingURL=LUT3dlLoader.js.map