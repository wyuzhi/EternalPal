import{ClampToEdgeWrapping,Data3DTexture,FileLoader,LinearFilter,Loader,UnsignedByteType,Vector3}from"three";export class LUTCubeLoader extends Loader{constructor(e){super(e),this.type=UnsignedByteType}setType(e){return this.type=e,this}load(e,t,r,a){const n=new FileLoader(this.manager);n.setPath(this.path),n.setResponseType("text"),n.load(e,(r=>{try{t(this.parse(r))}catch(t){a?a(t):console.error(t),this.manager.itemError(e)}}),r,a)}parse(e){const t=/^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;let r=/TITLE +"([^"]*)"/.exec(e);const a=null!==r?r[1]:null;if(r=/LUT_3D_SIZE +(\d+)/.exec(e),null===r)throw new Error("LUTCubeLoader: Missing LUT_3D_SIZE information");const n=Number(r[1]),i=n**3*4,o=this.type===UnsignedByteType?new Uint8Array(i):new Float32Array(i),s=new Vector3(0,0,0),p=new Vector3(1,1,1);if(r=/DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e),null!==r&&s.set(Number(r[1]),Number(r[2]),Number(r[3])),r=/DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e),null!==r&&p.set(Number(r[1]),Number(r[2]),Number(r[3])),s.x>p.x||s.y>p.y||s.z>p.z)throw new Error("LUTCubeLoader: Invalid input domain");const d=this.type===UnsignedByteType?255:1;let l=0;for(;null!==(r=t.exec(e));)o[l++]=Number(r[1])*d,o[l++]=Number(r[2])*d,o[l++]=Number(r[3])*d,o[l++]=d;const m=new Data3DTexture;return m.image.data=o,m.image.width=n,m.image.height=n,m.image.depth=n,m.type=this.type,m.magFilter=LinearFilter,m.minFilter=LinearFilter,m.wrapS=ClampToEdgeWrapping,m.wrapT=ClampToEdgeWrapping,m.wrapR=ClampToEdgeWrapping,m.generateMipmaps=!1,m.needsUpdate=!0,{title:a,size:n,domainMin:s,domainMax:p,texture3D:m}}}
//# sourceMappingURL=LUTCubeLoader.js.map