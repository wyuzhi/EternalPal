{"version":3,"file":"node_modules/three/examples/jsm/loaders/LWOLoader.js","names":["AddOperation","BackSide","BufferGeometry","ClampToEdgeWrapping","Color","DoubleSide","EquirectangularReflectionMapping","EquirectangularRefractionMapping","FileLoader","Float32BufferAttribute","FrontSide","LineBasicMaterial","LineSegments","Loader","Mesh","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MirroredRepeatWrapping","Points","PointsMaterial","RepeatWrapping","SRGBColorSpace","TextureLoader","Vector2","IFFParser","_lwoTree","LWOLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","resourcePath","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","filtered","filter","Boolean","length","m","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","attributes","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","refractionRatio","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","undefined","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","colorSpace","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","aoMap","fromArray","value","Transparency","opacity","bumpScale","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","setAttribute","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","Array","from","count","uvs","uvIndices","j","morphTargets","remappedPoints","array","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf"],"sources":["node_modules/three/examples/jsm/loaders/LWOLoader.js"],"sourcesContent":["import {\n\tAddOperation,\n\tBackSide,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMesh,\n\tMeshPhongMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tPoints,\n\tPointsMaterial,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tVector2\n} from 'three';\n\nimport { IFFParser } from './lwo/IFFParser.js';\n\nlet _lwoTree;\n\n/**\n * A loader for the LWO format.\n *\n * LWO3 and LWO2 formats are supported.\n *\n * References:\n * - [LWO3 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html}\n * - [LWO2 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html}\n *\n * ```js\n * const loader = new LWOLoader();\n * const lwoData = await loader.loadAsync( 'models/lwo/Objects/LWO3/Demo.lwo' );\n *\n * const mesh = object.meshes[ 0 ];\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { LWOLoader } from 'three/addons/loaders/LWOLoader.js';\n */\nclass LWOLoader extends Loader {\n\n\t/**\n\t * Constructs a new LWO loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LWO asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({meshes:Array<Mesh>,materials:Array<Material>})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? extractParentUrl( url, 'Objects' ) : scope.path;\n\n\t\t// give the mesh a default name based on the filename\n\t\tconst modelName = url.split( path ).pop().split( '.' )[ 0 ];\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t// console.time( 'Total parsing: ' );\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path, modelName ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'Total parsing: ' );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LWO data and returns the resulting meshes and materials.\n\t *\n\t * @param {ArrayBuffer} iffBuffer - The raw LWO data as an array buffer.\n\t * @param {string} path - The URL base path.\n\t * @param {string} modelName - The model name.\n\t * @return {{meshes:Array<Mesh>,materials:Array<Material>}} An object holding the parse meshes and materials.\n\t */\n\tparse( iffBuffer, path, modelName ) {\n\n\t\t_lwoTree = new IFFParser().parse( iffBuffer );\n\n\t\t// console.log( 'lwoTree', lwoTree );\n\n\t\tconst textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new LWOTreeParser( textureLoader ).parse( modelName );\n\n\t}\n\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse( modelName ) {\n\n\t\tthis.materials = new MaterialParser( this.textureLoader ).parse();\n\t\tthis.defaultLayerName = modelName;\n\n\t\tthis.meshes = this.parseLayers();\n\n\t\treturn {\n\t\t\tmaterials: this.materials,\n\t\t\tmeshes: this.meshes,\n\t\t};\n\n\t}\n\n\tparseLayers() {\n\n\t\t// array of all meshes for building hierarchy\n\t\tconst meshes = [];\n\n\t\t// final array containing meshes with scene graph hierarchy set up\n\t\tconst finalMeshes = [];\n\n\t\tconst geometryParser = new GeometryParser();\n\n\t\tconst scope = this;\n\t\t_lwoTree.layers.forEach( function ( layer ) {\n\n\t\t\tconst geometry = geometryParser.parse( layer.geometry, layer );\n\n\t\t\tconst mesh = scope.parseMesh( geometry, layer );\n\n\t\t\tmeshes[ layer.number ] = mesh;\n\n\t\t\tif ( layer.parent === - 1 ) finalMeshes.push( mesh );\n\t\t\telse meshes[ layer.parent ].add( mesh );\n\n\n\t\t} );\n\n\t\tthis.applyPivots( finalMeshes );\n\n\t\treturn finalMeshes;\n\n\t}\n\n\tparseMesh( geometry, layer ) {\n\n\t\tlet mesh;\n\n\t\tconst materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type );\n\n\t\tif ( layer.geometry.type === 'points' ) mesh = new Points( geometry, materials );\n\t\telse if ( layer.geometry.type === 'lines' ) mesh = new LineSegments( geometry, materials );\n\t\telse mesh = new Mesh( geometry, materials );\n\n\t\tif ( layer.name ) mesh.name = layer.name;\n\t\telse mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n\n\t\tmesh.userData.pivot = layer.pivot;\n\n\t\treturn mesh;\n\n\t}\n\n\t// TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\tapplyPivots( meshes ) {\n\n\t\tmeshes.forEach( function ( mesh ) {\n\n\t\t\tmesh.traverse( function ( child ) {\n\n\t\t\t\tconst pivot = child.userData.pivot;\n\n\t\t\t\tchild.position.x += pivot[ 0 ];\n\t\t\t\tchild.position.y += pivot[ 1 ];\n\t\t\t\tchild.position.z += pivot[ 2 ];\n\n\t\t\t\tif ( child.parent ) {\n\n\t\t\t\t\tconst parentPivot = child.parent.userData.pivot;\n\n\t\t\t\t\tchild.position.x -= parentPivot[ 0 ];\n\t\t\t\t\tchild.position.y -= parentPivot[ 1 ];\n\t\t\t\t\tchild.position.z -= parentPivot[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tgetMaterials( namesArray, type ) {\n\n\t\tconst materials = [];\n\n\t\tconst scope = this;\n\n\t\tnamesArray.forEach( function ( name, i ) {\n\n\t\t\tmaterials[ i ] = scope.getMaterialByName( name );\n\n\t\t} );\n\n\t\t// convert materials to line or point mats if required\n\t\tif ( type === 'points' || type === 'lines' ) {\n\n\t\t\tmaterials.forEach( function ( mat, i ) {\n\n\t\t\t\tconst spec = {\n\t\t\t\t\tcolor: mat.color,\n\t\t\t\t};\n\n\t\t\t\tif ( type === 'points' ) {\n\n\t\t\t\t\tspec.size = 0.1;\n\t\t\t\t\tspec.map = mat.map;\n\t\t\t\t\tmaterials[ i ] = new PointsMaterial( spec );\n\n\t\t\t\t} else if ( type === 'lines' ) {\n\n\t\t\t\t\tmaterials[ i ] = new LineBasicMaterial( spec );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// if there is only one material, return that directly instead of array\n\t\tconst filtered = materials.filter( Boolean );\n\t\tif ( filtered.length === 1 ) return filtered[ 0 ];\n\n\t\treturn materials;\n\n\t}\n\n\tgetMaterialByName( name ) {\n\n\t\treturn this.materials.filter( function ( m ) {\n\n\t\t\treturn m.name === name;\n\n\t\t} )[ 0 ];\n\n\t}\n\n}\n\nclass MaterialParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse() {\n\n\t\tconst materials = [];\n\t\tthis.textures = {};\n\n\t\tfor ( const name in _lwoTree.materials ) {\n\n\t\t\tif ( _lwoTree.format === 'LWO3' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterial( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t} else if ( _lwoTree.format === 'LWO2' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterialLwo2( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseMaterial( materialData, name, textures ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst connections = this.parseConnections( materialData.connections, materialData.nodes );\n\n\t\tconst maps = this.parseTextureNodes( connections.maps );\n\n\t\tthis.parseAttributeImageMaps( connections.attributes, textures, maps );\n\n\t\tconst attributes = this.parseAttributes( connections.attributes, maps );\n\n\t\tthis.parseEnvMap( connections, maps, attributes );\n\n\t\tparams = Object.assign( maps, params );\n\t\tparams = Object.assign( params, attributes );\n\n\t\tconst materialType = this.getMaterialType( connections.attributes );\n\n\t\tif ( materialType !== MeshPhongMaterial ) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\"\n\n\t\treturn new materialType( params );\n\n\t}\n\n\tparseMaterialLwo2( materialData, name/*, textures*/ ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst attributes = this.parseAttributes( materialData.attributes, {} );\n\t\tparams = Object.assign( params, attributes );\n\t\treturn new MeshPhongMaterial( params );\n\n\t}\n\n\t// Note: converting from left to right handed coords by switching x -> -x in vertices, and\n\t// then switching mat FrontSide -> BackSide\n\t// NB: this means that FrontSide and BackSide have been switched!\n\tgetSide( attributes ) {\n\n\t\tif ( ! attributes.side ) return BackSide;\n\n\t\tswitch ( attributes.side ) {\n\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\treturn BackSide;\n\t\t\tcase 2: return FrontSide;\n\t\t\tcase 3: return DoubleSide;\n\n\t\t}\n\n\t}\n\n\tgetSmooth( attributes ) {\n\n\t\tif ( ! attributes.smooth ) return true;\n\t\treturn ! attributes.smooth;\n\n\t}\n\n\tparseConnections( connections, nodes ) {\n\n\t\tconst materialConnections = {\n\t\t\tmaps: {}\n\t\t};\n\n\t\tconst inputName = connections.inputName;\n\t\tconst inputNodeName = connections.inputNodeName;\n\t\tconst nodeName = connections.nodeName;\n\n\t\tconst scope = this;\n\t\tinputName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === 'Material' ) {\n\n\t\t\t\tconst matNode = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\t\t\t\tmaterialConnections.attributes = matNode.attributes;\n\t\t\t\tmaterialConnections.envMap = matNode.fileName;\n\t\t\t\tmaterialConnections.name = inputNodeName[ index ];\n\n\t\t\t}\n\n\t\t} );\n\n\t\tnodeName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === materialConnections.name ) {\n\n\t\t\t\tmaterialConnections.maps[ inputName[ index ] ] = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn materialConnections;\n\n\t}\n\n\tgetNodeByRefName( refName, nodes ) {\n\n\t\tfor ( const name in nodes ) {\n\n\t\t\tif ( nodes[ name ].refName === refName ) return nodes[ name ];\n\n\t\t}\n\n\t}\n\n\tparseTextureNodes( textureNodes ) {\n\n\t\tconst maps = {};\n\n\t\tfor ( const name in textureNodes ) {\n\n\t\t\tconst node = textureNodes[ name ];\n\t\t\tconst path = node.fileName;\n\n\t\t\tif ( ! path ) return;\n\n\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\tif ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode );\n\t\t\tif ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode );\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'Color':\n\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Roughness':\n\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Specular':\n\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous':\n\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous Color':\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Metallic':\n\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Transparency':\n\t\t\t\tcase 'Alpha':\n\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Normal':\n\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\tif ( node.amplitude !== undefined ) maps.normalScale = new Vector2( node.amplitude, node.amplitude );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// LWO BSDF materials can have both spec and rough, but this is not valid in three\n\t\tif ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap;\n\n\t\treturn maps;\n\n\t}\n\n\t// maps can also be defined on individual material attributes, parse those here\n\t// This occurs on Standard (Phong) surfaces\n\tparseAttributeImageMaps( attributes, textures, maps ) {\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute.maps ) {\n\n\t\t\t\tconst mapData = attribute.maps[ 0 ];\n\n\t\t\t\tconst path = this.getTexturePathByIndex( mapData.imageIndex );\n\t\t\t\tif ( ! path ) return;\n\n\t\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w );\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h );\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Diffuse':\n\t\t\t\t\t\tmaps.aoMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Roughness':\n\t\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Specular':\n\t\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Luminosity':\n\t\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Metallic':\n\t\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Transparency':\n\t\t\t\t\tcase 'Alpha':\n\t\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseAttributes( attributes, maps ) {\n\n\t\tconst params = {};\n\n\t\t// don't use color data if color map is present\n\t\tif ( attributes.Color && ! maps.map ) {\n\n\t\t\tparams.color = new Color().fromArray( attributes.Color.value );\n\n\t\t} else {\n\n\t\t\tparams.color = new Color();\n\n\t\t}\n\n\n\t\tif ( attributes.Transparency && attributes.Transparency.value !== 0 ) {\n\n\t\t\tparams.opacity = 1 - attributes.Transparency.value;\n\t\t\tparams.transparent = true;\n\n\t\t}\n\n\t\tif ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1;\n\n\t\tthis.parsePhysicalAttributes( params, attributes, maps );\n\t\tthis.parseStandardAttributes( params, attributes, maps );\n\t\tthis.parsePhongAttributes( params, attributes, maps );\n\n\t\treturn params;\n\n\t}\n\n\tparsePhysicalAttributes( params, attributes/*, maps*/ ) {\n\n\t\tif ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) {\n\n\t\t\tparams.clearcoat = attributes.Clearcoat.value;\n\n\t\t\tif ( attributes[ 'Clearcoat Gloss' ] ) {\n\n\t\t\t\tparams.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseStandardAttributes( params, attributes, maps ) {\n\n\n\t\tif ( attributes.Luminous ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminous.value;\n\n\t\t\tif ( attributes[ 'Luminous Color' ] && ! maps.emissive ) {\n\n\t\t\t\tparams.emissive = new Color().fromArray( attributes[ 'Luminous Color' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value;\n\t\tif ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value;\n\n\t}\n\n\tparsePhongAttributes( params, attributes, maps ) {\n\n\t\tif ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 0.98 / attributes[ 'Refraction Index' ].value;\n\n\t\tif ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value );\n\n\t\tif ( attributes.Reflection ) {\n\n\t\t\tparams.reflectivity = attributes.Reflection.value;\n\t\t\tparams.combine = AddOperation;\n\n\t\t}\n\n\t\tif ( attributes.Luminosity ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminosity.value;\n\n\t\t\tif ( ! maps.emissiveMap && ! maps.map ) {\n\n\t\t\t\tparams.emissive = params.color;\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\t\tif ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) {\n\n\t\t\tif ( attributes[ 'Color Highlight' ] ) {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 );\n\n\t}\n\n\tparseEnvMap( connections, maps, attributes ) {\n\n\t\tif ( connections.envMap ) {\n\n\t\t\tconst envMap = this.loadTexture( connections.envMap );\n\n\t\t\tif ( attributes.transparent && attributes.opacity < 0.999 ) {\n\n\t\t\t\tenvMap.mapping = EquirectangularRefractionMapping;\n\n\t\t\t\t// Reflectivity and refraction mapping don't work well together in Phong materials\n\t\t\t\tif ( attributes.reflectivity !== undefined ) {\n\n\t\t\t\t\tdelete attributes.reflectivity;\n\t\t\t\t\tdelete attributes.combine;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes.metalness !== undefined ) {\n\n\t\t\t\t\tattributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible\n\n\t\t\t\t}\n\n\t\t\t\tattributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.\n\n\t\t\t} else envMap.mapping = EquirectangularReflectionMapping;\n\n\t\t\tmaps.envMap = envMap;\n\n\t\t}\n\n\t}\n\n\t// get texture defined at top level by its index\n\tgetTexturePathByIndex( index ) {\n\n\t\tlet fileName = '';\n\n\t\tif ( ! _lwoTree.textures ) return fileName;\n\n\t\t_lwoTree.textures.forEach( function ( texture ) {\n\n\t\t\tif ( texture.index === index ) fileName = texture.fileName;\n\n\t\t} );\n\n\t\treturn fileName;\n\n\t}\n\n\tloadTexture( path ) {\n\n\t\tif ( ! path ) return null;\n\n\t\tconst texture = this.textureLoader.load(\n\t\t\tpath,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfunction () {\n\n\t\t\t\tconsole.warn( 'LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.' );\n\n\t\t\t}\n\t\t);\n\n\t\treturn texture;\n\n\t}\n\n\t// 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\tgetWrappingType( num ) {\n\n\t\tswitch ( num ) {\n\n\t\t\tcase 0:\n\t\t\t\tconsole.warn( 'LWOLoader: \"Reset\" texture wrapping type is not supported in three.js' );\n\t\t\t\treturn ClampToEdgeWrapping;\n\t\t\tcase 1: return RepeatWrapping;\n\t\t\tcase 2: return MirroredRepeatWrapping;\n\t\t\tcase 3: return ClampToEdgeWrapping;\n\n\t\t}\n\n\t}\n\n\tgetMaterialType( nodeData ) {\n\n\t\tif ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return MeshPhysicalMaterial;\n\t\tif ( nodeData.Roughness ) return MeshStandardMaterial;\n\t\treturn MeshPhongMaterial;\n\n\t}\n\n}\n\nclass GeometryParser {\n\n\tparse( geoData, layer ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( geoData.points, 3 ) );\n\n\t\tconst indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions );\n\t\tgeometry.setIndex( indices );\n\n\t\tthis.parseGroups( geometry, geoData );\n\n\t\tgeometry.computeVertexNormals();\n\n\t\tthis.parseUVs( geometry, layer );\n\t\tthis.parseMorphTargets( geometry, layer );\n\n\t\t// TODO: z may need to be reversed to account for coordinate system change\n\t\tgeometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] );\n\n\t\t// let userData = geometry.userData;\n\t\t// geometry = geometry.toNonIndexed()\n\t\t// geometry.userData = userData;\n\n\t\treturn geometry;\n\n\t}\n\n\t// split quads into tris\n\tsplitIndices( indices, polygonDimensions ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tlet i = 0;\n\t\tpolygonDimensions.forEach( function ( dim ) {\n\n\t\t\tif ( dim < 4 ) {\n\n\t\t\t\tfor ( let k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push(\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 1 ],\n\t\t\t\t\tindices[ i + 2 ],\n\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 2 ],\n\t\t\t\t\tindices[ i + 3 ]\n\n\t\t\t\t);\n\n\t\t\t} else if ( dim > 4 ) {\n\n\t\t\t\tfor ( let k = 1; k < dim - 1; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' );\n\n\t\t\t}\n\n\t\t\ti += dim;\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\tparseGroups( geometry, geoData ) {\n\n\t\tconst tags = _lwoTree.tags;\n\t\tconst matNames = [];\n\n\t\tlet elemSize = 3;\n\t\tif ( geoData.type === 'lines' ) elemSize = 2;\n\t\tif ( geoData.type === 'points' ) elemSize = 1;\n\n\t\tconst remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices );\n\n\t\tlet indexNum = 0; // create new indices in numerical order\n\t\tconst indexPairs = {}; // original indices mapped to numerical indices\n\n\t\tlet prevMaterialIndex;\n\t\tlet materialIndex;\n\n\t\tlet prevStart = 0;\n\t\tlet currentCount = 0;\n\n\t\tfor ( let i = 0; i < remappedIndices.length; i += 2 ) {\n\n\t\t\tmaterialIndex = remappedIndices[ i + 1 ];\n\n\t\t\tif ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\tif ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex;\n\n\t\t\tif ( materialIndex !== prevMaterialIndex ) {\n\n\t\t\t\tlet currentIndex;\n\t\t\t\tif ( indexPairs[ tags[ prevMaterialIndex ] ] ) {\n\n\t\t\t\t\tcurrentIndex = indexPairs[ tags[ prevMaterialIndex ] ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\t\tindexPairs[ tags[ prevMaterialIndex ] ] = indexNum;\n\t\t\t\t\tmatNames[ indexNum ] = tags[ prevMaterialIndex ];\n\t\t\t\t\tindexNum ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t\t\tprevStart += currentCount;\n\n\t\t\t\tprevMaterialIndex = materialIndex;\n\t\t\t\tcurrentCount = 0;\n\n\t\t\t}\n\n\t\t\tcurrentCount += elemSize;\n\n\t\t}\n\n\t\t// the loop above doesn't add the last group, do that here.\n\t\tif ( geometry.groups.length > 0 ) {\n\n\t\t\tlet currentIndex;\n\t\t\tif ( indexPairs[ tags[ materialIndex ] ] ) {\n\n\t\t\t\tcurrentIndex = indexPairs[ tags[ materialIndex ] ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\tindexPairs[ tags[ materialIndex ] ] = indexNum;\n\t\t\t\tmatNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\t}\n\n\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t}\n\n\t\t// Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\t\tgeometry.userData.matNames = matNames;\n\n\t}\n\n\tsplitMaterialIndices( polygonDimensions, indices ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tpolygonDimensions.forEach( function ( dim, i ) {\n\n\t\t\tif ( dim <= 3 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ], indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else {\n\n\t\t\t\t // ignore > 4 for now\n\t\t\t\tfor ( let k = 0; k < dim - 2; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// UV maps:\n\t// 1: are defined via index into an array of points, not into a geometry\n\t// - the geometry is also defined by an index into this array, but the indexes may not match\n\t// 2: there can be any number of UV maps for a single geometry. Here these are combined,\n\t// \twith preference given to the first map encountered\n\t// 3: UV maps can be partial - that is, defined for only a part of the geometry\n\t// 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n\t// UV maps are defined as partially VMAP and partially VMAD\n\t// VMADs are currently not supported\n\tparseUVs( geometry, layer ) {\n\n\t\t// start by creating a UV map set to zero for the whole geometry\n\t\tconst remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () {\n\n\t\t\treturn 0;\n\n\t\t} );\n\n\t\tfor ( const name in layer.uvs ) {\n\n\t\t\tconst uvs = layer.uvs[ name ].uvs;\n\t\t\tconst uvIndices = layer.uvs[ name ].uvIndices;\n\n\t\t\tuvIndices.forEach( function ( i, j ) {\n\n\t\t\t\tremappedUVs[ i * 2 ] = uvs[ j * 2 ];\n\t\t\t\tremappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( remappedUVs, 2 ) );\n\n\t}\n\n\tparseMorphTargets( geometry, layer ) {\n\n\t\tlet num = 0;\n\t\tfor ( const name in layer.morphTargets ) {\n\n\t\t\tconst remappedPoints = geometry.attributes.position.array.slice();\n\n\t\t\tif ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = [];\n\n\t\t\tconst morphPoints = layer.morphTargets[ name ].points;\n\t\t\tconst morphIndices = layer.morphTargets[ name ].indices;\n\t\t\tconst type = layer.morphTargets[ name ].type;\n\n\t\t\tmorphIndices.forEach( function ( i, j ) {\n\n\t\t\t\tif ( type === 'relative' ) {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] += morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] = morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tgeometry.morphAttributes.position[ num ] = new Float32BufferAttribute( remappedPoints, 3 );\n\t\t\tgeometry.morphAttributes.position[ num ].name = name;\n\n\t\t\tnum ++;\n\n\t\t}\n\n\t\tgeometry.morphTargetsRelative = false;\n\n\t}\n\n}\n\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl( url, dir ) {\n\n\tconst index = url.indexOf( dir );\n\n\tif ( index === - 1 ) return './';\n\n\treturn url.slice( 0, index );\n\n}\n\nexport { LWOLoader };\n"],"mappings":"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","ignoreList":[]}