{"version":3,"file":"node_modules/three/examples/jsm/loaders/MDDLoader.js","names":["AnimationClip","BufferAttribute","FileLoader","Loader","NumberKeyframeTrack","MDDLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setResponseType","data","parse","view","DataView","totalFrames","getUint32","totalPoints","offset","times","Float32Array","values","fill","i","getFloat32","track","clip","length","morphTargets","morphTarget","j","stride","attribute","name","push"],"sources":["node_modules/three/examples/jsm/loaders/MDDLoader.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tBufferAttribute,\n\tFileLoader,\n\tLoader,\n\tNumberKeyframeTrack\n} from 'three';\n\n/**\n * A loader for the MDD format.\n *\n * MDD stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * - number of frames (a single uint32)\n * - number of vertices (a single uint32)\n * - time values for each frame (sequence of float32)\n * - vertex data for each frame (sequence of float32)\n *\n * ```js\n * const loader = new MDDLoader();\n * const result = await loader.loadAsync( 'models/mdd/cube.mdd' );\n *\n * const morphTargets = result.morphTargets;\n * const clip = result.clip;\n * // clip.optimize(); // optional\n *\n * const geometry = new THREE.BoxGeometry();\n * geometry.morphAttributes.position = morphTargets; // apply morph targets (vertex data must match)\n *\n * const material = new THREE.MeshBasicMaterial();\n *\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n *\n * const mixer = new THREE.AnimationMixer( mesh );\n * mixer.clipAction( clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { MDDLoader } from 'three/addons/loaders/MDDLoader.js';\n */\nclass MDDLoader extends Loader {\n\n\t/**\n\t * Constructs a new MDD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded MDD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({clip:AnimationClip, morphTargets:Array<BufferAttribute>})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\tonLoad( scope.parse( data ) );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given MDD data and returns an object holding the animation clip and the respective\n\t * morph targets.\n\t *\n\t * @param {ArrayBuffer} data - The raw XYZ data as an array buffer.\n\t * @return {{clip:AnimationClip, morphTargets:Array<BufferAttribute>}} The result object.\n\t */\n\tparse( data ) {\n\n\t\tconst view = new DataView( data );\n\n\t\tconst totalFrames = view.getUint32( 0 );\n\t\tconst totalPoints = view.getUint32( 4 );\n\n\t\tlet offset = 8;\n\n\t\t// animation clip\n\n\t\tconst times = new Float32Array( totalFrames );\n\t\tconst values = new Float32Array( totalFrames * totalFrames ).fill( 0 );\n\n\t\tfor ( let i = 0; i < totalFrames; i ++ ) {\n\n\t\t\ttimes[ i ] = view.getFloat32( offset ); offset += 4;\n\t\t\tvalues[ ( totalFrames * i ) + i ] = 1;\n\n\t\t}\n\n\t\tconst track = new NumberKeyframeTrack( '.morphTargetInfluences', times, values );\n\t\tconst clip = new AnimationClip( 'default', times[ times.length - 1 ], [ track ] );\n\n\t\t// morph targets\n\n\t\tconst morphTargets = [];\n\n\t\tfor ( let i = 0; i < totalFrames; i ++ ) {\n\n\t\t\tconst morphTarget = new Float32Array( totalPoints * 3 );\n\n\t\t\tfor ( let j = 0; j < totalPoints; j ++ ) {\n\n\t\t\t\tconst stride = ( j * 3 );\n\n\t\t\t\tmorphTarget[ stride + 0 ] = view.getFloat32( offset ); offset += 4; // x\n\t\t\t\tmorphTarget[ stride + 1 ] = view.getFloat32( offset ); offset += 4; // y\n\t\t\t\tmorphTarget[ stride + 2 ] = view.getFloat32( offset ); offset += 4; // z\n\n\t\t\t}\n\n\t\t\tconst attribute = new BufferAttribute( morphTarget, 3 );\n\t\t\tattribute.name = 'morph_' + i;\n\n\t\t\tmorphTargets.push( attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tmorphTargets: morphTargets,\n\t\t\tclip: clip\n\t\t};\n\n\t}\n\n}\n\nexport { MDDLoader };\n"],"mappings":"OACCA,cACAC,gBACAC,WACAC,OACAC,wBACM,QAsCP,MAAMC,kBAAkBF,OAOvB,WAAAG,CAAaC,GAEZC,MAAOD,EAER,CAWA,IAAAE,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQC,KAERC,EAAS,IAAId,WAAYa,KAAKR,SACpCS,EAAOC,QAASF,KAAKG,MACrBF,EAAOG,gBAAiB,eACxBH,EAAOP,KAAMC,GAAK,SAAWU,GAE5BT,EAAQG,EAAMO,MAAOD,GAEtB,GAAGR,EAAYC,EAEhB,CASA,KAAAQ,CAAOD,GAEN,MAAME,EAAO,IAAIC,SAAUH,GAErBI,EAAcF,EAAKG,UAAW,GAC9BC,EAAcJ,EAAKG,UAAW,GAEpC,IAAIE,EAAS,EAIb,MAAMC,EAAQ,IAAIC,aAAcL,GAC1BM,EAAS,IAAID,aAAcL,EAAcA,GAAcO,KAAM,GAEnE,IAAM,IAAIC,EAAI,EAAGA,EAAIR,EAAaQ,IAEjCJ,EAAOI,GAAMV,EAAKW,WAAYN,GAAUA,GAAU,EAClDG,EAAUN,EAAcQ,EAAMA,GAAM,EAIrC,MAAME,EAAQ,IAAI9B,oBAAqB,yBAA0BwB,EAAOE,GAClEK,EAAO,IAAInC,cAAe,UAAW4B,EAAOA,EAAMQ,OAAS,GAAK,CAAEF,IAIlEG,EAAe,GAErB,IAAM,IAAIL,EAAI,EAAGA,EAAIR,EAAaQ,IAAO,CAExC,MAAMM,EAAc,IAAIT,aAA4B,EAAdH,GAEtC,IAAM,IAAIa,EAAI,EAAGA,EAAIb,EAAaa,IAAO,CAExC,MAAMC,EAAe,EAAJD,EAEjBD,EAAaE,EAAS,GAAMlB,EAAKW,WAAYN,GAAUA,GAAU,EACjEW,EAAaE,EAAS,GAAMlB,EAAKW,WAAYN,GAAUA,GAAU,EACjEW,EAAaE,EAAS,GAAMlB,EAAKW,WAAYN,GAAUA,GAAU,CAElE,CAEA,MAAMc,EAAY,IAAIxC,gBAAiBqC,EAAa,GACpDG,EAAUC,KAAO,SAAWV,EAE5BK,EAAaM,KAAMF,EAEpB,CAEA,MAAO,CACNJ,aAAcA,EACdF,KAAMA,EAGR,SAIQ9B","ignoreList":[]}