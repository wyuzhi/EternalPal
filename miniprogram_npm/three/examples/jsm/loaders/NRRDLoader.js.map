{"version":3,"file":"node_modules/three/examples/jsm/loaders/NRRDLoader.js","names":["FileLoader","Loader","Matrix4","Vector3","fflate","Volume","NRRDLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","setSegmentation","segmentation","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","headerObject","_bytes","type","chunks","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","slice","array","chunkSize","u8","byteOffset","byteLength","i","j","k","tmp","flipEndianness","scan","_length","length","_header","_data_start","_parseChars","header","field","fn","l","m","_i","_len","lines","split","match","isNrrd","trim","_fieldFunctions","call","Error","encoding","vectors","push","spacings","isNaN","parseHeader","subarray","substring","gunzipSync","start","end","value","number","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","parseDataAsText","_copy","volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","xIndex","findIndex","vector","yIndex","zIndex","axisOrder","spacingX","fromArray","spacingY","spacingZ","spacing","matrix","transitionMatrix","space","set","v","ijk_to_transition","transition_to_ras","multiplyMatrices","inverseMatrix","copy","invert","RASDimensions","Math","floor","lowerThreshold","Infinity","upperThreshold","undefined","output","endian","dimension","dim","_ref","_results","space_origin","f","parts","_results2","_j","_len2"],"sources":["node_modules/three/examples/jsm/loaders/NRRDLoader.js"],"sourcesContent":["import {\n\tFileLoader,\n\tLoader,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nimport { Volume } from '../misc/Volume.js';\n\n/**\n * A loader for the NRRD format.\n *\n * ```js\n * const loader = new NRRDLoader();\n * const volume = await loader.loadAsync( 'models/nrrd/I.nrrd' );\n * ```\n *\n * @augments Loader\n * @three_import import { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';\n */\nclass NRRDLoader extends Loader {\n\n\t/**\n\t * Constructs a new NRRD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded NRRD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Volume)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Toggles the segmentation mode.\n\t *\n\t * @param {boolean} segmentation - Whether to use segmentation mode or not.\n\t */\n\tsetSegmentation( segmentation ) {\n\n\t\tthis.segmentation = segmentation;\n\n\t}\n\n\t/**\n\t * Parses the given NRRD data and returns the resulting volume data.\n\t *\n\t * @param {ArrayBuffer} data - The raw NRRD data as an array buffer.\n\t * @return {Volume} The parsed volume.\n\t */\n\tparse( data ) {\n\n\t\t// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n\t\tlet _data = data;\n\n\t\tlet _dataPointer = 0;\n\n\t\tconst _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0;\n\n\t\tconst _littleEndian = true;\n\n\t\tconst headerObject = {};\n\n\t\tfunction scan( type, chunks ) {\n\n\t\t\tlet _chunkSize = 1;\n\t\t\tlet _array_type = Uint8Array;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// 1 byte data types\n\t\t\t\tcase 'uchar':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'schar':\n\t\t\t\t\t_array_type = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\t// 2 byte data types\n\t\t\t\tcase 'ushort':\n\t\t\t\t\t_array_type = Uint16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sshort':\n\t\t\t\t\t_array_type = Int16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t// 4 byte data types\n\t\t\t\tcase 'uint':\n\t\t\t\t\t_array_type = Uint32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sint':\n\t\t\t\t\t_array_type = Int32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\t_array_type = Float32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complex':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// increase the data pointer in-place\n\t\t\tlet _bytes = new _array_type( _data.slice( _dataPointer,\n\t\t\t\t_dataPointer += chunks * _chunkSize ) );\n\n\t\t\t// if required, flip the endianness of the bytes\n\t\t\tif ( _nativeLittleEndian != _littleEndian ) {\n\n\t\t\t\t// we need to flip here since the format doesn't match the native endianness\n\t\t\t\t_bytes = flipEndianness( _bytes, _chunkSize );\n\n\t\t\t}\n\n\t\t\t// return the byte array\n\t\t\treturn _bytes;\n\n\t\t}\n\n\t\t//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\t\tfunction flipEndianness( array, chunkSize ) {\n\n\t\t\tconst u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength );\n\t\t\tfor ( let i = 0; i < array.byteLength; i += chunkSize ) {\n\n\t\t\t\tfor ( let j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) {\n\n\t\t\t\t\tconst tmp = u8[ k ];\n\t\t\t\t\tu8[ k ] = u8[ j ];\n\t\t\t\t\tu8[ j ] = tmp;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t//parse the header\n\t\tfunction parseHeader( header ) {\n\n\t\t\tlet data, field, fn, i, l, m, _i, _len;\n\t\t\tconst lines = header.split( /\\r?\\n/ );\n\t\t\tfor ( _i = 0, _len = lines.length; _i < _len; _i ++ ) {\n\n\t\t\t\tl = lines[ _i ];\n\t\t\t\tif ( l.match( /NRRD\\d+/ ) ) {\n\n\t\t\t\t\theaderObject.isNrrd = true;\n\n\t\t\t\t} else if ( ! l.match( /^#/ ) && ( m = l.match( /(.*):(.*)/ ) ) ) {\n\n\t\t\t\t\tfield = m[ 1 ].trim();\n\t\t\t\t\tdata = m[ 2 ].trim();\n\t\t\t\t\tfn = _fieldFunctions[ field ];\n\t\t\t\t\tif ( fn ) {\n\n\t\t\t\t\t\tfn.call( headerObject, data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\theaderObject[ field ] = data;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! headerObject.isNrrd ) {\n\n\t\t\t\tthrow new Error( 'Not an NRRD file' );\n\n\t\t\t}\n\n\t\t\tif ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) {\n\n\t\t\t\tthrow new Error( 'Bzip is not supported' );\n\n\t\t\t}\n\n\t\t\tif ( ! headerObject.vectors ) {\n\n\t\t\t\t//if no space direction is set, let's use the identity\n\t\t\t\theaderObject.vectors = [ ];\n\t\t\t\theaderObject.vectors.push( [ 1, 0, 0 ] );\n\t\t\t\theaderObject.vectors.push( [ 0, 1, 0 ] );\n\t\t\t\theaderObject.vectors.push( [ 0, 0, 1 ] );\n\n\t\t\t\t//apply spacing if defined\n\t\t\t\tif ( headerObject.spacings ) {\n\n\t\t\t\t\tfor ( i = 0; i <= 2; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isNaN( headerObject.spacings[ i ] ) ) {\n\n\t\t\t\t\t\t\tfor ( let j = 0; j <= 2; j ++ ) {\n\n\t\t\t\t\t\t\t\theaderObject.vectors[ i ][ j ] *= headerObject.spacings[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//parse the data when registered as one of this type : 'text', 'ascii', 'txt'\n\t\tfunction parseDataAsText( data, start, end ) {\n\n\t\t\tlet number = '';\n\t\t\tstart = start || 0;\n\t\t\tend = end || data.length;\n\t\t\tlet value;\n\t\t\t//length of the result is the product of the sizes\n\t\t\tconst lengthOfTheResult = headerObject.sizes.reduce( function ( previous, current ) {\n\n\t\t\t\treturn previous * current;\n\n\t\t\t}, 1 );\n\n\t\t\tlet base = 10;\n\t\t\tif ( headerObject.encoding === 'hex' ) {\n\n\t\t\t\tbase = 16;\n\n\t\t\t}\n\n\t\t\tconst result = new headerObject.__array( lengthOfTheResult );\n\t\t\tlet resultIndex = 0;\n\t\t\tlet parsingFunction = parseInt;\n\t\t\tif ( headerObject.__array === Float32Array || headerObject.__array === Float64Array ) {\n\n\t\t\t\tparsingFunction = parseFloat;\n\n\t\t\t}\n\n\t\t\tfor ( let i = start; i < end; i ++ ) {\n\n\t\t\t\tvalue = data[ i ];\n\t\t\t\t//if value is not a space\n\t\t\t\tif ( ( value < 9 || value > 13 ) && value !== 32 ) {\n\n\t\t\t\t\tnumber += String.fromCharCode( value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\t\t\tresultIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnumber = '';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( number !== '' ) {\n\n\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\tresultIndex ++;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tconst _bytes = scan( 'uchar', data.byteLength );\n\t\tconst _length = _bytes.length;\n\t\tlet _header = null;\n\t\tlet _data_start = 0;\n\t\tlet i;\n\t\tfor ( i = 1; i < _length; i ++ ) {\n\n\t\t\tif ( _bytes[ i - 1 ] == 10 && _bytes[ i ] == 10 ) {\n\n\t\t\t\t// we found two line breaks in a row\n\t\t\t\t// now we know what the header is\n\t\t\t\t_header = this._parseChars( _bytes, 0, i - 2 );\n\t\t\t\t// this is were the data starts\n\t\t\t\t_data_start = i + 1;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse the header\n\t\tparseHeader( _header );\n\n\t\t_data = _bytes.subarray( _data_start ); // the data without header\n\t\tif ( headerObject.encoding.substring( 0, 2 ) === 'gz' ) {\n\n\t\t\t// we need to decompress the datastream\n\t\t\t// here we start the unzipping and get a typed Uint8Array back\n\t\t\t_data = fflate.gunzipSync( new Uint8Array( _data ) );\n\n\t\t} else if ( headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex' ) {\n\n\t\t\t_data = parseDataAsText( _data );\n\n\t\t} else if ( headerObject.encoding === 'raw' ) {\n\n\t\t\t//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n\t\t\tconst _copy = new Uint8Array( _data.length );\n\n\t\t\tfor ( let i = 0; i < _data.length; i ++ ) {\n\n\t\t\t\t_copy[ i ] = _data[ i ];\n\n\t\t\t}\n\n\t\t\t_data = _copy;\n\n\t\t}\n\n\t\t// .. let's use the underlying array buffer\n\t\t_data = _data.buffer;\n\n\t\tconst volume = new Volume();\n\t\tvolume.header = headerObject;\n\t\tvolume.segmentation = this.segmentation;\n\t\t//\n\t\t// parse the (unzipped) data to a datastream of the correct type\n\t\t//\n\t\tvolume.data = new headerObject.__array( _data );\n\t\t// get the min and max intensities\n\t\tconst min_max = volume.computeMinMax();\n\t\tconst min = min_max[ 0 ];\n\t\tconst max = min_max[ 1 ];\n\t\t// attach the scalar range to the volume\n\t\tvolume.windowLow = min;\n\t\tvolume.windowHigh = max;\n\n\t\t// get the image dimensions\n\t\tvolume.dimensions = [ headerObject.sizes[ 0 ], headerObject.sizes[ 1 ], headerObject.sizes[ 2 ] ];\n\t\tvolume.xLength = volume.dimensions[ 0 ];\n\t\tvolume.yLength = volume.dimensions[ 1 ];\n\t\tvolume.zLength = volume.dimensions[ 2 ];\n\n\t\t// Identify axis order in the space-directions matrix from the header if possible.\n\t\tif ( headerObject.vectors ) {\n\n\t\t\tconst xIndex = headerObject.vectors.findIndex( vector => vector[ 0 ] !== 0 );\n\t\t\tconst yIndex = headerObject.vectors.findIndex( vector => vector[ 1 ] !== 0 );\n\t\t\tconst zIndex = headerObject.vectors.findIndex( vector => vector[ 2 ] !== 0 );\n\n\t\t\tconst axisOrder = [];\n\n\t\t\tif ( xIndex !== yIndex && xIndex !== zIndex && yIndex !== zIndex ) {\n\n\t\t\t\taxisOrder[ xIndex ] = 'x';\n\t\t\t\taxisOrder[ yIndex ] = 'y';\n\t\t\t\taxisOrder[ zIndex ] = 'z';\n\n\t\t\t} else {\n\n\t\t\t\taxisOrder[ 0 ] = 'x';\n\t\t\t\taxisOrder[ 1 ] = 'y';\n\t\t\t\taxisOrder[ 2 ] = 'z';\n\n\t\t\t}\n\n\t\t\tvolume.axisOrder = axisOrder;\n\n\t\t} else {\n\n\t\t\tvolume.axisOrder = [ 'x', 'y', 'z' ];\n\n\t\t}\n\n\t\t// spacing\n\t\tconst spacingX = new Vector3().fromArray( headerObject.vectors[ 0 ] ).length();\n\t\tconst spacingY = new Vector3().fromArray( headerObject.vectors[ 1 ] ).length();\n\t\tconst spacingZ = new Vector3().fromArray( headerObject.vectors[ 2 ] ).length();\n\t\tvolume.spacing = [ spacingX, spacingY, spacingZ ];\n\n\n\t\t// Create IJKtoRAS matrix\n\t\tvolume.matrix = new Matrix4();\n\n\t\tconst transitionMatrix = new Matrix4();\n\n\t\tif ( headerObject.space === 'left-posterior-superior' ) {\n\n\t\t\ttransitionMatrix.set(\n\t\t\t\t- 1, 0, 0, 0,\n\t\t\t\t0, - 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t} else if ( headerObject.space === 'left-anterior-superior' ) {\n\n\t\t\ttransitionMatrix.set(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, - 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t}\n\n\n\t\tif ( ! headerObject.vectors ) {\n\n\t\t\tvolume.matrix.set(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1 );\n\n\t\t} else {\n\n\t\t\tconst v = headerObject.vectors;\n\n\t\t\tconst ijk_to_transition = new Matrix4().set(\n\t\t\t\tv[ 0 ][ 0 ], v[ 1 ][ 0 ], v[ 2 ][ 0 ], 0,\n\t\t\t\tv[ 0 ][ 1 ], v[ 1 ][ 1 ], v[ 2 ][ 1 ], 0,\n\t\t\t\tv[ 0 ][ 2 ], v[ 1 ][ 2 ], v[ 2 ][ 2 ], 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tconst transition_to_ras = new Matrix4().multiplyMatrices( ijk_to_transition, transitionMatrix );\n\n\t\t\tvolume.matrix = transition_to_ras;\n\n\t\t}\n\n\t\tvolume.inverseMatrix = new Matrix4();\n\t\tvolume.inverseMatrix.copy( volume.matrix ).invert();\n\n\t\tvolume.RASDimensions = [\n\t\t\tMath.floor( volume.xLength * spacingX ),\n\t\t\tMath.floor( volume.yLength * spacingY ),\n\t\t\tMath.floor( volume.zLength * spacingZ )\n\t\t];\n\n\t\t// .. and set the default threshold\n\t\t// only if the threshold was not already set\n\t\tif ( volume.lowerThreshold === - Infinity ) {\n\n\t\t\tvolume.lowerThreshold = min;\n\n\t\t}\n\n\t\tif ( volume.upperThreshold === Infinity ) {\n\n\t\t\tvolume.upperThreshold = max;\n\n\t\t}\n\n\t\treturn volume;\n\n\t}\n\n\t_parseChars( array, start, end ) {\n\n\t\t// without borders, use the whole array\n\t\tif ( start === undefined ) {\n\n\t\t\tstart = 0;\n\n\t\t}\n\n\t\tif ( end === undefined ) {\n\n\t\t\tend = array.length;\n\n\t\t}\n\n\t\tlet output = '';\n\t\t// create and append the chars\n\t\tlet i = 0;\n\t\tfor ( i = start; i < end; ++ i ) {\n\n\t\t\toutput += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst _fieldFunctions = {\n\n\ttype: function ( data ) {\n\n\t\tswitch ( data ) {\n\n\t\t\tcase 'uchar':\n\t\t\tcase 'unsigned char':\n\t\t\tcase 'uint8':\n\t\t\tcase 'uint8_t':\n\t\t\t\tthis.__array = Uint8Array;\n\t\t\t\tbreak;\n\t\t\tcase 'signed char':\n\t\t\tcase 'int8':\n\t\t\tcase 'int8_t':\n\t\t\t\tthis.__array = Int8Array;\n\t\t\t\tbreak;\n\t\t\tcase 'short':\n\t\t\tcase 'short int':\n\t\t\tcase 'signed short':\n\t\t\tcase 'signed short int':\n\t\t\tcase 'int16':\n\t\t\tcase 'int16_t':\n\t\t\t\tthis.__array = Int16Array;\n\t\t\t\tbreak;\n\t\t\tcase 'ushort':\n\t\t\tcase 'unsigned short':\n\t\t\tcase 'unsigned short int':\n\t\t\tcase 'uint16':\n\t\t\tcase 'uint16_t':\n\t\t\t\tthis.__array = Uint16Array;\n\t\t\t\tbreak;\n\t\t\tcase 'int':\n\t\t\tcase 'signed int':\n\t\t\tcase 'int32':\n\t\t\tcase 'int32_t':\n\t\t\t\tthis.__array = Int32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'uint':\n\t\t\tcase 'unsigned int':\n\t\t\tcase 'uint32':\n\t\t\tcase 'uint32_t':\n\t\t\t\tthis.__array = Uint32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'float':\n\t\t\t\tthis.__array = Float32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'double':\n\t\t\t\tthis.__array = Float64Array;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'Unsupported NRRD data type: ' + data );\n\n\t\t}\n\n\t\treturn this.type = data;\n\n\t},\n\n\tendian: function ( data ) {\n\n\t\treturn this.endian = data;\n\n\t},\n\n\tencoding: function ( data ) {\n\n\t\treturn this.encoding = data;\n\n\t},\n\n\tdimension: function ( data ) {\n\n\t\treturn this.dim = parseInt( data, 10 );\n\n\t},\n\n\tsizes: function ( data ) {\n\n\t\tlet i;\n\t\treturn this.sizes = ( function () {\n\n\t\t\tconst _ref = data.split( /\\s+/ );\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = _ref.length; _i < _len; _i ++ ) {\n\n\t\t\t\ti = _ref[ _i ];\n\t\t\t\t_results.push( parseInt( i, 10 ) );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t},\n\n\tspace: function ( data ) {\n\n\t\treturn this.space = data;\n\n\t},\n\n\t'space origin': function ( data ) {\n\n\t\treturn this.space_origin = data.split( '(' )[ 1 ].split( ')' )[ 0 ].split( ',' );\n\n\t},\n\n\t'space directions': function ( data ) {\n\n\t\tlet f, v;\n\t\tconst parts = data.match( /\\(.*?\\)/g );\n\t\treturn this.vectors = ( function () {\n\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\tv = parts[ _i ];\n\t\t\t\t_results.push( ( function () {\n\n\t\t\t\t\tconst _ref = v.slice( 1, - 1 ).split( /,/ );\n\t\t\t\t\tconst _results2 = [];\n\n\t\t\t\t\tfor ( let _j = 0, _len2 = _ref.length; _j < _len2; _j ++ ) {\n\n\t\t\t\t\t\tf = _ref[ _j ];\n\t\t\t\t\t\t_results2.push( parseFloat( f ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn _results2;\n\n\t\t\t\t} )() );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t},\n\n\tspacings: function ( data ) {\n\n\t\tlet f;\n\t\tconst parts = data.split( /\\s+/ );\n\t\treturn this.spacings = ( function () {\n\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\tf = parts[ _i ];\n\t\t\t\t_results.push( parseFloat( f ) );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t}\n\n};\n\nexport { NRRDLoader };\n"],"mappings":"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","ignoreList":[]}