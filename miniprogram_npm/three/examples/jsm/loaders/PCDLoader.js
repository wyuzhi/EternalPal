import{BufferGeometry,Color,FileLoader,Float32BufferAttribute,Int32BufferAttribute,Loader,Points,PointsMaterial,SRGBColorSpace}from"three";class PCDLoader extends Loader{constructor(e){super(e),this.littleEndian=!0}load(e,t,i,s){const n=this,r=new FileLoader(n.manager);r.setPath(n.path),r.setResponseType("arraybuffer"),r.setRequestHeader(n.requestHeader),r.setWithCredentials(n.withCredentials),r.load(e,(function(i){try{t(n.parse(i))}catch(t){s?s(t):console.error(t),n.manager.itemError(e)}}),i,s)}_getDataView(e,t,i,s){switch(i){case"F":return 8===s?e.getFloat64(t,this.littleEndian):e.getFloat32(t,this.littleEndian);case"I":return 1===s?e.getInt8(t):2===s?e.getInt16(t,this.littleEndian):e.getInt32(t,this.littleEndian);case"U":return 1===s?e.getUint8(t):2===s?e.getUint16(t,this.littleEndian):e.getUint32(t,this.littleEndian)}}parse(e){const t=function(e){const t={},i=new Uint8Array(e);let s="",n="",r=0,o=!1;const a=i.length;for(;r<a&&!1===o;){const e=String.fromCharCode(i[r++]);"\n"===e||"\r"===e?(n.trim().toLowerCase().startsWith("data")&&(o=!0),n=""):n+=e,s+=e}const l=s.search(/[\r\n]DATA\s(\S*)\s/i),d=/[\r\n]DATA\s(\S*)\s/i.exec(s.slice(l-1));if(t.data=d[1],t.headerLen=d[0].length+l,t.str=s.slice(0,t.headerLen),t.str=t.str.replace(/#.*/gi,""),t.version=/^VERSION (.*)/im.exec(t.str),t.fields=/^FIELDS (.*)/im.exec(t.str),t.size=/^SIZE (.*)/im.exec(t.str),t.type=/^TYPE (.*)/im.exec(t.str),t.count=/^COUNT (.*)/im.exec(t.str),t.width=/^WIDTH (.*)/im.exec(t.str),t.height=/^HEIGHT (.*)/im.exec(t.str),t.viewpoint=/^VIEWPOINT (.*)/im.exec(t.str),t.points=/^POINTS (.*)/im.exec(t.str),null!==t.version&&(t.version=parseFloat(t.version[1])),t.fields=null!==t.fields?t.fields[1].split(" "):[],null!==t.type&&(t.type=t.type[1].split(" ")),null!==t.width&&(t.width=parseInt(t.width[1])),null!==t.height&&(t.height=parseInt(t.height[1])),null!==t.viewpoint&&(t.viewpoint=t.viewpoint[1]),null!==t.points&&(t.points=parseInt(t.points[1],10)),null===t.points&&(t.points=t.width*t.height),null!==t.size&&(t.size=t.size[1].split(" ").map((function(e){return parseInt(e,10)}))),null!==t.count)t.count=t.count[1].split(" ").map((function(e){return parseInt(e,10)}));else{t.count=[];for(let e=0,i=t.fields.length;e<i;e++)t.count.push(1)}t.offset={};let f=0;for(let e=0,i=t.fields.length;e<i;e++)"ascii"===t.data?t.offset[t.fields[e]]=e:(t.offset[t.fields[e]]=f,f+=t.size[e]*t.count[e]);return t.rowSize=f,t}(e),i=[],s=[],n=[],r=[],o=[],a=new Color;if("ascii"===t.data){const l=t.offset,d=(new TextDecoder).decode(e).slice(t.headerLen).split("\n");for(let e=0,f=d.length;e<f;e++){if(""===d[e])continue;const f=d[e].split(" ");if(void 0!==l.x&&(i.push(parseFloat(f[l.x])),i.push(parseFloat(f[l.y])),i.push(parseFloat(f[l.z]))),void 0!==l.rgb){const e=t.fields.findIndex((e=>"rgb"===e)),i=t.type[e],s=parseFloat(f[l.rgb]);let r=s;if("F"===i){const e=new Float32Array(1);e[0]=s,r=new Int32Array(e.buffer)[0]}const o=(r>>16&255)/255,d=(r>>8&255)/255,p=(r>>0&255)/255;a.setRGB(o,d,p,SRGBColorSpace),n.push(a.r,a.g,a.b)}void 0!==l.normal_x&&(s.push(parseFloat(f[l.normal_x])),s.push(parseFloat(f[l.normal_y])),s.push(parseFloat(f[l.normal_z]))),void 0!==l.intensity&&r.push(parseFloat(f[l.intensity])),void 0!==l.label&&o.push(parseInt(f[l.label]))}}if("binary_compressed"===t.data){const l=new Uint32Array(e.slice(t.headerLen,t.headerLen+8)),d=l[0],f=l[1],p=function(e,t){const i=e.length,s=new Uint8Array(t);let n,r,o,a=0,l=0;do{if(n=e[a++],n<32){if(n++,l+n>t)throw new Error("Output buffer is not large enough");if(a+n>i)throw new Error("Invalid compressed data");do{s[l++]=e[a++]}while(--n)}else{if(r=n>>5,o=l-((31&n)<<8)-1,a>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=e[a++],a>=i))throw new Error("Invalid compressed data");if(o-=e[a++],l+r+2>t)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=l)throw new Error("Invalid compressed data");do{s[l++]=s[o++]}while(2+--r)}}while(a<i);return s}(new Uint8Array(e,t.headerLen+8,d),f),h=new DataView(p.buffer),u=t.offset;for(let e=0;e<t.points;e++){if(void 0!==u.x){const s=t.fields.indexOf("x"),n=t.fields.indexOf("y"),r=t.fields.indexOf("z");i.push(this._getDataView(h,t.points*u.x+t.size[s]*e,t.type[s],t.size[s])),i.push(this._getDataView(h,t.points*u.y+t.size[n]*e,t.type[n],t.size[n])),i.push(this._getDataView(h,t.points*u.z+t.size[r]*e,t.type[r],t.size[r]))}if(void 0!==u.rgb){const i=t.fields.indexOf("rgb"),s=h.getUint8(t.points*u.rgb+t.size[i]*e+2)/255,r=h.getUint8(t.points*u.rgb+t.size[i]*e+1)/255,o=h.getUint8(t.points*u.rgb+t.size[i]*e+0)/255;a.setRGB(s,r,o,SRGBColorSpace),n.push(a.r,a.g,a.b)}if(void 0!==u.normal_x){const i=t.fields.indexOf("normal_x"),n=t.fields.indexOf("normal_y"),r=t.fields.indexOf("normal_z");s.push(this._getDataView(h,t.points*u.normal_x+t.size[i]*e,t.type[i],t.size[i])),s.push(this._getDataView(h,t.points*u.normal_y+t.size[n]*e,t.type[n],t.size[n])),s.push(this._getDataView(h,t.points*u.normal_z+t.size[r]*e,t.type[r],t.size[r]))}if(void 0!==u.intensity){const i=t.fields.indexOf("intensity");r.push(this._getDataView(h,t.points*u.intensity+t.size[i]*e,t.type[i],t.size[i]))}if(void 0!==u.label){const i=t.fields.indexOf("label");o.push(h.getInt32(t.points*u.label+t.size[i]*e,this.littleEndian))}}}if("binary"===t.data){const l=new DataView(e,t.headerLen),d=t.offset;for(let e=0,f=0;e<t.points;e++,f+=t.rowSize){if(void 0!==d.x){const e=t.fields.indexOf("x"),s=t.fields.indexOf("y"),n=t.fields.indexOf("z");i.push(this._getDataView(l,f+d.x,t.type[e],t.size[e])),i.push(this._getDataView(l,f+d.y,t.type[s],t.size[s])),i.push(this._getDataView(l,f+d.z,t.type[n],t.size[n]))}if(void 0!==d.rgb){const e=l.getUint8(f+d.rgb+2)/255,t=l.getUint8(f+d.rgb+1)/255,i=l.getUint8(f+d.rgb+0)/255;a.setRGB(e,t,i,SRGBColorSpace),n.push(a.r,a.g,a.b)}if(void 0!==d.normal_x){const e=t.fields.indexOf("normal_x"),i=t.fields.indexOf("normal_y"),n=t.fields.indexOf("normal_z");s.push(this._getDataView(l,f+d.normal_x,t.type[e],t.size[e])),s.push(this._getDataView(l,f+d.normal_y,t.type[i],t.size[i])),s.push(this._getDataView(l,f+d.normal_z,t.type[n],t.size[n]))}if(void 0!==d.intensity){const e=t.fields.indexOf("intensity");r.push(this._getDataView(l,f+d.intensity,t.type[e],t.size[e]))}void 0!==d.label&&o.push(l.getInt32(f+d.label,this.littleEndian))}}const l=new BufferGeometry;i.length>0&&l.setAttribute("position",new Float32BufferAttribute(i,3)),s.length>0&&l.setAttribute("normal",new Float32BufferAttribute(s,3)),n.length>0&&l.setAttribute("color",new Float32BufferAttribute(n,3)),r.length>0&&l.setAttribute("intensity",new Float32BufferAttribute(r,1)),o.length>0&&l.setAttribute("label",new Int32BufferAttribute(o,1)),l.computeBoundingSphere();const d=new PointsMaterial({size:.005});return n.length>0&&(d.vertexColors=!0),new Points(l,d)}}export{PCDLoader};
//# sourceMappingURL=PCDLoader.js.map