{"version":3,"file":"node_modules/three/examples/jsm/loaders/PCDLoader.js","names":["BufferGeometry","Color","FileLoader","Float32BufferAttribute","Int32BufferAttribute","Loader","Points","PointsMaterial","SRGBColorSpace","PCDLoader","constructor","manager","super","this","littleEndian","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","_getDataView","dataview","offset","type","size","getFloat64","getFloat32","getInt8","getInt16","getInt32","getUint8","getUint16","getUint32","PCDheader","binaryData","buffer","Uint8Array","line","i","end","max","length","char","String","fromCharCode","trim","toLowerCase","startsWith","result1","search","result2","exec","slice","headerLen","str","replace","version","fields","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","l","push","sizeSum","rowSize","parseHeader","position","normal","color","intensity","label","c","lines","TextDecoder","decode","undefined","y","z","rgb","rgb_field_index","findIndex","field","rgb_type","float","farr","Float32Array","Int32Array","r","g","b","setRGB","normal_x","normal_y","normal_z","sizes","Uint32Array","compressedSize","decompressedSize","decompressed","inData","outLength","inLength","outData","ctrl","len","ref","inPtr","outPtr","Error","decompressLZF","DataView","xIndex","indexOf","yIndex","zIndex","rgbIndex","intensityIndex","labelIndex","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors"],"sources":["node_modules/three/examples/jsm/loaders/PCDLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tInt32BufferAttribute,\n\tLoader,\n\tPoints,\n\tPointsMaterial,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the Point Cloud Data (PCD) format.\n *\n * PCDLoader supports ASCII and (compressed) binary files as well as the following PCD fields:\n * - x y z\n * - rgb\n * - normal_x normal_y normal_z\n * - intensity\n * - label\n *\n * ```js\n * const loader = new PCDLoader();\n *\n * const points = await loader.loadAsync( './models/pcd/binary/Zaghetto.pcd' );\n * points.geometry.center(); // optional\n * points.geometry.rotateX( Math.PI ); // optional\n * scene.add( points );\n * ```\n *\n * @augments Loader\n * @three_import import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';\n */\nclass PCDLoader extends Loader {\n\n\t/**\n\t * Constructs a new PCD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether to use little Endian or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.littleEndian = true;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded PCD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Points)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Get dataview value by field type and size.\n\t *\n\t * @param {DataView} dataview - The DataView to read from.\n\t * @param {number} offset - The offset to start reading from.\n\t * @param {'F' | 'U' | 'I'} type - Field type.\n\t * @param {number} size - Field size.\n\t * @returns {number} Field value.\n\t */\n\t_getDataView( dataview, offset, type, size ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'F': {\n\n\t\t\t\tif ( size === 8 ) {\n\n\t\t\t\t\treturn dataview.getFloat64( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getFloat32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t\tcase 'I': {\n\n\t\t\t\tif ( size === 1 ) {\n\n\t\t\t\t\treturn dataview.getInt8( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( size === 2 ) {\n\n\t\t\t\t\treturn dataview.getInt16( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getInt32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t\tcase 'U': {\n\n\t\t\t\tif ( size === 1 ) {\n\n\t\t\t\t\treturn dataview.getUint8( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( size === 2 ) {\n\n\t\t\t\t\treturn dataview.getUint16( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getUint32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Parses the given PCD data and returns a point cloud.\n\t *\n\t * @param {ArrayBuffer} data - The raw PCD data as an array buffer.\n\t * @return {Points} The parsed point cloud.\n\t */\n\tparse( data ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tconst inLength = inData.length;\n\t\t\tconst outData = new Uint8Array( outLength );\n\t\t\tlet inPtr = 0;\n\t\t\tlet outPtr = 0;\n\t\t\tlet ctrl;\n\t\t\tlet len;\n\t\t\tlet ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( binaryData ) {\n\n\t\t\tconst PCDheader = {};\n\n\t\t\tconst buffer = new Uint8Array( binaryData );\n\n\t\t\tlet data = '', line = '', i = 0, end = false;\n\n\t\t\tconst max = buffer.length;\n\n\t\t\twhile ( i < max && end === false ) {\n\n\t\t\t\tconst char = String.fromCharCode( buffer[ i ++ ] );\n\n\t\t\t\tif ( char === '\\n' || char === '\\r' ) {\n\n\t\t\t\t\tif ( line.trim().toLowerCase().startsWith( 'data' ) ) {\n\n\t\t\t\t\t\tend = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tline = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tline += char;\n\n\t\t\t\t}\n\n\t\t\t\tdata += char;\n\n\t\t\t}\n\n\t\t\tconst result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tconst result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.slice( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.slice( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /^VERSION (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /^FIELDS (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.size = /^SIZE (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.type = /^TYPE (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.count = /^COUNT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.width = /^WIDTH (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.height = /^HEIGHT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /^VIEWPOINT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.points = /^POINTS (.*)/im.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tPCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : [];\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tlet sizeSum = 0;\n\n\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\t// parse header\n\n\t\tconst PCDheader = parseHeader( data );\n\n\t\t// parse data\n\n\t\tconst position = [];\n\t\tconst normal = [];\n\t\tconst color = [];\n\t\tconst intensity = [];\n\t\tconst label = [];\n\n\t\tconst c = new Color();\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tconst offset = PCDheader.offset;\n\t\t\tconst textData = new TextDecoder().decode( data );\n\t\t\tconst pcdData = textData.slice( PCDheader.headerLen );\n\t\t\tconst lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tconst line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' );\n\t\t\t\t\tconst rgb_type = PCDheader.type[ rgb_field_index ];\n\n\t\t\t\t\tconst float = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tlet rgb = float;\n\n\t\t\t\t\tif ( rgb_type === 'F' ) {\n\n\t\t\t\t\t\t// treat float values as int\n\t\t\t\t\t\t// https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518\n\t\t\t\t\t\tconst farr = new Float32Array( 1 );\n\t\t\t\t\t\tfarr[ 0 ] = float;\n\t\t\t\t\t\trgb = new Int32Array( farr.buffer )[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst r = ( ( rgb >> 16 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst g = ( ( rgb >> 8 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst b = ( ( rgb >> 0 ) & 0x0000ff ) / 255;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tintensity.push( parseFloat( line[ offset.intensity ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( parseInt( line[ offset.label ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tconst sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tconst compressedSize = sizes[ 0 ];\n\t\t\tconst decompressedSize = sizes[ 1 ];\n\t\t\tconst decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tconst dataview = new DataView( decompressed.buffer );\n\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'z' );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgbIndex = PCDheader.fields.indexOf( 'rgb' );\n\n\t\t\t\t\tconst r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'normal_x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'normal_y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'normal_z' );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tconst intensityIndex = PCDheader.fields.indexOf( 'intensity' );\n\t\t\t\t\tintensity.push( this._getDataView( dataview, ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, PCDheader.type[ intensityIndex ], PCDheader.size[ intensityIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tconst labelIndex = PCDheader.fields.indexOf( 'label' );\n\t\t\t\t\tlabel.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tconst dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'z' );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.x, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.y, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.z, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'normal_x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'normal_y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'normal_z' );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_x, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_y, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_z, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tconst intensityIndex = PCDheader.fields.indexOf( 'intensity' );\n\t\t\t\t\tintensity.push( this._getDataView( dataview, row + offset.intensity, PCDheader.type[ intensityIndex ], PCDheader.size[ intensityIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( dataview.getInt32( row + offset.label, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\n\t\tif ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) );\n\t\tif ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tconst material = new PointsMaterial( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\treturn new Points( geometry, material );\n\n\t}\n\n}\n\nexport { PCDLoader };\n"],"mappings":"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","ignoreList":[]}