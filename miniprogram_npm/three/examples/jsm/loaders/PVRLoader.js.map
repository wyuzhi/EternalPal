{"version":3,"file":"node_modules/three/examples/jsm/loaders/PVRLoader.js","names":["CompressedTextureLoader","RGBA_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGB_PVRTC_4BPPV1_Format","PVRLoader","constructor","manager","super","parse","buffer","loadMipmaps","header","Uint32Array","pvrDatas","_parseV3","_parseV2","console","error","bpp","format","metaLen","pixelFormat","height","width","numFaces","numMipmaps","dataPtr","numSurfaces","isCubemap","_extract","headerLength","flags","bitmaskAlpha","numSurfs","formatFlags","_hasAlpha","pvr","mipmaps","mipmapCount","dataOffset","dataSize","blockSize","blockWidth","blockHeight","widthBlocks","heightBlocks","length","mipLevel","sWidth","sHeight","surfIndex","mipmap","data","Uint8Array"],"sources":["node_modules/three/examples/jsm/loaders/PVRLoader.js"],"sourcesContent":["import {\n\tCompressedTextureLoader,\n\tRGBA_PVRTC_2BPPV1_Format,\n\tRGBA_PVRTC_4BPPV1_Format,\n\tRGB_PVRTC_2BPPV1_Format,\n\tRGB_PVRTC_4BPPV1_Format\n} from 'three';\n\n/**\n * A loader for the PVRTC texture compression format.\n *\n * ```js\n * const loader = new PVRLoader();\n *\n * const map = loader.load( 'textures/compressed/disturb_4bpp_rgb.pvr' );\n * map.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments CompressedTextureLoader\n * @three_import import { PVRLoader } from 'three/addons/loaders/PVRLoader.js';\n */\nclass PVRLoader extends CompressedTextureLoader {\n\n\t/**\n\t * Constructs a new PVR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Parses the given PVRTC texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {boolean} loadMipmaps - Whether to load mipmaps or not. This option is not yet supported by the loader.\n\t * @return {CompressedTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst headerLengthInt = 13;\n\t\tconst header = new Uint32Array( buffer, 0, headerLengthInt );\n\n\t\tconst pvrDatas = {\n\t\t\tbuffer: buffer,\n\t\t\theader: header,\n\t\t\tloadMipmaps: loadMipmaps\n\t\t};\n\n\t\tif ( header[ 0 ] === 0x03525650 ) {\n\n\t\t\t// PVR v3\n\n\t\t\treturn _parseV3( pvrDatas );\n\n\t\t} else if ( header[ 11 ] === 0x21525650 ) {\n\n\t\t\t// PVR v2\n\n\t\t\treturn _parseV2( pvrDatas );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction _parseV3( pvrDatas ) {\n\n\tconst header = pvrDatas.header;\n\tlet bpp, format;\n\n\n\tconst metaLen = header[ 12 ],\n\t\tpixelFormat = header[ 2 ],\n\t\theight = header[ 6 ],\n\t\twidth = header[ 7 ],\n\t\t// numSurfs = header[ 9 ],\n\t\tnumFaces = header[ 10 ],\n\t\tnumMipmaps = header[ 11 ];\n\n\tswitch ( pixelFormat ) {\n\n\t\tcase 0 : // PVRTC 2bpp RGB\n\t\t\tbpp = 2;\n\t\t\tformat = RGB_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 1 : // PVRTC 2bpp RGBA\n\t\t\tbpp = 2;\n\t\t\tformat = RGBA_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 2 : // PVRTC 4bpp RGB\n\t\t\tbpp = 4;\n\t\t\tformat = RGB_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 3 : // PVRTC 4bpp RGBA\n\t\t\tbpp = 4;\n\t\t\tformat = RGBA_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tdefault :\n\t\t\tconsole.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );\n\n\t}\n\n\tpvrDatas.dataPtr = 52 + metaLen;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numFaces;\n\tpvrDatas.numMipmaps = numMipmaps;\n\tpvrDatas.isCubemap \t= ( numFaces === 6 );\n\n\treturn _extract( pvrDatas );\n\n}\n\nfunction _parseV2( pvrDatas ) {\n\n\tconst header = pvrDatas.header;\n\n\tconst headerLength = header[ 0 ],\n\t\theight = header[ 1 ],\n\t\twidth = header[ 2 ],\n\t\tnumMipmaps = header[ 3 ],\n\t\tflags = header[ 4 ],\n\t\t// dataLength = header[ 5 ],\n\t\t// bpp =  header[ 6 ],\n\t\t// bitmaskRed = header[ 7 ],\n\t\t// bitmaskGreen = header[ 8 ],\n\t\t// bitmaskBlue = header[ 9 ],\n\t\tbitmaskAlpha = header[ 10 ],\n\t\t// pvrTag = header[ 11 ],\n\t\tnumSurfs = header[ 12 ];\n\n\n\tconst TYPE_MASK = 0xff;\n\tconst PVRTC_2 = 24,\n\t\tPVRTC_4 = 25;\n\n\tconst formatFlags = flags & TYPE_MASK;\n\n\tlet bpp, format;\n\tconst _hasAlpha = bitmaskAlpha > 0;\n\n\tif ( formatFlags === PVRTC_4 ) {\n\n\t\tformat = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;\n\t\tbpp = 4;\n\n\t} else if ( formatFlags === PVRTC_2 ) {\n\n\t\tformat = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;\n\t\tbpp = 2;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );\n\n\t}\n\n\tpvrDatas.dataPtr = headerLength;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numSurfs;\n\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t// guess cubemap type seems tricky in v2\n\t// it's just a pvr containing 6 surface (no explicit cubemap type)\n\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\n\n\treturn _extract( pvrDatas );\n\n}\n\n\nfunction _extract( pvrDatas ) {\n\n\tconst pvr = {\n\t\tmipmaps: [],\n\t\twidth: pvrDatas.width,\n\t\theight: pvrDatas.height,\n\t\tformat: pvrDatas.format,\n\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\tisCubemap: pvrDatas.isCubemap\n\t};\n\n\tconst buffer = pvrDatas.buffer;\n\n\tlet dataOffset = pvrDatas.dataPtr,\n\t\tdataSize = 0,\n\t\tblockSize = 0,\n\t\tblockWidth = 0,\n\t\tblockHeight = 0,\n\t\twidthBlocks = 0,\n\t\theightBlocks = 0;\n\n\tconst bpp = pvrDatas.bpp,\n\t\tnumSurfs = pvrDatas.numSurfaces;\n\n\tif ( bpp === 2 ) {\n\n\t\tblockWidth = 8;\n\t\tblockHeight = 4;\n\n\t} else {\n\n\t\tblockWidth = 4;\n\t\tblockHeight = 4;\n\n\t}\n\n\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\n\n\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\tlet mipLevel = 0;\n\n\twhile ( mipLevel < pvrDatas.numMipmaps ) {\n\n\t\tconst sWidth = pvrDatas.width >> mipLevel,\n\t\t\tsHeight = pvrDatas.height >> mipLevel;\n\n\t\twidthBlocks = sWidth / blockWidth;\n\t\theightBlocks = sHeight / blockHeight;\n\n\t\t// Clamp to minimum number of blocks\n\t\tif ( widthBlocks < 2 ) widthBlocks = 2;\n\t\tif ( heightBlocks < 2 ) heightBlocks = 2;\n\n\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\tfor ( let surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\n\n\t\t\tconst byteArray = new Uint8Array( buffer, dataOffset, dataSize );\n\n\t\t\tconst mipmap = {\n\t\t\t\tdata: byteArray,\n\t\t\t\twidth: sWidth,\n\t\t\t\theight: sHeight\n\t\t\t};\n\n\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\n\n\t\t\tdataOffset += dataSize;\n\n\t\t}\n\n\t\tmipLevel ++;\n\n\t}\n\n\treturn pvr;\n\n}\n\nexport { PVRLoader };\n"],"mappings":"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","ignoreList":[]}