import{DataTextureLoader,DataUtils,FloatType,HalfFloatType,LinearFilter,LinearSRGBColorSpace}from"three";class RGBELoader extends DataTextureLoader{constructor(t){super(t),this.type=HalfFloatType}parse(t){const e=function(t,e){switch(t){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}},a=function(t,e,a){e=e||1024;let r=t.pos,o=-1,n=0,s="",i=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(o=i.indexOf("\n"))&&n<e&&r<t.byteLength;)s+=i,n+=i.length,r+=128,i+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<o&&(!1!==a&&(t.pos+=n+o+1),s+i.slice(0,o))},r=function(t,e,a,r){const o=t[e+3],n=Math.pow(2,o-128)/255;a[r+0]=t[e+0]*n,a[r+1]=t[e+1]*n,a[r+2]=t[e+2]*n,a[r+3]=1},o=function(t,e,a,r){const o=t[e+3],n=Math.pow(2,o-128)/255;a[r+0]=DataUtils.toHalfFloat(Math.min(t[e+0]*n,65504)),a[r+1]=DataUtils.toHalfFloat(Math.min(t[e+1]*n,65504)),a[r+2]=DataUtils.toHalfFloat(Math.min(t[e+2]*n,65504)),a[r+3]=DataUtils.toHalfFloat(1)},n=new Uint8Array(t);n.pos=0;const s=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,n=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,i={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,p;for((t.pos>=t.byteLength||!(l=a(t)))&&e(1,"no header found"),(p=l.match(/^#\?(\S+)/))||e(3,"bad initial token"),i.valid|=1,i.programtype=p[1],i.string+=l+"\n";l=a(t),!1!==l;)if(i.string+=l+"\n","#"!==l.charAt(0)){if((p=l.match(r))&&(i.gamma=parseFloat(p[1])),(p=l.match(o))&&(i.exposure=parseFloat(p[1])),(p=l.match(n))&&(i.valid|=2,i.format=p[1]),(p=l.match(s))&&(i.valid|=4,i.height=parseInt(p[1],10),i.width=parseInt(p[2],10)),2&i.valid&&4&i.valid)break}else i.comments+=l+"\n";return 2&i.valid||e(3,"missing format specifier"),4&i.valid||e(3,"missing image size specifier"),i}(n),i=s.width,l=s.height,p=function(t,a,r){const o=a;if(o<8||o>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);o!==(t[2]<<8|t[3])&&e(3,"wrong scanline width");const n=new Uint8Array(4*a*r);n.length||e(4,"unable to allocate buffer space");let s=0,i=0;const l=4*o,p=new Uint8Array(4),c=new Uint8Array(l);let h=r;for(;h>0&&i<t.byteLength;){i+4>t.byteLength&&e(1),p[0]=t[i++],p[1]=t[i++],p[2]=t[i++],p[3]=t[i++],2==p[0]&&2==p[1]&&(p[2]<<8|p[3])==o||e(3,"bad rgbe scanline format");let a,r=0;for(;r<l&&i<t.byteLength;){a=t[i++];const o=a>128;if(o&&(a-=128),(0===a||r+a>l)&&e(3,"bad scanline data"),o){const e=t[i++];for(let t=0;t<a;t++)c[r++]=e}else c.set(t.subarray(i,i+a),r),r+=a,i+=a}const d=o;for(let t=0;t<d;t++){let e=0;n[s]=c[t+e],e+=o,n[s+1]=c[t+e],e+=o,n[s+2]=c[t+e],e+=o,n[s+3]=c[t+e],s+=4}h--}return n}(n.subarray(n.pos),i,l);let c,h,d;switch(this.type){case FloatType:d=p.length/4;const t=new Float32Array(4*d);for(let e=0;e<d;e++)r(p,4*e,t,4*e);c=t,h=FloatType;break;case HalfFloatType:d=p.length/4;const e=new Uint16Array(4*d);for(let t=0;t<d;t++)o(p,4*t,e,4*t);c=e,h=HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:i,height:l,data:c,header:s.string,gamma:s.gamma,exposure:s.exposure,type:h}}setDataType(t){return this.type=t,this}load(t,e,a,r){return super.load(t,(function(t,a){switch(t.type){case FloatType:case HalfFloatType:t.colorSpace=LinearSRGBColorSpace,t.minFilter=LinearFilter,t.magFilter=LinearFilter,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,a)}),a,r)}}export{RGBELoader};
//# sourceMappingURL=RGBELoader.js.map