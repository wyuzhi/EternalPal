{"version":3,"file":"node_modules/three/examples/jsm/loaders/STLLoader.js","names":["BufferAttribute","BufferGeometry","Color","FileLoader","Float32BufferAttribute","Loader","Vector3","SRGBColorSpace","STLLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","matchDataViewAt","query","reader","offset","i","il","length","getUint8","binData","buffer","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","faces","r","g","b","colors","defaultR","defaultG","defaultB","alpha","hasColors","index","Float32Array","geometry","vertices","normals","color","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setRGB","setAttribute","parseBinary","patternSolid","patternFace","patternName","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","groupNames","normal","result","groupCount","startVertex","endVertex","exec","name","push","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","count","userData","addGroup","parseASCII","TextDecoder","decode"],"sources":["node_modules/three/examples/jsm/loaders/STLLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tVector3,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the STL format, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files. The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n * - Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n * - There is perhaps some question as to how valid it is to always assume little-endian-ness.\n * - ASCII decoding assumes file is UTF-8.\n *\n * ```js\n * const loader = new STLLoader();\n * const geometry = await loader.loadAsync( './models/stl/slotted_disk.stl' )\n * scene.add( new THREE.Mesh( geometry ) );\n * ```\n * For binary STLs geometry might contain colors for vertices. To use it:\n * ```js\n * // use the same code to load STL as above\n * if ( geometry.hasColors ) {\n * \tmaterial = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );\n * }\n * const mesh = new THREE.Mesh( geometry, material );\n * ```\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * ```js\n * const materials = [];\n * const nGeometryGroups = geometry.groups.length;\n *\n * for ( let i = 0; i < nGeometryGroups; i ++ ) {\n * \tconst material = new THREE.MeshPhongMaterial( { color: colorMap[ i ], wireframe: false } );\n * \tmaterials.push( material );\n * }\n *\n * const mesh = new THREE.Mesh(geometry, materials);\n * ```\n *\n * @augments Loader\n * @three_import import { STLLoader } from 'three/addons/loaders/STLLoader.js';\n */\nclass STLLoader extends Loader {\n\n\t/**\n\t * Constructs a new STL loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded STL asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given STL data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw STL data as an array buffer.\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\tcolors[ componentIdx ] = color.r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = color.g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tconst patternName = /solid\\s(.+)/;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst groupNames = [];\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\tconst name = ( result = patternName.exec( solid ) ) !== null ? result[ 1 ] : '';\n\t\t\t\tgroupNames.push( name );\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.userData.groupNames = groupNames;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn new TextDecoder().decode( buffer );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\nexport { STLLoader };\n"],"mappings":"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","ignoreList":[]}