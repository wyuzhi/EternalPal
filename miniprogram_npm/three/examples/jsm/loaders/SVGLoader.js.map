{"version":3,"file":"node_modules/three/examples/jsm/loaders/SVGLoader.js","names":["Box2","BufferGeometry","FileLoader","Float32BufferAttribute","Loader","Matrix3","Path","Shape","ShapePath","ShapeUtils","SRGBColorSpace","Vector2","Vector3","COLOR_SPACE_SVG","SVGLoader","constructor","manager","super","this","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","lineTo","x","y","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","SyntaxError","newNumber","push","Number","pow","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","scale","theUnit","String","n","u","endsWith","substring","parseFloat","isTransformFlipped","m","te","elements","isTransformSkewed","basisDot","sx","getTransformScaleX","sy","getTransformScaleY","EPSILON","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","nodeName","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","slice","array","identity","angle","makeTranslation","makeRotation","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","getNodeTransform","isDefsNode","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","definitions","fromEntries","entries","parseCSSStylesheet","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","commands","match","l","command","charAt","data","numbers","jl","moveTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","parsePathNode","w","h","bci","parseRectNode","iterator","index","regex","replace","parsePolygonNode","parsePolylineNode","r","subpath","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","usedNodeId","getAttributeNS","usedNode","viewportElement","getElementById","fill","color","setStyle","transfVec2","v2","applyMatrix3","transfEllipseGeneric","curve","xRadius","yRadius","cosTheta","aRotation","sinTheta","v1","f1","f2","mF","mFInv","invert","mQe","transpose","multiply","ed","A","B","C","rt1","rt2","cs","sn","t","sm","df","rt","eigenDecomposition","rt1sqrt","rt2sqrt","atan2","aEndAngle","aStartAngle","mDsqrt","mRT","mDRF","transformAngle","phi","cosR","sinR","aClockwise","transfEllipseNoSkew","isLineCurve","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","transformPath","userData","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","classifyResult","loc","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","intersection","find","getIntersections","points","identifier","isCW","sort","i1","i2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","isClockWise","sp","isAHole","simplePath","allPaths","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","isHoleTo","fillRule","shapesToReturn","shape","hole","holes","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","isClosed","equals","nextPoint","previousPoint","strokeWidth2","deltaU","u1","innerSideModified","joinIsOnLeftSide","isMiter","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl"],"sources":["node_modules/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tSRGBColorSpace,\n\tVector2,\n\tVector3\n} from 'three';\n\nconst COLOR_SPACE_SVG = SRGBColorSpace;\n\n/**\n * A loader for the SVG format.\n *\n * Scalable Vector Graphics is an XML-based vector image format for two-dimensional graphics\n * with support for interactivity and animation.\n *\n * ```js\n * const loader = new SVGLoader();\n * const data = await loader.loadAsync( 'data/svgSample.svg' );\n *\n * const paths = data.paths;\n * const group = new THREE.Group();\n *\n * for ( let i = 0; i < paths.length; i ++ ) {\n *\n * \tconst path = paths[ i ];\n * \tconst material = new THREE.MeshBasicMaterial( {\n * \t\tcolor: path.color,\n * \t\tside: THREE.DoubleSide,\n * \t\tdepthWrite: false\n * \t} );\n *\n * \tconst shapes = SVGLoader.createShapes( path );\n *\n * \tfor ( let j = 0; j < shapes.length; j ++ ) {\n *\n * \t\tconst shape = shapes[ j ];\n * \t\tconst geometry = new THREE.ShapeGeometry( shape );\n * \t\tconst mesh = new THREE.Mesh( geometry, material );\n * \t\tgroup.add( mesh );\n *\n * \t}\n *\n * }\n *\n * scene.add( group );\n * ```\n *\n * @augments Loader\n * @three_import import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';\n */\nclass SVGLoader extends Loader {\n\n\t/**\n\t * Constructs a new SVG loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Default dots per inch.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 90\n\t\t */\n\t\tthis.defaultDPI = 90;\n\n\t\t/**\n\t\t * Default unit.\n\t\t *\n\t\t * @type {('mm'|'cm'|'in'|'pt'|'pc'|'px')}\n\t\t * @default 'px'\n\t\t */\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded SVG asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({paths:Array<ShapePath>,xml:string})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given SVG data and returns the resulting data.\n\t *\n\t * @param {string} text - The raw SVG data as a string.\n\t * @return {{paths:Array<ShapePath>,xml:string}} An object holding an array of shape paths and the\n\t * SVG XML document.\n\t */\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet isDefsNode = false;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\tisDefsNode = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill, COLOR_SPACE_SVG );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tconst childNodes = node.childNodes;\n\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tconst node = childNodes[ i ];\n\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\n\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\n\t\t\t\t\t// <style/> there.\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tparseNode( node, style );\n\n\t\t\t}\n\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\tif ( d === '' || d === 'none' ) return null;\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.slice( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = 0;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseGeneric( curve ) {\n\n\t\t\t\t// For math description see:\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\n\n\t\t\t\tconst a = curve.xRadius;\n\t\t\t\tconst b = curve.yRadius;\n\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\n\n\t\t\t\tconst v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );\n\t\t\t\tconst v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );\n\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\n\n\t\t\t\tconst mF = tempTransform0.set(\n\t\t\t\t\tf1.x, f2.x, 0,\n\t\t\t\t\tf1.y, f2.y, 0,\n\t\t\t\t\t0, 0, 1,\n\t\t\t\t);\n\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\n\t\t\t\tconst mQe = mQ.elements;\n\n\t\t\t\tconst ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\n\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\n\n\t\t\t\tconst isFullEllipse =\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\n\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\n\t\t\t\t// would converge to a single value effectively removing the whole curve\n\n\t\t\t\tif ( ! isFullEllipse ) {\n\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\n\t\t\t\t\t\trt1sqrt, 0, 0,\n\t\t\t\t\t\t0, rt2sqrt, 0,\n\t\t\t\t\t\t0, 0, 1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mRT = tempTransform2.set(\n\t\t\t\t\t\ted.cs, ed.sn, 0,\n\t\t\t\t\t\t- ed.sn, ed.cs, 0,\n\t\t\t\t\t\t0, 0, 1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\n\n\t\t\t\t\tconst transformAngle = phi => {\n\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\n\t\t\t\t\t\t\tnew Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\n\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\n\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseNoSkew( curve ) {\n\n\t\t\t\t// Faster shortcut if no skew is applied\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\n\n\t\t\t\tconst sx = getTransformScaleX( m );\n\t\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\t\tcurve.xRadius *= sx;\n\t\t\t\tcurve.yRadius *= sy;\n\n\t\t\t\t// Extract rotation angle from the matrix of form:\n\t\t\t\t//\n\t\t\t\t//  | cosθ sx   -sinθ sy |\n\t\t\t\t//  | sinθ sx    cosθ sy |\n\t\t\t\t//\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\n\t\t\t\t// `sx`, `sy`, or both might be zero.\n\t\t\t\tconst theta =\n\t\t\t\t\tsx > Number.EPSILON\n\t\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\n\t\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\n\n\t\t\t\tcurve.aRotation += theta;\n\n\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\tcurve.aStartAngle *= - 1;\n\t\t\t\t\tcurve.aEndAngle *= - 1;\n\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t// Transform ellipse center point\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t// Transform ellipse shape parameters\n\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\n\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformFlipped( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\n\n\t\t}\n\n\t\tfunction isTransformSkewed( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\n\n\t\t\t// Shortcut for trivial rotations and transformations\n\t\t\tif ( basisDot === 0 ) return false;\n\n\t\t\tconst sx = getTransformScaleX( m );\n\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\n\t\t//    [ A  B ]\n\t\t//    [ B  C ]\n\t\t// in the form\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n\t\t// where rt1 >= rt2.\n\t\t//\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n\t\tfunction eigenDecomposition( A, B, C ) {\n\n\t\t\tlet rt1, rt2, cs, sn, t;\n\t\t\tconst sm = A + C;\n\t\t\tconst df = A - C;\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\n\n\t\t\tif ( sm > 0 ) {\n\n\t\t\t\trt1 = 0.5 * ( sm + rt );\n\t\t\t\tt = 1 / rt1;\n\t\t\t\trt2 = A * t * C - B * t * B;\n\n\t\t\t} else if ( sm < 0 ) {\n\n\t\t\t\trt2 = 0.5 * ( sm - rt );\n\n\t\t\t} else {\n\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\n\n\t\t\t\trt1 = 0.5 * rt;\n\t\t\t\trt2 = - 0.5 * rt;\n\n\t\t\t}\n\n\t\t\t// Calculate eigenvectors\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tcs = df + rt;\n\n\t\t\t} else {\n\n\t\t\t\tcs = df - rt;\n\n\t\t\t}\n\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\n\n\t\t\t\tt = - 2 * B / cs;\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tcs = t * sn;\n\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\n\n\t\t\t\tcs = 1;\n\t\t\t\tsn = 0;\n\n\t\t\t} else {\n\n\t\t\t\tt = - 0.5 * cs / B;\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tsn = t * cs;\n\n\t\t\t}\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tt = cs;\n\t\t\t\tcs = - sn;\n\t\t\t\tsn = t;\n\n\t\t\t}\n\n\t\t\treturn { rt1, rt2, cs, sn };\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Creates from the given shape path and array of shapes.\n\t *\n\t * @param {ShapePath} shapePath - The shape path.\n\t * @return {Array<Shape>} An array of shapes.\n\t */\n\tstatic createShapes( shapePath ) {\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that other path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {\n\n\t\t\tsimplePaths[ identifier ].identifier = identifier;\n\n\t\t}\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\t/**\n\t * Returns a stroke style object from the given parameters.\n\t *\n\t * @param {number} [width=1] - The stroke width.\n\t * @param {string} [color='#000'] - The stroke color, as  returned by {@link Color#getStyle}.\n\t * @param {'round'|'bevel'|'miter'|'miter-limit'} [lineJoin='miter'] - The line join style.\n\t * @param {'round'|'square'|'butt'} [lineCap='butt'] - The line cap style.\n\t * @param {number} [miterLimit=4] - Maximum join length, in multiples of the `width` parameter (join is truncated if it exceeds that distance).\n\t * @return {Object} The style object.\n\t */\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a stroke from an array of points.\n\t *\n\t * @param {Array<Vector2>} points - The points in 2D space. Minimum 2 points. The path can be open or closed (last point equals to first point).\n\t * @param {Object} style - Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object.\n\t * @param {number} [arcDivisions=12] - Arc divisions for round joins and endcaps.\n\t * @param {number} [minDistance=0.001] - Points closer to this distance will be merged.\n\t * @return {?BufferGeometry} The stroke geometry. UV coordinates are generated ('u' along path. 'v' across it, from left to right).\n\t * Returns `null` if not geometry was generated.\n\t */\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\t/**\n\t * Creates a stroke from an array of points.\n\t *\n\t * @param {Array<Vector2>} points - The points in 2D space. Minimum 2 points.\n\t * @param {Object} style - Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object.\n\t * @param {number} [arcDivisions=12] - Arc divisions for round joins and endcaps.\n\t * @param {number} [minDistance=0.001] - Points closer to this distance will be merged.\n\t * @param {Array<number>} vertices - An array holding vertices.\n\t * @param {Array<number>} normals - An array holding normals.\n\t * @param {Array<number>} uvs - An array holding uvs.\n\t * @param {number} [vertexOffset=0] - The vertex offset.\n\t * @return {number} The number of vertices.\n\t */\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot > Number.EPSILON ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( innerPoint, u, 0 );\n\t\t\t\t\taddVertex( nextPointR, u, 1 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t// using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n\t\t\t\t\t\t\tuvs[ 3 * 2 + 1 ] === 1 ? tempV2_4.toArray( vertices, 3 * 3 ) : tempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n"],"mappings":"OACCA,KACAC,eACAC,WACAC,uBACAC,OACAC,QACAC,KACAC,MACAC,UACAC,WACAC,eACAC,QACAC,YACM,QAEP,MAAMC,gBAAkBH,eA2CxB,MAAMI,kBAAkBV,OAOvB,WAAAW,CAAaC,GAEZC,MAAOD,GAQPE,KAAKC,WAAa,GAQlBD,KAAKE,YAAc,IAEpB,CAWA,IAAAC,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQR,KAERS,EAAS,IAAIzB,WAAYwB,EAAMV,SACrCW,EAAOC,QAASF,EAAMG,MACtBF,EAAOG,iBAAkBJ,EAAMK,eAC/BJ,EAAOK,mBAAoBN,EAAMO,iBACjCN,EAAON,KAAMC,GAAK,SAAWY,GAE5B,IAECX,EAAQG,EAAMS,MAAOD,GAEtB,CAAE,MAAQE,GAEJX,EAEJA,EAASW,GAITC,QAAQC,MAAOF,GAIhBV,EAAMV,QAAQuB,UAAWjB,EAE1B,CAED,GAAGE,EAAYC,EAEhB,CASA,KAAAU,CAAOD,GAEN,MAAMR,EAAQR,KA0nBd,SAASsB,EAAiBX,EAAMY,EAAIC,EAAIC,EAAiBC,EAAgBC,EAAYC,EAAOC,GAE3F,GAAW,GAANN,GAAiB,GAANC,EAIf,YADAb,EAAKmB,OAAQD,EAAIE,EAAGF,EAAIG,GAKzBP,EAAkBA,EAAkBQ,KAAKC,GAAK,IAG9CX,EAAKU,KAAKE,IAAKZ,GACfC,EAAKS,KAAKE,IAAKX,GAGf,MAAMY,GAAQR,EAAMG,EAAIF,EAAIE,GAAM,EAC5BM,GAAQT,EAAMI,EAAIH,EAAIG,GAAM,EAC5BM,EAAML,KAAKM,IAAKd,GAAoBW,EAAMH,KAAKO,IAAKf,GAAoBY,EACxEI,GAAQR,KAAKO,IAAKf,GAAoBW,EAAMH,KAAKM,IAAKd,GAAoBY,EAGhF,IAAIK,EAAMnB,EAAKA,EACXoB,EAAMnB,EAAKA,EACf,MAAMoB,EAAON,EAAMA,EACbO,EAAOJ,EAAMA,EAGbK,EAAKF,EAAOF,EAAMG,EAAOF,EAE/B,GAAKG,EAAK,EAAI,CAGb,MAAMC,EAAId,KAAKe,KAAMF,GAGrBJ,GAFAnB,GAAKwB,GAEMxB,EACXoB,GAFAnB,GAAKuB,GAEMvB,CAEZ,CAEA,MAAMyB,EAAOP,EAAMG,EAAOF,EAAMC,EAC1BM,GAAOR,EAAMC,EAAMM,GAAOA,EAChC,IAAIE,EAAIlB,KAAKe,KAAMf,KAAKmB,IAAK,EAAGF,IAC3BxB,IAAmBC,IAAawB,GAAMA,GAC3C,MAAME,EAAMF,EAAI5B,EAAKkB,EAAMjB,EACrB8B,GAAQH,EAAI3B,EAAKc,EAAMf,EAGvBgC,EAAKtB,KAAKM,IAAKd,GAAoB4B,EAAMpB,KAAKO,IAAKf,GAAoB6B,GAAQ1B,EAAMG,EAAIF,EAAIE,GAAM,EACnGyB,EAAKvB,KAAKO,IAAKf,GAAoB4B,EAAMpB,KAAKM,IAAKd,GAAoB6B,GAAQ1B,EAAMI,EAAIH,EAAIG,GAAM,EAGnGyB,EAAQC,EAAU,EAAG,GAAKpB,EAAMe,GAAQ9B,GAAMkB,EAAMa,GAAQ9B,GAC5DmC,EAAQD,GAAYpB,EAAMe,GAAQ9B,GAAMkB,EAAMa,GAAQ9B,IAAQc,EAAMe,GAAQ9B,IAAQkB,EAAMa,GAAQ9B,IAAmB,EAAVS,KAAKC,IAEtHvB,EAAKiD,YAAYC,WAAYN,EAAIC,EAAIjC,EAAIC,EAAIiC,EAAOA,EAAQE,EAAsB,IAAfhC,EAAkBF,EAEtF,CAEA,SAASiC,EAAUI,EAAIC,EAAIC,EAAIC,GAE9B,MAAMC,EAAMJ,EAAKE,EAAKD,EAAKE,EACrBE,EAAMlC,KAAKe,KAAMc,EAAKA,EAAKC,EAAKA,GAAO9B,KAAKe,KAAMgB,EAAKA,EAAKC,EAAKA,GACvE,IAAIG,EAAMnC,KAAKoC,KAAMpC,KAAKmB,KAAO,EAAGnB,KAAKqC,IAAK,EAAGJ,EAAMC,KAEvD,OADOL,EAAKG,EAAKF,EAAKC,EAAO,IAAII,GAAQA,GAClCA,CAER,CA2MA,SAASG,EAAYC,EAAMC,GAE1BA,EAAQC,OAAOC,OAAQ,CAAC,EAAGF,GAE3B,IAAIG,EAAmB,CAAC,EAExB,GAAKJ,EAAKK,aAAc,SAAY,CAEnC,MAAMC,EAAiBN,EAAKO,aAAc,SACxCC,MAAO,MACPC,OAAQC,SACRC,KAAKC,GAAKA,EAAEC,SAEd,IAAM,IAAID,EAAI,EAAGA,EAAIN,EAAeQ,OAAQF,IAE3CR,EAAmBF,OAAOC,OAAQC,EAAkBW,EAAa,IAAMT,EAAgBM,IAIzF,CAQA,SAASI,EAAUC,EAASC,EAAQC,QAEXC,IAAnBD,IAA+BA,EAAiB,SAAeE,GAInE,OAFKA,EAAEC,WAAY,QAAU3E,QAAQ4E,KAAM,2DAEpCF,CAER,GAEKrB,EAAKK,aAAcY,KAAYhB,EAAOiB,GAAWC,EAAgBnB,EAAKO,aAAcU,KACpFb,EAAkBa,KAAYhB,EAAOiB,GAAWC,EAAgBf,EAAkBa,KAClFjB,EAAKC,OAAmC,KAA1BD,EAAKC,MAAOgB,KAAmBhB,EAAOiB,GAAWC,EAAgBnB,EAAKC,MAAOgB,IAEjG,CAEA,SAASO,EAAOH,GAEf,OAAO5D,KAAKmB,IAAK,EAAGnB,KAAKqC,IAAK,EAAG2B,EAAqBJ,IAEvD,CAEA,SAASK,EAAUL,GAElB,OAAO5D,KAAKmB,IAAK,EAAG6C,EAAqBJ,GAE1C,CAcA,OA9CKrB,EAAKK,aAAc,QAEvBD,EAAmBF,OAAOC,OAAQC,EAAkBW,EAAa,IAAMf,EAAKO,aAAc,SAgC3FS,EAAU,OAAQ,QAClBA,EAAU,eAAgB,cAAeQ,GACzCR,EAAU,YAAa,YACvBA,EAAU,UAAW,UAAWQ,GAChCR,EAAU,SAAU,UACpBA,EAAU,iBAAkB,gBAAiBQ,GAC7CR,EAAU,eAAgB,cAAeU,GACzCV,EAAU,kBAAmB,kBAC7BA,EAAU,iBAAkB,iBAC5BA,EAAU,oBAAqB,mBAAoBU,GACnDV,EAAU,aAAc,cAEjBf,CAER,CAIA,SAAS0B,EAAeC,EAAGC,GAE1B,OAAOD,GAAMC,EAAID,EAElB,CAIA,SAASE,EAAaC,EAAOC,EAAOC,GAEnC,GAAsB,iBAAVF,EAEX,MAAM,IAAIG,UAAW,yBAA2BH,GAKjD,MAAMI,EAAK,CACVC,UAAW,kBACXC,WAAY,YACZC,MAAO,OACPC,KAAM,OACNC,MAAO,KACPC,MAAO,IACPC,IAAK,KACLC,MAAO,QASR,IAAIC,EALQ,EAMRC,GAAY,EACZC,EAAS,GAAIC,EAAW,GAC5B,MAAMC,EAAS,GAEf,SAASC,EAAkBC,EAAStC,EAAGuC,GAEtC,MAAMvG,EAAQ,IAAIwG,YAAa,yBAA2BF,EAAU,cAAgBtC,EAAI,KAExF,MADAhE,EAAMuG,QAAUA,EACVvG,CAEP,CAEA,SAASyG,IAEQ,KAAXP,IAEc,KAAbC,EAAkBC,EAAOM,KAAMC,OAAQT,IACvCE,EAAOM,KAAMC,OAAQT,GAAWrF,KAAK+F,IAAK,GAAID,OAAQR,MAI5DD,EAAS,GACTC,EAAW,EAEZ,CAEA,IAAIG,EACJ,MAAMpC,EAASiB,EAAMjB,OAErB,IAAM,IAAIF,EAAI,EAAGA,EAAIE,EAAQF,IAK5B,GAHAsC,EAAUnB,EAAOnB,GAGZ6C,MAAMC,QAAS1B,IAAWA,EAAM2B,SAAUX,EAAOlC,OAASmB,IAAYE,EAAGQ,MAAMiB,KAAMV,GAEzFN,EAzCU,EA0CVE,EAASI,EACTG,QAJD,CAUA,GAlDW,IAkDNT,EAAgB,CAGpB,GAAKT,EAAGE,WAAWuB,KAAMV,GAExB,SAKD,GAAKf,EAAGG,MAAMsB,KAAMV,IAAaf,EAAGI,KAAKqB,KAAMV,GAAY,CAE1DN,EA7DS,EA8DTE,EAASI,EACT,QAED,CAEA,GAAKf,EAAGK,MAAMoB,KAAMV,GAAY,CAE/BN,EApEW,EAqEXE,EAASI,EACT,QAED,CAGKf,EAAGM,MAAMmB,KAAMV,KAEdL,GAEJI,EAAkBC,EAAStC,EAAGoC,GAI/BH,GAAY,EAId,CAGA,GA3FW,IA2FND,EAAgB,CAEpB,GAAKT,EAAGG,MAAMsB,KAAMV,GAAY,CAE/BJ,GAAUI,EACV,QAED,CAEA,GAAKf,EAAGK,MAAMoB,KAAMV,GAAY,CAE/BJ,GAAUI,EACVN,EAtGW,EAuGX,QAED,CAEA,GAAKT,EAAGO,IAAIkB,KAAMV,GAAY,CAE7BN,EA5GS,EA6GT,QAED,CAGKT,EAAGI,KAAKqB,KAAMV,IACI,IAAlBJ,EAAOhC,QACPqB,EAAGI,KAAKqB,KAAMd,EAAQ,KAE1BG,EAAkBC,EAAStC,EAAGoC,EAIhC,CAGA,GA9Ha,IA8HRJ,EAAkB,CAEtB,GAAKT,EAAGG,MAAMsB,KAAMV,GAAY,CAE/BJ,GAAUI,EACV,QAED,CAEA,GAAKf,EAAGO,IAAIkB,KAAMV,GAAY,CAE7BN,EAxIS,EAyIT,QAED,CAGKT,EAAGK,MAAMoB,KAAMV,IAA6C,MAAhCJ,EAAQA,EAAOhC,OAAS,IAExDmC,EAAkBC,EAAStC,EAAGoC,EAIhC,CAGA,GAvJW,IAuJNJ,EAAgB,CAEpB,GAAKT,EAAGG,MAAMsB,KAAMV,GAAY,CAE/BH,GAAYG,EACZ,QAED,CAEA,GAAKf,EAAGI,KAAKqB,KAAMV,GAAY,CAE9B,GAAkB,KAAbH,EAAkB,CAEtBA,GAAYG,EACZ,QAED,CAEyB,IAApBH,EAASjC,QAAgBqB,EAAGI,KAAKqB,KAAMb,IAE3CE,EAAkBC,EAAStC,EAAGoC,EAIhC,CAED,CAIKb,EAAGE,WAAWuB,KAAMV,IAExBG,IACAT,EA3LU,EA4LVC,GAAY,GAEDV,EAAGM,MAAMmB,KAAMV,IAE1BG,IACAT,EAjMU,EAkMVC,GAAY,GAEDV,EAAGI,KAAKqB,KAAMV,IAEzBG,IACAT,EAtMU,EAuMVE,EAASI,GAEEf,EAAGK,MAAMoB,KAAMV,IAE1BG,IACAT,EA3MY,EA4MZE,EAASI,GAITD,EAAkBC,EAAStC,EAAGoC,EAnK/B,CA4KD,OAFAK,IAEOL,CAER,CAIA,MAAMa,EAAQ,CAAE,KAAM,KAAM,KAAM,KAAM,KAAM,MAGxCC,EAAiB,CAEtBC,GAAM,CACLA,GAAM,EACNC,GAAM,GACNC,GAAM,EAAI,KACVC,GAAM,GAAK,KACXC,GAAM,EAAI,KACVC,IAAQ,GAETJ,GAAM,CACLD,GAAM,GACNC,GAAM,EACNC,GAAM,EAAI,KACVC,GAAM,GAAK,KACXC,GAAM,EAAI,KACVC,IAAQ,GAETH,GAAM,CACLF,GAAM,KACNC,GAAM,KACNC,GAAM,EACNC,GAAM,GACNC,GAAM,EACNC,IAAQ,GAETF,GAAM,CACLH,GAAM,KAAO,GACbC,GAAM,KAAO,GACbC,GAAM,EAAI,GACVC,GAAM,EACNC,GAAM,EAAI,GACVC,IAAQ,GAETD,GAAM,CACLJ,GAAM,KAAO,EACbC,GAAM,KAAO,EACbC,GAAM,EAAI,EACVC,GAAM,GACNC,GAAM,EACNC,IAAQ,GAETA,GAAM,CACLA,GAAM,IAKR,SAAS3C,EAAqB4C,GAE7B,IAoBIC,EApBAC,EAAU,KAEd,GAAuB,iBAAXF,GAAuBA,aAAkBG,OAEpD,IAAM,IAAI5D,EAAI,EAAG6D,EAAIZ,EAAM/C,OAAQF,EAAI6D,EAAG7D,IAAO,CAEhD,MAAM8D,EAAIb,EAAOjD,GAEjB,GAAKyD,EAAOM,SAAUD,GAAM,CAE3BH,EAAUG,EACVL,EAASA,EAAOO,UAAW,EAAGP,EAAOvD,OAAS4D,EAAE5D,QAChD,KAED,CAED,CA0BD,MApBiB,OAAZyD,GAA0C,OAAtBvI,EAAMN,YAI9B4I,EAAQR,EAAqB,GAAG9H,EAAMN,aAAgBM,EAAMP,YAI5D6I,EAAQR,EAAgBS,GAAWvI,EAAMN,aAEpC4I,EAAQ,IAIZA,EAAQR,EAAgBS,GAAgB,GAAIvI,EAAMP,aAM7C6I,EAAQO,WAAYR,EAE5B,CAmXA,SAASS,EAAoBC,GAE5B,MAAMC,EAAKD,EAAEE,SACb,OAAOD,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAM,CAEhD,CAEA,SAASE,EAAmBH,GAE3B,MAAMC,EAAKD,EAAEE,SACPE,EAAWH,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAGnD,GAAkB,IAAbG,EAAiB,OAAO,EAE7B,MAAMC,EAAKC,EAAoBN,GACzBO,EAAKC,EAAoBR,GAE/B,OAAOtH,KAAKE,IAAKwH,GAAaC,EAAKE,IAAS/B,OAAOiC,OAEpD,CAEA,SAASH,EAAoBN,GAE5B,MAAMC,EAAKD,EAAEE,SACb,OAAOxH,KAAKe,KAAMwG,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAErD,CAEA,SAASO,EAAoBR,GAE5B,MAAMC,EAAKD,EAAEE,SACb,OAAOxH,KAAKe,KAAMwG,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAErD,CAmFA,MAAMS,EAAQ,GACR1E,EAAc,CAAC,EAEf2E,EAAiB,GAEjBC,EAAiB,IAAIhL,QACrBiL,EAAiB,IAAIjL,QACrBkL,EAAiB,IAAIlL,QACrBmL,EAAiB,IAAInL,QACrBoL,EAAS,IAAI9K,QACb+K,EAAS,IAAI9K,QAEb+K,EAAmB,IAAItL,QAEvBuL,GAAM,IAAIC,WAAYC,gBAAiB5J,EAAM,kBAtyDnD,SAAS6J,EAAWrG,EAAMC,GAEzB,GAAuB,IAAlBD,EAAKsG,SAAiB,OAE3B,MAAMC,EAgzCP,SAA2BvG,GAE1B,KAASA,EAAKK,aAAc,cAAqC,QAAlBL,EAAKwG,WAAwBxG,EAAKK,aAAc,MAASL,EAAKK,aAAc,OAE1H,OAAO,KAIR,MAAMkG,EAeP,SAA6BvG,GAE5B,MAAMuG,EAAY,IAAI5L,QAChBsL,EAAmBN,EAEzB,GAAuB,QAAlB3F,EAAKwG,WAAwBxG,EAAKK,aAAc,MAASL,EAAKK,aAAc,MAAU,CAE1F,MAAMoG,EAAKhF,EAAqBzB,EAAKO,aAAc,MAC7CmG,EAAKjF,EAAqBzB,EAAKO,aAAc,MAEnDgG,EAAUI,UAAWF,EAAIC,EAE1B,CAEA,GAAK1G,EAAKK,aAAc,aAAgB,CAEvC,MAAMuG,EAAkB5G,EAAKO,aAAc,aAAcC,MAAO,KAEhE,IAAM,IAAIqG,EAASD,EAAgB9F,OAAS,EAAG+F,GAAU,EAAGA,IAAY,CAEvE,MAAMC,EAAgBF,EAAiBC,GAAShG,OAEhD,GAAuB,KAAlBiG,EAAuB,SAE5B,MAAMC,EAAaD,EAAcE,QAAS,KACpCC,EAAcH,EAAchG,OAElC,GAAKiG,EAAa,GAAKA,EAAaE,EAAc,CAEjD,MAAMC,EAAgBJ,EAAcK,MAAO,EAAGJ,GAExCK,EAAQtF,EAAagF,EAAcK,MAAOJ,EAAa,IAI7D,OAFAd,EAAiBoB,WAERH,GAER,IAAK,YAEJ,GAAKE,EAAMtG,QAAU,EAAI,CAExB,MAAM2F,EAAKW,EAAO,GAClB,IAAIV,EAAK,EAEJU,EAAMtG,QAAU,IAEpB4F,EAAKU,EAAO,IAIbnB,EAAiBU,UAAWF,EAAIC,EAEjC,CAEA,MAED,IAAK,SAEJ,GAAKU,EAAMtG,QAAU,EAAI,CAExB,IAAIwG,EAAQ,EACRvI,EAAK,EACLC,EAAK,EAGTsI,EAAQF,EAAO,GAAM3J,KAAKC,GAAK,IAE1B0J,EAAMtG,QAAU,IAGpB/B,EAAKqI,EAAO,GACZpI,EAAKoI,EAAO,IAKbxB,EAAe2B,iBAAmBxI,GAAMC,GACxC6G,EAAe2B,aAAcF,GAC7BxB,EAAe2B,iBAAkB5B,EAAgBD,GACjDA,EAAe2B,gBAAiBxI,EAAIC,GACpCiH,EAAiBwB,iBAAkB7B,EAAgBE,EAEpD,CAEA,MAED,IAAK,QAEJ,GAAKsB,EAAMtG,QAAU,EAAI,CAExB,MAAM4G,EAASN,EAAO,GACtB,IAAIO,EAASD,EAERN,EAAMtG,QAAU,IAEpB6G,EAASP,EAAO,IAIjBnB,EAAiB3B,MAAOoD,EAAQC,EAEjC,CAEA,MAED,IAAK,QAEkB,IAAjBP,EAAMtG,QAEVmF,EAAiB2B,IAChB,EAAGnK,KAAKoK,IAAKT,EAAO,GAAM3J,KAAKC,GAAK,KAAO,EAC3C,EAAG,EAAG,EACN,EAAG,EAAG,GAKR,MAED,IAAK,QAEkB,IAAjB0J,EAAMtG,QAEVmF,EAAiB2B,IAChB,EAAG,EAAG,EACNnK,KAAKoK,IAAKT,EAAO,GAAM3J,KAAKC,GAAK,KAAO,EAAG,EAC3C,EAAG,EAAG,GAKR,MAED,IAAK,SAEkB,IAAjB0J,EAAMtG,QAEVmF,EAAiB2B,IAChBR,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAC/BA,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAC/B,EAAG,EAAG,GASX,CAEAb,EAAUuB,YAAa7B,EAExB,CAED,CAEA,OAAOM,CAER,CA9KmBwB,CAAoB/H,GAEjC0F,EAAe5E,OAAS,GAE5ByF,EAAUuB,YAAapC,EAAgBA,EAAe5E,OAAS,IAOhE,OAHAmF,EAAiB+B,KAAMzB,GACvBb,EAAepC,KAAMiD,GAEdA,CAER,CAr0CmB0B,CAAkBjI,GAEpC,IAAIkI,GAAa,EAEb/L,EAAO,KAEX,OAAS6D,EAAKwG,UAEb,IAAK,MAQL,IAAK,IACJvG,EAAQF,EAAYC,EAAMC,GAC1B,MAND,IAAK,SA8jBP,SAA6BD,GAE5B,IAAOA,EAAKmI,QAAWnI,EAAKmI,MAAMC,WAAcpI,EAAKmI,MAAMC,SAAStH,OAAS,OAE7E,IAAM,IAAIF,EAAI,EAAGA,EAAIZ,EAAKmI,MAAMC,SAAStH,OAAQF,IAAO,CAEvD,MAAMyH,EAAarI,EAAKmI,MAAMC,SAAUxH,GAExC,GAAyB,IAApByH,EAAWC,KAAa,SAE7B,MAAMC,EAAeF,EAAWG,aAC9BhI,MAAO,OACPC,OAAQC,SACRC,KAAKC,GAAKA,EAAEC,SAEd,IAAM,IAAI4H,EAAI,EAAGA,EAAIF,EAAazH,OAAQ2H,IAAO,CAGhD,MAAMC,EAAcxI,OAAOyI,YAC1BzI,OAAO0I,QAASP,EAAWpI,OAAQQ,QAAQ,EAAI,CAAEY,KAAe,KAANA,KAG3DN,EAAawH,EAAcE,IAAQvI,OAAOC,OACzCY,EAAawH,EAAcE,KAAS,CAAC,EACrCC,EAGF,CAED,CAED,CA5lBGG,CAAoB7I,GACpB,MAMD,IAAK,OACJC,EAAQF,EAAYC,EAAMC,GACrBD,EAAKK,aAAc,OAAQlE,EAkHnC,SAAwB6D,GAEvB,MAAM7D,EAAO,IAAIrB,UAEXgO,EAAQ,IAAI7N,QACZ8N,EAAU,IAAI9N,QAEd+N,EAAa,IAAI/N,QACvB,IAAIgO,GAAe,EACfC,GAAkB,EAEtB,MAAMC,EAAInJ,EAAKO,aAAc,KAE7B,GAAW,KAAN4I,GAAkB,SAANA,EAAe,OAAO,KAIvC,MAAMC,EAAWD,EAAEE,MAAO,wBAE1B,IAAM,IAAIzI,EAAI,EAAG0I,EAAIF,EAAStI,OAAQF,EAAI0I,EAAG1I,IAAO,CAEnD,MAAM2I,EAAUH,EAAUxI,GAEpB0H,EAAOiB,EAAQC,OAAQ,GACvBC,EAAOF,EAAQpC,MAAO,GAAItG,OAShC,IAAI6I,EAEJ,QATsB,IAAjBT,IAEJC,GAAkB,EAClBD,GAAe,GAMPX,GAER,IAAK,IACJoB,EAAU5H,EAAa2H,GACvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAEP,IAANiL,EAEJtM,EAAKyN,OAAQd,EAAMvL,EAAGuL,EAAMtL,GAI5BrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAIlB,IAANiL,GAAUO,EAAWhB,KAAMc,GAIjC,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,IAE7CK,EAAMvL,EAAImM,EAASjB,GACnBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,IAE7CK,EAAMtL,EAAIkM,EAASjB,GACnBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK0N,cACJH,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,IAEdM,EAAQxL,EAAImM,EAASjB,EAAI,GACzBM,EAAQvL,EAAIkM,EAASjB,EAAI,GACzBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GAEZ,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK0N,cACJlI,EAAemH,EAAMvL,EAAGwL,EAAQxL,GAChCoE,EAAemH,EAAMtL,EAAGuL,EAAQvL,GAChCkM,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,IAEdM,EAAQxL,EAAImM,EAASjB,EAAI,GACzBM,EAAQvL,EAAIkM,EAASjB,EAAI,GACzBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GAEZ,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK2N,iBACJJ,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,GACbiB,EAASjB,EAAI,IAEdM,EAAQxL,EAAImM,EAASjB,EAAI,GACzBM,EAAQvL,EAAIkM,EAASjB,EAAI,GACzBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GAEZ,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAAI,CAEtD,MAAM1L,EAAK4E,EAAemH,EAAMvL,EAAGwL,EAAQxL,GACrCP,EAAK2E,EAAemH,EAAMtL,EAAGuL,EAAQvL,GAC3CrB,EAAK2N,iBACJ/M,EACAC,EACA0M,EAASjB,EAAI,GACbiB,EAASjB,EAAI,IAEdM,EAAQxL,EAAIR,EACZgM,EAAQvL,EAAIR,EACZ8L,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GAEZ,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,EAE7D,CAEA,MAED,IAAK,IACJY,EAAU5H,EAAa2H,EAAM,CAAE,EAAG,GAAK,GAEvC,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAAI,CAGtD,GAAKiB,EAASjB,EAAI,IAAOK,EAAMvL,GAAKmM,EAASjB,EAAI,IAAOK,EAAMtL,EAAI,SAElE,MAAMJ,EAAQ0L,EAAMiB,QACpBjB,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBV,EACCX,EAAMuN,EAASjB,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKrL,EAAO0L,GAGzF,IAANL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,EAE7D,CAEA,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDK,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GACxBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAEP,IAANiL,EAEJtM,EAAKyN,OAAQd,EAAMvL,EAAGuL,EAAMtL,GAI5BrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAIlB,IAANiL,GAAUO,EAAWhB,KAAMc,GAIjC,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,IAE7CK,EAAMvL,GAAKmM,EAASjB,GACpBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,IAE7CK,EAAMtL,GAAKkM,EAASjB,GACpBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDK,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GACxBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBrB,EAAKmB,OAAQwL,EAAMvL,EAAGuL,EAAMtL,GAEjB,IAANiL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK0N,cACJf,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,IAExBM,EAAQxL,EAAIuL,EAAMvL,EAAImM,EAASjB,EAAI,GACnCM,EAAQvL,EAAIsL,EAAMtL,EAAIkM,EAASjB,EAAI,GACnCK,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GAEb,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK0N,cACJlI,EAAemH,EAAMvL,EAAGwL,EAAQxL,GAChCoE,EAAemH,EAAMtL,EAAGuL,EAAQvL,GAChCsL,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,IAExBM,EAAQxL,EAAIuL,EAAMvL,EAAImM,EAASjB,EAAI,GACnCM,EAAQvL,EAAIsL,EAAMtL,EAAIkM,EAASjB,EAAI,GACnCK,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GAEb,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAElDtM,EAAK2N,iBACJhB,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,GACvBK,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,IAExBM,EAAQxL,EAAIuL,EAAMvL,EAAImM,EAASjB,EAAI,GACnCM,EAAQvL,EAAIsL,EAAMtL,EAAIkM,EAASjB,EAAI,GACnCK,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GAEb,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,GAI7D,MAED,IAAK,IACJY,EAAU5H,EAAa2H,GAEvB,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAAI,CAEtD,MAAM1L,EAAK4E,EAAemH,EAAMvL,EAAGwL,EAAQxL,GACrCP,EAAK2E,EAAemH,EAAMtL,EAAGuL,EAAQvL,GAC3CrB,EAAK2N,iBACJ/M,EACAC,EACA8L,EAAMvL,EAAImM,EAASjB,EAAI,GACvBK,EAAMtL,EAAIkM,EAASjB,EAAI,IAExBM,EAAQxL,EAAIR,EACZgM,EAAQvL,EAAIR,EACZ8L,EAAMvL,EAAIuL,EAAMvL,EAAImM,EAASjB,EAAI,GACjCK,EAAMtL,EAAIsL,EAAMtL,EAAIkM,EAASjB,EAAI,GAEtB,IAANA,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,EAE7D,CAEA,MAED,IAAK,IACJY,EAAU5H,EAAa2H,EAAM,CAAE,EAAG,GAAK,GAEvC,IAAM,IAAIhB,EAAI,EAAGkB,EAAKD,EAAQ5I,OAAQ2H,EAAIkB,EAAIlB,GAAK,EAAI,CAGtD,GAAyB,GAApBiB,EAASjB,EAAI,IAAgC,GAApBiB,EAASjB,EAAI,GAAW,SAEtD,MAAMrL,EAAQ0L,EAAMiB,QACpBjB,EAAMvL,GAAKmM,EAASjB,EAAI,GACxBK,EAAMtL,GAAKkM,EAASjB,EAAI,GACxBM,EAAQxL,EAAIuL,EAAMvL,EAClBwL,EAAQvL,EAAIsL,EAAMtL,EAClBV,EACCX,EAAMuN,EAASjB,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKiB,EAASjB,EAAI,GAAKrL,EAAO0L,GAGzF,IAANL,IAA+B,IAApBS,GAA2BF,EAAWhB,KAAMc,EAE7D,CAEA,MAED,IAAK,IACL,IAAK,IACJ3M,EAAKiD,YAAY4K,WAAY,EAExB7N,EAAKiD,YAAY6K,OAAOnJ,OAAS,IAGrCgI,EAAMd,KAAMgB,GACZ7M,EAAKiD,YAAY8K,aAAalC,KAAMc,GACpCG,GAAe,GAIhB,MAED,QACCtM,QAAQ4E,KAAMgI,GAMhBL,GAAkB,CAEnB,CAEA,OAAO/M,CAER,CAljB0CgO,CAAenK,IACtD,MAED,IAAK,OACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EAqqBH,SAAwB6D,GAEvB,MAAMzC,EAAIkE,EAAqBzB,EAAKO,aAAc,MAAS,GACrD/C,EAAIiE,EAAqBzB,EAAKO,aAAc,MAAS,GACrDxD,EAAK0E,EAAqBzB,EAAKO,aAAc,OAAUP,EAAKO,aAAc,OAAU,GACpFvD,EAAKyE,EAAqBzB,EAAKO,aAAc,OAAUP,EAAKO,aAAc,OAAU,GACpF6J,EAAI3I,EAAqBzB,EAAKO,aAAc,UAC5C8J,EAAI5I,EAAqBzB,EAAKO,aAAc,WAI5C+J,EAAM,cAENnO,EAAO,IAAIrB,UAGjBqB,EAAKyN,OAAQrM,EAAIR,EAAIS,GAGrBrB,EAAKmB,OAAQC,EAAI6M,EAAIrN,EAAIS,IACb,IAAPT,GAAmB,IAAPC,IAEhBb,EAAK0N,cACJtM,EAAI6M,EAAIrN,EAAKuN,EACb9M,EACAD,EAAI6M,EACJ5M,EAAIR,EAAKsN,EACT/M,EAAI6M,EACJ5M,EAAIR,GAMNb,EAAKmB,OAAQC,EAAI6M,EAAG5M,EAAI6M,EAAIrN,IAChB,IAAPD,GAAmB,IAAPC,IAEhBb,EAAK0N,cACJtM,EAAI6M,EACJ5M,EAAI6M,EAAIrN,EAAKsN,EACb/M,EAAI6M,EAAIrN,EAAKuN,EACb9M,EAAI6M,EACJ9M,EAAI6M,EAAIrN,EACRS,EAAI6M,GAMNlO,EAAKmB,OAAQC,EAAIR,EAAIS,EAAI6M,IACb,IAAPtN,GAAmB,IAAPC,IAEhBb,EAAK0N,cACJtM,EAAIR,EAAKuN,EACT9M,EAAI6M,EACJ9M,EACAC,EAAI6M,EAAIrN,EAAKsN,EACb/M,EACAC,EAAI6M,EAAIrN,GAMVb,EAAKmB,OAAQC,EAAGC,EAAIR,IACR,IAAPD,GAAmB,IAAPC,IAEhBb,EAAK0N,cAAetM,EAAGC,EAAIR,EAAKsN,EAAK/M,EAAIR,EAAKuN,EAAK9M,EAAGD,EAAIR,EAAIS,GAI/D,OAAOrB,CAER,CA9uBUoO,CAAevK,GACtB,MAED,IAAK,UACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EA2uBH,SAA2B6D,GAE1B,SAASwK,EAAUnB,EAAOzH,EAAGC,GAE5B,MAAMtE,EAAIkE,EAAqBG,GACzBpE,EAAIiE,EAAqBI,GAEhB,IAAV4I,EAEJtO,EAAKyN,OAAQrM,EAAGC,GAIhBrB,EAAKmB,OAAQC,EAAGC,GAIjBiN,GAED,CAEA,MAAMC,EAAQ,wEAERvO,EAAO,IAAIrB,UAEjB,IAAI2P,EAAQ,EAMZ,OAJAzK,EAAKO,aAAc,UAAWoK,QAASD,EAAOF,GAE9CrO,EAAKiD,YAAY4K,WAAY,EAEtB7N,CAER,CA5wBUyO,CAAkB5K,GACzB,MAED,IAAK,WACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EAywBH,SAA4B6D,GAE3B,SAASwK,EAAUnB,EAAOzH,EAAGC,GAE5B,MAAMtE,EAAIkE,EAAqBG,GACzBpE,EAAIiE,EAAqBI,GAEhB,IAAV4I,EAEJtO,EAAKyN,OAAQrM,EAAGC,GAIhBrB,EAAKmB,OAAQC,EAAGC,GAIjBiN,GAED,CAEA,MAAMC,EAAQ,wEAERvO,EAAO,IAAIrB,UAEjB,IAAI2P,EAAQ,EAMZ,OAJAzK,EAAKO,aAAc,UAAWoK,QAASD,EAAOF,GAE9CrO,EAAKiD,YAAY4K,WAAY,EAEtB7N,CAER,CA1yBU0O,CAAmB7K,GAC1B,MAED,IAAK,SACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EAuyBH,SAA0B6D,GAEzB,MAAMzC,EAAIkE,EAAqBzB,EAAKO,aAAc,OAAU,GACtD/C,EAAIiE,EAAqBzB,EAAKO,aAAc,OAAU,GACtDuK,EAAIrJ,EAAqBzB,EAAKO,aAAc,MAAS,GAErDwK,EAAU,IAAInQ,KACpBmQ,EAAQC,OAAQzN,EAAGC,EAAGsN,EAAG,EAAa,EAAVrN,KAAKC,IAEjC,MAAMvB,EAAO,IAAIrB,UAGjB,OAFAqB,EAAK8O,SAAS3H,KAAMyH,GAEb5O,CAER,CArzBU+O,CAAiBlL,GACxB,MAED,IAAK,UACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EAkzBH,SAA2B6D,GAE1B,MAAMzC,EAAIkE,EAAqBzB,EAAKO,aAAc,OAAU,GACtD/C,EAAIiE,EAAqBzB,EAAKO,aAAc,OAAU,GACtDxD,EAAK0E,EAAqBzB,EAAKO,aAAc,OAAU,GACvDvD,EAAKyE,EAAqBzB,EAAKO,aAAc,OAAU,GAEvDwK,EAAU,IAAInQ,KACpBmQ,EAAQ1L,WAAY9B,EAAGC,EAAGT,EAAIC,EAAI,EAAa,EAAVS,KAAKC,IAE1C,MAAMvB,EAAO,IAAIrB,UAGjB,OAFAqB,EAAK8O,SAAS3H,KAAMyH,GAEb5O,CAER,CAj0BUgP,CAAkBnL,GACzB,MAED,IAAK,OACJC,EAAQF,EAAYC,EAAMC,GAC1B9D,EA8zBH,SAAwB6D,GAEvB,MAAMoL,EAAK3J,EAAqBzB,EAAKO,aAAc,OAAU,GACvD8K,EAAK5J,EAAqBzB,EAAKO,aAAc,OAAU,GACvD+K,EAAK7J,EAAqBzB,EAAKO,aAAc,OAAU,GACvDgL,EAAK9J,EAAqBzB,EAAKO,aAAc,OAAU,GAEvDpE,EAAO,IAAIrB,UAKjB,OAJAqB,EAAKyN,OAAQwB,EAAIC,GACjBlP,EAAKmB,OAAQgO,EAAIC,GACjBpP,EAAKiD,YAAY4K,WAAY,EAEtB7N,CAER,CA50BUqP,CAAexL,GACtB,MAED,IAAK,OACJkI,GAAa,EACb,MAED,IAAK,MACJjI,EAAQF,EAAYC,EAAMC,GAE1B,MACMwL,GADOzL,EAAK0L,eAAgB,+BAAgC,SAAY,IACtD9G,UAAW,GAC7B+G,EAAW3L,EAAK4L,gBAAgBC,eAAgBJ,GACjDE,EAEJtF,EAAWsF,EAAU1L,GAIrBtD,QAAQ4E,KAAM,0DAA8DkK,GAW1EtP,SAEgBiF,IAAfnB,EAAM6L,MAAqC,SAAf7L,EAAM6L,MAEtC3P,EAAK4P,MAAMC,SAAU/L,EAAM6L,KAAM3Q,iBAk5CpC,SAAwBgB,EAAM4I,GAE7B,SAASkH,EAAYC,GAEpBlG,EAAO4B,IAAKsE,EAAG3O,EAAG2O,EAAG1O,EAAG,GAAI2O,aAAcpH,GAE1CmH,EAAGtE,IAAK5B,EAAOzI,EAAGyI,EAAOxI,EAE1B,CAEA,SAAS4O,EAAsBC,GAK9B,MAAMzK,EAAIyK,EAAMC,QACVzK,EAAIwK,EAAME,QAEVC,EAAW/O,KAAKM,IAAKsO,EAAMI,WAC3BC,EAAWjP,KAAKO,IAAKqO,EAAMI,WAE3BE,EAAK,IAAIzR,QAAS0G,EAAI4K,EAAU5K,EAAI8K,EAAU,GAC9CR,EAAK,IAAIhR,SAAW2G,EAAI6K,EAAU7K,EAAI2K,EAAU,GAEhDI,EAAKD,EAAGR,aAAcpH,GACtB8H,EAAKX,EAAGC,aAAcpH,GAEtB+H,EAAKnH,EAAeiC,IACzBgF,EAAGrP,EAAGsP,EAAGtP,EAAG,EACZqP,EAAGpP,EAAGqP,EAAGrP,EAAG,EACZ,EAAG,EAAG,GAGDuP,EAAQnH,EAAeoC,KAAM8E,GAAKE,SAGlCC,EAFSpH,EAAemC,KAAM+E,GAAQG,YAC1BC,SAAUJ,GACb9H,SAETmI,EA+LR,SAA6BC,EAAGC,EAAGC,GAElC,IAAIC,EAAKC,EAAKC,EAAIC,EAAIC,EACtB,MAAMC,EAAKR,EAAIE,EACTO,EAAKT,EAAIE,EACTQ,EAAKtQ,KAAKe,KAAMsP,EAAKA,EAAK,EAAIR,EAAIA,GAEnCO,EAAK,GAETL,EAAM,IAAQK,EAAKE,GACnBH,EAAI,EAAIJ,EACRC,EAAMJ,EAAIO,EAAIL,EAAID,EAAIM,EAAIN,GAEfO,EAAK,EAEhBJ,EAAM,IAAQI,EAAKE,IAMnBP,EAAM,GAAMO,EACZN,GAAQ,GAAMM,GAQdL,EAFII,EAAK,EAEJA,EAAKC,EAILD,EAAKC,EAINtQ,KAAKE,IAAK+P,GAAO,EAAIjQ,KAAKE,IAAK2P,IAEnCM,GAAM,EAAIN,EAAII,EACdC,EAAK,EAAIlQ,KAAKe,KAAM,EAAIoP,EAAIA,GAC5BF,EAAKE,EAAID,GAEoB,IAAlBlQ,KAAKE,IAAK2P,IAErBI,EAAK,EACLC,EAAK,IAILC,GAAM,GAAMF,EAAKJ,EACjBI,EAAK,EAAIjQ,KAAKe,KAAM,EAAIoP,EAAIA,GAC5BD,EAAKC,EAAIF,GAILI,EAAK,IAETF,EAAIF,EACJA,GAAOC,EACPA,EAAKC,GAIN,MAAO,CAAEJ,MAAKC,MAAKC,KAAIC,KAExB,CAlQaK,CAAoBf,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAClDgB,EAAUxQ,KAAKe,KAAM4O,EAAGI,KACxBU,EAAUzQ,KAAKe,KAAM4O,EAAGK,KAE9BpB,EAAMC,QAAU,EAAI2B,EACpB5B,EAAME,QAAU,EAAI2B,EACpB7B,EAAMI,UAAYhP,KAAK0Q,MAAOf,EAAGO,GAAIP,EAAGM,IAQxC,MALGrB,EAAM+B,UAAY/B,EAAMgC,cAAkB,EAAI5Q,KAAKC,IAAO6F,OAAOiC,SAK7C,CAEtB,MAAM8I,EAAS1I,EAAegC,IAC7BqG,EAAS,EAAG,EACZ,EAAGC,EAAS,EACZ,EAAG,EAAG,GAGDK,EAAM1I,EAAe+B,IAC1BwF,EAAGM,GAAIN,EAAGO,GAAI,GACZP,EAAGO,GAAIP,EAAGM,GAAI,EAChB,EAAG,EAAG,GAGDc,EAAOF,EAAOnB,SAAUoB,GAAMpB,SAAUL,GAExC2B,EAAiBC,IAEtB,MAAQnR,EAAGoR,EAAMnR,EAAGoR,GACnB,IAAI1T,QAASuC,KAAKM,IAAK2Q,GAAOjR,KAAKO,IAAK0Q,GAAO,GAAIvC,aAAcqC,GAElE,OAAO/Q,KAAK0Q,MAAOS,EAAMD,EAAM,EAIhCtC,EAAMgC,YAAcI,EAAgBpC,EAAMgC,aAC1ChC,EAAM+B,UAAYK,EAAgBpC,EAAM+B,WAEnCtJ,EAAoBC,KAExBsH,EAAMwC,YAAexC,EAAMwC,WAI7B,CAED,CAEA,SAASC,EAAqBzC,GAK7B,MAAMjH,EAAKC,EAAoBN,GACzBO,EAAKC,EAAoBR,GAE/BsH,EAAMC,SAAWlH,EACjBiH,EAAME,SAAWjH,EASjB,MAAMrG,EACLmG,EAAK7B,OAAOiC,QACT/H,KAAK0Q,MAAOpJ,EAAEE,SAAU,GAAKF,EAAEE,SAAU,IACzCxH,KAAK0Q,OAASpJ,EAAEE,SAAU,GAAKF,EAAEE,SAAU,IAE/CoH,EAAMI,WAAaxN,EAEd6F,EAAoBC,KAExBsH,EAAMgC,cAAiB,EACvBhC,EAAM+B,YAAe,EACrB/B,EAAMwC,YAAexC,EAAMwC,WAI7B,CAEA,MAAM5D,EAAW9O,EAAK8O,SAEtB,IAAM,IAAIrK,EAAI,EAAG6D,EAAIwG,EAASnK,OAAQF,EAAI6D,EAAG7D,IAAO,CAEnD,MACMqJ,EADUgB,EAAUrK,GACHqJ,OAEvB,IAAM,IAAIxB,EAAI,EAAGA,EAAIwB,EAAOnJ,OAAQ2H,IAAO,CAE1C,MAAM4D,EAAQpC,EAAQxB,GAEjB4D,EAAM0C,aAEV9C,EAAYI,EAAMM,IAClBV,EAAYI,EAAMH,KAEPG,EAAM2C,oBAEjB/C,EAAYI,EAAM4C,IAClBhD,EAAYI,EAAMM,IAClBV,EAAYI,EAAMH,IAClBD,EAAYI,EAAM6C,KAEP7C,EAAM8C,wBAEjBlD,EAAYI,EAAM4C,IAClBhD,EAAYI,EAAMM,IAClBV,EAAYI,EAAMH,KAEPG,EAAM+C,iBAIjBrJ,EAAO6B,IAAKyE,EAAMgD,GAAIhD,EAAMiD,IAC5BrD,EAAYlG,GACZsG,EAAMgD,GAAKtJ,EAAOxI,EAClB8O,EAAMiD,GAAKvJ,EAAOvI,EAIb0H,EAAmBH,GAEvBqH,EAAsBC,GAItByC,EAAqBzC,GAMxB,CAED,CAED,CAnkDEkD,CAAepT,EAAM8J,GAErBR,EAAMnC,KAAMnH,GAEZA,EAAKqT,SAAW,CAAExP,KAAMA,EAAMC,MAAOA,IAItC,MAAMwP,EAAazP,EAAKyP,WAExB,IAAM,IAAI7O,EAAI,EAAGA,EAAI6O,EAAW3O,OAAQF,IAAO,CAE9C,MAAMZ,EAAOyP,EAAY7O,GAEpBsH,GAAgC,UAAlBlI,EAAKwG,UAA0C,SAAlBxG,EAAKwG,UASrDH,EAAWrG,EAAMC,EAElB,CAGKsG,IAEJb,EAAegK,MAEVhK,EAAe5E,OAAS,EAE5BmF,EAAiB+B,KAAMtC,EAAgBA,EAAe5E,OAAS,IAI/DmF,EAAiBoB,WAMpB,CA8pDAhB,CAAWH,EAAIyJ,gBAAiB,CAC/B7D,KAAM,OACN8D,YAAa,EACbC,cAAe,EACfC,YAAa,EACbC,eAAgB,QAChBC,cAAe,OACfC,iBAAkB,IAMnB,MAHa,CAAExK,MAAOA,EAAOS,IAAKA,EAAIyJ,gBAKvC,CAQA,mBAAOO,CAAcC,GAEpB,MAAMC,EAAY,UAEZC,EACG,EADHA,EAEQ,EAFRA,EAGI,EAHJA,EAIC,EAJDA,EAKE,EALFA,EAMG,EANHA,EAOG,EAGHC,EAAiB,CACtBC,IAAKF,EACLzC,EAAG,GAGJ,SAAS4C,EAAsBC,EAAIC,EAAIC,EAAIC,GAE1C,MAAMxF,EAAKqF,EAAGlT,EACR+N,EAAKoF,EAAGnT,EACRsT,EAAKF,EAAGpT,EACRuT,EAAKF,EAAGrT,EACR8N,EAAKoF,EAAGjT,EACR+N,EAAKmF,EAAGlT,EACRuT,EAAKJ,EAAGnT,EACRwT,EAAKJ,EAAGpT,EACRyT,GAASH,EAAKD,IAASxF,EAAK0F,IAASC,EAAKD,IAAS3F,EAAKyF,GAExDK,GAAUF,EAAKD,IAASzF,EAAKF,IAAS0F,EAAKD,IAAStF,EAAKF,GACzD8F,EAAKF,EAAOC,EACZE,IAHS9F,EAAKF,IAASC,EAAK0F,IAASxF,EAAKF,IAASD,EAAKyF,IAG5CK,EAElB,GAAmB,IAAVA,GAA4B,IAATD,GAAoBE,GAAM,GAASA,GAAM,GAASC,EAAK,GAASA,EAAK,EAIhG,OAAO,KAED,GAAgB,IAATH,GAA4B,IAAVC,EAAgB,CAK/C,IAAM,IAAItQ,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAI9B,GAFAyQ,EAAqB,IAANzQ,EAAU+P,EAAKC,EAAIH,EAAIC,GAEjCJ,EAAeC,KAAOF,EAAkC,CAE5D,MAAMvH,EAAgB,IAANlI,EAAU+P,EAAKC,EAC/B,MAAO,CAAErT,EAAGuL,EAAMvL,EAAGC,EAAGsL,EAAMtL,EAAGoQ,EAAG0C,EAAe1C,EAEpD,CAAO,GAAK0C,EAAeC,KAAOF,EAAmC,CAIpE,MAAO,CAAE9S,IAFO6N,EAAKkF,EAAe1C,GAAMtC,EAAKF,IAAOkG,YAAa,IAEpD9T,IADC6N,EAAKiF,EAAe1C,GAAMrC,EAAKF,IAAOiG,YAAa,IAC9C1D,EAAG0C,EAAe1C,EAExC,CAED,CAEA,OAAO,IAER,CAIC,IAAM,IAAIhN,EAAI,EAAGA,EAAI,EAAGA,IAIvB,GAFAyQ,EAAqB,IAANzQ,EAAU+P,EAAKC,EAAIH,EAAIC,GAEjCJ,EAAeC,KAAOF,EAAkC,CAE5D,MAAMvH,EAAgB,IAANlI,EAAU+P,EAAKC,EAC/B,MAAO,CAAErT,EAAGuL,EAAMvL,EAAGC,EAAGsL,EAAMtL,EAAGoQ,EAAG0C,EAAe1C,EAEpD,CAMD,MAAO,CAAErQ,IAFO6N,EAAK+F,GAAO7F,EAAKF,IAAOkG,YAAa,IAEtC9T,IADC6N,EAAK8F,GAAO5F,EAAKF,IAAOiG,YAAa,IAChC1D,EAAGuD,EAI1B,CAEA,SAASE,EAAeE,EAAGC,EAAWC,GAErC,MAAMC,EAAKD,EAAQlU,EAAIiU,EAAUjU,EAC3BoU,EAAKF,EAAQjU,EAAIgU,EAAUhU,EAC3BoU,EAAKL,EAAEhU,EAAIiU,EAAUjU,EACrBsU,EAAKN,EAAE/T,EAAIgU,EAAUhU,EACrBsU,EAAKJ,EAAKG,EAAKD,EAAKD,EAE1B,GAAOJ,EAAEhU,IAAMiU,EAAUjU,GAASgU,EAAE/T,IAAMgU,EAAUhU,EAInD,OAFA8S,EAAeC,IAAMF,OACrBC,EAAe1C,EAAI,GAKpB,GAAO2D,EAAEhU,IAAMkU,EAAQlU,GAASgU,EAAE/T,IAAMiU,EAAQjU,EAI/C,OAFA8S,EAAeC,IAAMF,OACrBC,EAAe1C,EAAI,GAKpB,GAAKkE,GAAOvO,OAAOiC,QAGlB,YADA8K,EAAeC,IAAMF,GAKtB,GAAKyB,EAAKvO,OAAOiC,QAGhB,YADA8K,EAAeC,IAAMF,GAMtB,GAASqB,EAAKE,EAAO,GAAWD,EAAKE,EAAO,EAG3C,YADAvB,EAAeC,IAAMF,GAKtB,GAAO5S,KAAKe,KAAMkT,EAAKA,EAAKC,EAAKA,GAAWlU,KAAKe,KAAMoT,EAAKA,EAAKC,EAAKA,GAGrE,YADAvB,EAAeC,IAAMF,GAKtB,IAAIzC,EAIHA,EAFW,IAAP8D,EAEAE,EAAKF,EAILG,EAAKF,EAIVrB,EAAeC,IAAMF,EACrBC,EAAe1C,EAAIA,CAEpB,CAkCA,SAASmE,EAA0BC,EAAUC,EAAaxM,GAEzD,MAAMyM,EAAS,IAAIjX,QACnBgX,EAAYE,UAAWD,GAEvB,MAAME,EAAmB,GA2BzB,OAzBA3M,EAAM4M,SAASlW,IAKd,GAAKA,EAAK8V,YAAYK,cAAeJ,GAAW,EA5ClD,SAA2BK,EAAOC,GAEjC,MAAMC,EAAmB,GACnBC,EAAgB,GAEtB,IAAM,IAAIjI,EAAQ,EAAGA,EAAQ8H,EAAMzR,OAAQ2J,IAAW,CAErD,MAAMkI,EAAiBJ,EAAO9H,EAAQ,GAChCmI,EAAeL,EAAO9H,GAE5B,IAAM,IAAIoI,EAAS,EAAGA,EAASL,EAAM1R,OAAQ+R,IAAY,CAExD,MAGMC,EAAetC,EAAsBmC,EAAgBC,EAHpCJ,EAAOK,EAAS,GAClBL,EAAOK,IAIN,OAAjBC,QAA4I1R,IAAnHqR,EAAiBM,MAAMnS,GAAKA,EAAEgN,GAAKkF,EAAalF,EAAIrK,OAAOiC,SAAW5E,EAAEgN,GAAKkF,EAAalF,EAAIrK,OAAOiC,YAElIiN,EAAiBnP,KAAMwP,GACvBJ,EAAcpP,KAAM,IAAIrI,QAAS6X,EAAavV,EAAGuV,EAAatV,IAIhE,CAED,CAEA,OAAOkV,CAER,EAgByBM,CAAkBhB,EAAU7V,EAAK8W,QAEzCZ,SAASd,IAEtBa,EAAiB9O,KAAM,CAAE4P,WAAY/W,EAAK+W,WAAYC,KAAMhX,EAAKgX,KAAMrK,MAAOyI,GAAK,GAIrF,KAIDa,EAAiBgB,MAAM,CAAEC,EAAIC,IAErBD,EAAGvK,MAAMvL,EAAI+V,EAAGxK,MAAMvL,IAIvB6U,CAER,CAiHA,IAAImB,EAAenD,EACfoD,GAAe,UAEfC,EAActD,EAAUlF,SAAStK,KAAK4Q,IAEzC,MAAM0B,EAAS1B,EAAEmC,YACjB,IAAIC,GAAO,UACPC,EAAOxD,EACPyD,GAAO,UACPC,EAAO1D,EAIX,IAAM,IAAIxP,EAAI,EAAGA,EAAIqS,EAAOnS,OAAQF,IAAO,CAE1C,MAAM2Q,EAAI0B,EAAQrS,GAEb2Q,EAAE/T,EAAImW,IAEVA,EAAOpC,EAAE/T,GAIL+T,EAAE/T,EAAIoW,IAEVA,EAAOrC,EAAE/T,GAIL+T,EAAEhU,EAAIsW,IAEVA,EAAOtC,EAAEhU,GAILgU,EAAEhU,EAAIuW,IAEVA,EAAOvC,EAAEhU,EAIX,CAeA,OAZKiW,GAAgBK,IAEpBL,EAAeK,EAAO,GAIlBN,GAAgBO,IAEpBP,EAAeO,EAAO,GAIhB,CAAE7J,OAAQsH,EAAEtH,OAAQgJ,OAAQA,EAAQE,KAAMpY,WAAWgZ,YAAad,GAAUC,YAAc,EAAGjB,YAAa,IAAI3X,KAAM,IAAIW,QAAS6Y,EAAMF,GAAQ,IAAI3Y,QAAS4Y,EAAMF,IAAU,IAIpLF,EAAcA,EAAYhT,QAAQuT,GAAMA,EAAGf,OAAOnS,OAAS,IAE3D,IAAM,IAAIoS,EAAa,EAAGA,EAAaO,EAAY3S,OAAQoS,IAE1DO,EAAaP,GAAaA,WAAaA,EAKxC,MAAMe,EAAUR,EAAY9S,KAAK4Q,GApLjC,SAAmB2C,EAAYC,EAAUZ,EAAcC,EAAcY,GAE/DA,SAA+D,KAAdA,IAErDA,EAAY,WAIb,MAAMC,EAAoB,IAAIpZ,QAC9BiZ,EAAWjC,YAAYE,UAAWkC,GAElC,MAEMC,EAAwBvC,EAFb,CAAE,IAAI9W,QAASsY,EAAcc,EAAkB7W,GAAK,IAAIvC,QAASuY,EAAca,EAAkB7W,IAEhD0W,EAAWjC,YAAakC,GAE1FG,EAAsBlB,MAAM,CAAEC,EAAIC,IAE1BD,EAAGvK,MAAMvL,EAAI+V,EAAGxK,MAAMvL,IAI9B,MAAMgX,EAAoB,GACpBC,EAAqB,GAE3BF,EAAsBjC,SAASzR,IAEzBA,EAAEsS,aAAegB,EAAWhB,WAEhCqB,EAAkBjR,KAAM1C,GAIxB4T,EAAmBlR,KAAM1C,EAE1B,IAID,MAAM6T,EAAeF,EAAmB,GAAIzL,MAAMvL,EAG5CmX,EAAQ,GACd,IAAI9T,EAAI,EAER,KAAQA,EAAI4T,EAAmB1T,QAAU0T,EAAoB5T,GAAIkI,MAAMvL,EAAIkX,GAErEC,EAAM5T,OAAS,GAAK4T,EAAOA,EAAM5T,OAAS,KAAQ0T,EAAoB5T,GAAIsS,WAE9EwB,EAAMhF,MAINgF,EAAMpR,KAAMkR,EAAoB5T,GAAIsS,YAIrCtS,IAMD,GAFA8T,EAAMpR,KAAM4Q,EAAWhB,YAEJ,YAAdkB,EAA0B,CAE9B,MAAMO,EAASD,EAAM5T,OAAS,GAAM,EAC9B8T,EAAYF,EAAOA,EAAM5T,OAAS,GAExC,MAAO,CAAEoS,WAAYgB,EAAWhB,WAAYyB,OAAQA,EAAQE,IAAKD,EAElE,CAAO,GAAmB,YAAdR,EAA0B,CAGrC,IAAIO,GAAS,EACTC,EAAY,KACZE,EAAc,KAElB,IAAM,IAAIlU,EAAI,EAAGA,EAAI8T,EAAM5T,OAAQF,IAAO,CAEzC,MAAMsS,EAAawB,EAAO9T,GACrB+T,GAEJG,EAAcX,EAAUjB,GAAaC,KACrCwB,GAAS,EACTC,EAAY1B,GAED4B,IAAgBX,EAAUjB,GAAaC,OAElD2B,EAAcX,EAAUjB,GAAaC,KACrCwB,GAAS,EAIX,CAEA,MAAO,CAAEzB,WAAYgB,EAAWhB,WAAYyB,OAAQA,EAAQE,IAAKD,EAElE,CAECjY,QAAQ4E,KAAM,eAAiB6S,EAAY,kCAI7C,CA8EsCW,CAAUxD,EAAGkC,EAAaF,EAAcC,EAAgBrD,EAAUX,SAAWW,EAAUX,SAASvP,MAAM+U,cAAW5T,KAGjJ6T,EAAiB,GAwBvB,OAvBAxB,EAAYpB,SAASd,IAIpB,IAFiB0C,EAAS1C,EAAE2B,YAEZyB,OAAS,CAExB,MAAMO,EAAQ,IAAIra,MAClBqa,EAAMjL,OAASsH,EAAEtH,OACHgK,EAAQxT,QAAQ4J,GAAKA,EAAEsK,QAAUtK,EAAEwK,MAAQtD,EAAE2B,aACrDb,SAAShI,IAEd,MAAM8K,EAAO1B,EAAapJ,EAAE6I,YACtB/W,EAAO,IAAIvB,KACjBuB,EAAK8N,OAASkL,EAAKlL,OACnBiL,EAAME,MAAM9R,KAAMnH,EAAM,IAGzB8Y,EAAe3R,KAAM4R,EAEtB,KAIMD,CAER,CAYA,qBAAOI,CAAgBC,EAAOvJ,EAAOwJ,EAAUC,EAASC,GAQvD,MAAO,CACNC,YAND3J,OAAkB3K,IAAV2K,EAAsBA,EAAQ,OAOrC+D,YARDwF,OAAkBlU,IAAVkU,EAAsBA,EAAQ,EASrCvF,eAPDwF,OAAwBnU,IAAbmU,EAAyBA,EAAW,QAQ9CvF,cAPDwF,OAAsBpU,IAAZoU,EAAwBA,EAAU,OAQ3CvF,iBAPDwF,OAA4BrU,IAAfqU,EAA2BA,EAAa,EAUtD,CAYA,qBAAOE,CAAgB1C,EAAQhT,EAAO2V,EAAcC,GAEnD,MAAMC,EAAW,GACXC,EAAU,GACVC,EAAM,GAEZ,GAAiH,IAA5G5a,UAAU6a,0BAA2BhD,EAAQhT,EAAO2V,EAAcC,EAAaC,EAAUC,EAASC,GAEtG,OAAO,KAIR,MAAME,EAAW,IAAI3b,eAKrB,OAJA2b,EAASC,aAAc,WAAY,IAAI1b,uBAAwBqb,EAAU,IACzEI,EAASC,aAAc,SAAU,IAAI1b,uBAAwBsb,EAAS,IACtEG,EAASC,aAAc,KAAM,IAAI1b,uBAAwBub,EAAK,IAEvDE,CAER,CAeA,gCAAOD,CAA2BhD,EAAQhT,EAAO2V,EAAcC,EAAaC,EAAUC,EAASC,EAAKI,GASnG,MAAMC,EAAW,IAAIpb,QACfqb,EAAW,IAAIrb,QACfsb,EAAW,IAAItb,QACfub,EAAW,IAAIvb,QACfwb,EAAW,IAAIxb,QACfyb,EAAW,IAAIzb,QACf0b,EAAW,IAAI1b,QACf2b,EAAa,IAAI3b,QACjB4b,EAAa,IAAI5b,QACjB6b,EAAU,IAAI7b,QACd8b,EAAU,IAAI9b,QACd+b,EAAgB,IAAI/b,QACpBgc,EAAgB,IAAIhc,QACpBic,EAAa,IAAIjc,QACjBkc,EAAa,IAAIlc,QACjBmc,EAAa,IAAInc,QACjBoc,EAAa,IAAIpc,QAEvB2a,OAAgCxU,IAAjBwU,EAA6BA,EAAe,GAC3DC,OAA8BzU,IAAhByU,EAA4BA,EAAc,KACxDO,OAAgChV,IAAjBgV,EAA6BA,EAAe,EAK3D,MAAMkB,GAFNrE,EAyqBA,SAAiCA,GAKhC,IAAIsE,GAAY,EAChB,IAAM,IAAI3W,EAAI,EAAG6D,EAAIwO,EAAOnS,OAAS,EAAGF,EAAI6D,EAAG7D,IAE9C,GAAKqS,EAAQrS,GAAI4W,WAAYvE,EAAQrS,EAAI,IAAQiV,EAAc,CAE9D0B,GAAY,EACZ,KAED,CAID,IAAOA,EAAY,OAAOtE,EAE1B,MAAMwE,EAAY,GAClBA,EAAUnU,KAAM2P,EAAQ,IAExB,IAAM,IAAIrS,EAAI,EAAG6D,EAAIwO,EAAOnS,OAAS,EAAGF,EAAI6D,EAAG7D,IAEzCqS,EAAQrS,GAAI4W,WAAYvE,EAAQrS,EAAI,KAASiV,GAEjD4B,EAAUnU,KAAM2P,EAAQrS,IAQ1B,OAFA6W,EAAUnU,KAAM2P,EAAQA,EAAOnS,OAAS,IAEjC2W,CAER,CA7sBSC,CAAwBzE,IAERnS,OAEzB,GAAKwW,EAAY,EAAI,OAAO,EAE5B,MAAMK,EAAW1E,EAAQ,GAAI2E,OAAQ3E,EAAQqE,EAAY,IAEzD,IAAIpN,EAEA2N,EADAC,EAAgB7E,EAAQ,GAG5B,MAAM8E,EAAe9X,EAAM6P,YAAc,EAEnCkI,EAAS,GAAMV,EAAY,GACjC,IAAYW,EAERC,EACAC,EACAC,EAJAC,EAAK,EAKLC,GAA0B,EAE1BC,EAAc,EACdC,EAAmC,EAAfpC,EACpBqC,EAAqC,EAAfrC,EAG1BsC,EAAWzF,EAAQ,GAAKA,EAAQ,GAAKoD,GAAWsC,eAAgBZ,GAChEnB,EAAW5O,KAAMiL,EAAQ,IAAM2F,IAAKvC,GACpCQ,EAAW7O,KAAMiL,EAAQ,IAAM4F,IAAKxC,GACpCS,EAAQ9O,KAAM4O,GACdG,EAAQ/O,KAAM6O,GAEd,IAAM,IAAIiC,EAAS,EAAGA,EAASxB,EAAWwB,IAAY,CAErD5O,EAAe+I,EAAQ6F,GAQrBjB,EALGiB,IAAWxB,EAAY,EAEtBK,EAGQ1E,EAAQ,QAEF7R,EAIP6R,EAAQ6F,EAAS,GAK9B,MAAMC,EAAU1C,EAWhB,GAVAqC,EAAWZ,EAAe5N,EAAc6O,GAExCxC,EAASvO,KAAM+Q,GAAUJ,eAAgBZ,GACzCf,EAAchP,KAAMkC,GAAe0O,IAAKrC,GACxCU,EAAcjP,KAAMkC,GAAe2O,IAAKtC,GAExC0B,EAAKI,EAAKL,EAEVE,GAAoB,OAED9W,IAAdyW,EAA0B,CAG9Ba,EAAWxO,EAAc2N,EAAWvB,GAEpCC,EAASvO,KAAMsO,GAAWqC,eAAgBZ,GAC1Cb,EAAWlP,KAAMkC,GAAe0O,IAAKrC,GACrCY,EAAWnP,KAAMkC,GAAe2O,IAAKtC,GAErC4B,GAAmB,EACnB5B,EAASyC,WAAYnB,EAAWC,GAC3BiB,EAAQrZ,IAAK6W,GAAa,IAE9B4B,GAAmB,GAIJ,IAAXW,IAAeR,EAA0BH,GAE9C5B,EAASyC,WAAYnB,EAAW3N,GAChCqM,EAAS0C,YACT,MAAMvZ,EAAMjC,KAAKE,IAAKob,EAAQrZ,IAAK6W,IAGnC,GAAK7W,EAAM6D,OAAOiC,QAAU,CAG3B,MAAM0T,EAAYnB,EAAerY,EACjC6W,EAASoC,gBAAkBO,GAC3B1C,EAASwC,WAAY9O,EAAc4N,GACnCrB,EAASzO,KAAMwO,GAAW2C,UAAWD,GAAYL,IAAKtC,GACtDa,EAAWpP,KAAMyO,GAAW2C,SAC5B,MAAMC,EAAe5C,EAAS3V,SACxBwY,EAAoB9C,EAAS1V,SACnC0V,EAAS+C,aAAcD,GACvB5C,EAASsC,WAAYnB,EAAW3N,GAChC,MAAMsP,EAAoB9C,EAAS5V,SAoCnC,OAnCA4V,EAAS6C,aAAcC,GAElBhD,EAAS9W,IAAK0X,GAAekC,GAAqB5C,EAAShX,IAAK0X,GAAeoC,IAEnFtB,GAAoB,GAIrBb,EAAWrP,KAAMyO,GAAWoC,IAAK3O,GACjCkN,EAAWyB,IAAK3O,GAEhBkO,GAAU,EAELF,EAECC,GAEJhB,EAAWnP,KAAMoP,GACjBH,EAAcjP,KAAMoP,KAIpBF,EAAWlP,KAAMoP,GACjBJ,EAAchP,KAAMoP,IAQrBqC,IAIQxZ,EAAM8P,gBAEd,IAAK,QAEJ2J,EAA0BvB,EAAkBD,EAAmBD,GAE/D,MAED,IAAK,QAIJ0B,EAAyCxB,EAAkBD,GAItDC,EAEJyB,EAAoB1P,EAAc8M,EAAeE,EAAYe,EAAI,GAIjE2B,EAAoB1P,EAAciN,EAAYF,EAAegB,EAAI,GAIlE,MAID,QAEC,MAAM4B,EAAkB9B,EAAe9X,EAAMgQ,iBAAqBoJ,EAElE,GAAKQ,EAAgB,EAAI,CAIxB,GAA8B,eAAzB5Z,EAAM8P,eAAkC,CAE5C2J,EAA0BvB,EAAkBD,EAAmBD,GAC/D,KAED,CAIC0B,EAAyCxB,EAAkBD,GAItDC,GAEJzB,EAASsC,WAAY3B,EAAYL,GAAgB2B,eAAgBkB,GAAgBhB,IAAK7B,GACtFL,EAASqC,WAAY3B,EAAYH,GAAayB,eAAgBkB,GAAgBhB,IAAK3B,GAEnF4C,EAAW9C,EAAeiB,EAAI,GAC9B6B,EAAWpD,EAAUuB,EAAI,GACzB6B,EAAW5P,EAAc+N,EAAI,IAE7B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWpD,EAAUuB,EAAI,GACzB6B,EAAWnD,EAAUsB,EAAI,GAEzB6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWnD,EAAUsB,EAAI,GACzB6B,EAAW5C,EAAYe,EAAI,KAI3BvB,EAASsC,WAAY3B,EAAYJ,GAAgB0B,eAAgBkB,GAAgBhB,IAAK5B,GACtFN,EAASqC,WAAY3B,EAAYF,GAAawB,eAAgBkB,GAAgBhB,IAAK1B,GAEnF2C,EAAW7C,EAAegB,EAAI,GAC9B6B,EAAWpD,EAAUuB,EAAI,GACzB6B,EAAW5P,EAAc+N,EAAI,IAE7B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWpD,EAAUuB,EAAI,GACzB6B,EAAWnD,EAAUsB,EAAI,GAEzB6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWnD,EAAUsB,EAAI,GACzB6B,EAAW3C,EAAYc,EAAI,GAM9B,MAIMC,GAICC,GAEJ2B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAWzC,EAAYY,EAAI,GAE3B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWzC,EAAYY,EAAI,GAC3B6B,EAAW1C,EAAYa,EAAI,KAI3B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAWzC,EAAYY,EAAI,GAE3B6B,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW1C,EAAYa,EAAI,GAC3B6B,EAAWzC,EAAYY,EAAI,IAKvBE,EAEJjB,EAAWlP,KAAMqP,GAIjBF,EAAWnP,KAAMqP,IASbc,GAEJ2B,EAAW9C,EAAeiB,EAAI,GAC9B6B,EAAWzC,EAAYY,EAAI,GAC3B6B,EAAW5P,EAAc+N,EAAI,IAE7B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWzC,EAAYY,EAAI,GAC3B6B,EAAW5C,EAAYe,EAAI,KAI3B6B,EAAW7C,EAAegB,EAAI,GAC9B6B,EAAWzC,EAAYY,EAAI,GAC3B6B,EAAW5P,EAAc+N,EAAI,IAE7B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAWzC,EAAYY,EAAI,GAC3B6B,EAAW3C,EAAYc,EAAI,IAM7BG,GAAU,EAQd,MAICqB,GAIF,MAICA,IAIM9B,GAAYmB,IAAWxB,EAAY,GAGzCyC,EAAgB9G,EAAQ,GAAK6D,EAASC,EAASoB,GAAkB,EAAME,GAMxEA,EAAKJ,EAELH,EAAgB5N,EAEhB0M,EAAW5O,KAAMkP,GACjBL,EAAW7O,KAAMmP,EAElB,CAEA,GAAOQ,GAKA,GAAKO,GAAqBpC,EAAW,CAI3C,IAAIkE,EAAY3C,EACZ4C,EAAY7C,EAEXkB,IAA4BH,IAEhC6B,EAAY5C,EACZ6C,EAAY5C,GAIRc,GAECC,GAAWE,KAEf2B,EAAUC,QAASpE,EAAU,GAC7BmE,EAAUC,QAASpE,EAAU,GAExBsC,GAEJ4B,EAAUE,QAASpE,EAAU,KAQ1BsC,GAAaE,IAEjB2B,EAAUC,QAASpE,EAAU,GAC7BmE,EAAUC,QAASpE,EAAU,GAExBsC,GAEJ4B,EAAUE,QAASpE,EAAU,GAQjC,OAhDCiE,EAAgB7P,EAAc8M,EAAeC,EAAekB,GAAkB,EAAOF,GAkDtF,OAAOM,EAMP,SAASG,EAAWyB,EAAIC,EAAIpX,GAG3B,OADAA,EAAOgW,WAAYoB,EAAID,GAChBnX,EAAO4E,KAAO5E,EAAOxF,EAAGwF,EAAOzF,GAAI0b,WAE3C,CAEA,SAASa,EAAWO,EAAU3V,EAAGrD,GAE3ByU,IAEJA,EAAU0C,GAAsB6B,EAAS9c,EACzCuY,EAAU0C,EAAoB,GAAM6B,EAAS7c,EAC7CsY,EAAU0C,EAAoB,GAAM,EAE/BzC,IAEJA,EAASyC,GAAsB,EAC/BzC,EAASyC,EAAoB,GAAM,EACnCzC,EAASyC,EAAoB,GAAM,GAIpCA,GAAqB,EAEhBxC,IAEJA,EAAKyC,GAAwB/T,EAC7BsR,EAAKyC,EAAsB,GAAMpX,EAEjCoX,GAAuB,IAMzBF,GAAe,CAEhB,CAEA,SAASqB,EAAoB1H,EAAQiI,EAAIC,EAAI1V,EAAGrD,GAK/CgV,EAASrO,KAAMmS,GAAKvB,IAAK1G,GAAS+G,YAClC3C,EAAStO,KAAMoS,GAAKxB,IAAK1G,GAAS+G,YAElC,IAAI3R,EAAQ7J,KAAKC,GACjB,MAAMgC,EAAM2W,EAAS3W,IAAK4W,GACrB7Y,KAAKE,IAAK+B,GAAQ,IAAI4H,EAAQ7J,KAAKE,IAAKF,KAAKoC,KAAMH,KAExD4H,GAASsO,EAETW,EAASvO,KAAMmS,GAEf,IAAM,IAAIvZ,EAAI,EAAG0Z,EAAK1E,EAAe,EAAGhV,EAAI0Z,EAAI1Z,IAE/C4V,EAASxO,KAAMuO,GAAWgE,aAAcrI,EAAQ5K,GAEhDwS,EAAWvD,EAAU7R,EAAGrD,GACxByY,EAAWtD,EAAU9R,EAAGrD,GACxByY,EAAW5H,EAAQxN,EAAG,IAEtB6R,EAASvO,KAAMwO,GAIhBsD,EAAWtD,EAAU9R,EAAGrD,GACxByY,EAAWM,EAAI1V,EAAGrD,GAClByY,EAAW5H,EAAQxN,EAAG,GAEvB,CAEA,SAAS+U,IAERK,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAE9B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAC9B6B,EAAW7C,EAAegB,EAAI,EAE/B,CAEA,SAASyB,EAA0BvB,EAAkBD,EAAmBxT,GAElEwT,EAICC,GAIJ2B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAE9B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAC9B6B,EAAW1C,EAAYa,EAAI,GAI3B6B,EAAW9C,EAAetS,EAAG,GAC7BoV,EAAW5C,EAAYxS,EAAG,GAC1BoV,EAAW1C,EAAY1S,EAAG,MAM1BoV,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW7C,EAAegB,EAAI,GAE9B6B,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW1C,EAAYa,EAAI,GAC3B6B,EAAW7C,EAAegB,EAAI,GAI9B6B,EAAW7C,EAAevS,EAAG,GAC7BoV,EAAW1C,EAAY1S,EAAG,GAC1BoV,EAAW3C,EAAYzS,EAAG,IAQtByT,GAEJ2B,EAAW9C,EAAetS,EAAG,GAC7BoV,EAAW5C,EAAYxS,EAAG,GAC1BoV,EAAW5P,EAAcxF,EAAG,MAI5BoV,EAAW7C,EAAevS,EAAG,GAC7BoV,EAAW3C,EAAYzS,EAAG,GAC1BoV,EAAW5P,EAAcxF,EAAG,IAM/B,CAEA,SAASiV,EAAyCxB,EAAkBD,GAE9DA,IAECC,GAEJ2B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAE9B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAW9C,EAAeiB,EAAI,GAC9B6B,EAAW1C,EAAYa,EAAI,GAE3B6B,EAAW9C,EAAeqB,EAAI,GAC9ByB,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAW1C,EAAYa,EAAI,GAE3B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAW5C,EAAYmB,EAAI,GAC3ByB,EAAW1C,EAAYa,EAAI,KAI3B6B,EAAWjD,EAAYwB,EAAI,GAC3ByB,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW7C,EAAegB,EAAI,GAE9B6B,EAAWlD,EAAYyB,EAAI,GAC3ByB,EAAW1C,EAAYa,EAAI,GAC3B6B,EAAW7C,EAAegB,EAAI,GAE9B6B,EAAW7C,EAAeoB,EAAI,GAC9ByB,EAAW1C,EAAYa,EAAI,GAC3B6B,EAAW5P,EAAc+N,EAAI,IAE7B6B,EAAW5P,EAAc+N,EAAI,IAC7B6B,EAAW1C,EAAYa,EAAI,GAC3B6B,EAAW3C,EAAYkB,EAAI,IAM9B,CAEA,SAAS0B,EAAgB7H,EAAQiI,EAAIC,EAAIjC,EAAkB/a,EAAOsH,GAKjE,OAASzE,EAAM+P,eAEd,IAAK,QAEC5S,EAEJwc,EAAoB1H,EAAQkI,EAAID,EAAIzV,EAAG,IAIvCkV,EAAoB1H,EAAQiI,EAAIC,EAAI1V,EAAG,IAIxC,MAED,IAAK,SAEJ,GAAKtH,EAEJiZ,EAAS2C,WAAYmB,EAAIjI,GACzBoE,EAAS1O,IAAKyO,EAAS7Y,GAAK6Y,EAAS9Y,GAErCgZ,EAASiE,WAAYnE,EAAUC,GAAWuC,IAAK3G,GAC/CsE,EAASwC,WAAY1C,EAAUD,GAAWwC,IAAK3G,GAG1CiG,GAEJ5B,EAAS2D,QAASpE,EAAU,GAC5BU,EAAS0D,QAASpE,EAAU,GAC5BU,EAAS0D,QAASpE,EAAU,KAI5BS,EAAS2D,QAASpE,EAAU,GAEP,IAArBE,EAAK,GAAoBQ,EAAS0D,QAASpE,EAAU,GAAUS,EAAS2D,QAASpE,EAAU,GAC3FU,EAAS0D,QAASpE,EAAU,QAIvB,CAENO,EAAS2C,WAAYoB,EAAIlI,GACzBoE,EAAS1O,IAAKyO,EAAS7Y,GAAK6Y,EAAS9Y,GAErCgZ,EAASiE,WAAYnE,EAAUC,GAAWuC,IAAK3G,GAC/CsE,EAASwC,WAAY1C,EAAUD,GAAWwC,IAAK3G,GAE/C,MAAMuI,EAAK3E,EAAShV,OAGfqX,GAEJ5B,EAAS2D,QAASpE,EAAU2E,EAAK,GACjCjE,EAAS0D,QAASpE,EAAU2E,EAAK,GACjCjE,EAAS0D,QAASpE,EAAU2E,EAAK,MAIjCjE,EAAS0D,QAASpE,EAAU2E,EAAK,GACjClE,EAAS2D,QAASpE,EAAU2E,EAAK,GACjCjE,EAAS0D,QAASpE,EAAU2E,EAAK,IAInC,EAYH,CAwCD,SAKQrf","ignoreList":[]}