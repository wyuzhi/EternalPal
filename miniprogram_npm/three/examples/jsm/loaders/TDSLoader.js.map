{"version":3,"file":"node_modules/three/examples/jsm/loaders/TDSLoader.js","names":["AdditiveBlending","BufferGeometry","Color","DoubleSide","FileLoader","Float32BufferAttribute","Group","Loader","LoaderUtils","Matrix4","Mesh","MeshPhongMaterial","TextureLoader","TDSLoader","constructor","manager","super","this","debug","group","materials","meshes","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","arraybuffer","readFile","i","length","add","DataView","chunk","Chunk","debugMessage","id","MLIBMAGIC","CMAGIC","M3DMAGIC","next","readChunk","M3D_VERSION","version","readDWord","MDATA","readMeshData","hexId","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","N_TRI_OBJECT","mesh","readMesh","push","material","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","value","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","MAT_ADDITIVE","blending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","map","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","POINT_ARRAY","points","readWord","vertices","setAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","position","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","endOfChunk","subchunk","MSH_MAT_GROUP","readMaterialGroup","count","addGroup","Array","isArray","undefined","texture","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","subChunk","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","INT_PERCENTAGE","readShort","FLOAT_PERCENTAGE","message","log","Function","size","end","byteLength","toString","v","getUint8","getFloat32","readInt","getInt32","getInt16","getUint32","getUint16","s","c","String","fromCharCode"],"sources":["node_modules/three/examples/jsm/loaders/TDSLoader.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tBufferGeometry,\n\tColor,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLoader,\n\tLoaderUtils,\n\tMatrix4,\n\tMesh,\n\tMeshPhongMaterial,\n\tTextureLoader\n} from 'three';\n\n/**\n * A loader for the 3DS format, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * ```js\n * const loader = new TDSLoader();\n * loader.setResourcePath( 'models/3ds/portalgun/textures/' );\n * const object = await loader.loadAsync( 'models/3ds/portalgun/portalgun.3ds' );\n * scene.add( object );\n *\n * @augments Loader\n * @three_import import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';\n */\nclass TDSLoader extends Loader {\n\n\t/**\n\t * Constructs a new 3DS loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether debug mode should be enabled or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.debug = false;\n\n\t\t// internals\n\n\t\tthis.group = null;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded 3DS asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given 3DS data and returns the resulting data.\n\t *\n\t * @param {ArrayBuffer} arraybuffer - The raw 3DS data as an array buffer.\n\t * @param {string} path - The asset path.\n\t * @return {Group} The parsed asset represented as a group.\n\t */\n\tparse( arraybuffer, path ) {\n\n\t\tthis.group = new Group();\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile( arraybuffer, path );\n\n\t\tfor ( let i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t}\n\n\t\treturn this.group;\n\n\t}\n\n\t/**\n\t * Decode file content to read 3ds data.\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arraybuffer - Arraybuffer data to be loaded.\n\t * @param {string} path - Path for external resources.\n\t */\n\treadFile( arraybuffer, path ) {\n\n\t\tconst data = new DataView( arraybuffer );\n\t\tconst chunk = new Chunk( data, 0, this.debugMessage );\n\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\tlet next = chunk.readChunk();\n\n\t\t\twhile ( next ) {\n\n\t\t\t\tif ( next.id === M3D_VERSION ) {\n\n\t\t\t\t\tconst version = next.readDWord();\n\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t} else if ( next.id === MDATA ) {\n\n\t\t\t\t\tthis.readMeshData( next, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.hexId );\n\n\t\t\t\t}\n\n\t\t\t\tnext = chunk.readChunk();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - to read mesh from\n\t * @param {string} path - Path for external resources.\n\t */\n\treadMeshData( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MESH_VERSION ) {\n\n\t\t\t\tconst version = + next.readDWord();\n\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t} else if ( next.id === MASTER_SCALE ) {\n\n\t\t\t\tconst scale = next.readFloat();\n\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t} else if ( next.id === NAMED_OBJECT ) {\n\n\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\tthis.readNamedObject( next );\n\n\t\t\t} else if ( next.id === MAT_ENTRY ) {\n\n\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\tthis.readMaterialEntry( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read named object chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t */\n\treadNamedObject( chunk ) {\n\n\t\tconst name = chunk.readString();\n\n\t\tlet next = chunk.readChunk();\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === N_TRI_OBJECT ) {\n\n\t\t\t\tconst mesh = this.readMesh( next );\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read material data chunk and add it to the material list.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {string} path - Path for external resources.\n\t */\n\treadMaterialEntry( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\t\tconst material = new MeshPhongMaterial();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_NAME ) {\n\n\t\t\t\tmaterial.name = next.readString();\n\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t} else if ( next.id === MAT_WIRE ) {\n\n\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t} else if ( next.id === MAT_WIRE_SIZE ) {\n\n\t\t\t\tconst value = next.readByte();\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t} else if ( next.id === MAT_TWO_SIDE ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t} else if ( next.id === MAT_ADDITIVE ) {\n\n\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\tmaterial.blending = AdditiveBlending;\n\n\t\t\t} else if ( next.id === MAT_DIFFUSE ) {\n\n\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SPECULAR ) {\n\n\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\tmaterial.specular = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_AMBIENT ) {\n\n\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SHININESS ) {\n\n\t\t\t\tconst shininess = this.readPercentage( next );\n\t\t\t\tmaterial.shininess = shininess * 100;\n\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t} else if ( next.id === MAT_TRANSPARENCY ) {\n\n\t\t\t\tconst transparency = this.readPercentage( next );\n\t\t\t\tmaterial.opacity = 1 - transparency;\n\t\t\t\tthis.debugMessage( '  Transparency : ' + transparency );\n\t\t\t\tmaterial.transparent = material.opacity < 1 ? true : false;\n\n\t\t\t} else if ( next.id === MAT_TEXMAP ) {\n\n\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\tmaterial.map = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_BUMPMAP ) {\n\n\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\tmaterial.bumpMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_OPACMAP ) {\n\n\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\tmaterial.alphaMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_SPECMAP ) {\n\n\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\tmaterial.specularMap = this.readMap( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t\tthis.materials[ material.name ] = material;\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @return {Mesh} - The parsed mesh.\n\t */\n\treadMesh( chunk ) {\n\n\t\tlet next = chunk.readChunk( );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst material = new MeshPhongMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.name = 'mesh';\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === POINT_ARRAY ) {\n\n\t\t\t\tconst points = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t} else if ( next.id === FACE_ARRAY ) {\n\n\t\t\t\tthis.readFaceArray( next, mesh );\n\n\t\t\t} else if ( next.id === TEX_VERTS ) {\n\n\t\t\t\tconst texels = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst uvs = [];\n\n\t\t\t\tfor ( let i = 0; i < texels; i ++ ) {\n\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t} else if ( next.id === MESH_MATRIX ) {\n\n\t\t\t\tthis.debugMessage( '   Transformation Matrix (TODO)' );\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = next.readFloat( );\n\n\t\t\t\t}\n\n\t\t\t\tconst matrix = new Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tconst inverse = new Matrix4();\n\t\t\t\tinverse.copy( matrix ).invert();\n\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn mesh;\n\n\t}\n\n\t/**\n\t * Read face array data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {Mesh} mesh - Mesh to be filled with the data read.\n\t */\n\treadFaceArray( chunk, mesh ) {\n\n\t\tconst faces = chunk.readWord( );\n\n\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\tconst index = [];\n\n\t\tfor ( let i = 0; i < faces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) );\n\n\t\t\tchunk.readWord( ); // visibility\n\n\t\t}\n\n\t\tmesh.geometry.setIndex( index );\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\n\t\twhile ( ! chunk.endOfChunk ) {\n\n\t\t\tconst subchunk = chunk.readChunk( );\n\n\t\t\tif ( subchunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\tconst group = this.readMaterialGroup( subchunk );\n\t\t\t\tconst count = group.index.length * 3; // assuming successive indices\n\n\t\t\t\tmesh.geometry.addGroup( start, count, materialIndex );\n\n\t\t\t\tstart += count;\n\t\t\t\tmaterialIndex ++;\n\n\t\t\t\tconst material = this.materials[ group.name ];\n\n\t\t\t\tif ( Array.isArray( mesh.material ) === false ) mesh.material = [];\n\n\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\tmesh.material.push( material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + subchunk.hexId );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility\n\n\t}\n\n\t/**\n\t * Read texture map data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {string} path - Path for external resources.\n\t * @return {Texture} Texture read from this data chunk.\n\t */\n\treadMap( chunk, path ) {\n\n\t\tlet next = chunk.readChunk( );\n\t\tlet texture = {};\n\n\t\tconst loader = new TextureLoader( this.manager );\n\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_MAPNAME ) {\n\n\t\t\t\tconst name = next.readString();\n\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t} else if ( next.id === MAT_MAP_UOFFSET ) {\n\n\t\t\t\ttexture.offset.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VOFFSET ) {\n\n\t\t\t\ttexture.offset.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t} else if ( next.id === MAT_MAP_USCALE ) {\n\n\t\t\t\ttexture.repeat.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VSCALE ) {\n\n\t\t\t\ttexture.repeat.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Read material group data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @return {Object} Object with name and index of the object.\n\t */\n\treadMaterialGroup( chunk ) {\n\n\t\tconst name = chunk.readString();\n\t\tconst numFaces = chunk.readWord();\n\n\t\tthis.debugMessage( '         Name: ' + name );\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\tconst index = [];\n\t\tfor ( let i = 0; i < numFaces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ) );\n\n\t\t}\n\n\t\treturn { name: name, index: index };\n\n\t}\n\n\t/**\n\t * Read a color value.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk.\n\t * @return {Color} Color value read.\n\t */\n\treadColor( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\t\tconst color = new Color();\n\n\t\tif ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) {\n\n\t\t\tconst r = subChunk.readByte( );\n\t\t\tconst g = subChunk.readByte( );\n\t\t\tconst b = subChunk.readByte( );\n\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) {\n\n\t\t\tconst r = subChunk.readFloat( );\n\t\t\tconst g = subChunk.readFloat( );\n\t\t\tconst b = subChunk.readFloat( );\n\n\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse {\n\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + subChunk.hexId );\n\n\t\t}\n\n\t\treturn color;\n\n\t}\n\n\t/**\n\t * Read percentage value.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk to read data from.\n\t * @return {number} Data read from the dataview.\n\t */\n\treadPercentage( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\n\t\tswitch ( subChunk.id ) {\n\n\t\t\tcase INT_PERCENTAGE:\n\t\t\t\treturn ( subChunk.readShort( ) / 100 );\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT_PERCENTAGE:\n\t\t\t\treturn subChunk.readFloat( );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.debugMessage( '      Unknown percentage chunk: ' + subChunk.hexId );\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Print debug message to the console.\n\t *\n\t * Is controlled by a flag to show or hide debug messages.\n\t *\n\t * @private\n\t * @param {Object} message - Debug message to print to the console.\n\t */\n\tdebugMessage( message ) {\n\n\t\tif ( this.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Read data/sub-chunks from chunk.\n *\n * @private\n */\nclass Chunk {\n\n\t/**\n\t * Create a new chunk\n\t *\n\t * @private\n\t * @param {DataView} data - DataView to read from.\n\t * @param {number} position - In data.\n\t * @param {Function} debugMessage - Logging callback.\n\t */\n\tconstructor( data, position, debugMessage ) {\n\n\t\tthis.data = data;\n\t\t// the offset to the begin of this chunk\n\t\tthis.offset = position;\n\t\t// the current reading position\n\t\tthis.position = position;\n\t\tthis.debugMessage = debugMessage;\n\n\t\tif ( this.debugMessage instanceof Function ) {\n\n\t\t\tthis.debugMessage = function () {};\n\n\t\t}\n\n\t\tthis.id = this.readWord();\n\t\tthis.size = this.readDWord();\n\t\tthis.end = this.offset + this.size;\n\n\t\tif ( this.end > data.byteLength ) {\n\n\t\t\tthis.debugMessage( 'Bad chunk size for chunk at ' + position );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Reads a sub cchunk.\n\t *\n\t * @private\n\t * @return {Chunk | null} next sub chunk.\n\t */\n\treadChunk() {\n\n\t\tif ( this.endOfChunk ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst next = new Chunk( this.data, this.position, this.debugMessage );\n\t\t\tthis.position += next.size;\n\t\t\treturn next;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the ID of this chunk as Hex\n\t *\n\t * @private\n\t * @return {string} hex-string of id\n\t */\n\tget hexId() {\n\n\t\treturn this.id.toString( 16 );\n\n\t}\n\n\tget endOfChunk() {\n\n\t\treturn this.position >= this.end;\n\n\t}\n\n\t/**\n\t * Read byte value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadByte() {\n\n\t\tconst v = this.data.getUint8( this.position, true );\n\t\tthis.position += 1;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit float value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadFloat() {\n\n\t\ttry {\n\n\t\t\tconst v = this.data.getFloat32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength );\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read 32 bit signed integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadInt() {\n\n\t\tconst v = this.data.getInt32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 16 bit signed integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadShort() {\n\n\t\tconst v = this.data.getInt16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 64 bit unsigned integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadDWord() {\n\n\t\tconst v = this.data.getUint32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit unsigned integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadWord() {\n\n\t\tconst v = this.data.getUint16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read NULL terminated ASCII string value from chunk-pos.\n\t *\n\t * @private\n\t * @return {string} Data read from the dataview.\n\t */\n\treadString() {\n\n\t\tlet s = '';\n\t\tlet c = this.readByte();\n\t\twhile ( c ) {\n\n\t\t\ts += String.fromCharCode( c );\n\t\t\tc = this.readByte();\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader };\n"],"mappings":"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","ignoreList":[]}