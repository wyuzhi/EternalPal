{"version":3,"file":"node_modules/three/examples/jsm/loaders/TGALoader.js","names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","constructor","manager","super","parse","buffer","TGA_TYPE_NO_DATA","TGA_TYPE_INDEXED","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_INDEXED","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_BL","TGA_ORIGIN_BR","TGA_ORIGIN_UL","TGA_ORIGIN_UR","length","Error","offset","content","Uint8Array","header","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","tgaCheckHeader","use_rle","use_pal","use_grey","imageData","result","data","pixel_data","palettes","pixel_total","subarray","c","count","i","shift","pixels","set","tgaParse","image","palette","x_start","y_start","x_step","y_step","x_end","y_end","color","x","y","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","colormap","tgaGetImageData8bits","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","getTgaRGBA","flipY","generateMipmaps","minFilter"],"sources":["node_modules/three/examples/jsm/loaders/TGALoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tLinearMipmapLinearFilter\n} from 'three';\n\n/**\n * A loader for the TGA texture format.\n *\n * ```js\n * const loader = new TGALoader();\n * const texture = await loader.loadAsync( 'textures/crate_color8.tga' );\n * texture.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments DataTextureLoader\n * @three_import import { TGALoader } from 'three/addons/loaders/TGALoader.js';\n */\nclass TGALoader extends DataTextureLoader {\n\n\t/**\n\t * Constructs a new TGA loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Parses the given TGA texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @return {DataTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type ' + header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid pixel size ' + header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tlet pixel_data,\n\t\t\t\tpalettes;\n\n\t\t\tconst pixel_size = header.pixel_size >> 3;\n\t\t\tconst pixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tlet c, count, i;\n\t\t\t\tlet shift = 0;\n\t\t\t\tconst pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tconst colormap = palettes;\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 );\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tlet x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tconst TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) throw new Error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tlet offset = 0;\n\n\t\tconst content = new Uint8Array( buffer ),\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tlet use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tconst imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tconst result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n}\n\nexport { TGALoader };\n"],"mappings":"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","ignoreList":[]}