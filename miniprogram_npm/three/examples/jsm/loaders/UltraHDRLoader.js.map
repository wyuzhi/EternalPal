{"version":3,"file":"node_modules/three/examples/jsm/loaders/UltraHDRLoader.js","names":["ClampToEdgeWrapping","DataTexture","DataUtils","FileLoader","HalfFloatType","LinearFilter","LinearMipMapLinearFilter","LinearSRGBColorSpace","Loader","RGBAFormat","UVMapping","SRGB_TO_LINEAR","Array","fill","map","_","value","Math","pow","UltraHDRLoader","constructor","manager","super","this","type","setDataType","parse","buffer","onLoad","xmpMetadata","version","baseRenditionIsHDR","gainMapMin","gainMapMax","gamma","offsetSDR","offsetHDR","hdrCapacityMin","hdrCapacityMax","textDecoder","TextDecoder","data","DataView","byteOffset","sections","byteLength","byte","getUint8","leadingByte","includes","push","sectionType","section","sectionOffset","length","primaryImage","gainmapImage","i","_parseXMPMetadata","decode","Uint8Array","sectionData","slice","getUint32","mpfLittleEndian","mpfBytesOffset","primaryImageSize","primaryImageOffset","gainmapImageSize","gainmapImageOffset","Error","_applyGainmapToSDR","hdrBuffer","width","height","format","error","load","url","onProgress","onError","texture","Uint16Array","Float32Array","generateMipmaps","flipY","loader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","texData","image","needsUpdate","console","xmpDataString","xmpXml","DOMParser","parseFromString","substring","indexOf","lastIndexOf","hasHDRContainerDescriptor","getElementsByTagName","gainmapNode","getAttribute","parseFloat","_srgbToLinear","sdrBuffer","gainmapBuffer","onSuccess","getImageDataFromBuffer","Promise","resolve","reject","imageLoader","document","createElement","onload","naturalWidth","naturalHeight","source","URL","revokeObjectURL","src","onerror","createObjectURL","Blob","all","then","sdrImage","canvas","ctx","getContext","willReadFrequently","colorSpace","drawImage","gainmapImageData","getImageData","sdrImageData","maxDisplayBoost","sqrt","unclampedWeightFactor","log2","weightFactor","min","max","useGammaOne","pixelIndex","x","y","floor","channelIndex","sdrValue","gainmapIndex","gainmapValue","logRecovery","logBoost","hdrValue","linearHDRValue","toHalfFloat","catch"],"sources":["node_modules/three/examples/jsm/loaders/UltraHDRLoader.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tDataUtils,\n\tFileLoader,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tRGBAFormat,\n\tUVMapping,\n} from 'three';\n\n/**\n * UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format\n *\n * Short format brief:\n *\n *  [JPEG headers]\n *  [XMP metadata describing the MPF container and *both* SDR and gainmap images]\n *  [Optional metadata] [EXIF] [ICC Profile]\n *  [SDR image]\n *  [XMP metadata describing only the gainmap image]\n *  [Gainmap image]\n *\n * Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)\n * Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.\n */\n\n\n// Calculating this SRGB powers is extremely slow for 4K images and can be sufficiently precalculated for a 3-4x speed boost\nconst SRGB_TO_LINEAR = Array( 1024 )\n\t.fill( 0 )\n\t.map( ( _, value ) =>\n\t\tMath.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 )\n\t);\n\n/**\n * A loader for the Ultra HDR Image Format.\n *\n * Existing HDR or EXR textures can be converted to Ultra HDR with this [tool]{@link https://gainmap-creator.monogrid.com/}.\n *\n * Current feature set:\n * - JPEG headers (required)\n * - XMP metadata (required)\n * - XMP validation (not implemented)\n * - EXIF profile (not implemented)\n * - ICC profile (not implemented)\n * - Binary storage for SDR & HDR images (required)\n * - Gainmap metadata (required)\n * - Non-JPEG image formats (not implemented)\n * - Primary image as an HDR image (not implemented)\n *\n * ```js\n * const loader = new UltraHDRLoader();\n * const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );\n * texture.mapping = THREE.EquirectangularReflectionMapping;\n *\n * scene.background = texture;\n * scene.environment = texture;\n * ```\n *\n * @augments Loader\n * @three_import import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n */\nclass UltraHDRLoader extends Loader {\n\n\t/**\n\t * Constructs a new Ultra HDR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBELoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given Ultra HDR texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {Function} onLoad - The `onLoad` callback.\n\t */\n\tparse( buffer, onLoad ) {\n\n\t\tconst xmpMetadata = {\n\t\t\tversion: null,\n\t\t\tbaseRenditionIsHDR: null,\n\t\t\tgainMapMin: null,\n\t\t\tgainMapMax: null,\n\t\t\tgamma: null,\n\t\t\toffsetSDR: null,\n\t\t\toffsetHDR: null,\n\t\t\thdrCapacityMin: null,\n\t\t\thdrCapacityMax: null,\n\t\t};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tconst data = new DataView( buffer );\n\n\t\tlet byteOffset = 0;\n\t\tconst sections = [];\n\n\t\twhile ( byteOffset < data.byteLength ) {\n\n\t\t\tconst byte = data.getUint8( byteOffset );\n\n\t\t\tif ( byte === 0xff ) {\n\n\t\t\t\tconst leadingByte = data.getUint8( byteOffset + 1 );\n\n\t\t\t\tif (\n\t\t\t\t\t[\n\t\t\t\t\t\t/* Valid section headers */\n\t\t\t\t\t\t0xd8, // SOI\n\t\t\t\t\t\t0xe0, // APP0\n\t\t\t\t\t\t0xe1, // APP1\n\t\t\t\t\t\t0xe2, // APP2\n\t\t\t\t\t].includes( leadingByte )\n\t\t\t\t) {\n\n\t\t\t\t\tsections.push( {\n\t\t\t\t\t\tsectionType: leadingByte,\n\t\t\t\t\t\tsection: [ byte, leadingByte ],\n\t\t\t\t\t\tsectionOffset: byteOffset + 2,\n\t\t\t\t\t} );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsections[ sections.length - 1 ].section.push( byte, leadingByte );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsections[ sections.length - 1 ].section.push( byte );\n\n\t\t\t\tbyteOffset ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet primaryImage, gainmapImage;\n\n\t\tfor ( let i = 0; i < sections.length; i ++ ) {\n\n\t\t\tconst { sectionType, section, sectionOffset } = sections[ i ];\n\n\t\t\tif ( sectionType === 0xe0 ) {\n\t\t\t\t/* JPEG Header - no useful information */\n\t\t\t} else if ( sectionType === 0xe1 ) {\n\n\t\t\t\t/* XMP Metadata */\n\n\t\t\t\tthis._parseXMPMetadata(\n\t\t\t\t\ttextDecoder.decode( new Uint8Array( section ) ),\n\t\t\t\t\txmpMetadata\n\t\t\t\t);\n\n\t\t\t} else if ( sectionType === 0xe2 ) {\n\n\t\t\t\t/* Data Sections - MPF / EXIF / ICC Profile */\n\n\t\t\t\tconst sectionData = new DataView(\n\t\t\t\t\tnew Uint8Array( section.slice( 2 ) ).buffer\n\t\t\t\t);\n\t\t\t\tconst sectionHeader = sectionData.getUint32( 2, false );\n\n\t\t\t\tif ( sectionHeader === 0x4d504600 ) {\n\n\t\t\t\t\t/* MPF Section */\n\n\t\t\t\t\t/* Section contains a list of static bytes and ends with offsets indicating location of SDR and gainmap images */\n\t\t\t\t\t/* First bytes after header indicate little / big endian ordering (0x49492A00 - LE / 0x4D4D002A - BE) */\n\t\t\t\t\t/*\n\t\t\t\t\t... 60 bytes indicating tags, versions, etc. ...\n\n\t\t\t\t\tbytes | bits | description\n\n\t\t\t\t\t4       32     primary image size\n\t\t\t\t\t4       32     primary image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\n\t\t\t\t\t4       32     0x00000000\n\t\t\t\t\t4       32     gainmap image size\n\t\t\t\t\t4       32     gainmap image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t*/\n\n\t\t\t\t\tconst mpfLittleEndian = sectionData.getUint32( 6 ) === 0x49492a00;\n\t\t\t\t\tconst mpfBytesOffset = 60;\n\n\t\t\t\t\t/* SDR size includes the metadata length, SDR offset is always 0 */\n\n\t\t\t\t\tconst primaryImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst primaryImageOffset = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 4,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\n\t\t\t\t\t/* Gainmap size is an absolute value starting from its offset, gainmap offset needs 6 bytes padding to take into account 0x00 bytes at the end of XMP */\n\t\t\t\t\tconst gainmapImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 16,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst gainmapImageOffset =\n\t\t\t\t\t\tsectionData.getUint32( mpfBytesOffset + 20, mpfLittleEndian ) +\n\t\t\t\t\t\tsectionOffset +\n\t\t\t\t\t\t6;\n\n\t\t\t\t\tprimaryImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tprimaryImageOffset,\n\t\t\t\t\t\tprimaryImageSize\n\t\t\t\t\t);\n\n\t\t\t\t\tgainmapImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tgainmapImageOffset,\n\t\t\t\t\t\tgainmapImageSize\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Minimal sufficient validation - https://developer.android.com/media/platform/hdr-image-format#signal_of_the_format */\n\t\tif ( ! xmpMetadata.version ) {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Not a valid UltraHDR image' );\n\n\t\t}\n\n\t\tif ( primaryImage && gainmapImage ) {\n\n\t\t\tthis._applyGainmapToSDR(\n\t\t\t\txmpMetadata,\n\t\t\t\tprimaryImage,\n\t\t\t\tgainmapImage,\n\t\t\t\t( hdrBuffer, width, height ) => {\n\n\t\t\t\t\tonLoad( {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tdata: hdrBuffer,\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: this.type,\n\t\t\t\t\t} );\n\n\t\t\t\t},\n\t\t\t\t( error ) => {\n\n\t\t\t\t\tthrow new Error( error );\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Could not parse UltraHDR images' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded Ultra HDR texture\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the files to be loaded. This can also be a data URI.\n\t * @param {function(DataTexture, Object)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {DataTexture} The Ultra HDR texture.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new DataTexture(\n\t\t\tthis.type === HalfFloatType ? new Uint16Array() : new Float32Array(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tRGBAFormat,\n\t\t\tthis.type,\n\t\t\tUVMapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tLinearFilter,\n\t\t\tLinearMipMapLinearFilter,\n\t\t\t1,\n\t\t\tLinearSRGBColorSpace\n\t\t);\n\t\ttexture.generateMipmaps = true;\n\t\ttexture.flipY = true;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\ttry {\n\n\t\t\t\tthis.parse(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t( texData ) => {\n\n\t\t\t\t\t\ttexture.image = {\n\t\t\t\t\t\t\tdata: texData.data,\n\t\t\t\t\t\t\twidth: texData.width,\n\t\t\t\t\t\t\theight: texData.height,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n\t_parseXMPMetadata( xmpDataString, xmpMetadata ) {\n\n\t\tconst domParser = new DOMParser();\n\n\t\tconst xmpXml = domParser.parseFromString(\n\t\t\txmpDataString.substring(\n\t\t\t\txmpDataString.indexOf( '<' ),\n\t\t\t\txmpDataString.lastIndexOf( '>' ) + 1\n\t\t\t),\n\t\t\t'text/xml'\n\t\t);\n\n\t\t/* Determine if given XMP metadata is the primary GContainer descriptor or a gainmap descriptor */\n\t\tconst [ hasHDRContainerDescriptor ] = xmpXml.getElementsByTagName(\n\t\t\t'Container:Directory'\n\t\t);\n\n\t\tif ( hasHDRContainerDescriptor ) {\n\t\t\t/* There's not much useful information in the container descriptor besides memory-validation */\n\t\t} else {\n\n\t\t\t/* Gainmap descriptor - defaults from https://developer.android.com/media/platform/hdr-image-format#HDR_gain_map_metadata */\n\n\t\t\tconst [ gainmapNode ] = xmpXml.getElementsByTagName( 'rdf:Description' );\n\n\t\t\txmpMetadata.version = gainmapNode.getAttribute( 'hdrgm:Version' );\n\t\t\txmpMetadata.baseRenditionIsHDR =\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:BaseRenditionIsHDR' ) === 'True';\n\t\t\txmpMetadata.gainMapMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.gainMapMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMax' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.gamma = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:Gamma' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.offsetSDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetSDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.offsetHDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetHDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMax' ) || 1.0\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t_srgbToLinear( value ) {\n\n\t\tif ( value / 255 < 0.04045 ) {\n\n\t\t\treturn ( value / 255 ) * 0.0773993808;\n\n\t\t}\n\n\t\tif ( value < 1024 ) {\n\n\t\t\treturn SRGB_TO_LINEAR[ ~ ~ value ];\n\n\t\t}\n\n\t\treturn Math.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t}\n\n\t_applyGainmapToSDR(\n\t\txmpMetadata,\n\t\tsdrBuffer,\n\t\tgainmapBuffer,\n\t\tonSuccess,\n\t\tonError\n\t) {\n\n\t\tconst getImageDataFromBuffer = ( buffer ) =>\n\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\tconst imageLoader = document.createElement( 'img' );\n\n\t\t\t\timageLoader.onload = () => {\n\n\t\t\t\t\tconst image = {\n\t\t\t\t\t\twidth: imageLoader.naturalWidth,\n\t\t\t\t\t\theight: imageLoader.naturalHeight,\n\t\t\t\t\t\tsource: imageLoader,\n\t\t\t\t\t};\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\tresolve( image );\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.onerror = () => {\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\treject();\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.src = URL.createObjectURL(\n\t\t\t\t\tnew Blob( [ buffer ], { type: 'image/jpeg' } )\n\t\t\t\t);\n\n\t\t\t} );\n\n\t\tPromise.all( [\n\t\t\tgetImageDataFromBuffer( sdrBuffer ),\n\t\t\tgetImageDataFromBuffer( gainmapBuffer ),\n\t\t] )\n\t\t\t.then( ( [ sdrImage, gainmapImage ] ) => {\n\n\t\t\t\tconst sdrImageAspect = sdrImage.width / sdrImage.height;\n\t\t\t\tconst gainmapImageAspect = gainmapImage.width / gainmapImage.height;\n\n\t\t\t\tif ( sdrImageAspect !== gainmapImageAspect ) {\n\n\t\t\t\t\tonError(\n\t\t\t\t\t\t'THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images'\n\t\t\t\t\t);\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\t\twillReadFrequently: true,\n\t\t\t\t\tcolorSpace: 'srgb',\n\t\t\t\t} );\n\n\t\t\t\tcanvas.width = sdrImage.width;\n\t\t\t\tcanvas.height = sdrImage.height;\n\n\t\t\t\t/* Use out-of-the-box interpolation of Canvas API to scale gainmap to fit the SDR resolution */\n\t\t\t\tctx.drawImage(\n\t\t\t\t\tgainmapImage.source,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tgainmapImage.width,\n\t\t\t\t\tgainmapImage.height,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height\n\t\t\t\t);\n\t\t\t\tconst gainmapImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\tctx.drawImage( sdrImage.source, 0, 0 );\n\t\t\t\tconst sdrImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\t/* HDR Recovery formula - https://developer.android.com/media/platform/hdr-image-format#use_the_gain_map_to_create_adapted_HDR_rendition */\n\t\t\t\tlet hdrBuffer;\n\n\t\t\t\tif ( this.type === HalfFloatType ) {\n\n\t\t\t\t\thdrBuffer = new Uint16Array( sdrImageData.data.length ).fill( 23544 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thdrBuffer = new Float32Array( sdrImageData.data.length ).fill( 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst maxDisplayBoost = Math.sqrt(\n\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t/* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */\n\t\t\t\t\t\t1.8,\n\t\t\t\t\t\txmpMetadata.hdrCapacityMax\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tconst unclampedWeightFactor =\n\t\t\t\t\t( Math.log2( maxDisplayBoost ) - xmpMetadata.hdrCapacityMin ) /\n\t\t\t\t\t( xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin );\n\t\t\t\tconst weightFactor = Math.min(\n\t\t\t\t\tMath.max( unclampedWeightFactor, 0.0 ),\n\t\t\t\t\t1.0\n\t\t\t\t);\n\t\t\t\tconst useGammaOne = xmpMetadata.gamma === 1.0;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet pixelIndex = 0;\n\t\t\t\t\tpixelIndex < sdrImageData.data.length;\n\t\t\t\t\tpixelIndex += 4\n\t\t\t\t) {\n\n\t\t\t\t\tconst x = ( pixelIndex / 4 ) % sdrImage.width;\n\t\t\t\t\tconst y = Math.floor( pixelIndex / 4 / sdrImage.width );\n\n\t\t\t\t\tfor ( let channelIndex = 0; channelIndex < 3; channelIndex ++ ) {\n\n\t\t\t\t\t\tconst sdrValue = sdrImageData.data[ pixelIndex + channelIndex ];\n\n\t\t\t\t\t\tconst gainmapIndex = ( y * sdrImage.width + x ) * 4 + channelIndex;\n\t\t\t\t\t\tconst gainmapValue = gainmapImageData.data[ gainmapIndex ] / 255.0;\n\n\t\t\t\t\t\t/* Gamma is 1.0 by default */\n\t\t\t\t\t\tconst logRecovery = useGammaOne\n\t\t\t\t\t\t\t? gainmapValue\n\t\t\t\t\t\t\t: Math.pow( gainmapValue, 1.0 / xmpMetadata.gamma );\n\n\t\t\t\t\t\tconst logBoost =\n\t\t\t\t\t\t\txmpMetadata.gainMapMin * ( 1.0 - logRecovery ) +\n\t\t\t\t\t\t\txmpMetadata.gainMapMax * logRecovery;\n\n\t\t\t\t\t\tconst hdrValue =\n\t\t\t\t\t\t\t( sdrValue + xmpMetadata.offsetSDR ) *\n\t\t\t\t\t\t\t\t( logBoost * weightFactor === 0.0\n\t\t\t\t\t\t\t\t\t? 1.0\n\t\t\t\t\t\t\t\t\t: Math.pow( 2, logBoost * weightFactor ) ) -\n\t\t\t\t\t\t\txmpMetadata.offsetHDR;\n\n\t\t\t\t\t\tconst linearHDRValue = Math.min(\n\t\t\t\t\t\t\tMath.max( this._srgbToLinear( hdrValue ), 0 ),\n\t\t\t\t\t\t\t65504\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\thdrBuffer[ pixelIndex + channelIndex ] =\n\t\t\t\t\t\t\tthis.type === HalfFloatType\n\t\t\t\t\t\t\t\t? DataUtils.toHalfFloat( linearHDRValue )\n\t\t\t\t\t\t\t\t: linearHDRValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tonSuccess( hdrBuffer, sdrImage.width, sdrImage.height );\n\n\t\t\t} )\n\t\t\t.catch( () => {\n\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'THREE.UltraHDRLoader Error: Could not parse UltraHDR images'\n\t\t\t\t);\n\n\t\t\t} );\n\n\t}\n\n}\n\nexport { UltraHDRLoader };\n"],"mappings":"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","ignoreList":[]}