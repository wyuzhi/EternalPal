{"version":3,"file":"node_modules/three/examples/jsm/loaders/VRMLLoader.js","names":["BackSide","BoxGeometry","BufferAttribute","BufferGeometry","ClampToEdgeWrapping","Color","ColorManagement","ConeGeometry","CylinderGeometry","DataTexture","DoubleSide","FileLoader","Float32BufferAttribute","FrontSide","Group","LineBasicMaterial","LineSegments","Loader","LoaderUtils","Mesh","MeshBasicMaterial","MeshPhongMaterial","Object3D","Points","PointsMaterial","Quaternion","RepeatWrapping","Scene","ShapeUtils","SphereGeometry","SRGBColorSpace","TextureLoader","Vector2","Vector3","chevrotain","VRMLLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","buildNodeMap","node","DEF","fields","i","l","length","field","type","fieldValues","values","j","jl","getNode","USE","identifier","build","isObject3D","isMaterial","clone","resolveUSE","undefined","nodeName","name","object","fieldName","parseFieldChildren","axis","normalize","angle","quaternion","setFromAxisAngle","scale","set","position","warn","buildGroupingNode","group","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","add","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","buildBackgroundNode","geometry","material","DEFAULT_MATERIAL_NAME","attributes","_type","pointsMaterial","opacity","transparent","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","buildShapeNode","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","buildAppearanceNode","buildMaterialNode","texture","wrapS","wrapT","textureLoader","colorSpace","buildImageTextureNode","width","height","textureType","getTextureType","Uint8Array","r","g","b","a","k","parseHexColor","stride","needsUpdate","buildPixelTextureNode","buildTextureTransformNode","coord","normal","texCoord","colorIndex","coordIndex","normalIndex","texCoordIndex","ccw","solid","creaseAngle","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","computeAttributeFromIndexedData","toNonIndexedAttribute","computeAttributeFromFaceData","triangulateFaceData","flattenData","convertColorsToLinearSRGB","computeNormalAttribute","positionAttribute","setAttribute","buildIndexedFaceSetNode","expandedLineIndex","expandLineIndex","computeAttributeFromLineData","expandLineData","buildIndexedLineSetNode","buildPointSetNode","size","x","y","z","buildBoxNode","openEnded","buildConeNode","buildCylinderNode","buildSphereNode","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","push","xn","yn","zn","s","t","indices","c","d","buildElevationGridNode","orientation","crossSection","spine","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","buildExtrusionNode","buildGeometricNode","worldInfo","title","info","buildWorldInfoNode","hasOwnProperty","buildNode","hex","value","INTENSITY","parseInt","substring","num_components","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","nA","weightedNormal","nB","nC","vector","angleTo","count","fromBufferAttribute","colorSpaceToWorking","setXYZ","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","getX","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","resourcePath","setCrossOrigin","crossOrigin","indexOf","Error","tree","tokenData","createToken","RouteIdentifier","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","Lexer","SKIPPED","tokens","tokenVocabulary","token","createTokens","lexer","VRMLLexer","parser","VRMLParser","visitor","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","vrml","ctx","version","visit","nodes","routes","route","image","def","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","forEach","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","errors","generateVRMLTree","scene","userData","parseTree","inputText","tokenize","CstParser","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"sources":["node_modules/three/examples/jsm/loaders/VRMLLoader.js"],"sourcesContent":["import {\n\tBackSide,\n\tBoxGeometry,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tConeGeometry,\n\tCylinderGeometry,\n\tDataTexture,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhongMaterial,\n\tObject3D,\n\tPoints,\n\tPointsMaterial,\n\tQuaternion,\n\tRepeatWrapping,\n\tScene,\n\tShapeUtils,\n\tSphereGeometry,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tVector2,\n\tVector3\n} from 'three';\nimport chevrotain from '../libs/chevrotain.module.min.js';\n\n/**\n * A loader for the VRML format.\n *\n * ```js\n * const loader = new VRMLLoader();\n * const object = await loader.loadAsync( 'models/vrml/house.wrl' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { VRMLLoader } from 'three/addons/loaders/VRMLLoader.js';\n */\nclass VRMLLoader extends Loader {\n\n\t/**\n\t * Constructs a new VRML loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded VRML asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Scene)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given VRML data and returns the resulting scene.\n\t *\n\t * @param {string} data - The raw VRML data as a string.\n\t * @param {string} path - The URL base path.\n\t * @return {Scene} The parsed scene.\n\t */\n\tparse( data, path ) {\n\n\t\tconst nodeMap = {};\n\n\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t// create lexer, parser and visitor\n\n\t\t\tconst tokenData = createTokens();\n\n\t\t\tconst lexer = new VRMLLexer( tokenData.tokens );\n\t\t\tconst parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\tconst visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t// lexing\n\n\t\t\tconst lexingResult = lexer.lex( data );\n\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t// parsing\n\n\t\t\tconst cstOutput = parser.vrml();\n\n\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t}\n\n\t\t\t// actions\n\n\t\t\tconst ast = visitor.visit( cstOutput );\n\n\t\t\treturn ast;\n\n\t\t}\n\n\t\tfunction createTokens() {\n\n\t\t\tconst createToken = chevrotain.createToken;\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\tconst RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\tconst Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]([^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d])*/, longer_alt: RouteIdentifier } );\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\tconst nodeTypes = [\n\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t];\n\n\t\t\t//\n\n\t\t\tconst Version = createToken( {\n\t\t\t\tname: 'Version',\n\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst NodeName = createToken( {\n\t\t\t\tname: 'NodeName',\n\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst DEF = createToken( {\n\t\t\t\tname: 'DEF',\n\t\t\t\tpattern: /DEF/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst USE = createToken( {\n\t\t\t\tname: 'USE',\n\t\t\t\tpattern: /USE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst ROUTE = createToken( {\n\t\t\t\tname: 'ROUTE',\n\t\t\t\tpattern: /ROUTE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst TO = createToken( {\n\t\t\t\tname: 'TO',\n\t\t\t\tpattern: /TO/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/ } );\n\t\t\tconst HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\tconst NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\tconst TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\tconst FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\tconst NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\tconst LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\tconst RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\tconst LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\tconst RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\tconst Comment = createToken( {\n\t\t\t\tname: 'Comment',\n\t\t\t\tpattern: /#.*/,\n\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t} );\n\n\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\tconst WhiteSpace = createToken( {\n\t\t\t\tname: 'WhiteSpace',\n\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t} );\n\n\t\t\tconst tokens = [\n\t\t\t\tWhiteSpace,\n\t\t\t\t// keywords appear before the Identifier\n\t\t\t\tNodeName,\n\t\t\t\tDEF,\n\t\t\t\tUSE,\n\t\t\t\tROUTE,\n\t\t\t\tTO,\n\t\t\t\tTrueLiteral,\n\t\t\t\tFalseLiteral,\n\t\t\t\tNullLiteral,\n\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\tVersion,\n\t\t\t\tIdentifier,\n\t\t\t\tRouteIdentifier,\n\t\t\t\tStringLiteral,\n\t\t\t\tHexLiteral,\n\t\t\t\tNumberLiteral,\n\t\t\t\tLSquare,\n\t\t\t\tRSquare,\n\t\t\t\tLCurly,\n\t\t\t\tRCurly,\n\t\t\t\tComment\n\t\t\t];\n\n\t\t\tconst tokenVocabulary = {};\n\n\t\t\tfor ( let i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\tconst token = tokens[ i ];\n\n\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t}\n\n\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t}\n\n\n\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t// the visitor is created dynamically based on the given base class\n\n\t\t\tclass VRMLToASTVisitor extends BaseVRMLVisitor {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tvrml( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\troutes: []\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst route = ctx.route[ i ];\n\n\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tversion( ctx ) {\n\n\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t}\n\n\t\t\t\tnode( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\tfields: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst field = ctx.field[ i ];\n\n\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// DEF\n\n\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tfield( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: null\n\t\t\t\t\t};\n\n\t\t\t\t\tlet result;\n\n\t\t\t\t\t// SFValue\n\n\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// MFValue\n\n\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tdef( ctx ) {\n\n\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t}\n\n\t\t\t\tuse( ctx ) {\n\n\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t}\n\n\t\t\t\tsingleFieldValue( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t}\n\n\t\t\t\tmultiFieldValue( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t}\n\n\t\t\t\troute( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t};\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\tconst field = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tvalues: []\n\t\t\t\t};\n\n\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst use = ctx.use[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn field;\n\n\t\t\t}\n\n\t\t\treturn new VRMLToASTVisitor();\n\n\t\t}\n\n\t\tfunction parseTree( tree ) {\n\n\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\tconst nodes = tree.nodes;\n\t\t\tconst scene = new Scene();\n\n\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\n\t\t\t\tbuildNodeMap( node );\n\n\t\t\t}\n\n\t\t\t// second iteration: build nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst object = getNode( node );\n\n\t\t\t\tif ( object instanceof Object3D ) scene.add( object );\n\n\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t}\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t\tfunction buildNodeMap( node ) {\n\n\t\t\tif ( node.DEF ) {\n\n\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t}\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\n\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\t\tfor ( let j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction getNode( node ) {\n\n\t\t\t// handle case where a node refers to a different one\n\n\t\t\tif ( node.USE ) {\n\n\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t}\n\n\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\tnode.build = buildNode( node );\n\n\t\t\treturn node.build;\n\n\t\t}\n\n\t\t// node builder\n\n\t\tfunction buildNode( node ) {\n\n\t\t\tconst nodeName = node.name;\n\t\t\tlet build;\n\n\t\t\tswitch ( nodeName ) {\n\n\t\t\t\tcase 'Anchor':\n\t\t\t\tcase 'Group':\n\t\t\t\tcase 'Transform':\n\t\t\t\tcase 'Collision':\n\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Background':\n\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Shape':\n\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Appearance':\n\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Material':\n\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointSet':\n\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Box':\n\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cone':\n\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cylinder':\n\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sphere':\n\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Extrusion':\n\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'Coordinate':\n\t\t\t\tcase 'Normal':\n\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Billboard':\n\n\t\t\t\tcase 'Inline':\n\t\t\t\tcase 'LOD':\n\t\t\t\tcase 'Switch':\n\n\t\t\t\tcase 'AudioClip':\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\tcase 'PointLight':\n\t\t\t\tcase 'Script':\n\t\t\t\tcase 'Sound':\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\tcase 'CylinderSensor':\n\t\t\t\tcase 'PlaneSensor':\n\t\t\t\tcase 'ProximitySensor':\n\t\t\t\tcase 'SphereSensor':\n\t\t\t\tcase 'TimeSensor':\n\t\t\t\tcase 'TouchSensor':\n\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\tcase 'Text':\n\n\t\t\t\tcase 'FontStyle':\n\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\tcase 'Fog':\n\t\t\t\tcase 'NavigationInfo':\n\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t// node not supported yet\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGroupingNode( node ) {\n\n\t\t\tconst object = new Group();\n\n\t\t\t//\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'children':\n\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'description':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'parameter':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\tconst axis = new Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ).normalize();\n\t\t\t\t\t\tconst angle = fieldValues[ 3 ];\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\tconst group = new Group();\n\n\t\t\tlet groundAngle, groundColor;\n\t\t\tlet skyAngle, skyColor;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst radius = 10000;\n\n\t\t\t// sky\n\n\t\t\tif ( skyColor ) {\n\n\t\t\t\tconst skyGeometry = new SphereGeometry( radius, 32, 16 );\n\t\t\t\tconst skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, depthWrite: false, depthTest: false } );\n\n\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ], SRGBColorSpace );\n\n\t\t\t\t}\n\n\t\t\t\tconst sky = new Mesh( skyGeometry, skyMaterial );\n\t\t\t\tgroup.add( sky );\n\n\t\t\t}\n\n\t\t\t// ground\n\n\t\t\tif ( groundColor ) {\n\n\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\tconst groundGeometry = new SphereGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\tconst groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\tconst ground = new Mesh( groundGeometry, groundMaterial );\n\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render background group first\n\n\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction buildShapeNode( node ) {\n\n\t\t\tconst fields = node.fields;\n\n\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\tlet material = new MeshBasicMaterial( {\n\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\tcolor: 0x000000\n\t\t\t} );\n\t\t\tlet geometry;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build 3D object\n\n\t\t\tlet object;\n\n\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\tconst type = geometry._type;\n\n\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial( {\n\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\topacity: material.opacity,\n\t\t\t\t\t\ttransparent: material.transparent\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new Points( geometry, pointsMaterial );\n\n\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\tconst lineMaterial = new LineBasicMaterial( {\n\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\topacity: material.opacity,\n\t\t\t\t\t\ttransparent: material.transparent\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new LineSegments( geometry, lineMaterial );\n\n\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? FrontSide : DoubleSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject = new Object3D();\n\n\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\tobject.visible = false;\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\tlet material = new MeshPhongMaterial();\n\t\t\tlet transformData;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'material':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tconst materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\tmaterial = new MeshBasicMaterial( {\n\t\t\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\t\t\tcolor: 0x000000\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tconst textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// MovieTexture not supported yet\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\t// respect VRML lighting model\n\n\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t}\n\n\t\t\t\t// apply texture transform\n\n\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction buildMaterialNode( node ) {\n\n\t\t\tconst materialData = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\tmaterialData.diffuseColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\tmaterialData.emissiveColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\tmaterialData.specularColor = new Color().setRGB( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ], SRGBColorSpace );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialData;\n\n\t\t}\n\n\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\tlet value;\n\n\t\t\tswitch ( textureType ) {\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\tvalue = parseInt( hex );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tcolor.a = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\tvalue = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tcolor.a = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureType( num_components ) {\n\n\t\t\tlet type;\n\n\t\t\tswitch ( num_components ) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t\treturn type;\n\n\t\t}\n\n\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = RepeatWrapping;\n\t\t\tlet wrapT = RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'image':\n\t\t\t\t\t\tconst width = fieldValues[ 0 ];\n\t\t\t\t\t\tconst height = fieldValues[ 1 ];\n\t\t\t\t\t\tconst num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\tconst textureType = getTextureType( num_components );\n\n\t\t\t\t\t\tconst data = new Uint8Array( 4 * width * height );\n\n\t\t\t\t\t\tconst color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\tfor ( let j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\tconst stride = k * 4;\n\n\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture = new DataTexture( data, width, height );\n\t\t\t\t\t\ttexture.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = RepeatWrapping;\n\t\t\tlet wrapT = RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'url':\n\t\t\t\t\t\tconst url = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\t\t\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\tconst transformData = {\n\t\t\t\tcenter: new Vector2(),\n\t\t\t\trotation: new Vector2(),\n\t\t\t\tscale: new Vector2(),\n\t\t\t\ttranslation: new Vector2()\n\t\t\t};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transformData;\n\n\t\t}\n\n\t\tfunction buildGeometricNode( node ) {\n\n\t\t\treturn node.fields[ 0 ].values;\n\n\t\t}\n\n\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\tconst worldInfo = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'title':\n\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'info':\n\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn worldInfo;\n\n\t\t}\n\n\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\tlet color, coord, normal, texCoord;\n\t\t\tlet ccw = true, solid = true, creaseAngle = 0;\n\t\t\tlet colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\tlet colorPerVertex = true, normalPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\treturn new BufferGeometry(); // handle VRML files with incomplete geometry definition\n\n\t\t\t}\n\n\t\t\tconst triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\t\t\tlet uvAttribute;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( normal, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// consider face normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t}\n\n\t\t\tif ( texCoord ) {\n\n\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\tconst triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( texCoord, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( coord, 3 ) );\n\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t// optional attributes\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\tlet color, coord;\n\t\t\tlet colorIndex, coordIndex;\n\t\t\tlet colorPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build lines\n\n\t\t\tlet colorAttribute;\n\n\t\t\tconst expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\tconst expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitive)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\tconst flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitive\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitive)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitive)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( coord, 3 ) );\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\tgeometry._type = 'line';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildPointSetNode( node ) {\n\n\t\t\tlet color, coord;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( coord, 3 ) );\n\n\t\t\tif ( color ) {\n\n\t\t\t\tconst colorAttribute = new Float32BufferAttribute( color, 3 );\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry._type = 'points';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildBoxNode( node ) {\n\n\t\t\tconst size = new Vector3( 2, 2, 2 );\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'size':\n\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BoxGeometry( size.x, size.y, size.z );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildConeNode( node ) {\n\n\t\t\tlet radius = 1, height = 2, openEnded = false;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new ConeGeometry( radius, height, 16, 1, openEnded );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildCylinderNode( node ) {\n\n\t\t\tlet radius = 1, height = 2;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new CylinderGeometry( radius, radius, height, 16, 1 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildSphereNode( node ) {\n\n\t\t\tlet radius = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new SphereGeometry( radius, 16, 16 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\tlet color;\n\t\t\tlet normal;\n\t\t\tlet texCoord;\n\t\t\tlet height;\n\n\t\t\tlet colorPerVertex = true;\n\t\t\tlet normalPerVertex = true;\n\t\t\tlet solid = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet xDimension = 2;\n\t\t\tlet zDimension = 2;\n\t\t\tlet xSpacing = 1;\n\t\t\tlet zSpacing = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// vertex data\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst colors = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor ( let i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\tconst index = ( i * xDimension ) + j;\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tconst x = xSpacing * i;\n\t\t\t\t\tconst y = height[ index ];\n\t\t\t\t\tconst z = zSpacing * j;\n\n\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\tconst s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\tconst t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\tconst a = i + j * xDimension;\n\t\t\t\t\tconst b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst uvAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( uvs, 2 ) );\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\n\t\t\t// color attribute\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolorAttribute = new Float32BufferAttribute( colors, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\t// normal attribute\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnormalAttribute = new Float32BufferAttribute( normals, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\tlet crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\tlet spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\tlet scale;\n\t\t\tlet orientation;\n\n\t\t\tlet beginCap = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet endCap = true;\n\t\t\tlet solid = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t// vertices\n\n\t\t\tconst vertices = [];\n\t\t\tconst spineVector = new Vector3();\n\t\t\tconst scaling = new Vector3();\n\n\t\t\tconst axis = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst quaternion = new Quaternion();\n\n\t\t\tfor ( let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\tscaling.y = 1;\n\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\tconst angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\tfor ( let k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t// scale\n\n\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t// rotate\n\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t// translate\n\n\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tconst spineCount = spine.length / 3;\n\t\t\tconst crossSectionCount = crossSection.length / 2;\n\n\t\t\tfor ( let i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\tconst a = j + i * crossSectionCount;\n\t\t\t\t\tlet b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\tconst c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\tlet d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// triangulate cap\n\n\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\tconst contour = [];\n\n\t\t\t\tfor ( let i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\tcontour.push( new Vector2( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape( contour, [] );\n\t\t\t\tconst capIndices = [];\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// begin cap\n\n\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// end cap\n\n\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\tconst indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t// no uvs yet\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction resolveUSE( identifier ) {\n\n\t\t\tconst node = nodeMap[ identifier ];\n\t\t\tconst build = getNode( node );\n\n\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t// any side effects\n\n\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t}\n\n\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = getNode( children[ i ] );\n\n\t\t\t\tif ( object instanceof Object3D ) owner.add( object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\tconst indices = [];\n\n\t\t\t// since face definitions can have more than three vertices, it's necessary to\n\t\t\t// perform a simple triangulation\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ start ];\n\t\t\t\tconst i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\tconst i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tfunction flattenData( data, index ) {\n\n\t\t\tconst flattenData = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\n\t\t\t\tconst stride = i1 * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t}\n\n\t\t\treturn flattenData;\n\n\t\t}\n\n\t\tfunction expandLineIndex( index ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\t\t\t\tconst i2 = index[ i + 1 ];\n\n\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction expandLineData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tconst vA = new Vector3();\n\t\tconst vB = new Vector3();\n\t\tconst vC = new Vector3();\n\n\t\tconst uvA = new Vector2();\n\t\tconst uvB = new Vector2();\n\t\tconst uvC = new Vector2();\n\n\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\tconst array = [];\n\n\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\tfor ( let i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, itemSize );\n\n\t\t}\n\n\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tconst ab = new Vector3();\n\t\tconst cb = new Vector3();\n\n\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\tconst faces = [];\n\t\t\tconst vertexNormals = {};\n\n\t\t\t// prepare face and raw vertex normals\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tconst face = new Face( a, b, c );\n\n\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\tfaces.push( face );\n\n\t\t\t}\n\n\t\t\t// compute vertex normals and build final geometry\n\n\t\t\tconst normals = [];\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\tconst nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\tconst nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( normals, 3 );\n\n\t\t}\n\n\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\tnormal.copy( vector );\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn normal.normalize();\n\n\t\t}\n\n\t\tfunction toColorArray( colors ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\tarray.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction convertColorsToLinearSRGB( attribute ) {\n\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tcolor.fromBufferAttribute( attribute, i );\n\n\t\t\t\tColorManagement.colorSpaceToWorking( color, SRGBColorSpace );\n\n\t\t\t\tattribute.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Vertically paints the faces interpolating between the\n\t\t * specified colors at the specified angels. This is used for the Background\n\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t *\n\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t * interpolating the skyColor down from the Zenith. When interpolating up from\n\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t *\n\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t * is linear along the Y axis in any case.\n\t\t *\n\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t * This is the color of the Zenith (the top of the shape).\n\t\t *\n\t\t * @param {BufferGeometry} geometry\n\t\t * @param {number} radius\n\t\t * @param {array} angles\n\t\t * @param {array} colors\n\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t */\n\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t// compute threshold values\n\n\t\t\tconst thresholds = [];\n\t\t\tconst startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tlet angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\tconst point = new Vector3();\n\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\tthresholds.push( point );\n\n\t\t\t}\n\n\t\t\t// generate vertex colors\n\n\t\t\tconst indices = geometry.index;\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\tconst position = new Vector3();\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\tconst index = indices.getX( i );\n\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\tlet thresholdIndexA, thresholdIndexB;\n\t\t\t\tlet t = 1;\n\n\t\t\t\tfor ( let j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\tconst thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\tconst thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst colorA = colors[ thresholdIndexA ];\n\t\t\t\tconst colorB = colors[ thresholdIndexB ];\n\n\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\tColorManagement.colorSpaceToWorking( color, SRGBColorSpace );\n\n\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t}\n\n\t\t//\n\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t// check version (only 2.0 is supported)\n\n\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t}\n\n\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\tconst tree = generateVRMLTree( data );\n\n\t\t// parse the tree structure to a three.js scene\n\n\t\tconst scene = parseTree( tree );\n\n\t\treturn scene;\n\n\t}\n\n}\n\nclass VRMLLexer {\n\n\tconstructor( tokens ) {\n\n\t\tthis.lexer = new chevrotain.Lexer( tokens );\n\n\t}\n\n\tlex( inputText ) {\n\n\t\tconst lexingResult = this.lexer.tokenize( inputText );\n\n\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t}\n\n\t\treturn lexingResult;\n\n\t}\n\n}\n\nconst CstParser = chevrotain.CstParser;\n\nclass VRMLParser extends CstParser {\n\n\tconstructor( tokenVocabulary ) {\n\n\t\tsuper( tokenVocabulary );\n\n\t\tconst $ = this;\n\n\t\tconst Version = tokenVocabulary[ 'Version' ];\n\t\tconst LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tconst RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tconst LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tconst RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tconst Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tconst RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tconst StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tconst HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tconst NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tconst TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tconst FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tconst NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tconst DEF = tokenVocabulary[ 'DEF' ];\n\t\tconst USE = tokenVocabulary[ 'USE' ];\n\t\tconst ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tconst TO = tokenVocabulary[ 'TO' ];\n\t\tconst NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n}\n\nclass Face {\n\n\tconstructor( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new Vector3();\n\n\t}\n\n}\n\nconst TEXTURE_TYPE = {\n\tINTENSITY: 1,\n\tINTENSITY_ALPHA: 2,\n\tRGB: 3,\n\tRGBA: 4\n};\n\nexport { VRMLLoader };\n"],"mappings":"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","ignoreList":[]}