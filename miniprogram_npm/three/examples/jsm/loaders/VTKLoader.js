import{BufferAttribute,BufferGeometry,Color,FileLoader,Float32BufferAttribute,Loader,SRGBColorSpace}from"three";import*as fflate from"../libs/fflate.module.js";class VTKLoader extends Loader{constructor(t){super(t)}load(t,e,r,n){const a=this,s=new FileLoader(a.manager);s.setPath(a.path),s.setResponseType("arraybuffer"),s.setRequestHeader(a.requestHeader),s.setWithCredentials(a.withCredentials),s.load(t,(function(r){try{e(a.parse(r))}catch(e){n?n(e):console.error(e),a.manager.itemError(t)}}),r,n)}parse(t){function e(t,e){const r=t.length,n=new Float32Array(r+e.length);return n.set(t),n.set(e,r),n}function r(t,e){const r=t.length,n=new Int32Array(r+e.length);return n.set(t),n.set(e,r),n}const n=new TextDecoder,a=n.decode(new Uint8Array(t,0,250)).split("\n");return-1!==a[0].indexOf("xml")?function(t){function n(t){const e="undefined"!=typeof Uint8Array?Uint8Array:Array,r=[],n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let t=0,e=64;t<e;++t)r[n.charCodeAt(t)]=t;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63;const a=t.length;if(a%4>0)throw new Error("Invalid string. Length must be a multiple of 4");const s="="===t[a-2]?2:"="===t[a-1]?1:0,o=new e(3*a/4-s),l=s>0?a-4:a;let i,f,u=0;for(i=0,f=0;i<l;i+=4,f+=3){const e=r[t.charCodeAt(i)]<<18|r[t.charCodeAt(i+1)]<<12|r[t.charCodeAt(i+2)]<<6|r[t.charCodeAt(i+3)];o[u++]=(16711680&e)>>16,o[u++]=(65280&e)>>8,o[u++]=255&e}if(2===s){const e=r[t.charCodeAt(i)]<<2|r[t.charCodeAt(i+1)]>>4;o[u++]=255&e}else if(1===s){const e=r[t.charCodeAt(i)]<<10|r[t.charCodeAt(i+1)]<<4|r[t.charCodeAt(i+2)]>>2;o[u++]=e>>8&255,o[u++]=255&e}return o}function a(t,a){let o,l,i=0;if("UInt64"===s.attributes.header_type?i=8:"UInt32"===s.attributes.header_type&&(i=4),"binary"===t.attributes.format&&a){"Float32"===t.attributes.type?o=new Float32Array:"Int32"!==t.attributes.type&&"Int64"!==t.attributes.type||(o=new Int32Array);const a=t["#text"],s=n(Array.isArray(a)?a[0]:a),f=8;let u=s[0];for(let t=1;t<i-1;t++)u|=s[t]<<t*f;let c=(u+3)*i;c+=c%3>0?3-c%3:0;const A=[];let p=c;A.push(p);const y=3*i;for(let t=0;t<u;t++){let e=s[t*i+y];for(let r=1;r<i-1;r++)e|=s[t*i+y+r]<<r*f;p+=e,A.push(p)}for(let n=0;n<A.length-1;n++)l=fflate.unzlibSync(s.slice(A[n],A[n+1])).buffer,"Float32"===t.attributes.type?(l=new Float32Array(l),o=e(o,l)):"Int32"!==t.attributes.type&&"Int64"!==t.attributes.type||(l=new Int32Array(l),o=r(o,l));delete t["#text"],"Int64"===t.attributes.type&&"binary"===t.attributes.format&&(o=o.filter((function(t,e){if(e%2!=1)return!0})))}else"binary"!==t.attributes.format||a?l=t["#text"]?t["#text"].split(/\s+/).filter((function(t){if(""!==t)return t})):new Int32Array(0).buffer:(l=n(t["#text"]),l=l.slice(i).buffer),delete t["#text"],"Float32"===t.attributes.type?o=new Float32Array(l):"Int32"===t.attributes.type?o=new Int32Array(l):"Int64"===t.attributes.type&&(o=new Int32Array(l),"binary"===t.attributes.format&&(o=o.filter((function(t,e){if(e%2!=1)return!0}))));return o}const s=function t(e){let r={};if(1===e.nodeType){if(e.attributes&&e.attributes.length>0){r.attributes={};for(let t=0;t<e.attributes.length;t++){const n=e.attributes.item(t);r.attributes[n.nodeName]=n.nodeValue.trim()}}}else 3===e.nodeType&&(r=e.nodeValue.trim());if(e.hasChildNodes())for(let n=0;n<e.childNodes.length;n++){const a=e.childNodes.item(n),s=a.nodeName;if(void 0===r[s]){const e=t(a);""!==e&&(Array.isArray(e["#text"])&&(e["#text"]=e["#text"][0]),r[s]=e)}else{if(void 0===r[s].push){const t=r[s];r[s]=[t]}const e=t(a);""!==e&&(Array.isArray(e["#text"])&&(e["#text"]=e["#text"][0]),r[s].push(e))}}return r}((new DOMParser).parseFromString(t,"application/xml").documentElement);let o=[],l=[],i=[];if(s.AppendedData){const t=s.AppendedData["#text"].slice(1),e=s.PolyData.Piece,r=["PointData","CellData","Points","Verts","Lines","Strips","Polys"];let n=0;const a=r.map((t=>{const r=e[t];return r&&r.DataArray?(Array.isArray(r.DataArray)?r.DataArray:[r.DataArray]).map((t=>t.attributes.offset)):[]})).flat();for(const s of r){const r=e[s];if(r&&r.DataArray)if(Array.isArray(r.DataArray))for(const e of r.DataArray)e["#text"]=t.slice(a[n],a[n+1]),e.attributes.format="binary",n++;else r.DataArray["#text"]=t.slice(a[n],a[n+1]),r.DataArray.attributes.format="binary",n++}}if(s.PolyData){const t=s.PolyData.Piece,e=s.attributes.hasOwnProperty("compressor"),r=["PointData","Points","Strips","Polys"];let n=0;const f=r.length;for(;n<f;){const s=t[r[n]];if(s&&s.DataArray){let f;f=Array.isArray(s.DataArray)?s.DataArray:[s.DataArray];let u=0;const c=f.length;for(;u<c;)"#text"in f[u]&&f[u]["#text"].length>0&&(f[u].text=a(f[u],e)),u++;switch(r[n]){case"PointData":{const e=parseInt(t.attributes.NumberOfPoints),r=s.attributes.Normals;if(e>0)for(let t=0,n=f.length;t<n;t++)if(r===f[t].attributes.Name){const r=f[t].attributes.NumberOfComponents;l=new Float32Array(e*r),l.set(f[t].text,0)}}break;case"Points":{const e=parseInt(t.attributes.NumberOfPoints);if(e>0){const t=s.DataArray.attributes.NumberOfComponents;o=new Float32Array(e*t),o.set(s.DataArray.text,0)}}break;case"Strips":{const e=parseInt(t.attributes.NumberOfStrips);if(e>0){const t=new Int32Array(s.DataArray[0].text.length),r=new Int32Array(s.DataArray[1].text.length);t.set(s.DataArray[0].text,0),r.set(s.DataArray[1].text,0);const n=e+t.length;i=new Uint32Array(3*n-9*e);let a=0;for(let n=0,s=e;n<s;n++){const e=[];for(let a=0,s=r[n],o=0;a<s-o;a++)e.push(t[a]),n>0&&(o=r[n-1]);for(let t=0,s=r[n],o=0;t<s-o-2;t++)t%2?(i[a++]=e[t],i[a++]=e[t+2],i[a++]=e[t+1]):(i[a++]=e[t],i[a++]=e[t+1],i[a++]=e[t+2]),n>0&&(o=r[n-1])}}}break;case"Polys":{const e=parseInt(t.attributes.NumberOfPolys);if(e>0){const t=new Int32Array(s.DataArray[0].text.length),r=new Int32Array(s.DataArray[1].text.length);t.set(s.DataArray[0].text,0),r.set(s.DataArray[1].text,0);const n=e+t.length;i=new Uint32Array(3*n-9*e);let a=0,o=0,l=0,f=0;const u=e;for(;l<u;){const e=[];let n=0;const s=r[l];for(;n<s-f;)e.push(t[o++]),n++;let u=1;for(;u<s-f-1;)i[a++]=e[0],i[a++]=e[u],i[a++]=e[u+1],u++;l++,f=r[l-1]}}}}}n++}const u=new BufferGeometry;return u.setIndex(new BufferAttribute(i,1)),u.setAttribute("position",new BufferAttribute(o,3)),l.length===o.length&&u.setAttribute("normal",new BufferAttribute(l,3)),u}throw new Error("Unsupported DATASET type")}(n.decode(t)):a[2].includes("ASCII")?function(t){const e=[],r=[],n=[],a=[];let s;const o=/^[^\d.\s-]+/,l=/(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g,i=/^(\d+)\s+([\s\d]*)/,f=/^POINTS /,u=/^POLYGONS /,c=/^TRIANGLE_STRIPS /,A=/^POINT_DATA[ ]+(\d+)/,p=/^CELL_DATA[ ]+(\d+)/,y=/^COLOR_SCALARS[ ]+(\w+)[ ]+3/,d=/^NORMALS[ ]+(\w+)[ ]+(\w+)/;let b=!1,h=!1,x=!1,I=!1,w=!1,g=!1,m=!1;const D=new Color,F=t.split("\n");for(const t in F){const S=F[t].trim();if(0===S.indexOf("DATASET")){const t=S.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(b)for(;null!==(s=l.exec(S))&&null===o.exec(S);){const t=parseFloat(s[1]),e=parseFloat(s[2]),n=parseFloat(s[3]);r.push(t,e,n)}else if(h){if(null!==(s=i.exec(S))){const t=parseInt(s[1]),r=s[2].split(/\s+/);if(t>=3){const n=parseInt(r[0]);let a=1;for(let s=0;s<t-2;++s){const t=parseInt(r[a]),s=parseInt(r[a+1]);e.push(n,t,s),a++}}}}else if(x){if(null!==(s=i.exec(S))){const t=parseInt(s[1]),r=s[2].split(/\s+/);if(t>=3)for(let n=0;n<t-2;n++)if(n%2==1){const t=parseInt(r[n]),a=parseInt(r[n+2]),s=parseInt(r[n+1]);e.push(t,a,s)}else{const t=parseInt(r[n]),a=parseInt(r[n+1]),s=parseInt(r[n+2]);e.push(t,a,s)}}}else if(I||w)if(g)for(;null!==(s=l.exec(S))&&null===o.exec(S);){const t=parseFloat(s[1]),e=parseFloat(s[2]),r=parseFloat(s[3]);D.setRGB(t,e,r,SRGBColorSpace),n.push(D.r,D.g,D.b)}else if(m)for(;null!==(s=l.exec(S))&&null===o.exec(S);){const t=parseFloat(s[1]),e=parseFloat(s[2]),r=parseFloat(s[3]);a.push(t,e,r)}null!==u.exec(S)?(h=!0,b=!1,x=!1):null!==f.exec(S)?(h=!1,b=!0,x=!1):null!==c.exec(S)?(h=!1,b=!1,x=!0):null!==A.exec(S)?(I=!0,b=!1,h=!1,x=!1):null!==p.exec(S)?(w=!0,b=!1,h=!1,x=!1):null!==y.exec(S)?(g=!0,m=!1,b=!1,h=!1,x=!1):null!==d.exec(S)&&(m=!0,g=!1,b=!1,h=!1,x=!1)}let S=new BufferGeometry;if(S.setIndex(e),S.setAttribute("position",new Float32BufferAttribute(r,3)),a.length===r.length&&S.setAttribute("normal",new Float32BufferAttribute(a,3)),n.length!==e.length)n.length===r.length&&S.setAttribute("color",new Float32BufferAttribute(n,3));else{S=S.toNonIndexed();const t=S.attributes.position.count/3;if(n.length===3*t){const e=[];for(let r=0;r<t;r++){const t=n[3*r+0],a=n[3*r+1],s=n[3*r+2];D.setRGB(t,a,s,SRGBColorSpace),e.push(D.r,D.g,D.b),e.push(D.r,D.g,D.b),e.push(D.r,D.g,D.b)}S.setAttribute("color",new Float32BufferAttribute(e,3))}}return S}(n.decode(t)):function(t){const e=new Uint8Array(t),r=new DataView(t);let n,a,s=[],o=[],l=[],i=0;function f(t,e){let r=e,n=t[r];const a=[];for(;10!==n;)a.push(String.fromCharCode(n)),r++,n=t[r];return{start:e,end:r,next:r+1,parsedString:a.join("")}}for(;;){if(n=f(e,i),a=n.parsedString,0===a.indexOf("DATASET")){const t=a.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(0===a.indexOf("POINTS")){const t=parseInt(a.split(" ")[1],10),e=4*t*3;s=new Float32Array(3*t);let o=n.next;for(let e=0;e<t;e++)s[3*e]=r.getFloat32(o,!1),s[3*e+1]=r.getFloat32(o+4,!1),s[3*e+2]=r.getFloat32(o+8,!1),o+=12;n.next=n.next+e+1}else if(0===a.indexOf("TRIANGLE_STRIPS")){const t=parseInt(a.split(" ")[1],10),e=parseInt(a.split(" ")[2],10),s=4*e;l=new Uint32Array(3*e-9*t);let o=0,i=n.next;for(let e=0;e<t;e++){const t=r.getInt32(i,!1),e=[];i+=4;for(let n=0;n<t;n++)e.push(r.getInt32(i,!1)),i+=4;for(let r=0;r<t-2;r++)r%2?(l[o++]=e[r],l[o++]=e[r+2],l[o++]=e[r+1]):(l[o++]=e[r],l[o++]=e[r+1],l[o++]=e[r+2])}n.next=n.next+s+1}else if(0===a.indexOf("POLYGONS")){const t=parseInt(a.split(" ")[1],10),e=parseInt(a.split(" ")[2],10),s=4*e;l=new Uint32Array(3*e-9*t);let o=0,i=n.next;for(let e=0;e<t;e++){const t=r.getInt32(i,!1),e=[];i+=4;for(let n=0;n<t;n++)e.push(r.getInt32(i,!1)),i+=4;for(let r=1;r<t-1;r++)l[o++]=e[0],l[o++]=e[r],l[o++]=e[r+1]}n.next=n.next+s+1}else if(0===a.indexOf("POINT_DATA")){const t=parseInt(a.split(" ")[1],10);n=f(e,n.next);const s=4*t*3;o=new Float32Array(3*t);let l=n.next;for(let e=0;e<t;e++)o[3*e]=r.getFloat32(l,!1),o[3*e+1]=r.getFloat32(l+4,!1),o[3*e+2]=r.getFloat32(l+8,!1),l+=12;n.next=n.next+s}if(i=n.next,i>=e.byteLength)break}const u=new BufferGeometry;return u.setIndex(new BufferAttribute(l,1)),u.setAttribute("position",new BufferAttribute(s,3)),o.length===s.length&&u.setAttribute("normal",new BufferAttribute(o,3)),u}(t)}}export{VTKLoader};
//# sourceMappingURL=VTKLoader.js.map