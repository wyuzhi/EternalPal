{"version":3,"file":"node_modules/three/examples/jsm/loaders/VTKLoader.js","names":["BufferAttribute","BufferGeometry","Color","FileLoader","Float32BufferAttribute","Loader","SRGBColorSpace","fflate","VTKLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","Float32Concat","first","second","firstLength","length","result","Float32Array","set","Int32Concat","Int32Array","textDecoder","TextDecoder","meta","decode","Uint8Array","split","indexOf","stringFile","Base64toByteArray","b64","Arr","Array","revLookup","code","i","l","charCodeAt","len","Error","placeHolders","arr","j","L","tmp","parseDataArray","ele","compressed","txt","content","numBytes","json","attributes","header_type","format","type","textNode","byteData","isArray","dataPointSize","blocks","headerSize","dataOffsets","currentOffset","push","cSizeStart","currentBlockSize","unzlibSync","slice","buffer","filter","el","idx","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","trim","hasChildNodes","childNodes","old","DOMParser","parseFromString","documentElement","points","normals","indices","AppendedData","appendedData","piece","PolyData","Piece","sections","sectionIndex","offsets","map","s","sect","DataArray","a","offset","flat","section","sectionEle","hasOwnProperty","numberOfSections","dataArrayIndex","numberOfDataArrays","numberOfPoints","parseInt","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","numberOfStrips","NumberOfStrips","connectivity","size","Uint32Array","indicesIndex","strip","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","geometry","setIndex","setAttribute","parseXML","includes","positions","colors","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","color","lines","line","dataset","exec","x","parseFloat","y","z","numVertices","inds","i0","k","i1","i2","r","g","b","setRGB","nx","ny","nz","toNonIndexed","numTriangles","position","count","newColors","parseASCII","dataView","DataView","state","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","pointIndex","getFloat32","indexCount","getInt32","byteLength","parseBinary"],"sources":["node_modules/three/examples/jsm/loaders/VTKLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tSRGBColorSpace\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n/**\n * A loader for the VTK format.\n *\n * This loader only supports the `POLYDATA` dataset format so far. Other formats\n * (structured points, structured grid, rectilinear grid, unstructured grid, appended)\n * are not supported.\n *\n * ```js\n * const loader = new VTKLoader();\n * const geometry = await loader.loadAsync( 'models/vtk/liver.vtk' );\n * geometry.computeVertexNormals();\n *\n * const mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial() );\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { VTKLoader } from 'three/addons/loaders/VTKLoader.js';\n */\nclass VTKLoader extends Loader {\n\n\t/**\n\t * Constructs a new VTK loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded VRML asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given VTK data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw VTK data as an array buffer\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\t// connectivity of the triangles\n\t\t\tconst indices = [];\n\n\t\t\t// triangles vertices\n\t\t\tconst positions = [];\n\n\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\tconst colors = [];\n\n\t\t\t// normal vector, one per vertex\n\t\t\tconst normals = [];\n\n\t\t\tlet result;\n\n\t\t\t// pattern for detecting the end of a number sequence\n\t\t\tconst patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\tconst pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t// the first integer is the number of polygon nodes\n\t\t\tconst patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t// indicates start of vertex data section\n\t\t\tconst patPOINTS = /^POINTS /;\n\n\t\t\t// indicates start of polygon connectivity section\n\t\t\tconst patPOLYGONS = /^POLYGONS /;\n\n\t\t\t// indicates start of triangle strips section\n\t\t\tconst patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t// POINT_DATA number_of_values\n\t\t\tconst patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t// CELL_DATA number_of_polys\n\t\t\tconst patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t// Start of color section\n\t\t\tconst patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t// NORMALS Normals float\n\t\t\tconst patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\tlet inPointsSection = false;\n\t\t\tlet inPolygonsSection = false;\n\t\t\tlet inTriangleStripSection = false;\n\t\t\tlet inPointDataSection = false;\n\t\t\tlet inCellDataSection = false;\n\t\t\tlet inColorSection = false;\n\t\t\tlet inNormalsSection = false;\n\n\t\t\tconst color = new Color();\n\n\t\t\tconst lines = data.split( '\\n' );\n\n\t\t\tfor ( const i in lines ) {\n\n\t\t\t\tconst line = lines[ i ].trim();\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t// get the vertices\n\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\tconst x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tconst y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tconst z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\tconst i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\tlet k = 1;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tconst r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tconst g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tconst b = parseFloat( result[ 3 ] );\n\n\t\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tconst nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tconst ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tconst nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\tinColorSection = true;\n\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\tinColorSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( indices );\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t// stagger\n\n\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// cell\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tconst numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\tconst newColors = [];\n\n\t\t\t\t\tfor ( let i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\tconst r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\tconst g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\tconst b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst buffer = new Uint8Array( data );\n\t\t\tconst dataView = new DataView( data );\n\n\t\t\t// Points and normals, by default, are empty\n\t\t\tlet points = [];\n\t\t\tlet normals = [];\n\t\t\tlet indices = [];\n\n\t\t\tlet index = 0;\n\n\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\tlet index = start;\n\t\t\t\tlet c = buffer[ index ];\n\t\t\t\tconst s = [];\n\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\tindex ++;\n\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t}\n\n\t\t\t\treturn { start: start,\n\t\t\t\t\tend: index,\n\t\t\t\t\tnext: index + 1,\n\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t}\n\n\t\t\tlet state, line;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\t// Get a string\n\t\t\t\tstate = findString( buffer, index );\n\t\t\t\tline = state.parsedString;\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\t// Add the points\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tconst count = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tconst strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\tfor ( let j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tconst count = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tconst strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\tfor ( let j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Grab the next line\n\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment past our data\n\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t}\n\n\t\t\t\t// Increment index\n\t\t\t\tindex = state.next;\n\n\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\n\n\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction Float32Concat( first, second ) {\n\n\t\t\tconst firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction Int32Concat( first, second ) {\n\n\t\t\tconst firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction parseXML( stringFile ) {\n\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t// Create the return object\n\t\t\t\tlet obj = {};\n\n\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t// do attributes\n\n\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t}\n\n\t\t\t\t// do children\n\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\tconst item = xml.childNodes.item( i );\n\t\t\t\t\t\tconst nodeName = item.nodeName;\n\n\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) {\n\n\t\t\t\t\t\t\t\tif ( Array.isArray( tmp[ '#text' ] ) ) {\n\n\t\t\t\t\t\t\t\t\ttmp[ '#text' ] = tmp[ '#text' ][ 0 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tconst old = obj[ nodeName ];\n\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) {\n\n\t\t\t\t\t\t\t\tif ( Array.isArray( tmp[ '#text' ] ) ) {\n\n\t\t\t\t\t\t\t\t\ttmp[ '#text' ] = tmp[ '#text' ][ 0 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\n\t\t\t}\n\n\t\t\t// Taken from Base64-js\n\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\tconst Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\tconst revLookup = [];\n\t\t\t\tconst code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\t\t\t\tfor ( let i = 0, l = code.length; i < l; ++ i ) {\n\n\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t}\n\n\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\tconst len = b64.length;\n\n\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t}\n\n\t\t\t\tconst placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\tconst arr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\tconst l = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\tlet L = 0;\n\t\t\t\tlet i, j;\n\n\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t}\n\n\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\tlet numBytes = 0;\n\n\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t}\n\n\t\t\t\tlet txt, content;\n\n\t\t\t\t// Check the format\n\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\ttxt = new Float32Array( );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t//\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t//\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\tconst textNode = ele[ '#text' ];\n\t\t\t\t\tconst rawData = Array.isArray( textNode ) ? textNode[ 0 ] : textNode;\n\n\t\t\t\t\tconst byteData = Base64toByteArray( rawData );\n\n\t\t\t\t\t// Each data point consists of 8 bits regardless of the header type\n\t\t\t\t\tconst dataPointSize = 8;\n\n\t\t\t\t\tlet blocks = byteData[ 0 ];\n\t\t\t\t\tfor ( let i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * dataPointSize ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet headerSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\tconst padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\tconst dataOffsets = [];\n\t\t\t\t\tlet currentOffset = headerSize;\n\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\tconst cSizeStart = 3 * numBytes;\n\n\t\t\t\t\tfor ( let i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\tlet currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\tfor ( let j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * dataPointSize ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\tconst data = fflate.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) );\n\t\t\t\t\t\tcontent = data.buffer;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\tcontent = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\tcontent = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontent = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\ttxt = new Float32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( content );\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\treturn txt;\n\n\t\t\t}\n\n\t\t\t// Main part\n\t\t\t// Get Dom\n\t\t\tconst dom = new DOMParser().parseFromString( stringFile, 'application/xml' );\n\n\t\t\t// Get the doc\n\t\t\tconst doc = dom.documentElement;\n\t\t\t// Convert to json\n\t\t\tconst json = xmlToJson( doc );\n\t\t\tlet points = [];\n\t\t\tlet normals = [];\n\t\t\tlet indices = [];\n\n\t\t\tif ( json.AppendedData ) {\n\n\t\t\t\tconst appendedData = json.AppendedData[ '#text' ].slice( 1 );\n\t\t\t\tconst piece = json.PolyData.Piece;\n\n\t\t\t\tconst sections = [ 'PointData', 'CellData', 'Points', 'Verts', 'Lines', 'Strips', 'Polys' ];\n\t\t\t\tlet sectionIndex = 0;\n\n\t\t\t\tconst offsets = sections.map( s => {\n\n\t\t\t\t\tconst sect = piece[ s ];\n\n\t\t\t\t\tif ( sect && sect.DataArray ) {\n\n\t\t\t\t\t\tconst arr = Array.isArray( sect.DataArray ) ? sect.DataArray : [ sect.DataArray ];\n\n\t\t\t\t\t\treturn arr.map( a => a.attributes.offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\n\t\t\t\t} ).flat();\n\n\t\t\t\tfor ( const sect of sections ) {\n\n\t\t\t\t\tconst section = piece[ sect ];\n\n\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\tif ( Array.isArray( section.DataArray ) ) {\n\n\t\t\t\t\t\t\tfor ( const sectionEle of section.DataArray ) {\n\n\t\t\t\t\t\t\t\tsectionEle[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );\n\t\t\t\t\t\t\t\tsectionEle.attributes.format = 'binary';\n\t\t\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tsection.DataArray[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );\n\t\t\t\t\t\t\tsection.DataArray.attributes.format = 'binary';\n\t\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.PolyData ) {\n\n\t\t\t\tconst piece = json.PolyData.Piece;\n\t\t\t\tconst compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t// Can be optimized\n\t\t\t\t// Loop through the sections\n\t\t\t\tconst sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\tlet sectionIndex = 0;\n\t\t\t\tconst numberOfSections = sections.length;\n\n\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\tconst section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\tlet arr;\n\n\t\t\t\t\t\tif ( Array.isArray( section.DataArray ) ) {\n\n\t\t\t\t\t\t\tarr = section.DataArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tarr = [ section.DataArray ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet dataArrayIndex = 0;\n\t\t\t\t\t\tconst numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\t\tconst normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconst components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst strip = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\t\tlet i = 0, len0 = 0;\n\t\t\t\t\t\t\t\t\t\tconst len = numberOfPolys;\n\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst poly = [];\n\t\t\t\t\t\t\t\t\t\t\tlet s = 0;\n\t\t\t\t\t\t\t\t\t\t\tconst len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlet j = 1;\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new BufferGeometry();\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst textDecoder = new TextDecoder();\n\n\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\tconst meta = textDecoder.decode( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\treturn parseXML( textDecoder.decode( data ) );\n\n\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\treturn parseASCII( textDecoder.decode( data ) );\n\n\t\t} else {\n\n\t\t\treturn parseBinary( data );\n\n\t\t}\n\n\t}\n\n}\n\nexport { VTKLoader };\n"],"mappings":"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","ignoreList":[]}