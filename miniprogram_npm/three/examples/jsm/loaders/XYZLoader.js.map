{"version":3,"file":"node_modules/three/examples/jsm/loaders/XYZLoader.js","names":["BufferGeometry","Color","FileLoader","Float32BufferAttribute","Loader","SRGBColorSpace","XYZLoader","load","url","onLoad","onProgress","onError","scope","this","loader","manager","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","lines","split","vertices","colors","color","line","trim","charAt","lineValues","length","push","parseFloat","r","g","b","setRGB","geometry","setAttribute"],"sources":["node_modules/three/examples/jsm/loaders/XYZLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the XYZ format.\n *\n * XYZ is a very simple format for storing point clouds. The layouts\n * `XYZ` (points) and `XYZRGB` (points + colors) are supported.\n *\n * ```js\n * const loader = new XYZLoader();\n * const geometry = await loader.loadAsync( 'models/xyz/helix_201.xyz' );\n * geometry.center();\n *\n * const vertexColors = ( geometry.hasAttribute( 'color' ) === true );\n * const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );\n *\n * const points = new THREE.Points( geometry, material );\n * scene.add( points );\n * ```\n *\n * @augments Loader\n * @three_import import { XYZLoader } from 'three/addons/loaders/XYZLoader.js';\n */\nclass XYZLoader extends Loader {\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded XYZ asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given XYZ data and returns the resulting geometry.\n\t *\n\t * @param {string} text - The raw XYZ data as a string.\n\t * @return {BufferGeometry} The geometry representing the point cloud.\n\t */\n\tparse( text ) {\n\n\t\tconst lines = text.split( '\\n' );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\t\tconst color = new Color();\n\n\t\tfor ( let line of lines ) {\n\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.charAt( 0 ) === '#' ) continue; // skip comments\n\n\t\t\tconst lineValues = line.split( /\\s+/ );\n\n\t\t\tif ( lineValues.length === 3 ) {\n\n\t\t\t\t// XYZ\n\n\t\t\t\tvertices.push( parseFloat( lineValues[ 0 ] ) );\n\t\t\t\tvertices.push( parseFloat( lineValues[ 1 ] ) );\n\t\t\t\tvertices.push( parseFloat( lineValues[ 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( lineValues.length === 6 ) {\n\n\t\t\t\t// XYZRGB\n\n\t\t\t\tvertices.push( parseFloat( lineValues[ 0 ] ) );\n\t\t\t\tvertices.push( parseFloat( lineValues[ 1 ] ) );\n\t\t\t\tvertices.push( parseFloat( lineValues[ 2 ] ) );\n\n\t\t\t\tconst r = parseFloat( lineValues[ 3 ] ) / 255;\n\t\t\t\tconst g = parseFloat( lineValues[ 4 ] ) / 255;\n\t\t\t\tconst b = parseFloat( lineValues[ 5 ] ) / 255;\n\n\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\tif ( colors.length > 0 ) {\n\n\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nexport { XYZLoader };\n"],"mappings":"OACCA,eACAC,MACAC,WACAC,uBACAC,OACAC,mBACM,QAuBP,MAAMC,kBAAkBF,OAWvB,IAAAG,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQC,KAERC,EAAS,IAAIZ,WAAYW,KAAKE,SACpCD,EAAOE,QAASH,KAAKI,MACrBH,EAAOI,iBAAkBL,KAAKM,eAC9BL,EAAOM,mBAAoBP,KAAKQ,iBAChCP,EAAOP,KAAMC,GAAK,SAAWc,GAE5B,IAECb,EAAQG,EAAMW,MAAOD,GAEtB,CAAE,MAAQE,GAEJb,EAEJA,EAASa,GAITC,QAAQC,MAAOF,GAIhBZ,EAAMG,QAAQY,UAAWnB,EAE1B,CAED,GAAGE,EAAYC,EAEhB,CAQA,KAAAY,CAAOD,GAEN,MAAMM,EAAQN,EAAKO,MAAO,MAEpBC,EAAW,GACXC,EAAS,GACTC,EAAQ,IAAI/B,MAElB,IAAM,IAAIgC,KAAQL,EAAQ,CAIzB,GAFAK,EAAOA,EAAKC,OAEc,MAArBD,EAAKE,OAAQ,GAAc,SAEhC,MAAMC,EAAaH,EAAKJ,MAAO,OAY/B,GAV2B,IAAtBO,EAAWC,SAIfP,EAASQ,KAAMC,WAAYH,EAAY,KACvCN,EAASQ,KAAMC,WAAYH,EAAY,KACvCN,EAASQ,KAAMC,WAAYH,EAAY,MAIb,IAAtBA,EAAWC,OAAe,CAI9BP,EAASQ,KAAMC,WAAYH,EAAY,KACvCN,EAASQ,KAAMC,WAAYH,EAAY,KACvCN,EAASQ,KAAMC,WAAYH,EAAY,KAEvC,MAAMI,EAAID,WAAYH,EAAY,IAAQ,IACpCK,EAAIF,WAAYH,EAAY,IAAQ,IACpCM,EAAIH,WAAYH,EAAY,IAAQ,IAE1CJ,EAAMW,OAAQH,EAAGC,EAAGC,EAAGrC,gBAEvB0B,EAAOO,KAAMN,EAAMQ,EAAGR,EAAMS,EAAGT,EAAMU,EAEtC,CAED,CAEA,MAAME,EAAW,IAAI5C,eASrB,OARA4C,EAASC,aAAc,WAAY,IAAI1C,uBAAwB2B,EAAU,IAEpEC,EAAOM,OAAS,GAEpBO,EAASC,aAAc,QAAS,IAAI1C,uBAAwB4B,EAAQ,IAI9Da,CAER,SAIQtC","ignoreList":[]}