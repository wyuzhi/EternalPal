import{BufferAttribute,BufferGeometry,ClampToEdgeWrapping,Group,NoColorSpace,Mesh,MeshPhysicalMaterial,MirroredRepeatWrapping,RepeatWrapping,SRGBColorSpace,TextureLoader,Object3D,Vector2}from"three";class USDAParser{parseText(e){const t={},o=e.split("\n");let r=null,n=t;const s=[t];for(const e of o)if(e.includes("=")){const t=e.split("="),o=t[0].trim(),r=t[1].trim();if(r.endsWith("{")){const e={};s.push(e),n[o]=e,n=e}else if(r.endsWith("(")){const e=r.slice(0,-1);n[o]=e;const t={};s.push(t),n=t}else n[o]=r}else if(e.endsWith("{")){const e=n[r]||{};s.push(e),n[r]=e,n=e}else if(e.endsWith("}")){if(s.pop(),0===s.length)continue;n=s[s.length-1]}else if(e.endsWith("(")){const t={};s.push(t),r=e.split("(")[0].trim()||r,n[r]=t,n=t}else e.endsWith(")")?(s.pop(),n=s[s.length-1]):r=e.trim();return t}parse(e,t){const o=this.parseText(e);function r(e,t){if(e){if(void 0!==t){const o=`def Mesh "${t}"`;if(o in e)return e[o]}for(const t in e){const o=e[t];if(t.startsWith("def Mesh"))return o;if("object"==typeof o){const e=r(o);if(e)return e}}}}function n(e,t){const o=[];for(let r=0;r<t.length;r++){const n=t[r],s=r*n;if(3===n){const t=e[s+0],r=e[s+1],n=e[s+2];o.push(t,r,n)}else if(4===n){const t=e[s+0],r=e[s+1],n=e[s+2],a=e[s+3];o.push(t,r,n),o.push(t,n,a)}else console.warn("THREE.USDZLoader: Face vertex count of %s unsupported.",n)}return o}function s(e,t){const o=e.array,r=e.itemSize,n=new o.constructor(t.length*r);let s=0,a=0;for(let e=0,i=t.length;e<i;e++){s=t[e]*r;for(let e=0;e<r;e++)n[a++]=o[s++]}return new BufferAttribute(n,r)}function a(e,t=""){for(const o in e){const r=e[o];if(o.startsWith("def Material"+t))return r;if("object"==typeof r){const e=a(r,t);if(e)return e}}}function i(e,t){t["float inputs:rotation"]&&(e.rotation=parseFloat(t["float inputs:rotation"])),t["float2 inputs:scale"]&&(e.repeat=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:scale"].replace(/[()]*/g,"")+"]"))),t["float2 inputs:translation"]&&(e.offset=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:translation"].replace(/[()]*/g,"")+"]")))}function c(e,t){for(const o in e){const r=e[o];if(o.startsWith(`def Shader "${t}"`))return r;if("object"==typeof r){const e=c(r,t);if(e)return e}}}function l(e){if("asset inputs:file"in e){const o=e["asset inputs:file"].replace(/@*/g,"").trim(),r=(new TextureLoader).load(t[o]),n={'"clamp"':ClampToEdgeWrapping,'"mirror"':MirroredRepeatWrapping,'"repeat"':RepeatWrapping};return"token inputs:wrapS"in e&&(r.wrapS=n[e["token inputs:wrapS"]]),"token inputs:wrapT"in e&&(r.wrapT=n[e["token inputs:wrapT"]]),r}return null}function f(e){const f=function(e){if(!e)return;const t=new BufferGeometry;let o=null,r=null,a=null,i=-1;if("int[] faceVertexIndices"in e&&(o=JSON.parse(e["int[] faceVertexIndices"])),"int[] faceVertexCounts"in e&&(r=JSON.parse(e["int[] faceVertexCounts"]),o=n(o,r)),"point3f[] points"in e){const r=JSON.parse(e["point3f[] points"].replace(/[()]*/g,""));i=r.length;let n=new BufferAttribute(new Float32Array(r),3);null!==o&&(n=s(n,o)),t.setAttribute("position",n)}if("float2[] primvars:st"in e&&(e["texCoord2f[] primvars:st"]=e["float2[] primvars:st"]),"texCoord2f[] primvars:st"in e){a=JSON.parse(e["texCoord2f[] primvars:st"].replace(/[()]*/g,""));let r=new BufferAttribute(new Float32Array(a),2);null!==o&&(r=s(r,o)),t.setAttribute("uv",r)}if("int[] primvars:st:indices"in e&&null!==a){const o=new BufferAttribute(new Float32Array(a),2);let i=JSON.parse(e["int[] primvars:st:indices"]);i=n(i,r),t.setAttribute("uv",s(o,i))}if("normal3f[] normals"in e){const a=JSON.parse(e["normal3f[] normals"].replace(/[()]*/g,""));let c=new BufferAttribute(new Float32Array(a),3);if(a.length===i)null!==o&&(c=s(c,o));else{let e=Array.from(Array(a.length/3).keys());e=n(e,r),c=s(c,e)}t.setAttribute("normal",c)}else t.computeVertexNormals();return t}(function(e){if(e){if("prepend references"in e){const o=e["prepend references"].split("@"),n=o[1].replace(/^.\//,""),s=o[2].replace(/^<\//,"").replace(/>$/,"");return r(t[n],s)}return r(e)}}(e)),p=function(e){const t=new MeshPhysicalMaterial;if(void 0!==e){let r;const n=e["token outputs:surface.connect"];if(n){const t=/(\w+)\.output/.exec(n);t&&(r=e[`def Shader "${t[1]}"`])}if(void 0!==r){if("color3f inputs:diffuseColor.connect"in r){const n=r["color3f inputs:diffuseColor.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.map=l(s),t.map.colorSpace=SRGBColorSpace,'def Shader "Transform2d_diffuse"'in e&&i(t.map,e['def Shader "Transform2d_diffuse"'])}else if("color3f inputs:diffuseColor"in r){const e=r["color3f inputs:diffuseColor"].replace(/[()]*/g,"");t.color.fromArray(JSON.parse("["+e+"]"))}if("color3f inputs:emissiveColor.connect"in r){const n=r["color3f inputs:emissiveColor.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.emissiveMap=l(s),t.emissiveMap.colorSpace=SRGBColorSpace,t.emissive.set(16777215),'def Shader "Transform2d_emissive"'in e&&i(t.emissiveMap,e['def Shader "Transform2d_emissive"'])}else if("color3f inputs:emissiveColor"in r){const e=r["color3f inputs:emissiveColor"].replace(/[()]*/g,"");t.emissive.fromArray(JSON.parse("["+e+"]"))}if("normal3f inputs:normal.connect"in r){const n=r["normal3f inputs:normal.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.normalMap=l(s),t.normalMap.colorSpace=NoColorSpace,'def Shader "Transform2d_normal"'in e&&i(t.normalMap,e['def Shader "Transform2d_normal"'])}if("float inputs:roughness.connect"in r){const n=r["float inputs:roughness.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.roughness=1,t.roughnessMap=l(s),t.roughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_roughness"'in e&&i(t.roughnessMap,e['def Shader "Transform2d_roughness"'])}else"float inputs:roughness"in r&&(t.roughness=parseFloat(r["float inputs:roughness"]));if("float inputs:metallic.connect"in r){const n=r["float inputs:metallic.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.metalness=1,t.metalnessMap=l(s),t.metalnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_metallic"'in e&&i(t.metalnessMap,e['def Shader "Transform2d_metallic"'])}else"float inputs:metallic"in r&&(t.metalness=parseFloat(r["float inputs:metallic"]));if("float inputs:clearcoat.connect"in r){const n=r["float inputs:clearcoat.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.clearcoat=1,t.clearcoatMap=l(s),t.clearcoatMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoat"'in e&&i(t.clearcoatMap,e['def Shader "Transform2d_clearcoat"'])}else"float inputs:clearcoat"in r&&(t.clearcoat=parseFloat(r["float inputs:clearcoat"]));if("float inputs:clearcoatRoughness.connect"in r){const n=r["float inputs:clearcoatRoughness.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.clearcoatRoughness=1,t.clearcoatRoughnessMap=l(s),t.clearcoatRoughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoatRoughness"'in e&&i(t.clearcoatRoughnessMap,e['def Shader "Transform2d_clearcoatRoughness"'])}else"float inputs:clearcoatRoughness"in r&&(t.clearcoatRoughness=parseFloat(r["float inputs:clearcoatRoughness"]));if("float inputs:ior"in r&&(t.ior=parseFloat(r["float inputs:ior"])),"float inputs:occlusion.connect"in r){const n=r["float inputs:occlusion.connect"],s=c(o,/(\w+).output/.exec(n)[1]);t.aoMap=l(s),t.aoMap.colorSpace=NoColorSpace,'def Shader "Transform2d_occlusion"'in e&&i(t.aoMap,e['def Shader "Transform2d_occlusion"'])}}}return t}(function(e){if(e){if("rel material:binding"in e){const t=e["rel material:binding"].replace(/^<\//,"").replace(/>$/,"").split("/");return a(o,` "${t[1]}"`)}return a(e)}}(e)),u=f?new Mesh(f,p):new Object3D;if("matrix4d xformOp:transform"in e){const t=JSON.parse("["+e["matrix4d xformOp:transform"].replace(/[()]*/g,"")+"]");u.matrix.fromArray(t),u.matrix.decompose(u.position,u.quaternion,u.scale)}return u}function p(e,t){for(const o in e)if(o.startsWith("def Scope"))p(e[o],t);else if(o.startsWith("def Xform")){const r=f(e[o]);/def Xform "(\w+)"/.test(o)&&(r.name=/def Xform "(\w+)"/.exec(o)[1]),t.add(r),p(e[o],r)}}return function(e){const t=new Group;return p(e,t),t}(o)}}export{USDAParser};
//# sourceMappingURL=USDAParser.js.map