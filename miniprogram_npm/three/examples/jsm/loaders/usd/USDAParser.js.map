{"version":3,"file":"node_modules/three/examples/jsm/loaders/usd/USDAParser.js","names":["BufferAttribute","BufferGeometry","ClampToEdgeWrapping","Group","NoColorSpace","Mesh","MeshPhysicalMaterial","MirroredRepeatWrapping","RepeatWrapping","SRGBColorSpace","TextureLoader","Object3D","Vector2","USDAParser","parseText","text","root","lines","split","string","target","stack","line","includes","assignment","lhs","trim","rhs","endsWith","group","push","values","slice","meta","pop","length","parse","assets","this","findGeometry","data","id","undefined","def","name","object","startsWith","geometry","toTriangleIndices","rawIndices","counts","indices","i","count","stride","a","b","c","d","console","warn","toFlatBufferAttribute","attribute","array","itemSize","array2","constructor","index","index2","l","j","findMaterial","material","setTextureParams","map","data_value","rotation","parseFloat","repeat","fromArray","JSON","replace","offset","findTexture","texture","buildTexture","path","load","wrapS","wrapT","buildObject","uvs","positionsLength","positions","Float32Array","setAttribute","normals","Array","from","keys","computeVertexNormals","buildGeometry","parts","findMeshGeometry","surface","surfaceConnection","match","exec","sampler","colorSpace","color","emissiveMap","emissive","set","normalMap","roughness","roughnessMap","metalness","metalnessMap","clearcoat","clearcoatMap","clearcoatRoughness","clearcoatRoughnessMap","ior","aoMap","buildMaterial","findMeshMaterial","mesh","matrix","decompose","position","quaternion","scale","buildHierarchy","test","add","buildGroup"],"sources":["node_modules/three/examples/jsm/loaders/usd/USDAParser.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tGroup,\n\tNoColorSpace,\n\tMesh,\n\tMeshPhysicalMaterial,\n\tMirroredRepeatWrapping,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tObject3D,\n\tVector2\n} from 'three';\n\nclass USDAParser {\n\n\tparseText( text ) {\n\n\t\tconst root = {};\n\n\t\tconst lines = text.split( '\\n' );\n\n\t\tlet string = null;\n\t\tlet target = root;\n\n\t\tconst stack = [ root ];\n\n\t\t// Parse USDA file\n\n\t\tfor ( const line of lines ) {\n\n\t\t\t// console.log( line );\n\n\t\t\tif ( line.includes( '=' ) ) {\n\n\t\t\t\tconst assignment = line.split( '=' );\n\n\t\t\t\tconst lhs = assignment[ 0 ].trim();\n\t\t\t\tconst rhs = assignment[ 1 ].trim();\n\n\t\t\t\tif ( rhs.endsWith( '{' ) ) {\n\n\t\t\t\t\tconst group = {};\n\t\t\t\t\tstack.push( group );\n\n\t\t\t\t\ttarget[ lhs ] = group;\n\t\t\t\t\ttarget = group;\n\n\t\t\t\t} else if ( rhs.endsWith( '(' ) ) {\n\n\t\t\t\t\t// see #28631\n\n\t\t\t\t\tconst values = rhs.slice( 0, - 1 );\n\t\t\t\t\ttarget[ lhs ] = values;\n\n\t\t\t\t\tconst meta = {};\n\t\t\t\t\tstack.push( meta );\n\n\t\t\t\t\ttarget = meta;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget[ lhs ] = rhs;\n\n\t\t\t\t}\n\n\t\t\t} else if ( line.endsWith( '{' ) ) {\n\n\t\t\t\tconst group = target[ string ] || {};\n\t\t\t\tstack.push( group );\n\n\t\t\t\ttarget[ string ] = group;\n\t\t\t\ttarget = group;\n\n\t\t\t} else if ( line.endsWith( '}' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\tif ( stack.length === 0 ) continue;\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else if ( line.endsWith( '(' ) ) {\n\n\t\t\t\tconst meta = {};\n\t\t\t\tstack.push( meta );\n\n\t\t\t\tstring = line.split( '(' )[ 0 ].trim() || string;\n\n\t\t\t\ttarget[ string ] = meta;\n\t\t\t\ttarget = meta;\n\n\t\t\t} else if ( line.endsWith( ')' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tstring = line.trim();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn root;\n\n\t}\n\n\tparse( text, assets ) {\n\n\t\tconst root = this.parseText( text );\n\n\t\t// Build scene graph\n\n\t\tfunction findMeshGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'prepend references' in data ) {\n\n\t\t\t\tconst reference = data[ 'prepend references' ];\n\t\t\t\tconst parts = reference.split( '@' );\n\t\t\t\tconst path = parts[ 1 ].replace( /^.\\//, '' );\n\t\t\t\tconst id = parts[ 2 ].replace( /^<\\//, '' ).replace( />$/, '' );\n\n\t\t\t\treturn findGeometry( assets[ path ], id );\n\n\t\t\t}\n\n\t\t\treturn findGeometry( data );\n\n\t\t}\n\n\t\tfunction findGeometry( data, id ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( id !== undefined ) {\n\n\t\t\t\tconst def = `def Mesh \"${id}\"`;\n\n\t\t\t\tif ( def in data ) {\n\n\t\t\t\t\treturn data[ def ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Mesh' ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst geometry = findGeometry( object );\n\n\t\t\t\t\tif ( geometry ) return geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tlet indices = null;\n\t\t\tlet counts = null;\n\t\t\tlet uvs = null;\n\n\t\t\tlet positionsLength = - 1;\n\n\t\t\t// index\n\n\t\t\tif ( 'int[] faceVertexIndices' in data ) {\n\n\t\t\t\tindices = JSON.parse( data[ 'int[] faceVertexIndices' ] );\n\n\t\t\t}\n\n\t\t\t// face count\n\n\t\t\tif ( 'int[] faceVertexCounts' in data ) {\n\n\t\t\t\tcounts = JSON.parse( data[ 'int[] faceVertexCounts' ] );\n\t\t\t\tindices = toTriangleIndices( indices, counts );\n\n\t\t\t}\n\n\t\t\t// position\n\n\t\t\tif ( 'point3f[] points' in data ) {\n\n\t\t\t\tconst positions = JSON.parse( data[ 'point3f[] points' ].replace( /[()]*/g, '' ) );\n\t\t\t\tpositionsLength = positions.length;\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( positions ), 3 );\n\n\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\tgeometry.setAttribute( 'position', attribute );\n\n\t\t\t}\n\n\t\t\t// uv\n\n\t\t\tif ( 'float2[] primvars:st' in data ) {\n\n\t\t\t\tdata[ 'texCoord2f[] primvars:st' ] = data[ 'float2[] primvars:st' ];\n\n\t\t\t}\n\n\t\t\tif ( 'texCoord2f[] primvars:st' in data ) {\n\n\t\t\t\tuvs = JSON.parse( data[ 'texCoord2f[] primvars:st' ].replace( /[()]*/g, '' ) );\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( uvs ), 2 );\n\n\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\tgeometry.setAttribute( 'uv', attribute );\n\n\t\t\t}\n\n\t\t\tif ( 'int[] primvars:st:indices' in data && uvs !== null ) {\n\n\t\t\t\t// custom uv index, overwrite uvs with new data\n\n\t\t\t\tconst attribute = new BufferAttribute( new Float32Array( uvs ), 2 );\n\t\t\t\tlet indices = JSON.parse( data[ 'int[] primvars:st:indices' ] );\n\t\t\t\tindices = toTriangleIndices( indices, counts );\n\t\t\t\tgeometry.setAttribute( 'uv', toFlatBufferAttribute( attribute, indices ) );\n\n\t\t\t}\n\n\t\t\t// normal\n\n\t\t\tif ( 'normal3f[] normals' in data ) {\n\n\t\t\t\tconst normals = JSON.parse( data[ 'normal3f[] normals' ].replace( /[()]*/g, '' ) );\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( normals ), 3 );\n\n\t\t\t\t// normals require a special treatment in USD\n\n\t\t\t\tif ( normals.length === positionsLength ) {\n\n\t\t\t\t\t// raw normal and position data have equal length (like produced by USDZExporter)\n\n\t\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unequal length, normals are independent of faceVertexIndices\n\n\t\t\t\t\tlet indices = Array.from( Array( normals.length / 3 ).keys() ); // [ 0, 1, 2, 3 ... ]\n\t\t\t\t\tindices = toTriangleIndices( indices, counts );\n\t\t\t\t\tattribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'normal', attribute );\n\n\t\t\t} else {\n\n\t\t\t\t// compute flat vertex normals\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction toTriangleIndices( rawIndices, counts ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0; i < counts.length; i ++ ) {\n\n\t\t\t\tconst count = counts[ i ];\n\n\t\t\t\tconst stride = i * count;\n\n\t\t\t\tif ( count === 3 ) {\n\n\t\t\t\t\tconst a = rawIndices[ stride + 0 ];\n\t\t\t\t\tconst b = rawIndices[ stride + 1 ];\n\t\t\t\t\tconst c = rawIndices[ stride + 2 ];\n\n\t\t\t\t\tindices.push( a, b, c );\n\n\t\t\t\t} else if ( count === 4 ) {\n\n\t\t\t\t\tconst a = rawIndices[ stride + 0 ];\n\t\t\t\t\tconst b = rawIndices[ stride + 1 ];\n\t\t\t\t\tconst c = rawIndices[ stride + 2 ];\n\t\t\t\t\tconst d = rawIndices[ stride + 3 ];\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\tindices.push( a, c, d );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.USDZLoader: Face vertex count of %s unsupported.', count );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction toFlatBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tfunction findMeshMaterial( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'rel material:binding' in data ) {\n\n\t\t\t\tconst reference = data[ 'rel material:binding' ];\n\t\t\t\tconst id = reference.replace( /^<\\//, '' ).replace( />$/, '' );\n\t\t\t\tconst parts = id.split( '/' );\n\n\t\t\t\treturn findMaterial( root, ` \"${ parts[ 1 ] }\"` );\n\n\t\t\t}\n\n\t\t\treturn findMaterial( data );\n\n\t\t}\n\n\t\tfunction findMaterial( data, id = '' ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Material' + id ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst material = findMaterial( object, id );\n\n\t\t\t\t\tif ( material ) return material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureParams( map, data_value ) {\n\n\t\t\t// rotation, scale and translation\n\n\t\t\tif ( data_value[ 'float inputs:rotation' ] ) {\n\n\t\t\t\tmap.rotation = parseFloat( data_value[ 'float inputs:rotation' ] );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:scale' ] ) {\n\n\t\t\t\tmap.repeat = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:scale' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:translation' ] ) {\n\n\t\t\t\tmap.offset = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:translation' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst material = new MeshPhysicalMaterial();\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\tlet surface = undefined;\n\n\t\t\t\tconst surfaceConnection = data[ 'token outputs:surface.connect' ];\n\n\t\t\t\tif ( surfaceConnection ) {\n\n\t\t\t\t\tconst match = /(\\w+)\\.output/.exec( surfaceConnection );\n\n\t\t\t\t\tif ( match ) {\n\n\t\t\t\t\t\tconst surfaceName = match[ 1 ];\n\t\t\t\t\t\tsurface = data[ `def Shader \"${surfaceName}\"` ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( surface !== undefined ) {\n\n\t\t\t\t\tif ( 'color3f inputs:diffuseColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:diffuseColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.map = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.map.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_diffuse\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.map, data[ 'def Shader \"Transform2d_diffuse\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:diffuseColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:diffuseColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.color.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'color3f inputs:emissiveColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:emissiveColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.emissiveMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaterial.emissive.set( 0xffffff );\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_emissive\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.emissiveMap, data[ 'def Shader \"Transform2d_emissive\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:emissiveColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:emissiveColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.emissive.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'normal3f inputs:normal.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'normal3f inputs:normal.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.normalMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.normalMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_normal\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.normalMap, data[ 'def Shader \"Transform2d_normal\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:roughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:roughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.roughness = 1.0;\n\t\t\t\t\t\tmaterial.roughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.roughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_roughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.roughnessMap, data[ 'def Shader \"Transform2d_roughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:roughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.roughness = parseFloat( surface[ 'float inputs:roughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:metallic.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:metallic.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.metalness = 1.0;\n\t\t\t\t\t\tmaterial.metalnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.metalnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_metallic\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.metalnessMap, data[ 'def Shader \"Transform2d_metallic\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:metallic' in surface ) {\n\n\t\t\t\t\t\tmaterial.metalness = parseFloat( surface[ 'float inputs:metallic' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoat.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoat.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoat = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoat\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatMap, data[ 'def Shader \"Transform2d_clearcoat\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoat' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoat = parseFloat( surface[ 'float inputs:clearcoat' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoatRoughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoatRoughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoatRoughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatRoughnessMap, data[ 'def Shader \"Transform2d_clearcoatRoughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoatRoughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = parseFloat( surface[ 'float inputs:clearcoatRoughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:ior' in surface ) {\n\n\t\t\t\t\t\tmaterial.ior = parseFloat( surface[ 'float inputs:ior' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:occlusion.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:occlusion.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.aoMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.aoMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_occlusion\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.aoMap, data[ 'def Shader \"Transform2d_occlusion\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction findTexture( data, id ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( `def Shader \"${ id }\"` ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst texture = findTexture( object, id );\n\n\t\t\t\t\tif ( texture ) return texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildTexture( data ) {\n\n\t\t\tif ( 'asset inputs:file' in data ) {\n\n\t\t\t\tconst path = data[ 'asset inputs:file' ].replace( /@*/g, '' ).trim();\n\n\t\t\t\tconst loader = new TextureLoader();\n\n\t\t\t\tconst texture = loader.load( assets[ path ] );\n\n\t\t\t\tconst map = {\n\t\t\t\t\t'\"clamp\"': ClampToEdgeWrapping,\n\t\t\t\t\t'\"mirror\"': MirroredRepeatWrapping,\n\t\t\t\t\t'\"repeat\"': RepeatWrapping\n\t\t\t\t};\n\n\t\t\t\tif ( 'token inputs:wrapS' in data ) {\n\n\t\t\t\t\ttexture.wrapS = map[ data[ 'token inputs:wrapS' ] ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'token inputs:wrapT' in data ) {\n\n\t\t\t\t\ttexture.wrapT = map[ data[ 'token inputs:wrapT' ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction buildObject( data ) {\n\n\t\t\tconst geometry = buildGeometry( findMeshGeometry( data ) );\n\t\t\tconst material = buildMaterial( findMeshMaterial( data ) );\n\n\t\t\tconst mesh = geometry ? new Mesh( geometry, material ) : new Object3D();\n\n\t\t\tif ( 'matrix4d xformOp:transform' in data ) {\n\n\t\t\t\tconst array = JSON.parse( '[' + data[ 'matrix4d xformOp:transform' ].replace( /[()]*/g, '' ) + ']' );\n\n\t\t\t\tmesh.matrix.fromArray( array );\n\t\t\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t}\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t\tfunction buildHierarchy( data, group ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tif ( name.startsWith( 'def Scope' ) ) {\n\n\t\t\t\t\tbuildHierarchy( data[ name ], group );\n\n\t\t\t\t} else if ( name.startsWith( 'def Xform' ) ) {\n\n\t\t\t\t\tconst mesh = buildObject( data[ name ] );\n\n\t\t\t\t\tif ( /def Xform \"(\\w+)\"/.test( name ) ) {\n\n\t\t\t\t\t\tmesh.name = /def Xform \"(\\w+)\"/.exec( name )[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\tbuildHierarchy( data[ name ], mesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGroup( data ) {\n\n\t\t\tconst group = new Group();\n\n\t\t\tbuildHierarchy( data, group );\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\treturn buildGroup( root );\n\n\t}\n\n}\n\nexport { USDAParser };\n"],"mappings":"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","ignoreList":[]}