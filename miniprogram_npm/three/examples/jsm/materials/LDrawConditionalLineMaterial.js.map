{"version":3,"file":"node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js","names":["Color","ShaderMaterial","UniformsLib","UniformsUtils","LDrawConditionalLineMaterial","type","constructor","parameters","super","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","this","get","set","color","setValues","isLDrawConditionalLineMaterial"],"sources":["node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js"],"sourcesContent":["import {\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n} from 'three';\n\n/**\n * A special line material for meshes loaded via {@link LDrawLoader}.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `LDrawConditionalLineNodeMaterial.js`.\n *\n * @augments ShaderMaterial\n * @three_import import { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n */\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LDrawConditionalLineMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional line material.\n\t *\n\t * @param {Object} [parameters] - An object with one or more properties\n\t * defining the material's appearance. Any property of the material\n\t * (including any property from inherited materials) can be passed\n\t * in here. Color values can be passed any type of value accepted\n\t * by {@link Color#set}.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\t/**\n\t\t\t * The material's opacity.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#opacity\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * The material's color.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#color\n\t\t\t * @type {Color}\n\t\t\t * @default (1,1,1)\n\t\t\t */\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nexport { LDrawConditionalLineMaterial };\n"],"mappings":"OACCA,MACAC,eACAC,YACAC,kBACM,QAWP,MAAMC,qCAAqCH,eAE1C,eAAWI,GAEV,MAAO,8BAER,CAWA,WAAAC,CAAaC,GAEZC,MAAO,CAENC,SAAUN,cAAcO,MAAO,CAC9BR,YAAYS,IACZ,CACCC,QAAS,CACRC,MAAO,IAAIb,OAEZc,QAAS,CACRD,MAAO,MAKVE,aAAwB,2zDAgDxBC,eAA0B,i3BA8B3BC,OAAOC,iBAAkBC,KAAM,CAS9BL,QAAS,CACRM,IAAK,WAEJ,OAAOD,KAAKV,SAASK,QAAQD,KAE9B,EAEAQ,IAAK,SAAWR,GAEfM,KAAKV,SAASK,QAAQD,MAAQA,CAE/B,GAUDS,MAAO,CACNF,IAAK,WAEJ,OAAOD,KAAKV,SAASG,QAAQC,KAE9B,KAKFM,KAAKI,UAAWhB,GAShBY,KAAKK,gCAAiC,CAEvC,SAIQpB","ignoreList":[]}