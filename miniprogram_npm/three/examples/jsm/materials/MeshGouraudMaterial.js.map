{"version":3,"file":"node_modules/three/examples/jsm/materials/MeshGouraudMaterial.js","names":["UniformsUtils","UniformsLib","ShaderMaterial","Color","MultiplyOperation","GouraudShader","name","uniforms","merge","common","specularmap","envmap","aomap","lightmap","emissivemap","fog","lights","emissive","value","vertexShader","fragmentShader","MeshGouraudMaterial","constructor","parameters","super","console","warn","this","isMeshGouraudMaterial","type","combine","clipping","shader","defines","Object","assign","clone","exposePropertyNames","propertyName","defineProperty","get","set","getOwnPropertyDescriptor","setValues","copy","source","color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveMap","emissiveIntensity","specularMap","alphaMap","envMap","reflectivity","refractionRatio","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin"],"sources":["node_modules/three/examples/jsm/materials/MeshGouraudMaterial.js"],"sourcesContent":["/**\n * MeshGouraudMaterial\n *\n * Lambert illumination model with Gouraud (per-vertex) shading\n *\n */\n\nimport { UniformsUtils, UniformsLib, ShaderMaterial, Color, MultiplyOperation } from 'three';\n\nconst GouraudShader = {\n\n\tname: 'GouraudShader',\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.specularmap,\n\t\tUniformsLib.envmap,\n\t\tUniformsLib.aomap,\n\t\tUniformsLib.lightmap,\n\t\tUniformsLib.emissivemap,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.lights,\n\t\t{\n\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t}\n\t] ),\n\n\tvertexShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <uv_pars_vertex>\n\t\t#include <envmap_pars_vertex>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <morphtarget_pars_vertex>\n\t\t#include <skinning_pars_vertex>\n\t\t#include <shadowmap_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\t#include <uv_vertex>\n\t\t\t#include <color_vertex>\n\t\t\t#include <morphcolor_vertex>\n\n\t\t\t#include <beginnormal_vertex>\n\t\t\t#include <morphnormal_vertex>\n\t\t\t#include <skinbase_vertex>\n\t\t\t#include <skinnormal_vertex>\n\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <morphtarget_vertex>\n\t\t\t#include <skinning_vertex>\n\t\t\t#include <project_vertex>\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <envmap_vertex>\n\n\t\t\t// inlining legacy <lights_lambert_vertex>\n\n\t\t\tvec3 diffuse = vec3( 1.0 );\n\n\t\t\tvec3 geometryPosition = mvPosition.xyz;\n\t\t\tvec3 geometryNormal = normalize( transformedNormal );\n\t\t\tvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\n\t\t\tvec3 backGeometryNormal = - geometryNormal;\n\n\t\t\tvLightFront = vec3( 0.0 );\n\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t#endif\n\n\t\t\tIncidentLight directLight;\n\t\t\tfloat dotNL;\n\t\t\tvec3 directLightColor_Diffuse;\n\n\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t\t\t#endif\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometryNormal );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetPointLightInfo( pointLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetSpotLightInfo( spotLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ i ], directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_HEMI_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometryNormal );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#include <shadowmap_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tuniform vec3 diffuse;\n\t\tuniform vec3 emissive;\n\t\tuniform float opacity;\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\t\t#include <dithering_pars_fragment>\n\t\t#include <color_pars_fragment>\n\t\t#include <uv_pars_fragment>\n\t\t#include <map_pars_fragment>\n\t\t#include <alphamap_pars_fragment>\n\t\t#include <alphatest_pars_fragment>\n\t\t#include <aomap_pars_fragment>\n\t\t#include <lightmap_pars_fragment>\n\t\t#include <emissivemap_pars_fragment>\n\t\t#include <envmap_common_pars_fragment>\n\t\t#include <envmap_pars_fragment>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <fog_pars_fragment>\n\t\t#include <shadowmap_pars_fragment>\n\t\t#include <shadowmask_pars_fragment>\n\t\t#include <specularmap_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <map_fragment>\n\t\t\t#include <color_fragment>\n\t\t\t#include <alphamap_fragment>\n\t\t\t#include <alphatest_fragment>\n\t\t\t#include <specularmap_fragment>\n\t\t\t#include <emissivemap_fragment>\n\n\t\t\t// accumulation\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_LIGHTMAP\n\n\t\t\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\t\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t\t\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.directDiffuse = vLightFront;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t\t\t// modulation\n\n\t\t\t#include <aomap_fragment>\n\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t\t\t#include <envmap_fragment>\n\n\t\t\t#include <opaque_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <dithering_fragment>\n\n\t\t}`\n\n};\n\n//\n\nclass MeshGouraudMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tconsole.warn( 'THREE.MeshGouraudMaterial: MeshGouraudMaterial has been deprecated and will be removed with r183. Use THREE.MeshLambertMaterial instead.' ); // @deprecated r173\n\n\t\tthis.isMeshGouraudMaterial = true;\n\n\t\tthis.type = 'MeshGouraudMaterial';\n\n\t\t//this.color = new THREE.Color( 0xffffff ); // diffuse\n\n\t\t//this.map = null;\n\n\t\t//this.lightMap = null;\n\t\t//this.lightMapIntensity = 1.0;\n\n\t\t//this.aoMap = null;\n\t\t//this.aoMapIntensity = 1.0;\n\n\t\t//this.emissive = new THREE.Color( 0x000000 );\n\t\t//this.emissiveIntensity = 1.0;\n\t\t//this.emissiveMap = null;\n\n\t\t//this.specularMap = null;\n\n\t\t//this.alphaMap = null;\n\n\t\t//this.envMap = null;\n\t\tthis.combine = MultiplyOperation; // combine has no uniform\n\t\t//this.reflectivity = 1;\n\t\t//this.refractionRatio = 0.98;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = true; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tconst shader = GouraudShader;\n\n\t\tthis.defines = Object.assign( {}, shader.defines );\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\t\tthis.vertexShader = shader.vertexShader;\n\t\tthis.fragmentShader = shader.fragmentShader;\n\n\t\tconst exposePropertyNames = [\n\t\t\t'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity',\n\t\t\t'emissive', 'emissiveIntensity', 'emissiveMap', 'specularMap', 'alphaMap',\n\t\t\t'envMap', 'reflectivity', 'refractionRatio', 'opacity', 'diffuse'\n\t\t];\n\n\t\tfor ( const propertyName of exposePropertyNames ) {\n\n\t\t\tObject.defineProperty( this, propertyName, {\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms[ propertyName ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms[ propertyName ].value = value;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tObject.defineProperty( this, 'color', Object.getOwnPropertyDescriptor( this, 'diffuse' ) );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshGouraudMaterial };\n"],"mappings":"OAOSA,cAAeC,YAAaC,eAAgBC,MAAOC,sBAAyB,QAErF,MAAMC,cAAgB,CAErBC,KAAM,gBAENC,SAAUP,cAAcQ,MAAO,CAC9BP,YAAYQ,OACZR,YAAYS,YACZT,YAAYU,OACZV,YAAYW,MACZX,YAAYY,SACZZ,YAAYa,YACZb,YAAYc,IACZd,YAAYe,OACZ,CACCC,SAAU,CAAEC,MAAO,IAAIf,MAAO,OAIhCgB,aAAwB,ohJAmLxBC,eAA0B,u1FA6G3B,MAAMC,4BAA4BnB,eAEjC,WAAAoB,CAAaC,GAEZC,QAEAC,QAAQC,KAAM,4IAEdC,KAAKC,uBAAwB,EAE7BD,KAAKE,KAAO,sBAqBZF,KAAKG,QAAU1B,kBAIfuB,KAAKZ,KAAM,EACXY,KAAKX,QAAS,EACdW,KAAKI,UAAW,EAEhB,MAAMC,EAAS3B,cAEfsB,KAAKM,QAAUC,OAAOC,OAAQ,CAAC,EAAGH,EAAOC,SACzCN,KAAKpB,SAAWP,cAAcoC,MAAOJ,EAAOzB,UAC5CoB,KAAKR,aAAea,EAAOb,aAC3BQ,KAAKP,eAAiBY,EAAOZ,eAE7B,MAAMiB,EAAsB,CAC3B,MAAO,WAAY,oBAAqB,QAAS,iBACjD,WAAY,oBAAqB,cAAe,cAAe,WAC/D,SAAU,eAAgB,kBAAmB,UAAW,WAGzD,IAAM,MAAMC,KAAgBD,EAE3BH,OAAOK,eAAgBZ,KAAMW,EAAc,CAE1CE,IAAK,WAEJ,OAAOb,KAAKpB,SAAU+B,GAAepB,KAEtC,EAEAuB,IAAK,SAAWvB,GAEfS,KAAKpB,SAAU+B,GAAepB,MAAQA,CAEvC,IAMFgB,OAAOK,eAAgBZ,KAAM,QAASO,OAAOQ,yBAA0Bf,KAAM,YAE7EA,KAAKgB,UAAWpB,EAEjB,CAEA,IAAAqB,CAAMC,GAkCL,OAhCArB,MAAMoB,KAAMC,GAEZlB,KAAKmB,MAAMF,KAAMC,EAAOC,OAExBnB,KAAKoB,IAAMF,EAAOE,IAElBpB,KAAKqB,SAAWH,EAAOG,SACvBrB,KAAKsB,kBAAoBJ,EAAOI,kBAEhCtB,KAAKuB,MAAQL,EAAOK,MACpBvB,KAAKwB,eAAiBN,EAAOM,eAE7BxB,KAAKV,SAAS2B,KAAMC,EAAO5B,UAC3BU,KAAKyB,YAAcP,EAAOO,YAC1BzB,KAAK0B,kBAAoBR,EAAOQ,kBAEhC1B,KAAK2B,YAAcT,EAAOS,YAE1B3B,KAAK4B,SAAWV,EAAOU,SAEvB5B,KAAK6B,OAASX,EAAOW,OACrB7B,KAAKG,QAAUe,EAAOf,QACtBH,KAAK8B,aAAeZ,EAAOY,aAC3B9B,KAAK+B,gBAAkBb,EAAOa,gBAE9B/B,KAAKgC,UAAYd,EAAOc,UACxBhC,KAAKiC,mBAAqBf,EAAOe,mBACjCjC,KAAKkC,iBAAmBhB,EAAOgB,iBAC/BlC,KAAKmC,kBAAoBjB,EAAOiB,kBAEhCnC,KAAKZ,IAAM8B,EAAO9B,IAEXY,IAER,SAIQN","ignoreList":[]}