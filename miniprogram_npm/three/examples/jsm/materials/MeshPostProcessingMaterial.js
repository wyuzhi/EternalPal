import{MeshPhysicalMaterial}from"three";class MeshPostProcessingMaterial extends MeshPhysicalMaterial{constructor(a){const e=a.aoPassMap,t=a.aoPassMapScale||1;delete a.aoPassMap,delete a.aoPassMapScale,super(a),this.onBeforeCompile=this._onBeforeCompile,this.customProgramCacheKey=this._customProgramCacheKey,this._aoPassMap=e,this.aoPassMapScale=t,this._shader=null}get aoPassMap(){return this._aoPassMap}set aoPassMap(a){this._aoPassMap=a,this.needsUpdate=!0,this._setUniforms()}_customProgramCacheKey(){return void 0!==this._aoPassMap&&null!==this._aoPassMap?"aoPassMap":""}_onBeforeCompile(a){this._shader=a,void 0!==this._aoPassMap&&null!==this._aoPassMap&&(a.fragmentShader=a.fragmentShader.replace("#include <aomap_pars_fragment>",aomap_pars_fragment_replacement),a.fragmentShader=a.fragmentShader.replace("#include <aomap_fragment>",aomap_fragment_replacement)),this._setUniforms()}_setUniforms(){this._shader&&(this._shader.uniforms.tAoPassMap={value:this._aoPassMap},this._shader.uniforms.aoPassMapScale={value:this.aoPassMapScale})}}const aomap_pars_fragment_replacement="\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\tuniform sampler2D tAoPassMap;\n\tuniform float aoPassMapScale;\n",aomap_fragment_replacement="\n#ifndef AOPASSMAP_SWIZZLE\n\t#define AOPASSMAP_SWIZZLE r\n#endif\n\tfloat ambientOcclusion = texelFetch( tAoPassMap, ivec2( gl_FragCoord.xy * aoPassMapScale ), 0 ).AOPASSMAP_SWIZZLE;\n\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tambientOcclusion = min( ambientOcclusion, texture2D( aoMap, vAoMapUv ).r );\n\tambientOcclusion *= ( ambientOcclusion - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n";export{MeshPostProcessingMaterial};
//# sourceMappingURL=MeshPostProcessingMaterial.js.map