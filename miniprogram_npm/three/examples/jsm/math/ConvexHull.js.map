{"version":3,"file":"node_modules/three/examples/jsm/math/ConvexHull.js","names":["Line3","Plane","Triangle","Vector3","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","constructor","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","_compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","face","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","_addVertexToFace","vertex","outside","append","insertBefore","_removeVertexFromFace","next","remove","_removeAllVerticesFromFace","start","end","removeSubList","prev","_deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","_resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","distance","_computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","_computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","_reindexFaces","activeFaces","_nextVertexToAdd","eyeVertex","eyeFace","_computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","_addAdjoiningFace","horizonEdge","tail","head","_addNewFaces","firstSideEdge","previousSideEdge","sideEdge","_addVertexToHull","clear","_cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","compute","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"sources":["node_modules/three/examples/jsm/math/ConvexHull.js"],"sourcesContent":["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\n/**\n * Can be used to compute the convex hull in 3D space for a given set of points. It\n * is primarily intended for {@link ConvexGeometry}.\n *\n * This Quickhull 3D implementation is a port of [quickhull3d]{@link https://github.com/maurizzzio/quickhull3d/}\n * by Mauricio Poppe.\n *\n * @three_import import { ConvexHull } from 'three/addons/math/ConvexHull.js';\n */\nclass ConvexHull {\n\n\t/**\n\t * Constructs a new convex hull.\n\t */\n\tconstructor() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; // vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\t/**\n\t * Computes to convex hull for the given array of points.\n\t *\n\t * @param {Array<Vector3>} points - The array of points in 3D space.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromPoints( points ) {\n\n\t\t// The algorithm needs at least four points.\n\n\t\tif ( points.length >= 4 ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis._compute();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the convex hull of the given 3D object (including its descendants),\n\t * accounting for the world transforms of both the 3D object and its descendants.\n\t *\n\t * @param {Object3D} object - The 3D object to compute the convex hull for.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromObject( object ) {\n\n\t\tconst points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tconst geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tconst attribute = geometry.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst point = new Vector3();\n\n\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies in the convex hull.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the given point lies in the convex hull or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tconst faces = this.faces;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Computes the intersections point of the given ray and this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n\t\tconst faces = this.faces;\n\n\t\tlet tNear = - Infinity;\n\t\tlet tFar = Infinity;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tconst vN = face.distanceToPoint( ray.origin );\n\t\t\tconst vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tconst t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t// plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects with this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @return {boolean} Whether the given ray intersects with this convex hull or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, _v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Makes the convex hull empty.\n\t *\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t}\n\n\t// private\n\n\t/**\n\t * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to add.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToFace( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the 'assigned' list of vertices and from the given face.\n\t * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'\n\t * is linked correctly after the removal.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_removeVertexFromFace( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that a given face is able to see which are stored in\n\t * the 'assigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The target face.\n\t * @return {VertexNode|undefined} A reference to this convex hull.\n\t */\n\t_removeAllVerticesFromFace( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tconst start = face.outside;\n\t\t\tlet end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that `face` is able to see.\n\t *\n\t * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.\n\t * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.\n\t * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The given face.\n\t * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_deleteFaceVertices( face, absorbingFace ) {\n\n\t\tconst faceVertices = this._removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tlet vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\t\tconst distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis._addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Reassigns as many vertices as possible from the unassigned list to the new faces.\n\t *\n\t * @private\n\t * @param {Array<Face>} newFaces - The new faces.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_resolveUnassignedPoints( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tlet vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see ._deleteFaceVertices()\n\n\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\tlet maxDistance = this.tolerance;\n\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tconst face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tconst distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the extremes values (min/max vectors) which will be used to\n\t * compute the initial hull.\n\t *\n\t * @private\n\t * @return {Object} The extremes.\n\t */\n\t_computeExtremes() {\n\n\t\tconst min = new Vector3();\n\t\tconst max = new Vector3();\n\n\t\tconst minVertices = [];\n\t\tconst maxVertices = [];\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tconst point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t}\n\n\t/**\n\t * Computes the initial simplex assigning to its faces all the points that are\n\t * candidates to form part of the hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeInitialHull() {\n\n\t\tconst vertices = this.vertices;\n\t\tconst extremes = this._computeExtremes();\n\t\tconst min = extremes.min;\n\t\tconst max = extremes.max;\n\n\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t// (max.x - min.x)\n\t\t// (max.y - min.y)\n\t\t// (max.z - min.z)\n\n\t\tlet maxDistance = 0;\n\t\tlet index = 0;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst v0 = min[ index ];\n\t\tconst v1 = max[ index ];\n\t\tlet v2;\n\t\tlet v3;\n\n\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\tmaxDistance = 0;\n\t\t_line3.set( v0.point, v1.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t_line3.closestPointToPoint( vertex.point, true, _closestPoint );\n\n\t\t\t\tconst distance = _closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\tmaxDistance = - 1;\n\t\t_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\tconst distance = Math.abs( _plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst faces = [];\n\n\t\tif ( _plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// the initial hull is the tetrahedron\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t}\n\n\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tconst distance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes inactive (e.g. deleted) faces from the internal face list.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_reindexFaces() {\n\n\t\tconst activeFaces = [];\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Finds the next vertex to create faces with the current hull.\n\t *\n\t * - Let the initial face be the first face existing in the 'assigned' vertex list.\n\t * - If a face doesn't exist then return since there're no vertices left.\n\t * - Otherwise for each vertex that face sees find the one furthest away from it.\n\t *\n\t * @private\n\t * @return {?VertexNode} The next vertex to add.\n\t */\n\t_nextVertexToAdd() {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tlet eyeVertex, maxDistance = 0;\n\n\t\t\t// grab the first available face and start with the first visible vertex of that face\n\n\t\t\tconst eyeFace = this.assigned.first().face;\n\t\t\tlet vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tconst distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes a chain of half edges in CCW order called the 'horizon'. For an edge\n\t * to be part of the horizon it must join a face that can see 'eyePoint' and a face\n\t * that cannot see 'eyePoint'.\n\t *\n\t * @private\n\t * @param {Vector3} eyePoint - The 3D-coordinates of a point.\n\t * @param {HalfEdge} crossEdge - The edge used to jump to the current face.\n\t * @param {Face} face - The current face being tested.\n\t * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeHorizon( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis._deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tlet edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tconst twinEdge = edge.twin;\n\t\t\tconst oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis._computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'\n\t * in CCW order. All the half edges are created in CCW order thus the face is always pointing\n\t * outside the hull.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {HalfEdge} horizonEdge - A single edge of the horizon.\n\t * @return {HalfEdge} The half edge whose vertex is the eyeVertex.\n\t */\n\t_addAdjoiningFace( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tconst face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t}\n\n\t/**\n\t * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon\n\t * opposite face and the face on the left/right.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {Array<HalfEdge>} horizon - The horizon.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addNewFaces( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tlet firstSideEdge = null;\n\t\tlet previousSideEdge = null;\n\n\t\tfor ( let i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tconst horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tconst sideEdge = this._addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a vertex to the hull with the following algorithm:\n\t *\n\t * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group\n\t * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.\n\t * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.\n\t * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected\n\t * with the opposite horizon face and the face on the left/right.\n\t * - The vertices removed from all the visible faces are assigned to the new faces if possible.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex to add.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToHull( eyeVertex ) {\n\n\t\tconst horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis._removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis._computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis._addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis._resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t}\n\n\t/**\n\t * Cleans up internal properties after computing the convex hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_cleanup() {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Starts the execution of the quick hull algorithm.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_compute() {\n\n\t\tlet vertex;\n\n\t\tthis._computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this._nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis._addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis._reindexFaces();\n\n\t\tthis._cleanup();\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Represents a section bounded by a specific amount of half-edges.\n * The current implementation assumes that a face always consist of three edges.\n *\n * @private\n */\nclass Face {\n\n\t/**\n\t * Constructs a new face.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The normal vector of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.normal = new Vector3();\n\n\t\t/**\n\t\t * The midpoint or centroid of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.midpoint = new Vector3();\n\n\t\t/**\n\t\t * The area of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.area = 0;\n\n\t\t/**\n\t\t * Signed distance from face to the origin.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.constant = 0;\n\n\t\t/**\n\t\t * Reference to a vertex in a vertex list this face can see.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\n\t\t/**\n\t\t * Reference to the base edge of a face. To retrieve all edges, you can use the\n\t\t * `next` reference of the current edge.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.edge = null;\n\n\t}\n\n\t/**\n\t * Creates a face from the given vertex nodes.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The first vertex node.\n\t * @param {VertexNode} b - The second vertex node.\n\t * @param {VertexNode} c - The third vertex node.\n\t * @return {Face} The created face.\n\t */\n\tstatic create( a, b, c ) {\n\n\t\tconst face = new Face();\n\n\t\tconst e0 = new HalfEdge( a, face );\n\t\tconst e1 = new HalfEdge( b, face );\n\t\tconst e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n\t/**\n\t * Returns an edge by the given index.\n\t *\n\t * @private\n\t * @param {number} i - The edge index.\n\t * @return {HalfEdge} The edge.\n\t */\n\tgetEdge( i ) {\n\n\t\tlet edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t}\n\n\t/**\n\t * Computes all properties of the face.\n\t *\n\t * @private\n\t * @return {Face} A reference to this face.\n\t */\n\tcompute() {\n\n\t\tconst a = this.edge.tail();\n\t\tconst b = this.edge.head();\n\t\tconst c = this.edge.next.head();\n\n\t\t_triangle.set( a.point, b.point, c.point );\n\n\t\t_triangle.getNormal( this.normal );\n\t\t_triangle.getMidpoint( this.midpoint );\n\t\tthis.area = _triangle.getArea();\n\n\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the signed distance from a given point to the plane representation of this face.\n\t *\n\t * @private\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n}\n\n/**\n * The basis for a half-edge data structure, also known as doubly\n * connected edge list (DCEL).\n *\n * @private\n */\nclass HalfEdge {\n\n\t/**\n\t * Constructs a new half edge.\n\t *\n\t * @param {VertexNode} vertex - A reference to its destination vertex.\n\t * @param {Face} face - A reference to its face.\n\t */\n\tconstructor( vertex, face ) {\n\n\t\t/**\n\t\t * A reference to its destination vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {VertexNode}\n\t\t */\n\t\tthis.vertex = vertex;\n\n\t\t/**\n\t\t * Reference to the previous half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the twin half-edge to reach the opposite face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.twin = null;\n\n\t\t/**\n\t\t * A reference to its face.\n\t\t *\n\t\t * @private\n\t\t * @type {Face}\n\t\t */\n\t\tthis.face = face;\n\n\t}\n\n\t/**\n\t * Returns the destination vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\thead() {\n\n\t\treturn this.vertex;\n\n\t}\n\n\t/**\n\t * Returns the origin vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\ttail() {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t}\n\n\t/**\n\t * Returns the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The edge's length.\n\t */\n\tlength() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Returns the square of the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The square of the edge's length.\n\t */\n\tlengthSquared() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Sets the twin edge of this half-edge. It also ensures that the twin reference\n\t * of the given half-edge is correctly set.\n\t *\n\t * @private\n\t * @param {HalfEdge} edge - The twin edge to set.\n\t * @return {HalfEdge} A reference to this edge.\n\t */\n\tsetTwin( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * A vertex as a double linked list node.\n *\n * @private\n */\nclass VertexNode {\n\n\t/**\n\t * Constructs a new vertex node.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t */\n\tconstructor( point ) {\n\n\t\t/**\n\t\t * A point in 3D space.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.point = point;\n\n\t\t/**\n\t\t * Reference to the previous vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the face that is able to see this vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {?Face}\n\t\t * @default null\n\t\t */\n\t\tthis.face = null;\n\n\t}\n\n}\n\n/**\n * A doubly linked list of vertices.\n *\n * @private\n */\nclass VertexList {\n\n\t/**\n\t * Constructs a new vertex list.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Reference to the first vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.head = null;\n\n\t\t/**\n\t\t * Reference to the last vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.tail = null;\n\n\t}\n\n\t/**\n\t * Returns the head reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The head reference.\n\t */\n\tfirst() {\n\n\t\treturn this.head;\n\n\t}\n\n\t/**\n\t * Returns the tail reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The tail reference.\n\t */\n\tlast() {\n\n\t\treturn this.tail;\n\n\t}\n\n\t/**\n\t * Clears the linked list.\n\t *\n\t * @private\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tclear() {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex before a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertBefore( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex after a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertAfter( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a vertex to this vertex list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to append.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappend( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a chain of vertices where the given vertex is the head.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The head vertex of a chain of vertices.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappendChain( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremove( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a sublist of vertices from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The head of the sublist.\n\t * @param {VertexNode} b - The tail of the sublist.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremoveSubList( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the linked list is empty.\n\t *\n\t * @private\n\t * @return {boolean} Whether the linked list is empty or not.\n\t */\n\tisEmpty() {\n\n\t\treturn this.head === null;\n\n\t}\n\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList };\n"],"mappings":"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","ignoreList":[]}