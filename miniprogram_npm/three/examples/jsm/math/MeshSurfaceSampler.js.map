{"version":3,"file":"node_modules/three/examples/jsm/math/MeshSurfaceSampler.js","names":["Triangle","Vector2","Vector3","_face","_color","_uva","_uvb","_uvc","MeshSurfaceSampler","constructor","mesh","this","geometry","randomFunction","Math","random","indexAttribute","index","positionAttribute","getAttribute","normalAttribute","colorAttribute","uvAttribute","weightAttribute","distribution","setWeightAttribute","name","build","totalFaces","count","faceWeights","Float32Array","i","faceWeight","i0","i1","i2","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","targetUV","faceIndex","_sampleFaceIndex","_sampleFace","length","_binarySearch","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","undefined","normalize","getNormal","r","g","y","z"],"sources":["node_modules/three/examples/jsm/math/MeshSurfaceSampler.js"],"sourcesContent":["import {\n\tTriangle,\n\tVector2,\n\tVector3\n} from 'three';\n\nconst _face = new Triangle();\nconst _color = new Vector3();\nconst _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - {@link http://www.joesfer.com/?p=84}\n * - {@link https://stackoverflow.com/a/4322940/1314762}\n *\n * ```js\n * const sampler = new MeshSurfaceSampler( surfaceMesh )\n * \t.setWeightAttribute( 'color' )\n * \t.build();\n *\n * const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );\n *\n * const position = new THREE.Vector3();\n * const matrix = new THREE.Matrix4();\n *\n * // Sample randomly from the surface, creating an instance of the sample geometry at each sample point.\n *\n * for ( let i = 0; i < 100; i ++ ) {\n *\n * \tsampler.sample( position );\n * \tmatrix.makeTranslation( position.x, position.y, position.z );\n * \tmesh.setMatrixAt( i, matrix );\n *\n * }\n *\n * scene.add( mesh );\n * ```\n *\n * @three_import import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';\n */\nclass MeshSurfaceSampler {\n\n\t/**\n\t * Constructs a mesh surface sampler.\n\t *\n\t * @param {Mesh} mesh - Surface mesh from which to sample.\n\t */\n\tconstructor( mesh ) {\n\n\t\tthis.geometry = mesh.geometry;\n\t\tthis.randomFunction = Math.random;\n\n\t\tthis.indexAttribute = this.geometry.index;\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\n\t\tthis.normalAttribute = this.geometry.getAttribute( 'normal' );\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\n\t\tthis.uvAttribute = this.geometry.getAttribute( 'uv' );\n\t\tthis.weightAttribute = null;\n\n\t\tthis.distribution = null;\n\n\t}\n\n\t/**\n\t * Specifies a vertex attribute to be used as a weight when sampling from the surface.\n\t * Faces with higher weights are more likely to be sampled, and those with weights of\n\t * zero will not be sampled at all. For vector attributes, only .x is used in sampling.\n\t *\n\t * If no weight attribute is selected, sampling is randomly distributed by area.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsetWeightAttribute( name ) {\n\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Processes the input geometry and prepares to return samples. Any configuration of the\n\t * geometry or sampler must occur before this method is called. Time complexity is O(n)\n\t * for a surface with n faces.\n\t *\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tbuild() {\n\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tconst positionAttribute = this.positionAttribute;\n\t\tconst weightAttribute = this.weightAttribute;\n\n\t\tconst totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );\n\t\tconst faceWeights = new Float32Array( totalFaces );\n\n\t\t// Accumulate weights for each mesh face.\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tlet faceWeight = 1;\n\n\t\t\tlet i0 = 3 * i;\n\t\t\tlet i1 = 3 * i + 1;\n\t\t\tlet i2 = 3 * i + 2;\n\n\t\t\tif ( indexAttribute ) {\n\n\t\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\tif ( weightAttribute ) {\n\n\t\t\t\tfaceWeight = weightAttribute.getX( i0 )\n\t\t\t\t\t+ weightAttribute.getX( i1 )\n\t\t\t\t\t+ weightAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i2 );\n\t\t\tfaceWeight *= _face.getArea();\n\n\t\t\tfaceWeights[ i ] = faceWeight;\n\n\t\t}\n\n\t\t// Store cumulative total face weights in an array, where weight index\n\t\t// corresponds to face index.\n\n\t\tconst distribution = new Float32Array( totalFaces );\n\t\tlet cumulativeTotal = 0;\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tcumulativeTotal += faceWeights[ i ];\n\t\t\tdistribution[ i ] = cumulativeTotal;\n\n\t\t}\n\n\t\tthis.distribution = distribution;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Allows to set a custom random number generator. Default is `Math.random()`.\n\t *\n\t * @param {Function} randomFunction - A random number generator.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsetRandomGenerator( randomFunction ) {\n\n\t\tthis.randomFunction = randomFunction;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Selects a random point on the surface of the input geometry, returning the\n\t * position and optionally the normal vector, color and UV Coordinate at that point.\n\t * Time complexity is O(log n) for a surface with n faces.\n\t *\n\t * @param {Vector3} targetPosition - The target object holding the sampled position.\n\t * @param {Vector3} targetNormal - The target object holding the sampled normal.\n\t * @param {Color} targetColor - The target object holding the sampled color.\n\t * @param {Vector2} targetUV -  The target object holding the sampled uv coordinates.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsample( targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tconst faceIndex = this._sampleFaceIndex();\n\t\treturn this._sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );\n\n\t}\n\n\t// private\n\n\t_sampleFaceIndex() {\n\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\n\t\treturn this._binarySearch( this.randomFunction() * cumulativeTotal );\n\n\t}\n\n\t_binarySearch( x ) {\n\n\t\tconst dist = this.distribution;\n\t\tlet start = 0;\n\t\tlet end = dist.length - 1;\n\n\t\tlet index = - 1;\n\n\t\twhile ( start <= end ) {\n\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\n\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\n\n\t\t\t\tindex = mid;\n\n\t\t\t\tbreak;\n\n\t\t\t} else if ( x < dist[ mid ] ) {\n\n\t\t\t\tend = mid - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstart = mid + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\t_sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tlet u = this.randomFunction();\n\t\tlet v = this.randomFunction();\n\n\t\tif ( u + v > 1 ) {\n\n\t\t\tu = 1 - u;\n\t\t\tv = 1 - v;\n\n\t\t}\n\n\t\t// get the vertex attribute indices\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tlet i0 = faceIndex * 3;\n\t\tlet i1 = faceIndex * 3 + 1;\n\t\tlet i2 = faceIndex * 3 + 2;\n\t\tif ( indexAttribute ) {\n\n\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t}\n\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, i0 );\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, i1 );\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, i2 );\n\n\t\ttargetPosition\n\t\t\t.set( 0, 0, 0 )\n\t\t\t.addScaledVector( _face.a, u )\n\t\t\t.addScaledVector( _face.b, v )\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\tif ( targetNormal !== undefined ) {\n\n\t\t\tif ( this.normalAttribute !== undefined ) {\n\n\t\t\t\t_face.a.fromBufferAttribute( this.normalAttribute, i0 );\n\t\t\t\t_face.b.fromBufferAttribute( this.normalAttribute, i1 );\n\t\t\t\t_face.c.fromBufferAttribute( this.normalAttribute, i2 );\n\t\t\t\ttargetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\t_face.getNormal( targetNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\n\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, i2 );\n\n\t\t\t_color\n\t\t\t\t.set( 0, 0, 0 )\n\t\t\t\t.addScaledVector( _face.a, u )\n\t\t\t\t.addScaledVector( _face.b, v )\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\t\ttargetColor.r = _color.x;\n\t\t\ttargetColor.g = _color.y;\n\t\t\ttargetColor.b = _color.z;\n\n\t\t}\n\n\t\tif ( targetUV !== undefined && this.uvAttribute !== undefined ) {\n\n\t\t\t_uva.fromBufferAttribute( this.uvAttribute, i0 );\n\t\t\t_uvb.fromBufferAttribute( this.uvAttribute, i1 );\n\t\t\t_uvc.fromBufferAttribute( this.uvAttribute, i2 );\n\t\t\ttargetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshSurfaceSampler };\n"],"mappings":"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","ignoreList":[]}