{"version":3,"file":"node_modules/three/examples/jsm/math/OBB.js","names":["Box3","MathUtils","Matrix4","Matrix3","Ray","Vector3","a","c","u","e","b","R","AbsR","t","xAxis","yAxis","zAxis","v1","size","closestPoint","rotationMatrix","aabb","matrix","inverse","localRay","OBB","constructor","center","halfSize","rotation","this","set","copy","obb","clone","getSize","target","multiplyScalar","clampPoint","point","subVectors","extractBasis","x","clamp","dot","add","y","z","containsPoint","Math","abs","intersectsBox3","box3","intersectsOBB","fromBox3","intersectsSphere","sphere","distanceToSquared","radius","epsilon","Number","EPSILON","i","j","ra","rb","intersectsPlane","plane","r","normal","d","constant","intersectRay","ray","setFromCenterAndSize","setFromMatrix3","setPosition","invert","applyMatrix4","intersectBox","intersectsRay","getCenter","identity","equals","elements","sx","length","sy","sz","determinant","setFromMatrix4","invSX","invSY","invSZ","multiply","setFromMatrixPosition"],"sources":["node_modules/three/examples/jsm/math/OBB.js"],"sourcesContent":["import {\n\tBox3,\n\tMathUtils,\n\tMatrix4,\n\tMatrix3,\n\tRay,\n\tVector3\n} from 'three';\n\n// module scope helper variables\n\nconst a = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst b = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\n\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\n\n/**\n * Represents an oriented bounding box (OBB) in 3D space.\n *\n * @three_import import { OBB } from 'three/addons/math/OBB.js';\n */\nclass OBB {\n\n\t/**\n\t * Constructs a new OBB.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t */\n\tconstructor( center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3() ) {\n\n\t\t/**\n\t\t * The center of the OBB.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.center = center;\n\n\t\t/**\n\t\t * Positive halfwidth extents of the OBB along each axis.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.halfSize = halfSize;\n\n\t\t/**\n\t\t * The rotation of the OBB.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.rotation = rotation;\n\n\t}\n\n\t/**\n\t * Sets the OBBs components to the given values.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tset( center, halfSize, rotation ) {\n\n\t\tthis.center = center;\n\t\tthis.halfSize = halfSize;\n\t\tthis.rotation = rotation;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given OBB to this instance.\n\t *\n\t * @param {OBB} obb - The OBB to copy.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tcopy( obb ) {\n\n\t\tthis.center.copy( obb.center );\n\t\tthis.halfSize.copy( obb.halfSize );\n\t\tthis.rotation.copy( obb.rotation );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new OBB with copied values from this instance.\n\t *\n\t * @return {OBB} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Returns the size of this OBB.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.copy( this.halfSize ).multiplyScalar( 2 );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB.\n\t *\n\t * @param {Vector3} point - The point that should be clamped within the bounds of this OBB.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @returns {Vector3} - The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\t// Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.1.4)\n\n\t\tconst halfSize = this.halfSize;\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// start at the center position of the OBB\n\n\t\ttarget.copy( this.center );\n\n\t\t// project the target onto the OBB axes and walk towards that point\n\n\t\tconst x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );\n\t\ttarget.add( xAxis.multiplyScalar( x ) );\n\n\t\tconst y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );\n\t\ttarget.add( yAxis.multiplyScalar( y ) );\n\n\t\tconst z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );\n\t\ttarget.add( zAxis.multiplyScalar( z ) );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within this OBB.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @returns {boolean} - Whether the given point lies within this OBB or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// project v1 onto each axis and check if these points lie inside the OBB\n\n\t\treturn Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&\n\t\t\t\tMath.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&\n\t\t\t\tMath.abs( v1.dot( zAxis ) ) <= this.halfSize.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given AABB intersects this OBB.\n\t *\n\t * @param {Box3} box3 - The AABB to test.\n\t * @returns {boolean} - Whether the given AABB intersects this OBB or not.\n\t */\n\tintersectsBox3( box3 ) {\n\n\t\treturn this.intersectsOBB( obb.fromBox3( box3 ) );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects this OBB.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @returns {boolean} - Whether the given bounding sphere intersects this OBB or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\t// find the point on the OBB closest to the sphere center\n\n\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t// if that point is inside the sphere, the OBB and sphere intersect\n\n\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB intersects this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @param {number} [epsilon=Number.EPSILON] - A small value to prevent arithmetic errors.\n\t * @returns {boolean} - Whether the given OBB intersects this OBB or not.\n\t */\n\tintersectsOBB( obb, epsilon = Number.EPSILON ) {\n\n\t\t// Reference: OBB-OBB Intersection in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 4.4.1)\n\n\t\t// prepare data structures (the code uses the same nomenclature like the reference)\n\n\t\ta.c = this.center;\n\t\ta.e[ 0 ] = this.halfSize.x;\n\t\ta.e[ 1 ] = this.halfSize.y;\n\t\ta.e[ 2 ] = this.halfSize.z;\n\t\tthis.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );\n\n\t\tb.c = obb.center;\n\t\tb.e[ 0 ] = obb.halfSize.x;\n\t\tb.e[ 1 ] = obb.halfSize.y;\n\t\tb.e[ 2 ] = obb.halfSize.z;\n\t\tobb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );\n\n\t\t// compute rotation matrix expressing b in a's coordinate frame\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tR[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute translation vector\n\n\t\tv1.subVectors( b.c, a.c );\n\n\t\t// bring translation into a's coordinate frame\n\n\t\tt[ 0 ] = v1.dot( a.u[ 0 ] );\n\t\tt[ 1 ] = v1.dot( a.u[ 1 ] );\n\t\tt[ 2 ] = v1.dot( a.u[ 2 ] );\n\n\t\t// compute common subexpressions. Add in an epsilon term to\n\t\t// counteract arithmetic errors when two edges are parallel and\n\t\t// their cross product is (near) null\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tAbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet ra, rb;\n\n\t\t// test axes L = A0, L = A1, L = A2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ i ];\n\t\t\trb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];\n\t\t\tif ( Math.abs( t[ i ] ) > ra + rb ) return false;\n\n\n\t\t}\n\n\t\t// test axes L = B0, L = B1, L = B2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];\n\t\t\trb = b.e[ i ];\n\t\t\tif ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;\n\n\t\t}\n\n\t\t// test axis L = A0 x B0\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B1\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B2\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// since no separating axis is found, the OBBs must be intersecting\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given plane intersects this OBB.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @returns {boolean} Whether the given plane intersects this OBB or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// Reference: Testing Box Against Plane in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.2.3)\n\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n\t\tconst r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +\n\t\t\t\tthis.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +\n\t\t\t\tthis.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );\n\n\t\t// compute distance of the OBB's center from the plane\n\n\t\tconst d = plane.normal.dot( this.center ) - plane.constant;\n\n\t\t// Intersection occurs when distance d falls within [-r,+r] interval\n\n\t\treturn Math.abs( d ) <= r;\n\n\t}\n\n\t/**\n\t * Performs a ray/OBB intersection test and stores the intersection point\n\t * in the given 3D vector.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point. If no intersection is detected, `null` is returned.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// the idea is to perform the intersection test in the local space\n\t\t// of the OBB.\n\n\t\tthis.getSize( size );\n\t\taabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );\n\n\t\t// create a 4x4 transformation matrix\n\n\t\tmatrix.setFromMatrix3( this.rotation );\n\t\tmatrix.setPosition( this.center );\n\n\t\t// transform ray to the local space of the OBB\n\n\t\tinverse.copy( matrix ).invert();\n\t\tlocalRay.copy( ray ).applyMatrix4( inverse );\n\n\t\t// perform ray <-> AABB intersection test\n\n\t\tif ( localRay.intersectBox( aabb, target ) ) {\n\n\t\t\t// transform the intersection point back to world space\n\n\t\t\treturn target.applyMatrix4( matrix );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects this OBB.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @returns {boolean} Whether the given ray intersects this OBB or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Defines an OBB based on the given AABB.\n\t *\n\t * @param {Box3} box3 - The AABB to setup the OBB from.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tfromBox3( box3 ) {\n\n\t\tbox3.getCenter( this.center );\n\n\t\tbox3.getSize( this.halfSize ).multiplyScalar( 0.5 );\n\n\t\tthis.rotation.identity();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB is equal to this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @returns {boolean} Whether the given OBB is equal to this OBB or not.\n\t */\n\tequals( obb ) {\n\n\t\treturn obb.center.equals( this.center ) &&\n\t\t\tobb.halfSize.equals( this.halfSize ) &&\n\t\t\tobb.rotation.equals( this.rotation );\n\n\t}\n\n\t/**\n\t * Applies the given transformation matrix to this OBB. This method can be\n\t * used to transform the bounding volume with the world matrix of a 3D object\n\t * in order to keep both entities in sync.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst e = matrix.elements;\n\n\t\tlet sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();\n\t\tconst sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();\n\t\tconst sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();\n\n\t\tconst det = matrix.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\trotationMatrix.setFromMatrix4( matrix );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\trotationMatrix.elements[ 0 ] *= invSX;\n\t\trotationMatrix.elements[ 1 ] *= invSX;\n\t\trotationMatrix.elements[ 2 ] *= invSX;\n\n\t\trotationMatrix.elements[ 3 ] *= invSY;\n\t\trotationMatrix.elements[ 4 ] *= invSY;\n\t\trotationMatrix.elements[ 5 ] *= invSY;\n\n\t\trotationMatrix.elements[ 6 ] *= invSZ;\n\t\trotationMatrix.elements[ 7 ] *= invSZ;\n\t\trotationMatrix.elements[ 8 ] *= invSZ;\n\n\t\tthis.rotation.multiply( rotationMatrix );\n\n\t\tthis.halfSize.x *= sx;\n\t\tthis.halfSize.y *= sy;\n\t\tthis.halfSize.z *= sz;\n\n\t\tv1.setFromMatrixPosition( matrix );\n\t\tthis.center.add( v1 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst obb = new OBB();\n\nexport { OBB };\n"],"mappings":"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","ignoreList":[]}