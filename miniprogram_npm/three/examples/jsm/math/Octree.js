import{Box3,Line3,Plane,Sphere,Triangle,Vector3,Layers}from"three";import{Capsule}from"../math/Capsule.js";const _v1=new Vector3,_v2=new Vector3,_point1=new Vector3,_point2=new Vector3,_plane=new Plane,_line1=new Line3,_line2=new Line3,_sphere=new Sphere,_capsule=new Capsule,_temp1=new Vector3,_temp2=new Vector3,_temp3=new Vector3,EPS=1e-10;function lineToLineClosestPoints(e,t,n=null,s=null){const r=_temp1.copy(e.end).sub(e.start),i=_temp2.copy(t.end).sub(t.start),a=_temp3.copy(t.start).sub(e.start),l=r.dot(i),o=r.dot(r),h=i.dot(i),c=i.dot(a),p=r.dot(a);let u,d;const g=o*h-l*l;if(Math.abs(g)<EPS){const e=-c/h,t=(l-c)/h;Math.abs(e-.5)<Math.abs(t-.5)?(u=0,d=e):(u=1,d=t)}else u=(c*l+p*h)/g,d=(u*l-c)/h;d=Math.max(0,Math.min(1,d)),u=Math.max(0,Math.min(1,u)),n&&n.copy(r).multiplyScalar(u).add(e.start),s&&s.copy(i).multiplyScalar(d).add(t.start)}class Octree{constructor(e){this.box=e,this.bounds=new Box3,this.layers=new Layers,this.trianglesPerLeaf=8,this.maxLevel=16,this.subTrees=[],this.triangles=[]}addTriangle(e){return this.bounds.min.x=Math.min(this.bounds.min.x,e.a.x,e.b.x,e.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,e.a.y,e.b.y,e.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,e.a.z,e.b.z,e.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,e.a.x,e.b.x,e.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,e.a.y,e.b.y,e.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,e.a.z,e.b.z,e.c.z),this.triangles.push(e),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(e){if(!this.box)return;const t=[],n=_v2.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let e=0;e<2;e++)for(let s=0;s<2;s++)for(let r=0;r<2;r++){const i=new Box3,a=_v1.set(e,s,r);i.min.copy(this.box.min).add(a.multiply(n)),i.max.copy(i.min).add(n),t.push(new Octree(i))}let s;for(;s=this.triangles.pop();)for(let e=0;e<t.length;e++)t[e].box.intersectsTriangle(s)&&t[e].triangles.push(s);for(let n=0;n<t.length;n++){const s=t[n].triangles.length;s>this.trianglesPerLeaf&&e<this.maxLevel&&t[n].split(e+1),0!==s&&this.subTrees.push(t[n])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getRayTriangles(e,t)}}triangleCapsuleIntersect(e,t){t.getPlane(_plane);const n=_plane.distanceToPoint(e.start)-e.radius,s=_plane.distanceToPoint(e.end)-e.radius;if(n>0&&s>0||n<-e.radius&&s<-e.radius)return!1;const r=Math.abs(n/(Math.abs(n)+Math.abs(s))),i=_v1.copy(e.start).lerp(e.end,r);if(t.containsPoint(i))return{normal:_plane.normal.clone(),point:i.clone(),depth:Math.abs(Math.min(n,s))};const a=e.radius*e.radius,l=_line1.set(e.start,e.end),o=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<o.length;t++){if(lineToLineClosestPoints(l,_line2.set(o[t][0],o[t][1]),_point1,_point2),_point1.distanceToSquared(_point2)<a)return{normal:_point1.clone().sub(_point2).normalize(),point:_point2.clone(),depth:e.radius-_point1.distanceTo(_point2)}}return!1}triangleSphereIntersect(e,t){if(t.getPlane(_plane),!e.intersectsPlane(_plane))return!1;const n=Math.abs(_plane.distanceToSphere(e)),s=e.radius*e.radius-n*n,r=_plane.projectPoint(e.center,_v1);if(t.containsPoint(e.center))return{normal:_plane.normal.clone(),point:r.clone(),depth:Math.abs(_plane.distanceToSphere(e))};const i=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<i.length;t++){_line1.set(i[t][0],i[t][1]),_line1.closestPointToPoint(r,!0,_v2);const n=_v2.distanceToSquared(e.center);if(n<s)return{normal:e.center.clone().sub(_v2).normalize(),point:_v2.clone(),depth:e.radius-Math.sqrt(n)}}return!1}getSphereTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getSphereTriangles(e,t)}}getCapsuleTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getCapsuleTriangles(e,t)}}sphereIntersect(e){_sphere.copy(e);const t=[];let n,s=!1;this.getSphereTriangles(e,t);for(let e=0;e<t.length;e++)(n=this.triangleSphereIntersect(_sphere,t[e]))&&(s=!0,_sphere.center.add(n.normal.multiplyScalar(n.depth)));if(s){const t=_sphere.center.clone().sub(e.center),n=t.length();return{normal:t.normalize(),depth:n}}return!1}capsuleIntersect(e){_capsule.copy(e);const t=[];let n,s=!1;this.getCapsuleTriangles(_capsule,t);for(let e=0;e<t.length;e++)(n=this.triangleCapsuleIntersect(_capsule,t[e]))&&(s=!0,_capsule.translate(n.normal.multiplyScalar(n.depth)));if(s){const t=_capsule.getCenter(new Vector3).sub(e.getCenter(_v1)),n=t.length();return{normal:t.normalize(),depth:n}}return!1}rayIntersect(e){const t=[];let n,s,r=1e100;this.getRayTriangles(e,t);for(let i=0;i<t.length;i++){const a=e.intersectTriangle(t[i].a,t[i].b,t[i].c,!0,_v1);if(a){const l=a.sub(e.origin).length();r>l&&(s=a.clone().add(e.origin),r=l,n=t[i])}}return r<1e100&&{distance:r,triangle:n,position:s}}fromGraphNode(e){return e.updateWorldMatrix(!0,!0),e.traverse((e=>{if(!0===e.isMesh&&this.layers.test(e.layers)){let t,n=!1;null!==e.geometry.index?(n=!0,t=e.geometry.toNonIndexed()):t=e.geometry;const s=t.getAttribute("position");for(let t=0;t<s.count;t+=3){const n=(new Vector3).fromBufferAttribute(s,t),r=(new Vector3).fromBufferAttribute(s,t+1),i=(new Vector3).fromBufferAttribute(s,t+2);n.applyMatrix4(e.matrixWorld),r.applyMatrix4(e.matrixWorld),i.applyMatrix4(e.matrixWorld),this.addTriangle(new Triangle(n,r,i))}n&&t.dispose()}})),this.build(),this}clear(){return this.box=null,this.bounds.makeEmpty(),this.subTrees.length=0,this.triangles.length=0,this}}export{Octree};
//# sourceMappingURL=Octree.js.map