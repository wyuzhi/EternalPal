{"version":3,"file":"node_modules/three/examples/jsm/math/Octree.js","names":["Box3","Line3","Plane","Sphere","Triangle","Vector3","Layers","Capsule","_v1","_v2","_point1","_point2","_plane","_line1","_line2","_sphere","_capsule","_temp1","_temp2","_temp3","EPS","lineToLineClosestPoints","line1","line2","target1","target2","r","copy","end","sub","start","s","w","a","dot","b","c","d","e","t1","t2","divisor","Math","abs","d1","d2","max","min","multiplyScalar","add","Octree","constructor","box","this","bounds","layers","trianglesPerLeaf","maxLevel","subTrees","triangles","addTriangle","triangle","x","y","z","push","calcBox","clone","split","level","halfsize","v","set","multiply","pop","i","length","intersectsTriangle","len","build","getRayTriangles","ray","subTree","intersectsBox","j","indexOf","triangleCapsuleIntersect","capsule","getPlane","distanceToPoint","radius","delta","intersectPoint","lerp","containsPoint","normal","point","depth","r2","lines","distanceToSquared","normalize","distanceTo","triangleSphereIntersect","sphere","intersectsPlane","distanceToSphere","plainPoint","projectPoint","center","closestPointToPoint","sqrt","getSphereTriangles","getCapsuleTriangles","sphereIntersect","result","hit","collisionVector","capsuleIntersect","translate","getCenter","rayIntersect","position","distance","intersectTriangle","newdistance","origin","fromGraphNode","group","updateWorldMatrix","traverse","obj","isMesh","test","geometry","isTemp","index","toNonIndexed","positionAttribute","getAttribute","count","v1","fromBufferAttribute","v2","v3","applyMatrix4","matrixWorld","dispose","clear","makeEmpty"],"sources":["node_modules/three/examples/jsm/math/Octree.js"],"sourcesContent":["import {\n\tBox3,\n\tLine3,\n\tPlane,\n\tSphere,\n\tTriangle,\n\tVector3,\n\tLayers\n} from 'three';\nimport { Capsule } from '../math/Capsule.js';\n\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _point1 = new Vector3();\nconst _point2 = new Vector3();\nconst _plane = new Plane();\nconst _line1 = new Line3();\nconst _line2 = new Line3();\nconst _sphere = new Sphere();\nconst _capsule = new Capsule();\n\nconst _temp1 = new Vector3();\nconst _temp2 = new Vector3();\nconst _temp3 = new Vector3();\nconst EPS = 1e-10;\n\nfunction lineToLineClosestPoints( line1, line2, target1 = null, target2 = null ) {\n\n\tconst r = _temp1.copy( line1.end ).sub( line1.start );\n\tconst s = _temp2.copy( line2.end ).sub( line2.start );\n\tconst w = _temp3.copy( line2.start ).sub( line1.start );\n\n\tconst a = r.dot( s ),\n\t\tb = r.dot( r ),\n\t\tc = s.dot( s ),\n\t\td = s.dot( w ),\n\t\te = r.dot( w );\n\n\tlet t1, t2;\n\tconst divisor = b * c - a * a;\n\n\tif ( Math.abs( divisor ) < EPS ) {\n\n\t\tconst d1 = - d / c;\n\t\tconst d2 = ( a - d ) / c;\n\n\t\tif ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {\n\n\t\t\tt1 = 0;\n\t\t\tt2 = d1;\n\n\t\t} else {\n\n\t\t\tt1 = 1;\n\t\t\tt2 = d2;\n\n\t\t}\n\n\t} else {\n\n\t\tt1 = ( d * a + e * c ) / divisor;\n\t\tt2 = ( t1 * a - d ) / c;\n\n\t}\n\n\tt2 = Math.max( 0, Math.min( 1, t2 ) );\n\tt1 = Math.max( 0, Math.min( 1, t1 ) );\n\n\tif ( target1 ) {\n\n\t\ttarget1.copy( r ).multiplyScalar( t1 ).add( line1.start );\n\n\t}\n\n\tif ( target2 ) {\n\n\t\ttarget2.copy( s ).multiplyScalar( t2 ).add( line2.start );\n\n\t}\n\n}\n\n/**\n * An octree is a hierarchical tree data structure used to partition a three-dimensional\n * space by recursively subdividing it into eight octants.\n *\n * This particular implementation can have up to sixteen levels and stores up to eight triangles\n * in leaf nodes.\n *\n * `Octree` can be used in games to compute collision between the game world and colliders from\n * the player or other dynamic 3D objects.\n *\n *\n * ```js\n * const octree = new Octree().fromGraphNode( scene );\n * const result = octree.capsuleIntersect( playerCollider ); // collision detection\n * ```\n *\n * @three_import import { Octree } from 'three/addons/math/Octree.js';\n */\nclass Octree {\n\n\t/**\n\t * Constructs a new Octree.\n\t *\n\t * @param {Box3} [box] - The base box with enclose the entire Octree.\n\t */\n\tconstructor( box ) {\n\n\t\t/**\n\t\t * The base box with enclose the entire Octree.\n\t\t *\n\t\t * @type {Box3}\n\t\t */\n\t\tthis.box = box;\n\n\t\t/**\n\t\t * The bounds of the Octree. Compared to {@link Octree#box}, no\n\t\t * margin is applied.\n\t\t *\n\t\t * @type {Box3}\n\t\t */\n\t\tthis.bounds = new Box3();\n\n\t\t/**\n\t\t * Can by used for layers configuration for refine testing.\n\t\t *\n\t\t * @type {Layers}\n\t\t */\n\t\tthis.layers = new Layers();\n\n\t\t/**\n\t\t * The number of triangles a leaf can store before it is split.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 8\n\t\t */\n\t\tthis.trianglesPerLeaf = 8;\n\n\t\t/**\n\t\t * The maximum level of the Octree. It defines the maximum\n\t\t * hierarchical depth of the data structure.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 16\n\t\t */\n\t\tthis.maxLevel = 16;\n\n\t\t// private\n\n\t\tthis.subTrees = [];\n\t\tthis.triangles = [];\n\n\t}\n\n\t/**\n\t * Adds the given triangle to the Octree. The triangle vertices are clamped if they exceed\n\t * the bounds of the Octree.\n\t *\n\t * @param {Triangle} triangle - The triangle to add.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\taddTriangle( triangle ) {\n\n\t\tthis.bounds.min.x = Math.min( this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.min.y = Math.min( this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.min.z = Math.min( this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\t\tthis.bounds.max.x = Math.max( this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.max.y = Math.max( this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.max.z = Math.max( this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\n\t\tthis.triangles.push( triangle );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Prepares {@link Octree#box} for the build.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tcalcBox() {\n\n\t\tthis.box = this.bounds.clone();\n\n\t\t// offset small amount to account for regular grid\n\t\tthis.box.min.x -= 0.01;\n\t\tthis.box.min.y -= 0.01;\n\t\tthis.box.min.z -= 0.01;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Splits the Octree. This method is used recursively when\n\t * building the Octree.\n\t *\n\t * @param {number} level - The current level.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tsplit( level ) {\n\n\t\tif ( ! this.box ) return;\n\n\t\tconst subTrees = [];\n\t\tconst halfsize = _v2.copy( this.box.max ).sub( this.box.min ).multiplyScalar( 0.5 );\n\n\t\tfor ( let x = 0; x < 2; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < 2; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < 2; z ++ ) {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tconst v = _v1.set( x, y, z );\n\n\t\t\t\t\tbox.min.copy( this.box.min ).add( v.multiply( halfsize ) );\n\t\t\t\t\tbox.max.copy( box.min ).add( halfsize );\n\n\t\t\t\t\tsubTrees.push( new Octree( box ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet triangle;\n\n\t\twhile ( triangle = this.triangles.pop() ) {\n\n\t\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\t\tif ( subTrees[ i ].box.intersectsTriangle( triangle ) ) {\n\n\t\t\t\t\tsubTrees[ i ].triangles.push( triangle );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\tconst len = subTrees[ i ].triangles.length;\n\n\t\t\tif ( len > this.trianglesPerLeaf && level < this.maxLevel ) {\n\n\t\t\t\tsubTrees[ i ].split( level + 1 );\n\n\t\t\t}\n\n\t\t\tif ( len !== 0 ) {\n\n\t\t\t\tthis.subTrees.push( subTrees[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Builds the Octree.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tbuild() {\n\n\t\tthis.calcBox();\n\t\tthis.split( 0 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given ray.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetRayTriangles( ray, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\t\t\tif ( ! ray.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getRayTriangles( ray, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the intersection between the given capsule and triangle.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {Object|false} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\ttriangleCapsuleIntersect( capsule, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tconst d1 = _plane.distanceToPoint( capsule.start ) - capsule.radius;\n\t\tconst d2 = _plane.distanceToPoint( capsule.end ) - capsule.radius;\n\n\t\tif ( ( d1 > 0 && d2 > 0 ) || ( d1 < - capsule.radius && d2 < - capsule.radius ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst delta = Math.abs( d1 / ( Math.abs( d1 ) + Math.abs( d2 ) ) );\n\t\tconst intersectPoint = _v1.copy( capsule.start ).lerp( capsule.end, delta );\n\n\t\tif ( triangle.containsPoint( intersectPoint ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs( Math.min( d1, d2 ) ) };\n\n\t\t}\n\n\t\tconst r2 = capsule.radius * capsule.radius;\n\n\t\tconst line1 = _line1.set( capsule.start, capsule.end );\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tconst line2 = _line2.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\n\t\t\tlineToLineClosestPoints( line1, line2, _point1, _point2 );\n\n\t\t\tif ( _point1.distanceToSquared( _point2 ) < r2 ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tnormal: _point1.clone().sub( _point2 ).normalize(),\n\t\t\t\t\tpoint: _point2.clone(),\n\t\t\t\t\tdepth: capsule.radius - _point1.distanceTo( _point2 )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Computes the intersection between the given sphere and triangle.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {Object|false} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\ttriangleSphereIntersect( sphere, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tif ( ! sphere.intersectsPlane( _plane ) ) return false;\n\n\t\tconst depth = Math.abs( _plane.distanceToSphere( sphere ) );\n\t\tconst r2 = sphere.radius * sphere.radius - depth * depth;\n\n\t\tconst plainPoint = _plane.projectPoint( sphere.center, _v1 );\n\n\t\tif ( triangle.containsPoint( sphere.center ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: plainPoint.clone(), depth: Math.abs( _plane.distanceToSphere( sphere ) ) };\n\n\t\t}\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t_line1.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\t\t\t_line1.closestPointToPoint( plainPoint, true, _v2 );\n\n\t\t\tconst d = _v2.distanceToSquared( sphere.center );\n\n\t\t\tif ( d < r2 ) {\n\n\t\t\t\treturn { normal: sphere.center.clone().sub( _v2 ).normalize(), point: _v2.clone(), depth: sphere.radius - Math.sqrt( d ) };\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given bounding sphere.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetSphereTriangles( sphere, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! sphere.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getSphereTriangles( sphere, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given capsule.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetCapsuleTriangles( capsule, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! capsule.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getCapsuleTriangles( capsule, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a bounding sphere intersection test with this Octree.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {Object|boolean} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\tsphereIntersect( sphere ) {\n\n\t\t_sphere.copy( sphere );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getSphereTriangles( sphere, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleSphereIntersect( _sphere, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_sphere.center.add( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _sphere.center.clone().sub( sphere.center );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Performs a capsule intersection test with this Octree.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @return {Object|boolean} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\tcapsuleIntersect( capsule ) {\n\n\t\t_capsule.copy( capsule );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getCapsuleTriangles( _capsule, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleCapsuleIntersect( _capsule, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_capsule.translate( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _capsule.getCenter( new Vector3() ).sub( capsule.getCenter( _v1 ) );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Performs a ray intersection test with this Octree.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @return {Object|boolean} The nearest intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\trayIntersect( ray ) {\n\n\t\tconst triangles = [];\n\t\tlet triangle, position, distance = 1e100;\n\n\t\tthis.getRayTriangles( ray, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tconst result = ray.intersectTriangle( triangles[ i ].a, triangles[ i ].b, triangles[ i ].c, true, _v1 );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tconst newdistance = result.sub( ray.origin ).length();\n\n\t\t\t\tif ( distance > newdistance ) {\n\n\t\t\t\t\tposition = result.clone().add( ray.origin );\n\t\t\t\t\tdistance = newdistance;\n\t\t\t\t\ttriangle = triangles[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false;\n\n\t}\n\n\t/**\n\t * Constructs the Octree from the given 3D object.\n\t *\n\t * @param {Object3D} group - The scene graph node.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tfromGraphNode( group ) {\n\n\t\tgroup.updateWorldMatrix( true, true );\n\n\t\tgroup.traverse( ( obj ) => {\n\n\t\t\tif ( obj.isMesh === true ) {\n\n\t\t\t\tif ( this.layers.test( obj.layers ) ) {\n\n\t\t\t\t\tlet geometry, isTemp = false;\n\n\t\t\t\t\tif ( obj.geometry.index !== null ) {\n\n\t\t\t\t\t\tisTemp = true;\n\t\t\t\t\t\tgeometry = obj.geometry.toNonIndexed();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgeometry = obj.geometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\t\t\tconst v1 = new Vector3().fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\tconst v2 = new Vector3().fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\t\tconst v3 = new Vector3().fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\t\tv1.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\t\tv2.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\t\tv3.applyMatrix4( obj.matrixWorld );\n\n\t\t\t\t\t\tthis.addTriangle( new Triangle( v1, v2, v3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isTemp ) {\n\n\t\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.build();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the Octree by making it empty.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tclear() {\n\n\t\tthis.box = null;\n\t\tthis.bounds.makeEmpty();\n\n\t\tthis.subTrees.length = 0;\n\t\tthis.triangles.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Octree };\n"],"mappings":"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","ignoreList":[]}