{"version":3,"file":"node_modules/three/examples/jsm/misc/ConvexObjectBreaker.js","names":["Line3","Mesh","Plane","Vector3","ConvexGeometry","_v1","ConvexObjectBreaker","constructor","minSizeForBreak","smallDelta","this","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","i","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","geometry","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","console","error","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint"],"sources":["node_modules/three/examples/jsm/misc/ConvexObjectBreaker.js"],"sourcesContent":["import {\n\tLine3,\n\tMesh,\n\tPlane,\n\tVector3\n} from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\nconst _v1 = new Vector3();\n\n/**\n * This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane).\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n * - Mesh object must have a buffer geometry and a material.\n * - Vertex normals must be planar (not smoothed).\n * - The geometry must be convex (this is not checked in the library). You can create convex\n * geometries with {@link ConvexGeometry}. The {@link BoxGeometry}, {@link SphereGeometry} and other\n * convex primitives can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @three_import import { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';\n */\nclass ConvexObjectBreaker {\n\n\t/**\n\t * Constructs a new convex object breaker.\n\t *\n\t * @param {number} [minSizeForBreak=1.4] - Min size a debris can have to break.\n \t * @param {number} [smallDelta=0.0001] - Max distance to consider that a point belongs to a plane.\n\t */\n\tconstructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {\n\n\t\tthis.minSizeForBreak = minSizeForBreak;\n\t\tthis.smallDelta = smallDelta;\n\n\t\tthis.tempLine1 = new Line3();\n\t\tthis.tempPlane1 = new Plane();\n\t\tthis.tempPlane2 = new Plane();\n\t\tthis.tempPlane_Cut = new Plane();\n\t\tthis.tempCM1 = new Vector3();\n\t\tthis.tempCM2 = new Vector3();\n\t\tthis.tempVector3 = new Vector3();\n\t\tthis.tempVector3_2 = new Vector3();\n\t\tthis.tempVector3_3 = new Vector3();\n\t\tthis.tempVector3_P0 = new Vector3();\n\t\tthis.tempVector3_P1 = new Vector3();\n\t\tthis.tempVector3_P2 = new Vector3();\n\t\tthis.tempVector3_N0 = new Vector3();\n\t\tthis.tempVector3_N1 = new Vector3();\n\t\tthis.tempVector3_AB = new Vector3();\n\t\tthis.tempVector3_CB = new Vector3();\n\t\tthis.tempResultObjects = { object1: null, object2: null };\n\n\t\tthis.segments = [];\n\t\tconst n = 30 * 30;\n\t\tfor ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;\n\n\t}\n\n\t/**\n\t * Must be called for all 3D objects that should be breakable.\n\t *\n\t * @param {Object3D} object - The 3D object. It must have a convex geometry.\n\t * @param {number} mass - The 3D object's mass in kg. Must be greater than `0`.\n\t * @param {Vector3} velocity - The 3D object's velocity.\n\t * @param {Vector3} angularVelocity - The 3D object's angular velocity.\n\t * @param {boolean} breakable - Whether the 3D object is breakable or not.\n\t */\n\tprepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {\n\n\t\t// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n\t\t// Its material property is propagated to its children (sub-pieces)\n\t\t// mass must be > 0\n\n\t\tconst userData = object.userData;\n\t\tuserData.mass = mass;\n\t\tuserData.velocity = velocity.clone();\n\t\tuserData.angularVelocity = angularVelocity.clone();\n\t\tuserData.breakable = breakable;\n\n\t}\n\n\t/**\n\t * Subdivides the given 3D object into pieces by an impact (meaning another object hits\n\t * the given 3D object at a certain surface point).\n\t *\n\t * @param {Object3D} object - The 3D object to subdivide.\n\t * @param {Vector3} pointOfImpact - The point of impact.\n\t * @param {Vector3} normal - The impact normal.\n\t * @param {number} maxRadialIterations - Iterations for radial cuts.\n\t * @param {number} maxRandomIterations - Max random iterations for not-radial cuts.\n\t * @return {Array<Object3D>} The array of pieces.\n\t */\n\tsubdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\n\n\t\tconst debris = [];\n\n\t\tconst tempPlane1 = this.tempPlane1;\n\t\tconst tempPlane2 = this.tempPlane2;\n\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\n\n\t\tconst maxTotalIterations = maxRandomIterations + maxRadialIterations;\n\n\t\tconst scope = this;\n\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\n\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\n\n\t\t\t\tdebris.push( subObject );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet angle = Math.PI;\n\n\t\t\tif ( numIterations === 0 ) {\n\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\n\n\t\t\t} else {\n\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\n\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\n\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\n\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Perform the cut\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\n\n\t\t\tconst obj1 = scope.tempResultObjects.object1;\n\t\t\tconst obj2 = scope.tempResultObjects.object2;\n\n\t\t\tif ( obj1 ) {\n\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t\tif ( obj2 ) {\n\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\n\n\t\treturn debris;\n\n\t}\n\n\t/**\n\t * Subdivides the given 3D object into pieces by a plane.\n\t *\n\t * @param {Object3D} object - The 3D object to subdivide.\n\t * @param {Plane} plane - The plane to cut the 3D object.\n\t * @param {{object1:?Mesh,object2:?Mesh}} output - An object that stores the pieces.\n\t * @return {number} The number of pieces.\n\t */\n\tcutByPlane( object, plane, output ) {\n\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n\t\t// object2 can be null if the plane doesn't cut the object.\n\t\t// object1 can be null only in case of internal error\n\t\t// Returned value is number of pieces, 0 for error.\n\n\t\tconst geometry = object.geometry;\n\t\tconst coords = geometry.attributes.position.array;\n\t\tconst normals = geometry.attributes.normal.array;\n\n\t\tconst numPoints = coords.length / 3;\n\t\tlet numFaces = numPoints / 3;\n\n\t\tlet indices = geometry.getIndex();\n\n\t\tif ( indices ) {\n\n\t\t\tindices = indices.array;\n\t\t\tnumFaces = indices.length / 3;\n\n\t\t}\n\n\t\tfunction getVertexIndex( faceIdx, vert ) {\n\n\t\t\t// vert = 0, 1 or 2.\n\n\t\t\tconst idx = faceIdx * 3 + vert;\n\n\t\t\treturn indices ? indices[ idx ] : idx;\n\n\t\t}\n\n\t\tconst points1 = [];\n\t\tconst points2 = [];\n\n\t\tconst delta = this.smallDelta;\n\n\t\t// Reset segments mark\n\t\tconst numPointPairs = numPoints * numPoints;\n\t\tfor ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\n\n\t\tconst p0 = this.tempVector3_P0;\n\t\tconst p1 = this.tempVector3_P1;\n\t\tconst n0 = this.tempVector3_N0;\n\t\tconst n1 = this.tempVector3_N1;\n\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\n\t\tfor ( let i = 0; i < numFaces - 1; i ++ ) {\n\n\t\t\tconst a1 = getVertexIndex( i, 0 );\n\t\t\tconst b1 = getVertexIndex( i, 1 );\n\t\t\tconst c1 = getVertexIndex( i, 2 );\n\n\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\n\n\t\t\tfor ( let j = i + 1; j < numFaces; j ++ ) {\n\n\t\t\t\tconst a2 = getVertexIndex( j, 0 );\n\t\t\t\tconst b2 = getVertexIndex( j, 1 );\n\t\t\t\tconst c2 = getVertexIndex( j, 2 );\n\n\t\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\n\n\t\t\t\tconst coplanar = 1 - n0.dot( n1 ) < delta;\n\n\t\t\t\tif ( coplanar ) {\n\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\n\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\n\n\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\n\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Transform the plane to object local space\n\t\tconst localPlane = this.tempPlane_Cut;\n\t\tobject.updateMatrix();\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\n\n\t\t// Iterate through the faces adding points to both pieces\n\t\tfor ( let i = 0; i < numFaces; i ++ ) {\n\n\t\t\tconst va = getVertexIndex( i, 0 );\n\t\t\tconst vb = getVertexIndex( i, 1 );\n\t\t\tconst vc = getVertexIndex( i, 2 );\n\n\t\t\tfor ( let segment = 0; segment < 3; segment ++ ) {\n\n\t\t\t\tconst i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\n\t\t\t\tconst i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\n\n\t\t\t\tconst segmentState = this.segments[ i0 * numPoints + i1 ];\n\n\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\n\n\t\t\t\t// Mark segment as processed (also inverted segment)\n\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\n\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\n\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark0 = 0;\n\n\t\t\t\tlet d = localPlane.distanceToPoint( p0 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark0 = 2;\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark0 = 1;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmark0 = 3;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t}\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark1 = 0;\n\n\t\t\t\td = localPlane.distanceToPoint( p1 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark1 = 2;\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark1 = 1;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\n\t\t\t\t}\telse {\n\n\t\t\t\t\tmark1 = 3;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\n\n\t\t\t\t\t// Intersection of segment with the plane\n\n\t\t\t\t\tthis.tempLine1.start.copy( p0 );\n\t\t\t\t\tthis.tempLine1.end.copy( p1 );\n\n\t\t\t\t\tlet intersection = new Vector3();\n\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\n\n\t\t\t\t\tif ( intersection === null ) {\n\n\t\t\t\t\t\t// Shouldn't happen\n\t\t\t\t\t\tconsole.error( 'Internal error: segment does not intersect plane.' );\n\t\t\t\t\t\toutput.segmentedObject1 = null;\n\t\t\t\t\t\toutput.segmentedObject2 = null;\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpoints1.push( intersection );\n\t\t\t\t\tpoints2.push( intersection.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Calculate debris mass (very fast and imprecise):\n\t\tconst newMass = object.userData.mass * 0.5;\n\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\n\t\tthis.tempCM1.set( 0, 0, 0 );\n\t\tlet radius1 = 0;\n\t\tconst numPoints1 = points1.length;\n\n\t\tif ( numPoints1 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\n\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tp.sub( this.tempCM1 );\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM1.add( object.position );\n\n\t\t}\n\n\t\tthis.tempCM2.set( 0, 0, 0 );\n\t\tlet radius2 = 0;\n\t\tconst numPoints2 = points2.length;\n\t\tif ( numPoints2 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\n\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tp.sub( this.tempCM2 );\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM2.add( object.position );\n\n\t\t}\n\n\t\tlet object1 = null;\n\t\tlet object2 = null;\n\n\t\tlet numObjects = 0;\n\n\t\tif ( numPoints1 > 4 ) {\n\n\t\t\tobject1 = new Mesh( new ConvexGeometry( points1 ), object.material );\n\t\t\tobject1.position.copy( this.tempCM1 );\n\t\t\tobject1.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\tif ( numPoints2 > 4 ) {\n\n\t\t\tobject2 = new Mesh( new ConvexGeometry( points2 ), object.material );\n\t\t\tobject2.position.copy( this.tempCM2 );\n\t\t\tobject2.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\toutput.object1 = object1;\n\t\toutput.object2 = object2;\n\n\t\treturn numObjects;\n\n\t}\n\n\t// internal helpers\n\n\tstatic transformFreeVector( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformFreeVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformTiedVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a tied (ordinary) vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformPlaneToLocalSpace( plane, m, resultPlane ) {\n\n\t\tresultPlane.normal.copy( plane.normal );\n\t\tresultPlane.constant = plane.constant;\n\n\t\tconst referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );\n\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\n\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\n\n\t}\n\n}\n\nexport { ConvexObjectBreaker };\n"],"mappings":"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","ignoreList":[]}