{"version":3,"file":"node_modules/three/examples/jsm/misc/GPUComputationRenderer.js","names":["ClampToEdgeWrapping","DataTexture","FloatType","NearestFilter","RGBAFormat","ShaderMaterial","WebGLRenderTarget","FullScreenQuad","GPUComputationRenderer","constructor","sizeX","sizeY","renderer","this","variables","currentTextureIndex","dataType","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","quad","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","name","vertexShader","fragmentShader","setDataType","type","addVariable","variableName","initialValueTexture","variable","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","d","depVar","found","j","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","sizeXTexture","sizeYTexture","format","depthBuffer","createTexture","data","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","render"],"sources":["node_modules/three/examples/jsm/misc/GPUComputationRenderer.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tFloatType,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by @zz85.\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel).\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * ```\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n * ```\n * Basic use:\n * ```js\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, vel0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, pos0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n * ```\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * ```js\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * ```\n *\n * @three_import import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n */\nclass GPUComputationRenderer {\n\n\t/**\n\t * Constructs a new GPU computation renderer.\n\t *\n\t * @param {number} sizeX - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {number} sizeY - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tlet dataType = FloatType;\n\n\t\tconst passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tconst quad = new FullScreenQuad( passThruShader );\n\n\t\t/**\n\t\t * Sets the data type of the internal textures.\n\t\t *\n\t\t * @param {(FloatType|HalfFloatType)} type - The type to set.\n\t\t * @return {GPUComputationRenderer} A reference to this renderer.\n\t\t */\n\t\tthis.setDataType = function ( type ) {\n\n\t\t\tdataType = type;\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Adds a compute variable to the renderer.\n\t\t *\n\t\t * @param {string} variableName - The variable name.\n\t\t * @param {string} computeFragmentShader - The compute (fragment) shader source.\n\t\t * @param {Texture} initialValueTexture - The initial value texture.\n\t\t * @return {Object} The compute variable.\n\t\t */\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tconst variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tmagFilter: NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets variable dependencies.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @param {Array<Object>} dependencies - Other compute variables that represents the dependencies.\n\t\t */\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the renderer.\n\t\t *\n\t\t * @return {?string} Returns `null` if no errors are detected. Otherwise returns the error message.\n\t\t */\n\t\tthis.init = function () {\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn 'No support for vertex shader textures.';\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tconst material = variable.material;\n\t\t\t\tconst uniforms = material.uniforms;\n\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tlet found = false;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\t/**\n\t\t * Executes the compute. This method is usually called in the animation loop.\n\t\t */\n\t\tthis.compute = function () {\n\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\n\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the current render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The current render target.\n\t\t */\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the alternate render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The alternate render target.\n\t\t */\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\t/**\n\t\t * Frees all internal resources. Call this method if you don't need the\n\t\t * renderer anymore.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tquad.dispose();\n\n\t\t\tconst variables = this.variables;\n\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\n\n\t\t\t\tconst variable = variables[ i ];\n\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\n\n\t\t\t\tconst renderTargets = variable.renderTargets;\n\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\n\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\n\t\t\t\t\trenderTarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\n\n\t\t}\n\n\t\t/**\n\t\t * Adds a resolution defined for the given material shader.\n\t\t *\n\t\t * @param {Object} materialShader - The material shader.\n\t\t */\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\tname: 'GPUComputationShader',\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\t/**\n\t\t * Creates a new render target from the given parameters.\n\t\t *\n\t\t * @param {number} sizeXTexture - The width of the render target.\n\t\t * @param {number} sizeYTexture - The height of the render target.\n\t\t * @param {number} wrapS - The wrapS value.\n\t\t * @param {number} wrapT - The wrapS value.\n\t\t * @param {number} minFilter - The minFilter value.\n\t\t * @param {number} magFilter - The magFilter value.\n\t\t * @return {WebGLRenderTarget} The new render target.\n\t\t */\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || NearestFilter;\n\t\t\tmagFilter = magFilter || NearestFilter;\n\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: dataType,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Creates a new data texture.\n\t\t *\n\t\t * @return {DataTexture} The new data texture.\n\t\t */\n\t\tthis.createTexture = function () {\n\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\t\t\ttexture.needsUpdate = true;\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Renders the given texture into the given render target.\n\t\t *\n\t\t * @param {Texture} input - The input.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\n\t\t/**\n\t\t * Renders the given material into the given render target\n\t\t * with a full-screen pass.\n\t\t *\n\t\t * @param {Material} material - The material.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\tquad.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\tquad.render( renderer );\n\t\t\tquad.material = passThruShader;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t'void main()\t{\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'void main() {\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t}\n\n}\n\nexport { GPUComputationRenderer };\n"],"mappings":"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","ignoreList":[]}