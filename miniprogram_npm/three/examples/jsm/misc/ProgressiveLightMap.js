import{DoubleSide,FloatType,HalfFloatType,Mesh,MeshBasicMaterial,MeshPhongMaterial,PlaneGeometry,Scene,WebGLRenderTarget}from"three";import{potpack}from"../libs/potpack.module.js";class ProgressiveLightMap{constructor(e,t=1024){this.renderer=e,this.res=t,this.lightMapContainers=[],this.scene=new Scene,this.buffer1Active=!1,this.firstUpdate=!0,this.labelMesh=null,this.blurringPlane=null;const i=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?HalfFloatType:FloatType;this.progressiveLightMap1=new WebGLRenderTarget(this.res,this.res,{type:i}),this.progressiveLightMap2=new WebGLRenderTarget(this.res,this.res,{type:i}),this.progressiveLightMap2.texture.channel=1,this.uvMat=new MeshPhongMaterial,this.uvMat.uniforms={},this.uvMat.onBeforeCompile=e=>{e.vertexShader="attribute vec2 uv1;\n#define USE_LIGHTMAP\n#define LIGHTMAP_UV uv1\n"+e.vertexShader.slice(0,-1)+"\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader="#define USE_LIGHTMAP\n"+e.fragmentShader.slice(0,t)+"\tuniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}",e.uniforms.previousShadowMap={value:this.progressiveLightMap1.texture},e.uniforms.averagingWindow={value:100},this.uvMat.uniforms=e.uniforms,this.uvMat.userData.shader=e}}addObjectsToLightMap(e){this.uv_boxes=[];const t=3/this.res;for(let i=0;i<e.length;i++){const s=e[i];s.isLight?this.scene.attach(s):!1!==s.geometry.hasAttribute("uv")?(null===this.blurringPlane&&this._initializeBlurPlane(this.res,this.progressiveLightMap1),s.material.lightMap=this.progressiveLightMap2.texture,s.material.dithering=!0,s.castShadow=!0,s.receiveShadow=!0,s.renderOrder=1e3+i,this.uv_boxes.push({w:1+2*t,h:1+2*t,index:i}),this.lightMapContainers.push({basicMat:s.material,object:s})):console.warn("THREE.ProgressiveLightMap: All lightmap objects need uvs.")}const i=potpack(this.uv_boxes);this.uv_boxes.forEach((s=>{const r=e[s.index].geometry.getAttribute("uv").clone();for(let e=0;e<r.array.length;e+=r.itemSize)r.array[e]=(r.array[e]+s.x+t)/i.w,r.array[e+1]=(r.array[e+1]+s.y+t)/i.h;e[s.index].geometry.setAttribute("uv1",r),e[s.index].geometry.getAttribute("uv1").needsUpdate=!0}))}update(e,t=100,i=!0){if(null===this.blurringPlane)return;const s=this.renderer.getRenderTarget();this.blurringPlane.visible=i;for(let e=0;e<this.lightMapContainers.length;e++)this.lightMapContainers[e].object.oldScene=this.lightMapContainers[e].object.parent,this.scene.attach(this.lightMapContainers[e].object);!0===this.firstUpdate&&(this.renderer.compile(this.scene,e),this.firstUpdate=!1);for(let e=0;e<this.lightMapContainers.length;e++)this.uvMat.uniforms.averagingWindow={value:t},this.lightMapContainers[e].object.material=this.uvMat,this.lightMapContainers[e].object.oldFrustumCulled=this.lightMapContainers[e].object.frustumCulled,this.lightMapContainers[e].object.frustumCulled=!1;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,a=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1;this.renderer.setRenderTarget(r),this.uvMat.uniforms.previousShadowMap={value:a.texture},this.blurringPlane.material.uniforms.previousShadowMap={value:a.texture},this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e);for(let e=0;e<this.lightMapContainers.length;e++)this.lightMapContainers[e].object.frustumCulled=this.lightMapContainers[e].object.oldFrustumCulled,this.lightMapContainers[e].object.material=this.lightMapContainers[e].basicMat,this.lightMapContainers[e].object.oldScene.attach(this.lightMapContainers[e].object);this.renderer.setRenderTarget(s)}showDebugLightmap(e,t=void 0){if(0!==this.lightMapContainers.length){if(null===this.labelMesh){const e=new MeshBasicMaterial({map:this.progressiveLightMap1.texture,side:DoubleSide}),t=new PlaneGeometry(100,100);this.labelMesh=new Mesh(t,e),this.labelMesh.position.y=250,this.lightMapContainers[0].object.parent.add(this.labelMesh)}void 0!==t&&this.labelMesh.position.copy(t),this.labelMesh.visible=e}else console.warn("THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.")}_initializeBlurPlane(e,t=null){const i=new MeshBasicMaterial;i.uniforms={previousShadowMap:{value:null},pixelOffset:{value:1/e},polygonOffset:!0,polygonOffsetFactor:-1,polygonOffsetUnits:3},i.onBeforeCompile=s=>{s.vertexShader="#define USE_UV\n"+s.vertexShader.slice(0,-1)+"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const r=s.fragmentShader.indexOf("void main() {");s.fragmentShader="#define USE_UV\n"+s.fragmentShader.slice(0,r)+"\tuniform sampler2D previousShadowMap;\n\tuniform float pixelOffset;\n"+s.fragmentShader.slice(r-1,-1)+"\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}",s.uniforms.previousShadowMap={value:t.texture},s.uniforms.pixelOffset={value:.5/e},i.uniforms=s.uniforms,i.userData.shader=s},this.blurringPlane=new Mesh(new PlaneGeometry(1,1),i),this.blurringPlane.name="Blurring Plane",this.blurringPlane.frustumCulled=!1,this.blurringPlane.renderOrder=0,this.blurringPlane.material.depthWrite=!1,this.scene.add(this.blurringPlane)}dispose(){this.progressiveLightMap1.dispose(),this.progressiveLightMap2.dispose(),this.uvMat.dispose(),null!==this.blurringPlane&&(this.blurringPlane.geometry.dispose(),this.blurringPlane.material.dispose()),null!==this.labelMesh&&(this.labelMesh.geometry.dispose(),this.labelMesh.material.dispose())}}export{ProgressiveLightMap};
//# sourceMappingURL=ProgressiveLightMap.js.map