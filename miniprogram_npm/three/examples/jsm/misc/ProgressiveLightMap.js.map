{"version":3,"file":"node_modules/three/examples/jsm/misc/ProgressiveLightMap.js","names":["DoubleSide","FloatType","HalfFloatType","Mesh","MeshBasicMaterial","MeshPhongMaterial","PlaneGeometry","Scene","WebGLRenderTarget","potpack","ProgressiveLightMap","constructor","renderer","res","this","lightMapContainers","scene","buffer1Active","firstUpdate","labelMesh","blurringPlane","format","test","navigator","userAgent","progressiveLightMap1","type","progressiveLightMap2","texture","channel","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","averagingWindow","userData","addObjectsToLightMap","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","console","warn","dimensions","forEach","box","uv1","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","compile","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","setRenderTarget","render","showDebugLightmap","position","undefined","labelMaterial","map","side","labelGeometry","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite","dispose"],"sources":["node_modules/three/examples/jsm/misc/ProgressiveLightMap.js"],"sourcesContent":["import { DoubleSide, FloatType, HalfFloatType, Mesh, MeshBasicMaterial, MeshPhongMaterial, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo]{@link https://github.com/zalo/}.\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * This class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `ProgressiveLightMapGPU.js`.\n *\n * @three_import import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';\n */\nclass ProgressiveLightMap {\n\n\t/**\n\t * Constructs a new progressive light map.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n \t * @param {number} [res=1024] - The side-long dimension of the total lightmap.\n\t */\n\tconstructor( renderer, res = 1024 ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The side-long dimension of the total lightmap.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1024\n\t\t */\n\t\tthis.res = res;\n\n\t\t// internals\n\n\t\tthis.lightMapContainers = [];\n\t\tthis.scene = new Scene();\n\t\tthis.buffer1Active = false;\n\t\tthis.firstUpdate = true;\n\t\tthis.labelMesh = null;\n\t\tthis.blurringPlane = null;\n\n\t\t// Create the Progressive LightMap Texture\n\t\tconst format = /(Android|iPad|iPhone|iPod)/g.test( navigator.userAgent ) ? HalfFloatType : FloatType;\n\t\tthis.progressiveLightMap1 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2.texture.channel = 1;\n\n\t\t// Inject some spicy new logic into a standard phong material\n\t\tthis.uvMat = new MeshPhongMaterial();\n\t\tthis.uvMat.uniforms = {};\n\t\tthis.uvMat.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'attribute vec2 uv1;\\n' +\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\t'#define LIGHTMAP_UV uv1\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\t\t\tconst bodyStart = shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t`\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n\t\t\t// Set the Previous Frame's Texture Buffer and Averaging Window\n\t\t\tshader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n\t\t\tshader.uniforms.averagingWindow = { value: 100 };\n\n\t\t\tthis.uvMat.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tthis.uvMat.userData.shader = shader;\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets these objects' materials' lightmaps and modifies their uv1's.\n\t *\n\t * @param {Array<Object3D>} objects - An array of objects and lights to set up your lightmap.\n\t */\n\taddObjectsToLightMap( objects ) {\n\n\t\t// Prepare list of UV bounding boxes for packing later...\n\t\tthis.uv_boxes = []; const padding = 3 / this.res;\n\n\t\tfor ( let ob = 0; ob < objects.length; ob ++ ) {\n\n\t\t\tconst object = objects[ ob ];\n\n\t\t\t// If this object is a light, simply add it to the internal scene\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tthis.scene.attach( object ); continue;\n\n\t\t\t}\n\n\t\t\tif ( object.geometry.hasAttribute( 'uv' ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: All lightmap objects need uvs.' ); continue;\n\n\t\t\t}\n\n\t\t\tif ( this.blurringPlane === null ) {\n\n\t\t\t\tthis._initializeBlurPlane( this.res, this.progressiveLightMap1 );\n\n\t\t\t}\n\n\t\t\t// Apply the lightmap to the object\n\t\t\tobject.material.lightMap = this.progressiveLightMap2.texture;\n\t\t\tobject.material.dithering = true;\n\t\t\tobject.castShadow = true;\n\t\t\tobject.receiveShadow = true;\n\t\t\tobject.renderOrder = 1000 + ob;\n\n\t\t\t// Prepare UV boxes for potpack\n\t\t\t// TODO: Size these by object surface area\n\t\t\tthis.uv_boxes.push( { w: 1 + ( padding * 2 ),\n\t\t\t\t\t\t\t\t  h: 1 + ( padding * 2 ), index: ob } );\n\n\t\t\tthis.lightMapContainers.push( { basicMat: object.material, object: object } );\n\n\t\t}\n\n\t\t// Pack the objects' lightmap UVs into the same global space\n\t\tconst dimensions = potpack( this.uv_boxes );\n\t\tthis.uv_boxes.forEach( ( box ) => {\n\n\t\t\tconst uv1 = objects[ box.index ].geometry.getAttribute( 'uv' ).clone();\n\t\t\tfor ( let i = 0; i < uv1.array.length; i += uv1.itemSize ) {\n\n\t\t\t\tuv1.array[ i ] = ( uv1.array[ i ] + box.x + padding ) / dimensions.w;\n\t\t\t\tuv1.array[ i + 1 ] = ( uv1.array[ i + 1 ] + box.y + padding ) / dimensions.h;\n\n\t\t\t}\n\n\t\t\tobjects[ box.index ].geometry.setAttribute( 'uv1', uv1 );\n\t\t\tobjects[ box.index ].geometry.getAttribute( 'uv1' ).needsUpdate = true;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * This function renders each mesh one at a time into their respective surface maps.\n\t *\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t * @param {number} [blendWindow=100] - When >1, samples will accumulate over time.\n\t * @param {boolean} [blurEdges=true] - Whether to fix UV Edges via blurring.\n\t */\n\tupdate( camera, blendWindow = 100, blurEdges = true ) {\n\n\t\tif ( this.blurringPlane === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Store the original Render Target\n\t\tconst oldTarget = this.renderer.getRenderTarget();\n\n\t\t// The blurring plane applies blur to the seams of the lightmap\n\t\tthis.blurringPlane.visible = blurEdges;\n\n\t\t// Steal the Object3D from the real world to our special dimension\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.oldScene =\n\t\t\t\tthis.lightMapContainers[ l ].object.parent;\n\t\t\tthis.scene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Initialize everything\n\t\tif ( this.firstUpdate === true ) {\n\n\t\t\tthis.renderer.compile( this.scene, camera );\n\t\t\tthis.firstUpdate = false;\n\n\t\t}\n\n\t\t// Set each object's material to the UV Unwrapped Surface Mapping Version\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.uvMat.uniforms.averagingWindow = { value: blendWindow };\n\t\t\tthis.lightMapContainers[ l ].object.material = this.uvMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.frustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled = false;\n\n\t\t}\n\n\t\t// Ping-pong two surface buffers for reading/writing\n\t\tconst activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n\t\tconst inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n\t\t// Render the object's surface maps\n\t\tthis.renderer.setRenderTarget( activeMap );\n\t\tthis.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.buffer1Active = ! this.buffer1Active;\n\t\tthis.renderer.render( this.scene, camera );\n\n\t\t// Restore the object's Real-time Material and add it back to the original world\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.material = this.lightMapContainers[ l ].basicMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldScene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Restore the original Render Target\n\t\tthis.renderer.setRenderTarget( oldTarget );\n\n\t}\n\n\t/**\n\t * Draws the lightmap in the main scene. Call this after adding the objects to it.\n\t *\n\t * @param {boolean} visible - Whether the debug plane should be visible\n\t * @param {Vector3} [position] - Where the debug plane should be drawn\n\t*/\n\tshowDebugLightmap( visible, position = undefined ) {\n\n\t\tif ( this.lightMapContainers.length === 0 ) {\n\n\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.labelMesh === null ) {\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: this.progressiveLightMap1.texture, side: DoubleSide } );\n\t\t\tconst labelGeometry = new PlaneGeometry( 100, 100 );\n\t\t\tthis.labelMesh = new Mesh( labelGeometry, labelMaterial );\n\t\t\tthis.labelMesh.position.y = 250;\n\t\t\tthis.lightMapContainers[ 0 ].object.parent.add( this.labelMesh );\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.labelMesh.position.copy( position );\n\n\t\t}\n\n\t\tthis.labelMesh.visible = visible;\n\n\t}\n\n\t/**\n\t * Creates the Blurring Plane.\n\t *\n\t * @private\n\t * @param {number} res - The square resolution of this object's lightMap.\n\t * @param {WebGLRenderTarget} [lightMap] - The lightmap to initialize the plane with.\n\t */\n\t_initializeBlurPlane( res, lightMap = null ) {\n\n\t\tconst blurMaterial = new MeshBasicMaterial();\n\t\tblurMaterial.uniforms = { previousShadowMap: { value: null },\n\t\t\t\t\t\t\t\t  pixelOffset: { value: 1.0 / res },\n\t\t\t\t\t\t\t\t  polygonOffset: true, polygonOffsetFactor: - 1, polygonOffsetUnits: 3.0 };\n\t\tblurMaterial.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\t\t\tconst bodyStart\t= shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t\t`\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n\t\t\t// Set the LightMap Accumulation Buffer\n\t\t\tshader.uniforms.previousShadowMap = { value: lightMap.texture };\n\t\t\tshader.uniforms.pixelOffset = { value: 0.5 / res };\n\t\t\tblurMaterial.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tblurMaterial.userData.shader = shader;\n\n\t\t};\n\n\t\tthis.blurringPlane = new Mesh( new PlaneGeometry( 1, 1 ), blurMaterial );\n\t\tthis.blurringPlane.name = 'Blurring Plane';\n\t\tthis.blurringPlane.frustumCulled = false;\n\t\tthis.blurringPlane.renderOrder = 0;\n\t\tthis.blurringPlane.material.depthWrite = false;\n\t\tthis.scene.add( this.blurringPlane );\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.progressiveLightMap1.dispose();\n\t\tthis.progressiveLightMap2.dispose();\n\n\t\tthis.uvMat.dispose();\n\n\t\tif ( this.blurringPlane !== null ) {\n\n\t\t\tthis.blurringPlane.geometry.dispose();\n\t\t\tthis.blurringPlane.material.dispose();\n\n\t\t}\n\n\t\tif ( this.labelMesh !== null ) {\n\n\t\t\tthis.labelMesh.geometry.dispose();\n\t\t\tthis.labelMesh.material.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport { ProgressiveLightMap };\n"],"mappings":"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","ignoreList":[]}