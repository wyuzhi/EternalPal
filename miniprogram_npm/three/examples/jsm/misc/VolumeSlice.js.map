{"version":3,"file":"node_modules/three/examples/jsm/misc/VolumeSlice.js","names":["ClampToEdgeWrapping","DoubleSide","LinearFilter","Mesh","MeshBasicMaterial","PlaneGeometry","Texture","SRGBColorSpace","VolumeSlice","constructor","volume","index","axis","slice","this","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","ctx","canvasBuffer","ctxBuffer","updateGeometry","canvasMap","minFilter","generateMipmaps","wrapS","wrapT","colorSpace","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","iLength","jLength","sliceAccess","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","console","error","j","i","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"sources":["node_modules/three/examples/jsm/misc/VolumeSlice.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tTexture,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data.\n *\n * @see {@link Volume}\n * @three_import import { VolumeSlice } from 'three/addons/misc/VolumeSlice.js';\n */\nclass VolumeSlice {\n\n\t/**\n\t * Constructs a new volume slice.\n\t *\n \t * @param {Volume} volume - The associated volume.\n \t * @param {number} [index=0] - The index of the slice.\n \t * @param {('x'|'y'|'z')} [axis='z'] - For now only 'x', 'y' or 'z' but later it will change to a normal vector.\n\t */\n\tconstructor( volume, index = 0, axis = 'z' ) {\n\n\t\tconst slice = this;\n\n\t\t/**\n\t\t * The associated volume.\n\t\t *\n\t\t * @type {Volume}\n\t\t */\n\t\tthis.volume = volume;\n\n\t\tObject.defineProperty( this, 'index', {\n\t\t\tget: function () {\n\n\t\t\t\treturn index;\n\n\t\t\t},\n\t\t\t/**\n\t\t\t * The index of the slice, if changed, will automatically call updateGeometry at the next repaint.\n\t\t\t *\n\t\t\t * @name VolumeSlice#index\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t * @param {number} value\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\tset: function ( value ) {\n\n\t\t\t\tindex = value;\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t\treturn index;\n\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * The normal axis.\n\t\t *\n\t\t * @type {('x'|'y'|'z')}\n\t\t */\n\t\tthis.axis = axis;\n\n\t\t/**\n\t\t * The final canvas used for the texture.\n\t\t *\n\t\t * @type {HTMLCanvasElement}\n\t\t */\n\t\tthis.canvas = document.createElement( 'canvas' );\n\n\t\t/**\n\t\t * The rendering context of the canvas.\n\t\t *\n\t\t * @type {CanvasRenderingContext2D}\n\t\t */\n\t\tthis.ctx;\n\n\t\t/**\n\t\t * The intermediary canvas used to paint the data.\n\t\t *\n\t\t * @type {HTMLCanvasElement}\n\t\t */\n\t\tthis.canvasBuffer = document.createElement( 'canvas' );\n\n\t\t/**\n\t\t * The rendering context of the canvas buffer,\n\t\t *\n\t\t * @type {CanvasRenderingContext2D}\n\t\t */\n\t\tthis.ctxBuffer;\n\n\t\tthis.updateGeometry();\n\n\n\t\tconst canvasMap = new Texture( this.canvas );\n\t\tcanvasMap.minFilter = LinearFilter;\n\t\tcanvasMap.generateMipmaps = false;\n\t\tcanvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n\t\tcanvasMap.colorSpace = SRGBColorSpace;\n\t\tconst material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );\n\n\t\t/**\n\t\t * The mesh ready to get used in the scene.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = new Mesh( this.geometry, material );\n\t\tthis.mesh.matrixAutoUpdate = false;\n\n\t\t/**\n\t\t * If set to `true`, `updateGeometry()` will be triggered at the next repaint.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.geometryNeedsUpdate = true;\n\t\tthis.repaint();\n\n\t\t/**\n\t\t * Width of slice in the original coordinate system, corresponds to the width of the buffer canvas.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.iLength = 0;\n\n\t\t/**\n\t\t * Height of slice in the original coordinate system, corresponds to the height of the buffer canvas.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.jLength = 0;\n\n\t\t/**\n\t\t * Function that allow the slice to access right data.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @see {@link Volume#extractPerpendicularPlane}\n\t\t */\n\t\tthis.sliceAccess = null;\n\n\t}\n\n\t/**\n\t * Refresh the texture and the geometry if geometryNeedsUpdate is set to `true`.\n\t */\n\trepaint() {\n\n\t\tif ( this.geometryNeedsUpdate ) {\n\n\t\t\tthis.updateGeometry();\n\n\t\t}\n\n\t\tconst iLength = this.iLength,\n\t\t\tjLength = this.jLength,\n\t\t\tsliceAccess = this.sliceAccess,\n\t\t\tvolume = this.volume,\n\t\t\tcanvas = this.canvasBuffer,\n\t\t\tctx = this.ctxBuffer;\n\n\n\t\t// get the imageData and pixel array from the canvas\n\t\tconst imgData = ctx.getImageData( 0, 0, iLength, jLength );\n\t\tconst data = imgData.data;\n\t\tconst volumeData = volume.data;\n\t\tconst upperThreshold = volume.upperThreshold;\n\t\tconst lowerThreshold = volume.lowerThreshold;\n\t\tconst windowLow = volume.windowLow;\n\t\tconst windowHigh = volume.windowHigh;\n\n\t\t// manipulate some pixel elements\n\t\tlet pixelCount = 0;\n\n\t\tif ( volume.dataType === 'label' ) {\n\n\t\t\tconsole.error( 'THREE.VolumeSlice.repaint: label are not supported yet' );\n\n\t\t\t// This part is currently useless but will be used when colortables will be handled\n\n\t\t\t// for ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t// \tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t// \t\tlet label = volumeData[ sliceAccess( i, j ) ];\n\t\t\t// \t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n\t\t\t// \t\tconst color = this.colorMap[ label ];\n\t\t\t// \t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n\t\t\t// \t\tpixelCount ++;\n\n\t\t\t// \t}\n\n\t\t\t// }\n\n\t\t} else {\n\n\t\t\tfor ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tlet value = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tlet alpha = 0xff;\n\t\t\t\t\t//apply threshold\n\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\n\t\t\t\t\t//apply window level\n\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\n\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\n\n\t\t\t\t\tdata[ 4 * pixelCount ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imgData, 0, 0 );\n\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\n\n\n\t\tthis.mesh.material.map.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Refresh the geometry according to axis and index.\n\t * @see {@link Volume#extractPerpendicularPlane}\n\t */\n\tupdateGeometry() {\n\n\t\tconst extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\n\t\tthis.sliceAccess = extracted.sliceAccess;\n\t\tthis.jLength = extracted.jLength;\n\t\tthis.iLength = extracted.iLength;\n\t\tthis.matrix = extracted.matrix;\n\n\t\tthis.canvas.width = extracted.planeWidth;\n\t\tthis.canvas.height = extracted.planeHeight;\n\t\tthis.canvasBuffer.width = this.iLength;\n\t\tthis.canvasBuffer.height = this.jLength;\n\t\tthis.ctx = this.canvas.getContext( '2d' );\n\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\n\n\t\tif ( this.geometry ) this.geometry.dispose(); // dispose existing geometry\n\n\t\tthis.geometry = new PlaneGeometry( extracted.planeWidth, extracted.planeHeight );\n\n\t\tif ( this.mesh ) {\n\n\t\t\tthis.mesh.geometry = this.geometry;\n\t\t\t//reset mesh matrix\n\t\t\tthis.mesh.matrix.identity();\n\t\t\tthis.mesh.applyMatrix4( this.matrix );\n\n\t\t}\n\n\t\tthis.geometryNeedsUpdate = false;\n\n\t}\n\n}\n\nexport { VolumeSlice };\n"],"mappings":"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","ignoreList":[]}