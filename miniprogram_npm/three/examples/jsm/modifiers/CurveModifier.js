const CHANNELS=4,TEXTURE_WIDTH=1024,TEXTURE_HEIGHT=4;import{DataTexture,DataUtils,RGBAFormat,HalfFloatType,RepeatWrapping,Mesh,InstancedMesh,LinearFilter,DynamicDrawUsage,Matrix4}from"three";function initSplineTexture(e=1){const t=new Uint16Array(4*TEXTURE_WIDTH*e*CHANNELS),n=new DataTexture(t,TEXTURE_WIDTH,4*e,RGBAFormat,HalfFloatType);return n.wrapS=RepeatWrapping,n.wrapY=RepeatWrapping,n.magFilter=LinearFilter,n.minFilter=LinearFilter,n.needsUpdate=!0,n}function updateSplineTexture(e,t,n=0){const r=Math.floor(1*TEXTURE_WIDTH);t.arcLengthDivisions=r/2,t.updateArcLengths();const a=t.getSpacedPoints(r),i=t.computeFrenetFrames(r,!0);for(let t=0;t<r;t++){const r=Math.floor(t/TEXTURE_WIDTH),s=t%TEXTURE_WIDTH;let o=a[t];setTextureValue(e,s,o.x,o.y,o.z,0+r+4*n),o=i.tangents[t],setTextureValue(e,s,o.x,o.y,o.z,1+r+4*n),o=i.normals[t],setTextureValue(e,s,o.x,o.y,o.z,2+r+4*n),o=i.binormals[t],setTextureValue(e,s,o.x,o.y,o.z,3+r+4*n)}e.needsUpdate=!0}function setTextureValue(e,t,n,r,a,i){const s=e.image,{data:o}=s,l=CHANNELS*TEXTURE_WIDTH*i;o[t*CHANNELS+l+0]=DataUtils.toHalfFloat(n),o[t*CHANNELS+l+1]=DataUtils.toHalfFloat(r),o[t*CHANNELS+l+2]=DataUtils.toHalfFloat(a),o[t*CHANNELS+l+3]=DataUtils.toHalfFloat(1)}function getUniforms(e){return{spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}}}function modifyShader(e,t,n=1){e.__ok||(e.__ok=!0,e.onBeforeCompile=e=>{if(e.__modified)return;e.__modified=!0,Object.assign(e.uniforms,t);const r=`\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${4*n}.;\n\t\tfloat textureStacks = 1.;\n\n\t\t${e.vertexShader}\n\t\t`.replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,"\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * 4.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t").replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=r})}export class Flow{constructor(e,t=1){const n=e.clone(),r=initSplineTexture(t),a=getUniforms(r);n.traverse((function(e){if(e instanceof Mesh||e instanceof InstancedMesh)if(Array.isArray(e.material)){const n=[];for(const r of e.material){const e=r.clone();modifyShader(e,a,t),n.push(e)}e.material=n}else e.material=e.material.clone(),modifyShader(e.material,a,t)})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=n,this.splineTexture=r,this.uniforms=a}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Flow: Index out of range.");const n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,updateSplineTexture(this.splineTexture,t,e)}moveAlongCurve(e){this.uniforms.pathOffset.value+=e}}const _matrix=new Matrix4;export class InstancedFlow extends Flow{constructor(e,t,n,r){const a=new InstancedMesh(n,r,e);a.instanceMatrix.setUsage(DynamicDrawUsage),a.frustumCulled=!1,super(a,t),this.offsets=new Array(e).fill(0),this.whichCurve=new Array(e).fill(0)}writeChanges(e){_matrix.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,_matrix),this.object3D.instanceMatrix.needsUpdate=!0}moveIndividualAlongCurve(e,t){this.offsets[e]+=t,this.writeChanges(e)}setCurve(e,t){if(isNaN(t))throw Error("InstancedFlow: Curve index being set is Not a Number (NaN).");this.whichCurve[e]=t,this.writeChanges(e)}}
//# sourceMappingURL=CurveModifier.js.map