{"version":3,"file":"node_modules/three/examples/jsm/modifiers/CurveModifier.js","names":["CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","DataTexture","DataUtils","RGBAFormat","HalfFloatType","RepeatWrapping","Mesh","InstancedMesh","LinearFilter","DynamicDrawUsage","Matrix4","initSplineTexture","numberOfCurves","dataArray","Uint16Array","dataTexture","wrapS","wrapY","magFilter","minFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","toHalfFloat","getUniforms","splineTexture","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","Flow","constructor","mesh","obj3D","clone","traverse","child","Array","isArray","materials","newMaterial","push","this","curveArray","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount","_matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","frustumCulled","super","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"sources":["node_modules/three/examples/jsm/modifiers/CurveModifier.js"],"sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tDataUtils,\n\tRGBAFormat,\n\tHalfFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tLinearFilter,\n\tDynamicDrawUsage,\n\tMatrix4\n} from 'three';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @private\n * @param {number} numberOfCurves - The number of curves needed to be described by this texture.\n * @returns {DataTexture}\n */\nfunction initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Uint16Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBAFormat,\n\t\tHalfFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = LinearFilter;\n\tdataTexture.minFilter = LinearFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture.\n *\n * @private\n * @param {DataTexture} texture - The data texture to write to.\n * @param {Curve} splineCurve - The curve to describe.\n * @param {number} offset - Which curve slot to write to.\n */\nfunction updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\tdata[ index * CHANNELS + i + 0 ] = DataUtils.toHalfFloat( x );\n\tdata[ index * CHANNELS + i + 1 ] = DataUtils.toHalfFloat( y );\n\tdata[ index * CHANNELS + i + 2 ] = DataUtils.toHalfFloat( z );\n\tdata[ index * CHANNELS + i + 3 ] = DataUtils.toHalfFloat( 1 );\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier.\n *\n * @param {DataTexture} splineTexture - Which holds the curve description.\n * @returns {Object} The uniforms object to be used in the shader.\n */\nfunction getUniforms( splineTexture ) {\n\n\tconst uniforms = {\n\t\tspineTexture: { value: splineTexture },\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\n\t\tspineOffset: { type: 'f', value: 161 },\n\t\tspineLength: { type: 'f', value: 400 },\n\t\tflow: { type: 'i', value: 1 },\n\t};\n\treturn uniforms;\n\n}\n\nfunction modifyShader( material, uniforms, numberOfCurves = 1 ) {\n\n\tif ( material.__ok ) return;\n\tmaterial.__ok = true;\n\n\tmaterial.onBeforeCompile = ( shader ) => {\n\n\t\tif ( shader.__modified ) return;\n\t\tshader.__modified = true;\n\n\t\tObject.assign( shader.uniforms, uniforms );\n\n\t\tconst vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n\t\t// chunk import moved in front of modified shader below\n\t\t\t.replace( '#include <beginnormal_vertex>', '' )\n\n\t\t\t// vec3 transformedNormal declaration overridden below\n\t\t\t.replace( '#include <defaultnormal_vertex>', '' )\n\n\t\t\t// vec3 transformed declaration overridden below\n\t\t\t.replace( '#include <begin_vertex>', '' )\n\n\t\t\t// shader override\n\t\t\t.replace(\n\t\t\t\t/void\\s*main\\s*\\(\\)\\s*\\{/,\n\t\t\t\t`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t` ).replace(\n\t\t\t\t'#include <project_vertex>',\n\t\t\t\t`vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n\t\t\t);\n\n\t\tshader.vertexShader = vertexShader;\n\n\t};\n\n}\n\n/**\n * A modifier for making meshes bend around curves.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `CurveModifierGPU.js`.\n *\n * @three_import import { Flow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class Flow {\n\n\t/**\n\t * Constructs a new Flow instance.\n\t *\n\t * @param {Mesh} mesh - The mesh to clone and modify to bend around the curve.\n\t * @param {number} numberOfCurves - The amount of space that should preallocated for additional curves.\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexture = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexture );\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\tconst materials = [];\n\n\t\t\t\t\tfor ( const material of child.material ) {\n\n\t\t\t\t\t\tconst newMaterial = material.clone();\n\t\t\t\t\t\tmodifyShader( newMaterial, uniforms, numberOfCurves );\n\t\t\t\t\t\tmaterials.push( newMaterial );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tchild.material = materials;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.material = child.material.clone();\n\t\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexture = splineTexture;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\t/**\n\t * Updates the curve for the given curve index.\n\t *\n\t * @param {number} index - The curve index.\n\t * @param {Curve} curve - The curve that should be used to bend the mesh.\n\t */\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Flow: Index out of range.' );\n\t\tconst curveLength = curve.getLength();\n\t\tthis.uniforms.spineLength.value = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\t\tupdateSplineTexture( this.splineTexture, curve, index );\n\n\t}\n\n\t/**\n\t * Moves the mesh along the curve.\n\t *\n\t * @param {number} amount - The offset.\n\t */\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset.value += amount;\n\n\t}\n\n}\n\nconst _matrix = new Matrix4();\n\n/**\n * An instanced version of {@link Flow} for making meshes bend around curves, where the instances are placed on the curve.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Flow\n * @three_import import { InstancedFlow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class InstancedFlow extends Flow {\n\n\t/**\n\t * Constructs a new InstancedFlow instance.\n\t *\n\t * @param {number} count - The number of instanced elements.\n\t * @param {number} curveCount - The number of curves to preallocate for.\n\t * @param {Geometry} geometry - The geometry to use for the instanced mesh.\n\t * @param {Material} material - The material to use for the instanced mesh.\n\t */\n\tconstructor( count, curveCount, geometry, material ) {\n\n\t\tconst mesh = new InstancedMesh(\n\t\t\tgeometry,\n\t\t\tmaterial,\n\t\t\tcount\n\t\t);\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\n\t\tmesh.frustumCulled = false;\n\t\tsuper( mesh, curveCount );\n\n\t\tthis.offsets = new Array( count ).fill( 0 );\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\n\n\t}\n\n\t/**\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n\t * This writes that information to the matrix and marks it as needing update.\n\t *\n\t * @param {number} index - The index of tge instanced element to update.\n\t */\n\twriteChanges( index ) {\n\n\t\t_matrix.makeTranslation(\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\n\t\t\tthis.whichCurve[ index ],\n\t\t\tthis.offsets[ index ]\n\t\t);\n\t\tthis.object3D.setMatrixAt( index, _matrix );\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Move an individual element along the curve by a specific amount.\n\t *\n\t * @param {number} index - Which element to update.\n\t * @param {number} offset - The offset.\n\t */\n\tmoveIndividualAlongCurve( index, offset ) {\n\n\t\tthis.offsets[ index ] += offset;\n\t\tthis.writeChanges( index );\n\n\t}\n\n\t/**\n\t * Select which curve to use for an element.\n\t *\n\t * @param {number} index - The index of the instanced element to update.\n\t * @param {number} curveNo - The index of the curve it should use.\n\t */\n\tsetCurve( index, curveNo ) {\n\n\t\tif ( isNaN( curveNo ) ) throw Error( 'InstancedFlow: Curve index being set is Not a Number (NaN).' );\n\t\tthis.whichCurve[ index ] = curveNo;\n\t\tthis.writeChanges( index );\n\n\t}\n\n}\n"],"mappings":"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","ignoreList":[]}