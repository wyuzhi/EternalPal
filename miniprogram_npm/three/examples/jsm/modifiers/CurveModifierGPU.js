const CHANNELS=4,TEXTURE_WIDTH=1024,TEXTURE_HEIGHT=4;import{DataTexture,DataUtils,RGBAFormat,HalfFloatType,RepeatWrapping,Mesh,InstancedMesh,LinearFilter}from"three";import{modelWorldMatrix,normalLocal,vec2,vec3,vec4,mat3,varyingProperty,texture,reference,Fn,select,positionLocal}from"three/tsl";function initSplineTexture(e=1){const t=new Uint16Array(4*TEXTURE_WIDTH*e*CHANNELS),r=new DataTexture(t,TEXTURE_WIDTH,4*e,RGBAFormat,HalfFloatType);return r.wrapS=RepeatWrapping,r.wrapY=RepeatWrapping,r.magFilter=LinearFilter,r.minFilter=LinearFilter,r.needsUpdate=!0,r}function updateSplineTexture(e,t,r=0){const a=Math.floor(1*TEXTURE_WIDTH);t.arcLengthDivisions=a/2,t.updateArcLengths();const n=t.getSpacedPoints(a),o=t.computeFrenetFrames(a,!0);for(let t=0;t<a;t++){const a=Math.floor(t/TEXTURE_WIDTH),i=t%TEXTURE_WIDTH;let s=n[t];setTextureValue(e,i,s.x,s.y,s.z,0+a+4*r),s=o.tangents[t],setTextureValue(e,i,s.x,s.y,s.z,1+a+4*r),s=o.normals[t],setTextureValue(e,i,s.x,s.y,s.z,2+a+4*r),s=o.binormals[t],setTextureValue(e,i,s.x,s.y,s.z,3+a+4*r)}e.needsUpdate=!0}function setTextureValue(e,t,r,a,n,o){const i=e.image,{data:s}=i,l=CHANNELS*TEXTURE_WIDTH*o;s[t*CHANNELS+l+0]=DataUtils.toHalfFloat(r),s[t*CHANNELS+l+1]=DataUtils.toHalfFloat(a),s[t*CHANNELS+l+2]=DataUtils.toHalfFloat(n),s[t*CHANNELS+l+3]=DataUtils.toHalfFloat(1)}function getUniforms(e){return{spineTexture:e,pathOffset:0,pathSegment:1,spineOffset:161,spineLength:400,flow:1}}function modifyShader(e,t,r){const a=t.spineTexture,n=reference("pathOffset","float",t),o=reference("pathSegment","float",t),i=reference("spineOffset","float",t),s=reference("spineLength","float",t),l=reference("flow","float",t);e.positionNode=Fn((()=>{const e=4*r,t=modelWorldMatrix.mul(vec4(positionLocal,1)).toVar(),c=l.greaterThan(0).toVar(),u=select(c,0,1).toVar(),f=select(c,t.x.add(i).div(s),0).mul(o).add(n).mul(1).toVar();f.assign(f.mod(1));const p=f.floor().toVar(),m=texture(a,vec2(f,p.add(.5).div(e))).xyz,d=texture(a,vec2(f,p.add(1.5).div(e))).xyz,T=texture(a,vec2(f,p.add(2.5).div(e))).xyz,h=texture(a,vec2(f,p.add(3.5).div(e))).xyz,x=mat3(d,T,h).toVar();return varyingProperty("vec3","curveNormal").assign(x.mul(normalLocal)),x.mul(vec3(t.x.mul(u),t.y,t.z)).add(m)}))(),e.normalNode=varyingProperty("vec3","curveNormal")}export class Flow{constructor(e,t=1){const r=e.clone(),a=initSplineTexture(t),n=getUniforms(a);r.traverse((function(e){if(e instanceof Mesh||e instanceof InstancedMesh)if(Array.isArray(e.material)){const r=[];for(const a of e.material){const e=a.clone();modifyShader(e,n,t),r.push(e)}e.material=r}else e.material=e.material.clone(),modifyShader(e.material,n,t)})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=r,this.splineTexture=a,this.uniforms=n}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Flow: Index out of range.");const r=t.getLength();this.uniforms.spineLength=r,this.curveLengthArray[e]=r,this.curveArray[e]=t,updateSplineTexture(this.splineTexture,t,e)}moveAlongCurve(e){this.uniforms.pathOffset+=e}}
//# sourceMappingURL=CurveModifierGPU.js.map