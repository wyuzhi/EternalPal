{"version":3,"file":"node_modules/three/examples/jsm/modifiers/CurveModifierGPU.js","names":["CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","DataTexture","DataUtils","RGBAFormat","HalfFloatType","RepeatWrapping","Mesh","InstancedMesh","LinearFilter","modelWorldMatrix","normalLocal","vec2","vec3","vec4","mat3","varyingProperty","texture","reference","Fn","select","positionLocal","initSplineTexture","numberOfCurves","dataArray","Uint16Array","dataTexture","wrapS","wrapY","magFilter","minFilter","needsUpdate","updateSplineTexture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","toHalfFloat","getUniforms","splineTexture","spineTexture","pathOffset","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","positionNode","textureScale","worldPos","mul","toVar","bend","greaterThan","xWeight","mt","add","div","assign","mod","spinePos","xyz","a","b","c","basis","normalNode","Flow","constructor","mesh","obj3D","clone","traverse","child","Array","isArray","materials","newMaterial","push","this","curveArray","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount"],"sources":["node_modules/three/examples/jsm/modifiers/CurveModifierGPU.js"],"sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tDataUtils,\n\tRGBAFormat,\n\tHalfFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tLinearFilter\n} from 'three';\n\nimport { modelWorldMatrix, normalLocal, vec2, vec3, vec4, mat3, varyingProperty, texture, reference, Fn, select, positionLocal } from 'three/tsl';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @private\n * @param {number} [numberOfCurves=1] - The number of curves needed to be described by this texture.\n * @returns  {DataTexture} The new data texture.\n */\nfunction initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Uint16Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBAFormat,\n\t\tHalfFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = LinearFilter;\n\tdataTexture.minFilter = LinearFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture.\n *\n * @private\n * @param {DataTexture} texture - The data texture to write to.\n * @param {Curve} splineCurve - The curve to describe.\n * @param {number} [offset=0] - Which curve slot to write to.\n */\nfunction updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\n\tdata[ index * CHANNELS + i + 0 ] = DataUtils.toHalfFloat( x );\n\tdata[ index * CHANNELS + i + 1 ] = DataUtils.toHalfFloat( y );\n\tdata[ index * CHANNELS + i + 2 ] = DataUtils.toHalfFloat( z );\n\tdata[ index * CHANNELS + i + 3 ] = DataUtils.toHalfFloat( 1 );\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier.\n *\n * @private\n * @param {DataTexture} splineTexture - Which holds the curve description.\n * @returns {Object} The uniforms object.\n */\nfunction getUniforms( splineTexture ) {\n\n\treturn {\n\t\tspineTexture: splineTexture,\n\t\tpathOffset: 0, // time of path curve\n\t\tpathSegment: 1, // fractional length of path\n\t\tspineOffset: 161,\n\t\tspineLength: 400,\n\t\tflow: 1, // int\n\t};\n\n}\n\nfunction modifyShader( material, uniforms, numberOfCurves ) {\n\n\tconst spineTexture = uniforms.spineTexture;\n\n\tconst pathOffset = reference( 'pathOffset', 'float', uniforms );\n\tconst pathSegment = reference( 'pathSegment', 'float', uniforms );\n\tconst spineOffset = reference( 'spineOffset', 'float', uniforms );\n\tconst spineLength = reference( 'spineLength', 'float', uniforms );\n\tconst flow = reference( 'flow', 'float', uniforms );\n\n\tmaterial.positionNode = Fn( () => {\n\n\t\tconst textureStacks = TEXTURE_HEIGHT / 4;\n\t\tconst textureScale = TEXTURE_HEIGHT * numberOfCurves;\n\n\t\tconst worldPos = modelWorldMatrix.mul( vec4( positionLocal, 1 ) ).toVar();\n\n\t\tconst bend = flow.greaterThan( 0 ).toVar();\n\t\tconst xWeight = select( bend, 0, 1 ).toVar();\n\n\t\tconst spinePortion = select( bend, worldPos.x.add( spineOffset ).div( spineLength ), 0 );\n\t\tconst mt = spinePortion.mul( pathSegment ).add( pathOffset ).mul( textureStacks ).toVar();\n\n\t\tmt.assign( mt.mod( textureStacks ) );\n\n\t\tconst rowOffset = mt.floor().toVar();\n\n\t\tconst spinePos = texture( spineTexture, vec2( mt, rowOffset.add( 0.5 ).div( textureScale ) ) ).xyz;\n\n\t\tconst a = texture( spineTexture, vec2( mt, rowOffset.add( 1.5 ).div( textureScale ) ) ).xyz;\n\t\tconst b = texture( spineTexture, vec2( mt, rowOffset.add( 2.5 ).div( textureScale ) ) ).xyz;\n\t\tconst c = texture( spineTexture, vec2( mt, rowOffset.add( 3.5 ).div( textureScale ) ) ).xyz;\n\n\t\tconst basis = mat3( a, b, c ).toVar();\n\n\t\tvaryingProperty( 'vec3', 'curveNormal' ).assign( basis.mul( normalLocal ) );\n\n\t\treturn basis.mul( vec3( worldPos.x.mul( xWeight ), worldPos.y, worldPos.z ) ).add( spinePos );\n\n\t} )();\n\n\tmaterial.normalNode = varyingProperty( 'vec3', 'curveNormal' );\n\n}\n\n/**\n * A modifier for making meshes bend around curves.\n *\n * This module can only be used with {@link WebGPURenderer}. When using {@link WebGLRenderer},\n * import the class from `CurveModifier.js`.\n *\n * @three_import import { Flow } from 'three/addons/modifiers/CurveModifierGPU.js';\n */\nexport class Flow {\n\n\t/**\n\t * Constructs a new Flow instance.\n\t *\n\t * @param {Mesh} mesh - The mesh to clone and modify to bend around the curve.\n\t * @param {number} numberOfCurves - The amount of space that should preallocated for additional curves.\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexture = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexture );\n\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\tconst materials = [];\n\n\t\t\t\t\tfor ( const material of child.material ) {\n\n\t\t\t\t\t\tconst newMaterial = material.clone();\n\t\t\t\t\t\tmodifyShader( newMaterial, uniforms, numberOfCurves );\n\t\t\t\t\t\tmaterials.push( newMaterial );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tchild.material = materials;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.material = child.material.clone();\n\t\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexture = splineTexture;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\t/**\n\t * Updates the curve for the given curve index.\n\t *\n\t * @param {number} index - The curve index.\n\t * @param {Curve} curve - The curve that should be used to bend the mesh.\n\t */\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Flow: Index out of range.' );\n\n\t\tconst curveLength = curve.getLength();\n\n\t\tthis.uniforms.spineLength = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\n\t\tupdateSplineTexture( this.splineTexture, curve, index );\n\n\t}\n\n\t/**\n\t * Moves the mesh along the curve.\n\t *\n\t * @param {number} amount - The offset.\n\t */\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset += amount;\n\n\t}\n\n}\n"],"mappings":"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","ignoreList":[]}