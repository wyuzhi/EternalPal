{"version":3,"file":"node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js","names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","_A","_B","_C","EdgeSplitModifier","modify","geometry","cutOffAngle","tryKeepNormals","edgeSplitToGroups","indexes","cutOff","firstIndex","set","normals","normalize","result","splitGroup","currentGroup","j","dot","push","edgeSplit","original","length","groupResults","index","groupResult","splitIndexes","hadNormals","oldNormals","attributes","normal","clone","array","deleteAttribute","mergeVertices","positions","getAttribute","pointToIndexMap","Float32Array","i","sub","cross","x","y","z","computeNormals","Array","mapPositionsToIndexes","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"sources":["node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\n\n/**\n * The modifier can be used to split faces at sharp edges. This allows to compute\n * normals without smoothing the edges which can lead to an improved visual result.\n *\n * ```js\n * const modifier = new EdgeSplitModifier();\n * geometry = modifier.modify( geometry, Math.PI * 0.4 );\n * ```\n *\n * @three_import import { EdgeSplitModifier } from 'three/addons/modifiers/EdgeSplitModifier.js';\n */\nclass EdgeSplitModifier {\n\n\t/**\n\t * Returns a new, modified version of the given geometry by applying an edge-split operation.\n\t * Please note that the resulting geometry is always indexed.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to modify.\n\t * @param {number} cutOffAngle - The cut off angle in radians.\n\t * @param {boolean} [tryKeepNormals=true] - Whether to try to keep normals or not.\n\t * @return {BufferGeometry} A new, modified geometry.\n\t */\n\tmodify( geometry, cutOffAngle, tryKeepNormals = true ) {\n\n\t\tfunction computeNormals() {\n\n\t\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\t\tlet index = indexes[ i ];\n\n\t\t\t\t_A.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 1 ];\n\t\t\t\t_B.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 2 ];\n\t\t\t\t_C.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\t_C.sub( _B );\n\t\t\t\t_A.sub( _B );\n\n\t\t\t\tconst normal = _C.cross( _A ).normalize();\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction mapPositionsToIndexes() {\n\n\t\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\tconst index = indexes[ i ];\n\n\t\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\t\t_A.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\t\tconst result = {\n\t\t\t\tsplitGroup: [],\n\t\t\t\tcurrentGroup: [ firstIndex ]\n\t\t\t};\n\n\t\t\tfor ( const j of indexes ) {\n\n\t\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\t\t_B.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\t\tif ( _B.dot( _A ) < cutOff ) {\n\n\t\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\t\tif ( indexes.length === 0 ) return;\n\n\t\t\tconst groupResults = [];\n\n\t\t\tfor ( const index of indexes ) {\n\n\t\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t\t}\n\n\t\t\tlet result = groupResults[ 0 ];\n\n\t\t\tfor ( const groupResult of groupResults ) {\n\n\t\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\t\tresult = groupResult;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( original != null ) {\n\n\t\t\t\tsplitIndexes.push( {\n\t\t\t\t\toriginal: original,\n\t\t\t\t\tindexes: result.currentGroup\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( result.splitGroup.length ) {\n\n\t\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet hadNormals = false;\n\t\tlet oldNormals = null;\n\n\t\tif ( geometry.attributes.normal ) {\n\n\t\t\thadNormals = true;\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t\tif ( tryKeepNormals === true && geometry.index !== null ) {\n\n\t\t\t\toldNormals = geometry.attributes.normal.array;\n\n\t\t\t}\n\n\t\t\tgeometry.deleteAttribute( 'normal' );\n\n\t\t}\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tconst indexes = geometry.index.array;\n\t\tconst positions = geometry.getAttribute( 'position' ).array;\n\n\t\tlet normals;\n\t\tlet pointToIndexMap;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\t\tconst splitIndexes = [];\n\n\t\tfor ( const vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tconst newAttributes = {};\n\t\tfor ( const name of Object.keys( geometry.attributes ) ) {\n\n\t\t\tconst oldAttribute = geometry.attributes[ name ];\n\t\t\tconst newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );\n\t\t\tnewArray.set( oldAttribute.array );\n\t\t\tnewAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t}\n\n\t\tconst newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( let i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tconst split = splitIndexes[ i ];\n\t\t\tconst index = indexes[ split.original ];\n\n\t\t\tfor ( const attribute of Object.values( newAttributes ) ) {\n\n\t\t\t\tfor ( let j = 0; j < attribute.itemSize; j ++ ) {\n\n\t\t\t\t\tattribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =\n\t\t\t\t\t\tattribute.array[ index * attribute.itemSize + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = indexes.length + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\tfor ( const name of Object.keys( newAttributes ) ) {\n\n\t\t\tgeometry.setAttribute( name, newAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( hadNormals ) {\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tif ( oldNormals !== null ) {\n\n\t\t\t\tconst changedNormals = new Array( oldNormals.length / 3 ).fill( false );\n\n\t\t\t\tfor ( const splitData of splitIndexes )\n\t\t\t\t\tchangedNormals[ splitData.original ] = true;\n\n\t\t\t\tfor ( let i = 0; i < changedNormals.length; i ++ ) {\n\n\t\t\t\t\tif ( changedNormals[ i ] === false ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ )\n\t\t\t\t\t\t\tgeometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n\nexport { EdgeSplitModifier };\n"],"mappings":"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","ignoreList":[]}