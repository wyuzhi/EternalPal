import{BufferGeometry,Color,Float32BufferAttribute,Vector2,Vector3,Vector4}from"three";import*as BufferGeometryUtils from"../utils/BufferGeometryUtils.js";const _cb=new Vector3,_ab=new Vector3;class SimplifyModifier{modify(e,t){delete(e=e.clone()).morphAttributes.position,delete e.morphAttributes.normal;const o=e.attributes;for(const t in o)"position"!==t&&"uv"!==t&&"normal"!==t&&"tangent"!==t&&"color"!==t&&e.deleteAttribute(t);const r=[],s=[],i=(e=BufferGeometryUtils.mergeVertices(e)).getAttribute("position"),n=e.getAttribute("uv"),l=e.getAttribute("normal"),h=e.getAttribute("tangent"),a=e.getAttribute("color");let c=null,u=null,f=null,g=null;for(let e=0;e<i.count;e++){const t=(new Vector3).fromBufferAttribute(i,e);n&&(u=(new Vector2).fromBufferAttribute(n,e)),l&&(f=(new Vector3).fromBufferAttribute(l,e)),h&&(c=(new Vector4).fromBufferAttribute(h,e)),a&&(g=(new Color).fromBufferAttribute(a,e));const o=new Vertex(t,u,f,c,g);r.push(o)}let m,v=e.getIndex();if(null!==v)for(let e=0;e<v.count;e+=3){const t=v.getX(e),o=v.getX(e+1),i=v.getX(e+2),n=new Triangle(r[t],r[o],r[i],t,o,i);s.push(n)}else for(let e=0;e<i.count;e+=3){const t=e,o=e+1,i=e+2,n=new Triangle(r[t],r[o],r[i],t,o,i);s.push(n)}for(let e=0,t=r.length;e<t;e++)computeEdgeCostAtVertex(r[e]);let b=t;for(;b--;){if(m=minimumCostEdge(r),!m){console.log("THREE.SimplifyModifier: No next vertex");break}collapse(r,s,m,m.collapseNeighbor)}const p=new BufferGeometry,d=[],N=[],A=[],x=[],C=[];v=[];for(let e=0;e<r.length;e++){const t=r[e];d.push(t.position.x,t.position.y,t.position.z),t.uv&&N.push(t.uv.x,t.uv.y),t.normal&&A.push(t.normal.x,t.normal.y,t.normal.z),t.tangent&&x.push(t.tangent.x,t.tangent.y,t.tangent.z,t.tangent.w),t.color&&C.push(t.color.r,t.color.g,t.color.b),t.id=e}for(let e=0;e<s.length;e++){const t=s[e];v.push(t.v1.id,t.v2.id,t.v3.id)}return p.setAttribute("position",new Float32BufferAttribute(d,3)),N.length>0&&p.setAttribute("uv",new Float32BufferAttribute(N,2)),A.length>0&&p.setAttribute("normal",new Float32BufferAttribute(A,3)),x.length>0&&p.setAttribute("tangent",new Float32BufferAttribute(x,4)),C.length>0&&p.setAttribute("color",new Float32BufferAttribute(C,3)),p.setIndex(v),p}}function pushIfUnique(e,t){-1===e.indexOf(t)&&e.push(t)}function removeFromArray(e,t){const o=e.indexOf(t);o>-1&&e.splice(o,1)}function computeEdgeCollapseCost(e,t){const o=t.position.distanceTo(e.position);let r=0;const s=[];for(let o=0,r=e.faces.length;o<r;o++){const r=e.faces[o];r.hasVertex(t)&&s.push(r)}for(let t=0,o=e.faces.length;t<o;t++){let o=1;const i=e.faces[t];for(let e=0;e<s.length;e++){const t=s[e],r=i.normal.dot(t.normal);o=Math.min(o,(1.001-r)/2)}r=Math.max(r,o)}s.length<2&&(r=1);return o*r+0}function computeEdgeCostAtVertex(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const o=computeEdgeCollapseCost(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=o,e.minCost=o,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=o,o<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=o)}e.collapseCost=e.totalCost/e.costCount}function removeVertex(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;){removeFromArray(e.neighbors.pop().neighbors,e)}removeFromArray(t,e)}function removeFace(e,t){removeFromArray(t,e),e.v1&&removeFromArray(e.v1.faces,e),e.v2&&removeFromArray(e.v2.faces,e),e.v3&&removeFromArray(e.v3.faces,e);const o=[e.v1,e.v2,e.v3];for(let e=0;e<3;e++){const t=o[e],r=o[(e+1)%3];t&&r&&(t.removeIfNonNeighbor(r),r.removeIfNonNeighbor(t))}}function collapse(e,t,o,r){if(!r)return void removeVertex(o,e);r.uv&&o.uv.copy(r.uv),r.normal&&r.normal.add(o.normal).normalize(),r.tangent&&r.tangent.add(o.tangent).normalize();const s=[];for(let e=0;e<o.neighbors.length;e++)s.push(o.neighbors[e]);for(let e=o.faces.length-1;e>=0;e--)o.faces[e]&&o.faces[e].hasVertex(r)&&removeFace(o.faces[e],t);for(let e=o.faces.length-1;e>=0;e--)o.faces[e].replaceVertex(o,r);removeVertex(o,e);for(let e=0;e<s.length;e++)computeEdgeCostAtVertex(s[e])}function minimumCostEdge(e){let t=e[0];for(let o=0;o<e.length;o++)e[o].collapseCost<t.collapseCost&&(t=e[o]);return t}class Triangle{constructor(e,t,o,r,s,i){this.a=r,this.b=s,this.c=i,this.v1=e,this.v2=t,this.v3=o,this.normal=new Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(o),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(o),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(t)}computeNormal(){const e=this.v1.position,t=this.v2.position,o=this.v3.position;_cb.subVectors(o,t),_ab.subVectors(e,t),_cb.cross(_ab).normalize(),this.normal.copy(_cb)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),removeFromArray(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class Vertex{constructor(e,t,o,r,s){this.position=e,this.uv=t,this.normal=o,this.tangent=r,this.color=s,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){pushIfUnique(this.neighbors,e)}removeIfNonNeighbor(e){const t=this.neighbors,o=this.faces,r=t.indexOf(e);if(-1!==r){for(let t=0;t<o.length;t++)if(o[t].hasVertex(e))return;t.splice(r,1)}}}export{SimplifyModifier};
//# sourceMappingURL=SimplifyModifier.js.map