{"version":3,"file":"node_modules/three/examples/jsm/modifiers/SimplifyModifier.js","names":["BufferGeometry","Color","Float32BufferAttribute","Vector2","Vector3","Vector4","BufferGeometryUtils","_cb","_ab","SimplifyModifier","modify","geometry","count","clone","morphAttributes","position","normal","attributes","name","deleteAttribute","vertices","faces","positionAttribute","mergeVertices","getAttribute","uvAttribute","normalAttribute","tangentAttribute","colorAttribute","t","v2","nor","col","i","v","fromBufferAttribute","vertex","Vertex","push","nextVertex","index","getIndex","a","getX","b","c","triangle","Triangle","il","length","computeEdgeCostAtVertex","z","minimumCostEdge","console","log","collapse","collapseNeighbor","simplifiedGeometry","uv","tangent","color","x","y","w","r","g","id","face","v1","v3","setAttribute","setIndex","pushIfUnique","array","object","indexOf","removeFromArray","k","splice","computeEdgeCollapseCost","u","edgelength","distanceTo","curvature","sideFaces","hasVertex","minCurvature","j","sideFace","dotProd","dot","Math","min","max","neighbors","collapseCost","minCost","totalCost","costCount","removeVertex","assert","pop","removeFace","f","vs","removeIfNonNeighbor","copy","add","normalize","tmpVertices","replaceVertex","least","constructor","this","computeNormal","addUniqueNeighbor","vA","vB","vC","subVectors","cross","oldv","newv","n","offset"],"sources":["node_modules/three/examples/jsm/modifiers/SimplifyModifier.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tColor,\n\tFloat32BufferAttribute,\n\tVector2,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _cb = new Vector3(), _ab = new Vector3();\n\n/**\n * This class can be used to modify a geometry by simplifying it. A typical use\n * case for such a modifier is automatic LOD generation.\n *\n * The implementation is based on [Progressive Mesh type Polygon Reduction Algorithm]{@link https://web.archive.org/web/20230610044040/http://www.melax.com/polychop/}\n * by Stan Melax in 1998.\n *\n * ```js\n * const modifier = new SimplifyModifier();\n * geometry = modifier.modify( geometry );\n * ```\n *\n * @three_import import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';\n */\nclass SimplifyModifier {\n\n\t/**\n\t * Returns a new, modified version of the given geometry by applying a simplification.\n\t * Please note that the resulting geometry is always non-indexed.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to modify.\n\t * @param {number} count - The number of vertices to remove.\n\t * @return {BufferGeometry} A new, modified geometry.\n\t */\n\tmodify( geometry, count ) {\n\n\t\tgeometry = geometry.clone();\n\n\t\t// currently morphAttributes are not supported\n\t\tdelete geometry.morphAttributes.position;\n\t\tdelete geometry.morphAttributes.normal;\n\t\tconst attributes = geometry.attributes;\n\n\t\t// this modifier can only process indexed and non-indexed geometries with at least a position attribute\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tif ( name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color' ) geometry.deleteAttribute( name );\n\n\t\t}\n\n\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\tconst vertices = [];\n\t\tconst faces = [];\n\n\t\t// add vertices\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst uvAttribute = geometry.getAttribute( 'uv' );\n\t\tconst normalAttribute = geometry.getAttribute( 'normal' );\n\t\tconst tangentAttribute = geometry.getAttribute( 'tangent' );\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\tlet t = null;\n\t\tlet v2 = null;\n\t\tlet nor = null;\n\t\tlet col = null;\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\n\t\t\tif ( uvAttribute ) {\n\n\t\t\t\tv2 = new Vector2().fromBufferAttribute( uvAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( normalAttribute ) {\n\n\t\t\t\tnor = new Vector3().fromBufferAttribute( normalAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( tangentAttribute ) {\n\n\t\t\t\tt = new Vector4().fromBufferAttribute( tangentAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( colorAttribute ) {\n\n\t\t\t\tcol = new Color().fromBufferAttribute( colorAttribute, i );\n\n\t\t\t}\n\n\t\t\tconst vertex = new Vertex( v, v2, nor, t, col );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tlet index = geometry.getIndex();\n\n\t\tif ( index !== null ) {\n\n\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\tconst a = i;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tlet nextVertex;\n\n\t\tlet z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tconst simplifiedGeometry = new BufferGeometry();\n\t\tconst position = [];\n\t\tconst uv = [];\n\t\tconst normal = [];\n\t\tconst tangent = [];\n\t\tconst color = [];\n\n\t\tindex = [];\n\n\t\t//\n\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\t\t\tposition.push( vertex.position.x, vertex.position.y, vertex.position.z );\n\t\t\tif ( vertex.uv ) {\n\n\t\t\t\tuv.push( vertex.uv.x, vertex.uv.y );\n\n\t\t\t}\n\n\t\t\tif ( vertex.normal ) {\n\n\t\t\t\tnormal.push( vertex.normal.x, vertex.normal.y, vertex.normal.z );\n\n\t\t\t}\n\n\t\t\tif ( vertex.tangent ) {\n\n\t\t\t\ttangent.push( vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w );\n\n\t\t\t}\n\n\t\t\tif ( vertex.color ) {\n\n\t\t\t\tcolor.push( vertex.color.r, vertex.color.g, vertex.color.b );\n\n\t\t\t}\n\n\n\t\t\t// cache final index to GREATLY speed up faces reconstruction\n\t\t\tvertex.id = i;\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\n\n\t\t}\n\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tif ( uv.length > 0 ) simplifiedGeometry.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\t\tif ( normal.length > 0 ) simplifiedGeometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\n\t\tif ( tangent.length > 0 ) simplifiedGeometry.setAttribute( 'tangent', new Float32BufferAttribute( tangent, 4 ) );\n\t\tif ( color.length > 0 ) simplifiedGeometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\n\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t}\n\n}\n\nfunction pushIfUnique( array, object ) {\n\n\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n}\n\nfunction removeFromArray( array, object ) {\n\n\tconst k = array.indexOf( object );\n\tif ( k > - 1 ) array.splice( k, 1 );\n\n}\n\nfunction computeEdgeCollapseCost( u, v ) {\n\n\t// if we collapse edge uv by moving u to v then how\n\t// much different will the model change, i.e. the \"error\".\n\n\tconst edgelength = v.position.distanceTo( u.position );\n\tlet curvature = 0;\n\n\tconst sideFaces = [];\n\n\t// find the \"sides\" triangles that are on the edge uv\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tconst face = u.faces[ i ];\n\n\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\tsideFaces.push( face );\n\n\t\t}\n\n\t}\n\n\t// use the triangle facing most away from the sides\n\t// to determine our curvature term\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tlet minCurvature = 1;\n\t\tconst face = u.faces[ i ];\n\n\t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\tconst sideFace = sideFaces[ j ];\n\t\t\t// use dot product of face normals.\n\t\t\tconst dotProd = face.normal.dot( sideFace.normal );\n\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t}\n\n\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t}\n\n\t// crude approach in attempt to preserve borders\n\t// though it seems not to be totally correct\n\tconst borders = 0;\n\n\tif ( sideFaces.length < 2 ) {\n\n\t\t// we add some arbitrary cost for borders,\n\t\t// borders += 10;\n\t\tcurvature = 1;\n\n\t}\n\n\tconst amt = edgelength * curvature + borders;\n\n\treturn amt;\n\n}\n\nfunction computeEdgeCostAtVertex( v ) {\n\n\t// compute the edge collapse cost for all edges that start\n\t// from vertex v.  Since we are only interested in reducing\n\t// the object by selecting the min cost edge at each step, we\n\t// only cache the cost of the least cost edge at this vertex\n\t// (in member variable collapse) as well as the value of the\n\t// cost (in member variable collapseCost).\n\n\tif ( v.neighbors.length === 0 ) {\n\n\t\t// collapse if no neighbors.\n\t\tv.collapseNeighbor = null;\n\t\tv.collapseCost = - 0.01;\n\n\t\treturn;\n\n\t}\n\n\tv.collapseCost = 100000;\n\tv.collapseNeighbor = null;\n\n\t// search all neighboring edges for \"least cost\" edge\n\tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.collapseCost = collapseCost;\n\t\t\tv.minCost = collapseCost;\n\t\t\tv.totalCost = 0;\n\t\t\tv.costCount = 0;\n\n\t\t}\n\n\t\tv.costCount ++;\n\t\tv.totalCost += collapseCost;\n\n\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.minCost = collapseCost;\n\n\t\t}\n\n\t}\n\n\t// we average the cost of collapsing at this vertex\n\tv.collapseCost = v.totalCost / v.costCount;\n\t// v.collapseCost = v.minCost;\n\n}\n\nfunction removeVertex( v, vertices ) {\n\n\tconsole.assert( v.faces.length === 0 );\n\n\twhile ( v.neighbors.length ) {\n\n\t\tconst n = v.neighbors.pop();\n\t\tremoveFromArray( n.neighbors, v );\n\n\t}\n\n\tremoveFromArray( vertices, v );\n\n}\n\nfunction removeFace( f, faces ) {\n\n\tremoveFromArray( faces, f );\n\n\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t// TODO optimize this!\n\tconst vs = [ f.v1, f.v2, f.v3 ];\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst v1 = vs[ i ];\n\t\tconst v2 = vs[ ( i + 1 ) % 3 ];\n\n\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\tv1.removeIfNonNeighbor( v2 );\n\t\tv2.removeIfNonNeighbor( v1 );\n\n\t}\n\n}\n\nfunction collapse( vertices, faces, u, v ) {\n\n\t// Collapse the edge uv by moving vertex u onto v\n\n\tif ( ! v ) {\n\n\t\t// u is a vertex all by itself so just delete it..\n\t\tremoveVertex( u, vertices );\n\t\treturn;\n\n\t}\n\n\tif ( v.uv ) {\n\n\t\tu.uv.copy( v.uv );\n\n\t}\n\n\tif ( v.normal ) {\n\n\t\tv.normal.add( u.normal ).normalize();\n\n\t}\n\n\tif ( v.tangent ) {\n\n\t\tv.tangent.add( u.tangent ).normalize();\n\n\t}\n\n\tconst tmpVertices = [];\n\n\tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t}\n\n\n\t// delete triangles on edge uv:\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tif ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t}\n\n\t}\n\n\t// update remaining triangles to have v instead of u\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t}\n\n\n\tremoveVertex( u, vertices );\n\n\t// recompute the edge collapse costs in neighborhood\n\tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t}\n\n}\n\n\n\nfunction minimumCostEdge( vertices ) {\n\n\t// O(n * n) approach. TODO optimize this\n\n\tlet least = vertices[ 0 ];\n\n\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\tleast = vertices[ i ];\n\n\t\t}\n\n\t}\n\n\treturn least;\n\n}\n\n// we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n\n\tconstructor( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tcomputeNormal() {\n\n\t\tconst vA = this.v1.position;\n\t\tconst vB = this.v2.position;\n\t\tconst vC = this.v3.position;\n\n\t\t_cb.subVectors( vC, vB );\n\t\t_ab.subVectors( vA, vB );\n\t\t_cb.cross( _ab ).normalize();\n\n\t\tthis.normal.copy( _cb );\n\n\t}\n\n\thasVertex( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t}\n\n\treplaceVertex( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t}\n\n}\n\nclass Vertex {\n\n\tconstructor( v, uv, normal, tangent, color ) {\n\n\t\tthis.position = v;\n\t\tthis.uv = uv;\n\t\tthis.normal = normal;\n\t\tthis.tangent = tangent;\n\t\tthis.color = color;\n\n\t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candidate for collapsing\n\n\t}\n\n\taddUniqueNeighbor( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t}\n\n\tremoveIfNonNeighbor( n ) {\n\n\t\tconst neighbors = this.neighbors;\n\t\tconst faces = this.faces;\n\n\t\tconst offset = neighbors.indexOf( n );\n\n\t\tif ( offset === - 1 ) return;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t}\n\n}\n\nexport { SimplifyModifier };\n"],"mappings":"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","ignoreList":[]}