{"version":3,"file":"node_modules/three/examples/jsm/objects/Lensflare.js","names":["AdditiveBlending","Box2","BufferGeometry","Color","FramebufferTexture","InterleavedBuffer","InterleavedBufferAttribute","Mesh","MeshBasicMaterial","RawShaderMaterial","UnsignedByteType","Vector2","Vector3","Vector4","Lensflare","constructor","super","Geometry","opacity","transparent","this","isLensflare","type","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","occlusionMap","currentType","geometry","material1a","uniforms","scale","value","screenPosition","vertexShader","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","name","color","blending","mesh2","addElement","element","push","screenPositionPixels","validArea","viewport","onBeforeRender","renderer","scene","camera","getCurrentViewport","renderTarget","getRenderTarget","texture","dispose","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","distance","uniformsNeedUpdate","float32Array","Float32Array","interleavedBuffer","setIndex","setAttribute"],"sources":["node_modules/three/examples/jsm/objects/Lensflare.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tBox2,\n\tBufferGeometry,\n\tColor,\n\tFramebufferTexture,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMesh,\n\tMeshBasicMaterial,\n\tRawShaderMaterial,\n\tUnsignedByteType,\n\tVector2,\n\tVector3,\n\tVector4\n} from 'three';\n\n/**\n * Creates a simulated lens flare that tracks a light.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link LensflareMesh}.\n *\n * ```js\n * const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );\n *\n * const lensflare = new Lensflare();\n * lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );\n * lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );\n * lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );\n *\n * light.add( lensflare );\n * ```\n *\n * @augments Mesh\n * @three_import import { Lensflare } from 'three/addons/objects/Lensflare.js';\n */\nclass Lensflare extends Mesh {\n\n\t/**\n\t * Constructs a new lensflare.\n\t */\n\tconstructor() {\n\n\t\tsuper( Lensflare.Geometry, new MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLensflare = true;\n\n\t\tthis.type = 'Lensflare';\n\n\t\t/**\n\t\t * Overwritten to disable view-frustum culling by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.frustumCulled = false;\n\n\t\t/**\n\t\t * Overwritten to make sure lensflares a rendered last.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.renderOrder = Infinity;\n\n\t\t//\n\n\t\tconst positionScreen = new Vector3();\n\t\tconst positionView = new Vector3();\n\n\t\t// textures\n\n\t\tconst tempMap = new FramebufferTexture( 16, 16 );\n\t\tconst occlusionMap = new FramebufferTexture( 16, 16 );\n\n\t\tlet currentType = UnsignedByteType;\n\n\t\t// material\n\n\t\tconst geometry = Lensflare.Geometry;\n\n\t\tconst material1a = new RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\tconst material1b = new RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\t// the following object is used for occlusionMap generation\n\n\t\tconst mesh1 = new Mesh( geometry, material1a );\n\n\t\t//\n\n\t\tconst elements = [];\n\n\t\tconst shader = LensflareElement.Shader;\n\n\t\tconst material2 = new RawShaderMaterial( {\n\t\t\tname: shader.name,\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new Color( 0xffffff ) },\n\t\t\t\t'scale': { value: new Vector2() },\n\t\t\t\t'screenPosition': { value: new Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tconst mesh2 = new Mesh( geometry, material2 );\n\n\t\t/**\n\t\t * Adds the given lensflare element to this instance.\n\t\t *\n\t\t * @param {LensflareElement} element - The element to add.\n\t\t */\n\t\tthis.addElement = function ( element ) {\n\n\t\t\telements.push( element );\n\n\t\t};\n\n\t\t//\n\n\t\tconst scale = new Vector2();\n\t\tconst screenPositionPixels = new Vector2();\n\t\tconst validArea = new Box2();\n\t\tconst viewport = new Vector4();\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\trenderer.getCurrentViewport( viewport );\n\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\t\t\tconst type = ( renderTarget !== null ) ? renderTarget.texture.type : UnsignedByteType;\n\n\t\t\tif ( currentType !== type ) {\n\n\t\t\t\ttempMap.dispose();\n\t\t\t\tocclusionMap.dispose();\n\n\t\t\t\ttempMap.type = occlusionMap.type = type;\n\n\t\t\t\tcurrentType = type;\n\n\t\t\t}\n\n\t\t\tconst invAspect = viewport.w / viewport.z;\n\t\t\tconst halfViewportWidth = viewport.z / 2.0;\n\t\t\tconst halfViewportHeight = viewport.w / 2.0;\n\n\t\t\tlet size = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\t// calculate position in screen space\n\n\t\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\trenderer.copyFramebufferToTexture( tempMap, screenPositionPixels );\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tlet uniforms = material1a.uniforms;\n\t\t\t\tuniforms[ 'scale' ].value = scale;\n\t\t\t\tuniforms[ 'screenPosition' ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\trenderer.copyFramebufferToTexture( occlusionMap, screenPositionPixels );\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tuniforms = material1b.uniforms;\n\t\t\t\tuniforms[ 'scale' ].value = scale;\n\t\t\t\tuniforms[ 'screenPosition' ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t\t// render elements\n\n\t\t\t\tconst vecX = - positionScreen.x * 2;\n\t\t\t\tconst vecY = - positionScreen.y * 2;\n\n\t\t\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\t\tconst uniforms = material2.uniforms;\n\n\t\t\t\t\tuniforms[ 'color' ].value.copy( element.color );\n\t\t\t\t\tuniforms[ 'map' ].value = element.texture;\n\t\t\t\t\tuniforms[ 'screenPosition' ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[ 'screenPosition' ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\t\tsize = element.size / viewport.w;\n\t\t\t\t\tconst invAspect = viewport.w / viewport.z;\n\n\t\t\t\t\tuniforms[ 'scale' ].value.set( size * invAspect, size );\n\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\n\t\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\telements[ i ].texture.dispose();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\n/**\n * Represents a single flare that can be added to a {@link Lensflare} container.\n *\n * @three_import import { LensflareElement } from 'three/addons/objects/Lensflare.js';\n */\nclass LensflareElement {\n\n\t/**\n\t * Constructs a new lensflare element.\n\t *\n\t * @param {Texture} texture - The flare's texture.\n\t * @param {number} [size=1] - The size in pixels.\n\t * @param {number} [distance=0] - The normalized distance (`[0,1]`) from the light source.\n\t * A value of `0` means the flare is located at light source.\n\t * @param {Color} [color] - The flare's color\n\t */\n\tconstructor( texture, size = 1, distance = 0, color = new Color( 0xffffff ) ) {\n\n\t\t/**\n\t\t * The flare's texture.\n\t\t *\n\t\t * @type {Texture}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The size in pixels.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.size = size;\n\n\t\t/**\n\t\t * The normalized distance (`[0,1]`) from the light source.\n\t\t * A value of `0` means the flare is located at light source.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.distance = distance;\n\n\t\t/**\n\t\t * The flare's color\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (1,1,1)\n\t\t */\n\t\tthis.color = color;\n\n\t}\n\n}\n\nLensflareElement.Shader = {\n\n\tname: 'LensflareElementShader',\n\n\tuniforms: {\n\n\t\t'map': { value: null },\n\t\t'occlusionMap': { value: null },\n\t\t'color': { value: null },\n\t\t'scale': { value: null },\n\t\t'screenPosition': { value: null }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n\n};\n\nLensflare.Geometry = ( function () {\n\n\tconst geometry = new BufferGeometry();\n\n\tconst float32Array = new Float32Array( [\n\t\t- 1, - 1, 0, 0, 0,\n\t\t1, - 1, 0, 1, 0,\n\t\t1, 1, 0, 1, 1,\n\t\t- 1, 1, 0, 0, 1\n\t] );\n\n\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\tgeometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\tgeometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\treturn geometry;\n\n} )();\n\nexport { Lensflare, LensflareElement };\n"],"mappings":"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","ignoreList":[]}