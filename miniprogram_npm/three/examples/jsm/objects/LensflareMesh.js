import{AdditiveBlending,Box2,BufferGeometry,Color,FramebufferTexture,InterleavedBuffer,InterleavedBufferAttribute,Mesh,MeshBasicNodeMaterial,NodeMaterial,UnsignedByteType,Vector2,Vector3,Vector4,Node}from"three/webgpu";import{texture,textureLoad,uv,ivec2,vec2,vec4,positionGeometry,reference,varyingProperty,materialReference,Fn}from"three/tsl";class LensflareMesh extends Mesh{constructor(){super(LensflareMesh.Geometry,new MeshBasicNodeMaterial({opacity:0,transparent:!0})),this.isLensflareMesh=!0,this.type="LensflareMesh",this.frustumCulled=!1,this.renderOrder=1/0;const e=new Vector3,t=new FramebufferTexture(16,16),r=new FramebufferTexture(16,16);let n=UnsignedByteType;const o=LensflareMesh.Geometry,s={scale:new Vector2,positionScreen:new Vector3},i=reference("scale","vec2",s),a=reference("positionScreen","vec3",s),c=vec4(positionGeometry.xy.mul(i).add(a.xy),a.z,1),d=new NodeMaterial;d.depthTest=!0,d.depthWrite=!1,d.transparent=!1,d.fog=!1,d.type="Lensflare-1a",d.vertexNode=c,d.colorNode=vec4(1,0,1,1);const l=new NodeMaterial;l.depthTest=!1,l.depthWrite=!1,l.transparent=!1,l.fog=!1,l.type="Lensflare-1b",l.vertexNode=c,l.colorNode=texture(t,vec2(uv().flipY()));const u=new Mesh(o,d),p=[],f=[],x=new NodeMaterial;x.transparent=!0,x.blending=AdditiveBlending,x.depthWrite=!1,x.depthTest=!1,x.fog=!1,x.type="Lensflare-2",x.screenPosition=new Vector3,x.scale=new Vector2,x.occlusionMap=r,x.vertexNode=Fn((({material:e})=>{const t=materialReference("scale","vec2"),r=materialReference("screenPosition","vec3"),n=e.occlusionMap,o=positionGeometry.xy.toVar(),s=textureLoad(n,ivec2(2,2)).toVar();s.addAssign(textureLoad(n,ivec2(8,2))),s.addAssign(textureLoad(n,ivec2(14,2))),s.addAssign(textureLoad(n,ivec2(14,8))),s.addAssign(textureLoad(n,ivec2(14,14))),s.addAssign(textureLoad(n,ivec2(8,14))),s.addAssign(textureLoad(n,ivec2(2,14))),s.addAssign(textureLoad(n,ivec2(2,8))),s.addAssign(textureLoad(n,ivec2(8,8)));const i=varyingProperty("float","vVisibility");return i.assign(s.r.div(9)),i.mulAssign(s.g.div(9).oneMinus()),i.mulAssign(s.b.div(9)),vec4(o.mul(t).add(r.xy).xy,r.z,1)}))(),x.colorNode=Fn((()=>{const e=reference("color","color"),t=reference("map","texture"),r=varyingProperty("float","vVisibility"),n=t.toVar();return n.a.mulAssign(r),n.rgb.mulAssign(e),n}))(),this.addElement=function(e){p.push(e)};const y=s.positionScreen,v=new Vector4(0,0,16,16),m=new Box2,h=new Vector4,g=new Node;this.onBeforeRender=(i,a,c)=>{i.getViewport(h),h.multiplyScalar(window.devicePixelRatio);const w=i.getRenderTarget(),M=null!==w?w.texture.type:UnsignedByteType;n!==M&&(t.dispose(),r.dispose(),t.type=r.type=M,n=M);const L=h.w/h.z,b=h.z/2,A=h.w/2,B=16/h.w;if(s.scale.set(B*L,B),m.min.set(h.x,h.y),m.max.set(h.x+(h.z-16),h.y+(h.w-16)),e.setFromMatrixPosition(this.matrixWorld),e.applyMatrix4(c.matrixWorldInverse),!(e.z>0)&&(y.copy(e).applyMatrix4(c.projectionMatrix),v.x=h.x+y.x*b+b-8,v.y=h.y-y.y*A+A-8,m.containsPoint(v))){i.copyFramebufferToTexture(t,v),i.renderObject(u,a,c,o,d,null,g),i.copyFramebufferToTexture(r,v),i.renderObject(u,a,c,o,l,null,g);const e=2*-y.x,n=2*-y.y;for(let t=0,r=p.length;t<r;t++){const r=p[t];let s=f[t];void 0===s&&(s=f[t]=new Mesh(o,x),s.color=r.color.convertSRGBToLinear(),s.map=r.texture),x.screenPosition.x=y.x+e*r.distance,x.screenPosition.y=y.y-n*r.distance,x.screenPosition.z=y.z;const d=r.size/h.w;x.scale.set(d*L,d),i.renderObject(s,a,c,o,x,null,g)}}},this.dispose=function(){d.dispose(),l.dispose(),x.dispose(),t.dispose(),r.dispose();for(let e=0,t=p.length;e<t;e++)p[e].texture.dispose()}}}class LensflareElement{constructor(e,t=1,r=0,n=new Color(16777215)){this.texture=e,this.size=t,this.distance=r,this.color=n}}LensflareMesh.Geometry=function(){const e=new BufferGeometry,t=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),r=new InterleavedBuffer(t,5);return e.setIndex([0,1,2,0,2,3]),e.setAttribute("position",new InterleavedBufferAttribute(r,3,0,!1)),e.setAttribute("uv",new InterleavedBufferAttribute(r,2,3,!1)),e}();export{LensflareMesh,LensflareElement};
//# sourceMappingURL=LensflareMesh.js.map