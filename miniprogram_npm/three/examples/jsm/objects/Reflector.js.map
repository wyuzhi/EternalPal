{"version":3,"file":"node_modules/three/examples/jsm/objects/Reflector.js","names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","Reflector","constructor","geometry","options","super","this","isReflector","type","forceUpdate","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","name","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","tDiffuse"],"sources":["node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType\n} from 'three';\n\n/**\n * Can be used to create a flat, reflective surface like a mirror.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ReflectorNode}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const reflector = new Reflector( geometry, {\n * \tclipBias: 0.003,\n * \ttextureWidth: window.innerWidth * window.devicePixelRatio,\n * \ttextureHeight: window.innerHeight * window.devicePixelRatio,\n * \tcolor: 0xc1cbcb\n * } );\n *\n * scene.add( reflector );\n * ```\n *\n * @augments Mesh\n * @three_import import { Reflector } from 'three/addons/objects/Reflector.js';\n */\nclass Reflector extends Mesh {\n\n\t/**\n\t * Constructs a new reflector.\n\t *\n\t * @param {BufferGeometry} geometry - The reflector's geometry.\n\t * @param {Reflector~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\n\t\t/**\n\t\t * Whether to force an update, no matter if the reflector\n\t\t * is in view or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.forceUpdate = false;\n\n\t\t/**\n\t\t * The reflector's virtual camera. This is used to render\n\t\t * the scene from the mirror's point of view.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away unless forcing an update\n\t\t\tconst isFacingAway = view.dot( normal ) > 0;\n\n\t\t\tif ( isFacingAway === true && this.forceUpdate === false ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\t\t\tthis.forceUpdate = false;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tname: 'ReflectorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\n\n/**\n * Constructor options of `Reflector`.\n *\n * @typedef {Object} Reflector~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Reflector };\n"],"mappings":"OACCA,MACAC,QACAC,KACAC,kBACAC,MACAC,eACAC,cACAC,QACAC,QACAC,kBACAC,kBACM,QAwBP,MAAMC,kBAAkBT,KAQvB,WAAAU,CAAaC,EAAUC,EAAU,CAAC,GAEjCC,MAAOF,GASPG,KAAKC,aAAc,EAEnBD,KAAKE,KAAO,YASZF,KAAKG,aAAc,EAQnBH,KAAKI,OAAS,IAAIjB,kBAElB,MAAMkB,EAAQL,KAERM,OAA4BC,IAAlBT,EAAQQ,MAAwB,IAAItB,MAAOc,EAAQQ,OAAU,IAAItB,MAAO,SAClFwB,EAAeV,EAAQU,cAAgB,IACvCC,EAAgBX,EAAQW,eAAiB,IACzCC,EAAWZ,EAAQY,UAAY,EAC/BC,EAASb,EAAQa,QAAUhB,UAAUiB,gBACrCC,OAAwCN,IAAxBT,EAAQe,YAA8Bf,EAAQe,YAAc,EAI5EC,EAAiB,IAAI1B,MACrB2B,EAAS,IAAIxB,QACbyB,EAAyB,IAAIzB,QAC7B0B,EAAsB,IAAI1B,QAC1B2B,EAAiB,IAAIjC,QACrBkC,EAAiB,IAAI5B,QAAS,EAAG,GAAK,GACtC6B,EAAY,IAAI5B,QAEhB6B,EAAO,IAAI9B,QACX+B,EAAS,IAAI/B,QACbgC,EAAI,IAAI/B,QAERgC,EAAgB,IAAIvC,QACpBwC,EAAgBzB,KAAKI,OAErBsB,EAAe,IAAIjC,kBAAmBe,EAAcC,EAAe,CAAEkB,QAASd,EAAaX,KAAMR,gBAEjGkC,EAAW,IAAIvC,eAAgB,CACpCwC,UAAwBtB,IAAhBI,EAAOkB,KAAuBlB,EAAOkB,KAAO,cACpDC,SAAUxC,cAAcyC,MAAOpB,EAAOmB,UACtCE,eAAgBrB,EAAOqB,eACvBC,aAActB,EAAOsB,eAGtBL,EAASE,SAAqB,SAAEI,MAAQR,EAAaS,QACrDP,EAASE,SAAkB,MAAEI,MAAQ5B,EACrCsB,EAASE,SAA0B,cAAEI,MAAQV,EAE7CxB,KAAK4B,SAAWA,EAEhB5B,KAAKoC,eAAiB,SAAWC,EAAUC,EAAOlC,GAEjDY,EAAuBuB,sBAAuBlC,EAAMmC,aACpDvB,EAAoBsB,sBAAuBnC,EAAOoC,aAElDtB,EAAeuB,gBAAiBpC,EAAMmC,aAEtCzB,EAAO2B,IAAK,EAAG,EAAG,GAClB3B,EAAO4B,aAAczB,GAErBG,EAAKuB,WAAY5B,EAAwBC,GAKzC,IAAsB,IAFDI,EAAKwB,IAAK9B,GAAW,IAES,IAArBf,KAAKG,YAAwB,OAE3DkB,EAAKyB,QAAS/B,GAASgC,SACvB1B,EAAK2B,IAAKhC,GAEVE,EAAeuB,gBAAiBrC,EAAOoC,aAEvCrB,EAAeuB,IAAK,EAAG,GAAK,GAC5BvB,EAAewB,aAAczB,GAC7BC,EAAe6B,IAAK/B,GAEpBK,EAAOsB,WAAY5B,EAAwBG,GAC3CG,EAAOwB,QAAS/B,GAASgC,SACzBzB,EAAO0B,IAAKhC,GAEZS,EAAcwB,SAASC,KAAM7B,GAC7BI,EAAc0B,GAAGT,IAAK,EAAG,EAAG,GAC5BjB,EAAc0B,GAAGR,aAAczB,GAC/BO,EAAc0B,GAAGL,QAAS/B,GAC1BU,EAAc2B,OAAQ9B,GAEtBG,EAAc4B,IAAMjD,EAAOiD,IAE3B5B,EAAc6B,oBACd7B,EAAc8B,iBAAiBL,KAAM9C,EAAOmD,kBAG5C/B,EAAckB,IACb,GAAK,EAAK,EAAK,GACf,EAAK,GAAK,EAAK,GACf,EAAK,EAAK,GAAK,GACf,EAAK,EAAK,EAAK,GAEhBlB,EAAcgC,SAAU/B,EAAc8B,kBACtC/B,EAAcgC,SAAU/B,EAAcgC,oBACtCjC,EAAcgC,SAAUnD,EAAMmC,aAI9B1B,EAAe4C,8BAA+B3C,EAAQC,GACtDF,EAAe6B,aAAclB,EAAcgC,oBAE3CrC,EAAUsB,IAAK5B,EAAeC,OAAO4C,EAAG7C,EAAeC,OAAO6C,EAAG9C,EAAeC,OAAO8C,EAAG/C,EAAegD,UAEzG,MAAMP,EAAmB9B,EAAc8B,iBAEvChC,EAAEoC,GAAMI,KAAKC,KAAM5C,EAAUuC,GAAMJ,EAAiBU,SAAU,IAAQV,EAAiBU,SAAU,GACjG1C,EAAEqC,GAAMG,KAAKC,KAAM5C,EAAUwC,GAAML,EAAiBU,SAAU,IAAQV,EAAiBU,SAAU,GACjG1C,EAAEsC,GAAM,EACRtC,EAAE2C,GAAM,EAAMX,EAAiBU,SAAU,KAASV,EAAiBU,SAAU,IAG7E7C,EAAU+C,eAAgB,EAAM/C,EAAUyB,IAAKtB,IAG/CgC,EAAiBU,SAAU,GAAM7C,EAAUuC,EAC3CJ,EAAiBU,SAAU,GAAM7C,EAAUwC,EAC3CL,EAAiBU,SAAU,IAAO7C,EAAUyC,EAAI,EAAMnD,EACtD6C,EAAiBU,SAAU,IAAO7C,EAAU8C,EAG5C7D,EAAM+D,SAAU,EAEhB,MAAMC,EAAsBhC,EAASiC,kBAE/BC,EAAmBlC,EAASmC,GAAGC,QAC/BC,EAA0BrC,EAASsC,UAAUC,WAEnDvC,EAASmC,GAAGC,SAAU,EACtBpC,EAASsC,UAAUC,YAAa,EAEhCvC,EAASwC,gBAAiBnD,GAE1BW,EAASyC,MAAMC,QAAQC,MAAMC,SAAS,IAEV,IAAvB5C,EAAS6C,WAAsB7C,EAAS8C,QAC7C9C,EAAS+C,OAAQ9C,EAAOb,GAExBY,EAASmC,GAAGC,QAAUF,EACtBlC,EAASsC,UAAUC,WAAaF,EAEhCrC,EAASwC,gBAAiBR,GAI1B,MAAMgB,EAAWjF,EAAOiF,cAEN9E,IAAb8E,GAEJhD,EAASyC,MAAMO,SAAUA,GAI1BhF,EAAM+D,SAAU,EAChBpE,KAAKG,aAAc,CAEpB,EAOAH,KAAKsE,gBAAkB,WAEtB,OAAO5C,CAER,EAMA1B,KAAKsF,QAAU,WAEd5D,EAAa4D,UACbjF,EAAMuB,SAAS0D,SAEhB,CAED,EAID3F,UAAUiB,gBAAkB,CAE3BiB,KAAM,kBAENC,SAAU,CAETxB,MAAS,CACR4B,MAAO,MAGRqD,SAAY,CACXrD,MAAO,MAGRV,cAAiB,CAChBU,MAAO,OAKTD,aAAwB,0UAiBxBD,eAA0B,0vBA4ClBrC","ignoreList":[]}