{"version":3,"file":"node_modules/three/examples/jsm/objects/ReflectorForSSRPass.js","names":["Color","Matrix4","Mesh","PerspectiveCamera","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","DepthTexture","UnsignedShortType","NearestFilter","Plane","HalfFloatType","ReflectorForSSRPass","constructor","geometry","options","super","this","isReflectorForSSRPass","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","renderTarget","name","transparent","assign","clone","fragmentShader","vertexShader","texture","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["node_modules/three/examples/jsm/objects/ReflectorForSSRPass.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget,\n\tDepthTexture,\n\tUnsignedShortType,\n\tNearestFilter,\n\tPlane,\n\tHalfFloatType\n} from 'three';\n\n/**\n * A special version of {@link Reflector} for usage with {@link SSRPass}.\n *\n * @augments Mesh\n * @three_import import { ReflectorForSSRPass } from 'three/addons/objects/ReflectorForSSRPass.js';\n */\nclass ReflectorForSSRPass extends Mesh {\n\n\t/**\n\t * Constructs a new reflector.\n\t *\n\t * @param {BufferGeometry} geometry - The reflector's geometry.\n\t * @param {ReflectorForSSRPass~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflectorForSSRPass = true;\n\n\t\tthis.type = 'ReflectorForSSRPass';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n\t\tconst useDepthTexture = options.useDepthTexture === true;\n\t\tconst yAxis = new Vector3( 0, 1, 0 );\n\t\tconst vecTemp0 = new Vector3();\n\t\tconst vecTemp1 = new Vector3();\n\n\t\t//\n\n\t\tscope.needsUpdate = false;\n\t\tscope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n\t\tscope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n\t\tscope.color = color;\n\t\tscope.resolution = options.resolution || new Vector2( window.innerWidth, window.innerHeight );\n\n\n\t\tscope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n\t\tObject.defineProperty( scope, 'distanceAttenuation', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._distanceAttenuation;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._distanceAttenuation === val ) return;\n\t\t\t\tscope._distanceAttenuation = val;\n\t\t\t\tscope.material.defines.DISTANCE_ATTENUATION = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tscope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n\t\tObject.defineProperty( scope, 'fresnel', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._fresnel;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._fresnel === val ) return;\n\t\t\t\tscope._fresnel = val;\n\t\t\t\tscope.material.defines.FRESNEL = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tlet depthTexture;\n\n\t\tif ( useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.type = UnsignedShortType;\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\n\t\t}\n\n\t\tconst parameters = {\n\t\t\tdepthTexture: useDepthTexture ? depthTexture : null,\n\t\t\ttype: HalfFloatType\n\t\t};\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\ttransparent: useDepthTexture,\n\t\t\tdefines: Object.assign( {}, ReflectorForSSRPass.ReflectorShader.defines, {\n\t\t\t\tuseDepthTexture\n\t\t\t} ),\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\t\tif ( useDepthTexture ) {\n\n\t\t\tmaterial.uniforms[ 'tDepth' ].value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tthis.material = material;\n\n\t\tconst globalPlane = new Plane( new Vector3( 0, 1, 0 ), clipBias );\n\t\tconst globalPlanes = [ globalPlane ];\n\n\t\tthis.doRender = function ( renderer, scene, camera ) {\n\n\t\t\tmaterial.uniforms[ 'maxDistance' ].value = scope.maxDistance;\n\t\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\t\tmaterial.uniforms[ 'opacity' ].value = scope.opacity;\n\n\t\t\tvecTemp0.copy( camera.position ).normalize();\n\t\t\tvecTemp1.copy( vecTemp0 ).reflect( yAxis );\n\t\t\tmaterial.uniforms[ 'fresnelCoe' ].value = ( vecTemp0.dot( vecTemp1 ) + 1. ) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tmaterial.uniforms[ 'virtualCameraNear' ].value = camera.near;\n\t\t\tmaterial.uniforms[ 'virtualCameraFar' ].value = camera.far;\n\t\t\tmaterial.uniforms[ 'virtualCameraMatrixWorld' ].value = virtualCamera.matrixWorld;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrix' ].value = camera.projectionMatrix;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrixInverse' ].value = camera.projectionMatrixInverse;\n\t\t\tmaterial.uniforms[ 'resolution' ].value = scope.resolution;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// scope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentClippingPlanes = renderer.clippingPlanes;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.clippingPlanes = globalPlanes;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.clippingPlanes = currentClippingPlanes;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\t// scope.visible = true;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflectorForSSRPass.ReflectorShader = {\n\n\tname: 'ReflectorShader',\n\n\tdefines: {\n\t\tDISTANCE_ATTENUATION: true,\n\t\tFRESNEL: true,\n\t},\n\n\tuniforms: {\n\n\t\tcolor: { value: null },\n\t\ttDiffuse: { value: null },\n\t\ttDepth: { value: null },\n\t\ttextureMatrix: { value: new Matrix4() },\n\t\tmaxDistance: { value: 180 },\n\t\topacity: { value: 0.5 },\n\t\tfresnelCoe: { value: null },\n\t\tvirtualCameraNear: { value: null },\n\t\tvirtualCameraFar: { value: null },\n\t\tvirtualCameraProjectionMatrix: { value: new Matrix4() },\n\t\tvirtualCameraMatrixWorld: { value: new Matrix4() },\n\t\tvirtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n\t\tresolution: { value: new Vector2() },\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n};\n\n/**\n * Constructor options of `ReflectorForSSRPass`.\n *\n * @typedef {Object} ReflectorForSSRPass~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {boolean} [useDepthTexture=true] - Whether to store depth values in a texture or not.\n **/\n\nexport { ReflectorForSSRPass };\n"],"mappings":"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","ignoreList":[]}