{"version":3,"file":"node_modules/three/examples/jsm/objects/Refractor.js","names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","Quaternion","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","Refractor","constructor","geometry","options","super","this","isRefractor","type","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","name","uniforms","clone","vertexShader","fragmentShader","transparent","value","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","onBeforeRender","renderer","scene","multiply","updateTextureMatrix","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","dispose","tDiffuse"],"sources":["node_modules/three/examples/jsm/objects/Refractor.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tQuaternion,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType\n} from 'three';\n\n/**\n * Can be used to create a flat, refractive surface like for special\n * windows or water effects.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link viewportSharedTexture}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const refractor = new Refractor( refractorGeometry, {\n * \tcolor: 0xcbcbcb,\n * \ttextureWidth: 1024,\n * \ttextureHeight: 1024\n * } );\n *\n * scene.add( refractor );\n * ```\n *\n * @augments Mesh\n * @three_import import { Refractor } from 'three/addons/objects/Refractor.js';\n */\nclass Refractor extends Mesh {\n\n\t/**\n\t * Constructs a new refractor.\n\t *\n\t * @param {BufferGeometry} geometry - The refractor's geometry.\n\t * @param {Refractor~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRefractor = true;\n\n\t\tthis.type = 'Refractor';\n\n\t\t/**\n\t\t * The reflector's virtual camera.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Refractor.RefractorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst virtualCamera = this.camera;\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tconst refractorPlane = new Plane();\n\t\tconst textureMatrix = new Matrix4();\n\n\t\t// render target\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\t// material\n\n\t\tthis.material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ 'color' ].value = color;\n\t\tthis.material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tconst visible = ( function () {\n\n\t\t\tconst refractorWorldPosition = new Vector3();\n\t\t\tconst cameraWorldPosition = new Vector3();\n\t\t\tconst rotationMatrix = new Matrix4();\n\n\t\t\tconst view = new Vector3();\n\t\t\tconst normal = new Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateRefractorPlane = ( function () {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst position = new Vector3();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateVirtualCamera = ( function () {\n\n\t\t\tconst clipPlane = new Plane();\n\t\t\tconst clipVector = new Vector4();\n\t\t\tconst q = new Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.copy( virtualCamera.matrixWorld ).invert();\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nRefractor.RefractorShader = {\n\n\tname: 'RefractorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n\n};\n\n/**\n * Constructor options of `Refractor`.\n *\n * @typedef {Object} Refractor~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The refractor's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Refractor };\n"],"mappings":"OACCA,MACAC,QACAC,KACAC,kBACAC,MACAC,WACAC,eACAC,cACAC,QACAC,QACAC,kBACAC,kBACM,QAwBP,MAAMC,kBAAkBV,KAQvB,WAAAW,CAAaC,EAAUC,EAAU,CAAC,GAEjCC,MAAOF,GASPG,KAAKC,aAAc,EAEnBD,KAAKE,KAAO,YAOZF,KAAKG,OAAS,IAAIjB,kBAElB,MAAMkB,EAAQJ,KAERK,OAA4BC,IAAlBR,EAAQO,MAAwB,IAAItB,MAAOe,EAAQO,OAAU,IAAItB,MAAO,SAClFwB,EAAeT,EAAQS,cAAgB,IACvCC,EAAgBV,EAAQU,eAAiB,IACzCC,EAAWX,EAAQW,UAAY,EAC/BC,EAASZ,EAAQY,QAAUf,UAAUgB,gBACrCC,OAAwCN,IAAxBR,EAAQc,YAA8Bd,EAAQc,YAAc,EAI5EC,EAAgBb,KAAKG,OAC3BU,EAAcC,kBAAmB,EACjCD,EAAcE,SAASC,WAAY,EAInC,MAAMC,EAAiB,IAAI9B,MACrB+B,EAAgB,IAAIlC,QAIpBmC,EAAe,IAAI1B,kBAAmBc,EAAcC,EAAe,CAAEY,QAASR,EAAaV,KAAMR,gBAIvGM,KAAKqB,SAAW,IAAIhC,eAAgB,CACnCiC,UAAwBhB,IAAhBI,EAAOY,KAAuBZ,EAAOY,KAAO,cACpDC,SAAUjC,cAAckC,MAAOd,EAAOa,UACtCE,aAAcf,EAAOe,aACrBC,eAAgBhB,EAAOgB,eACvBC,aAAa,IAGd3B,KAAKqB,SAASE,SAAkB,MAAEK,MAAQvB,EAC1CL,KAAKqB,SAASE,SAAqB,SAAEK,MAAQT,EAAaU,QAC1D7B,KAAKqB,SAASE,SAA0B,cAAEK,MAAQV,EAIlD,MAAMY,EAAU,WAEf,MAAMC,EAAyB,IAAIxC,QAC7ByC,EAAsB,IAAIzC,QAC1B0C,EAAiB,IAAIjD,QAErBkD,EAAO,IAAI3C,QACX4C,EAAS,IAAI5C,QAEnB,OAAO,SAAkBY,GAYxB,OAVA4B,EAAuBK,sBAAuBhC,EAAMiC,aACpDL,EAAoBI,sBAAuBjC,EAAOkC,aAElDH,EAAKI,WAAYP,EAAwBC,GAEzCC,EAAeM,gBAAiBnC,EAAMiC,aAEtCF,EAAOK,IAAK,EAAG,EAAG,GAClBL,EAAOM,aAAcR,GAEdC,EAAKQ,IAAKP,GAAW,CAE7B,CAEC,CAzBc,GA2BVQ,EAAuB,WAE5B,MAAMR,EAAS,IAAI5C,QACbqD,EAAW,IAAIrD,QACfsD,EAAa,IAAIzD,WACjB0D,EAAQ,IAAIvD,QAElB,OAAO,WAENa,EAAMiC,YAAYU,UAAWH,EAAUC,EAAYC,GACnDX,EAAOK,IAAK,EAAG,EAAG,GAAIQ,gBAAiBH,GAAaI,YAIpDd,EAAOe,SAEPjC,EAAekC,8BAA+BhB,EAAQS,EAEvD,CAEC,CApB2B,GAsBvBQ,EAAsB,WAE3B,MAAMC,EAAY,IAAIlE,MAChBmE,EAAa,IAAI9D,QACjB+D,EAAI,IAAI/D,QAEd,OAAO,SAA8BW,GAEpCU,EAAcwB,YAAYmB,KAAMrD,EAAOkC,aACvCxB,EAAc4C,mBAAmBD,KAAM3C,EAAcwB,aAAcqB,SACnE7C,EAAc8C,iBAAiBH,KAAMrD,EAAOwD,kBAC5C9C,EAAc+C,IAAMzD,EAAOyD,IAM3BP,EAAUG,KAAMvC,GAChBoC,EAAUZ,aAAc5B,EAAc4C,oBAEtCH,EAAWd,IAAKa,EAAUlB,OAAO0B,EAAGR,EAAUlB,OAAO2B,EAAGT,EAAUlB,OAAO4B,EAAGV,EAAUW,UAKtF,MAAML,EAAmB9C,EAAc8C,iBAEvCJ,EAAEM,GAAMI,KAAKC,KAAMZ,EAAWO,GAAMF,EAAiBQ,SAAU,IAAQR,EAAiBQ,SAAU,GAClGZ,EAAEO,GAAMG,KAAKC,KAAMZ,EAAWQ,GAAMH,EAAiBQ,SAAU,IAAQR,EAAiBQ,SAAU,GAClGZ,EAAEQ,GAAM,EACRR,EAAEa,GAAM,EAAMT,EAAiBQ,SAAU,KAASR,EAAiBQ,SAAU,IAI7Eb,EAAWe,eAAgB,EAAMf,EAAWZ,IAAKa,IAIjDI,EAAiBQ,SAAU,GAAMb,EAAWO,EAC5CF,EAAiBQ,SAAU,GAAMb,EAAWQ,EAC5CH,EAAiBQ,SAAU,IAAOb,EAAWS,EAAI,EAAMtD,EACvDkD,EAAiBQ,SAAU,IAAOb,EAAWc,CAE9C,CAEC,CA7C0B,GA4G5BpE,KAAKsE,eAAiB,SAAWC,EAAUC,EAAOrE,IAId,IAA9BA,EAAOY,SAASC,YAIQ,IAAtBc,EAAS3B,KAIhBwC,IAtED,SAA8BxC,GAI7Be,EAAcsB,IACb,GAAK,EAAK,EAAK,GACf,EAAK,GAAK,EAAK,GACf,EAAK,EAAK,GAAK,GACf,EAAK,EAAK,EAAK,GAOhBtB,EAAcuD,SAAUtE,EAAOwD,kBAC/BzC,EAAcuD,SAAUtE,EAAOsD,oBAC/BvC,EAAcuD,SAAUrE,EAAMiC,YAE/B,CAqDCqC,CAAqBvE,GAErBiD,EAAqBjD,GAnDtB,SAAiBoE,EAAUC,EAAOrE,GAEjCC,EAAM0B,SAAU,EAEhB,MAAM6C,EAAsBJ,EAASK,kBAC/BC,EAAmBN,EAASO,GAAGC,QAC/BC,EAA0BT,EAASU,UAAUC,WAEnDX,EAASO,GAAGC,SAAU,EACtBR,EAASU,UAAUC,YAAa,EAEhCX,EAASY,gBAAiBhE,IACE,IAAvBoD,EAASa,WAAsBb,EAASc,QAC7Cd,EAASe,OAAQd,EAAO3D,GAExB0D,EAASO,GAAGC,QAAUF,EACtBN,EAASU,UAAUC,WAAaF,EAChCT,EAASY,gBAAiBR,GAI1B,MAAMY,EAAWpF,EAAOoF,cAENjF,IAAbiF,GAEJhB,EAASiB,MAAMD,SAAUA,GAI1BnF,EAAM0B,SAAU,CAEjB,CAsBCwD,CAAQf,EAAUC,EAAOrE,GAE1B,EAOAH,KAAK4E,gBAAkB,WAEtB,OAAOzD,CAER,EAMAnB,KAAKyF,QAAU,WAEdtE,EAAasE,UACbrF,EAAMiB,SAASoE,SAEhB,CAED,EAID9F,UAAUgB,gBAAkB,CAE3BW,KAAM,kBAENC,SAAU,CAETlB,MAAS,CACRuB,MAAO,MAGR8D,SAAY,CACX9D,MAAO,MAGRV,cAAiB,CAChBU,MAAO,OAKTH,aAAwB,oOAaxBC,eAA0B,yqBA2ClB/B","ignoreList":[]}