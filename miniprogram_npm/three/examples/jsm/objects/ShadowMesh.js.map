{"version":3,"file":"node_modules/three/examples/jsm/objects/ShadowMesh.js","names":["Matrix4","Mesh","MeshBasicMaterial","EqualStencilFunc","IncrementStencilOp","_shadowMatrix","ShadowMesh","constructor","mesh","shadowMaterial","color","transparent","opacity","depthWrite","stencilWrite","stencilFunc","stencilRef","stencilZPass","super","geometry","this","isShadowMesh","meshMatrix","matrixWorld","frustumCulled","matrixAutoUpdate","update","plane","lightPosition4D","dot","normal","x","y","z","constant","w","sme","elements","matrix","multiplyMatrices"],"sources":["node_modules/three/examples/jsm/objects/ShadowMesh.js"],"sourcesContent":["import {\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tEqualStencilFunc,\n\tIncrementStencilOp\n} from 'three';\n\nconst _shadowMatrix = new Matrix4();\n\n/**\n * A Shadow Mesh that follows a shadow-casting mesh in the scene,\n * but is confined to a single plane. This technique can be used as\n * a very performant alternative to classic shadow mapping. However,\n * it has serious limitations like:\n *\n * - Shadows can only be casted on flat planes.\n * - No soft shadows support.\n *\n * ```js\n * const cubeShadow = new ShadowMesh( cube );\n * scene.add( cubeShadow );\n * ```\n *\n * @augments Mesh\n * @three_import import { ShadowMesh } from 'three/addons/objects/ShadowMesh.js';\n */\nclass ShadowMesh extends Mesh {\n\n\t/**\n\t * Constructs a new shadow mesh.\n\t *\n\t * @param {Mesh} mesh - The shadow-casting reference mesh.\n\t */\n\tconstructor( mesh ) {\n\n\t\tconst shadowMaterial = new MeshBasicMaterial( {\n\n\t\t\tcolor: 0x000000,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.6,\n\t\t\tdepthWrite: false,\n\t\t\tstencilWrite: true,\n\t\t\tstencilFunc: EqualStencilFunc,\n\t\t\tstencilRef: 0,\n\t\t\tstencilZPass: IncrementStencilOp\n\n\t\t} );\n\n\t\tsuper( mesh.geometry, shadowMaterial );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowMesh = true;\n\n\t\t/**\n\t\t * Represent the world matrix of the reference mesh.\n\t\t *\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis.meshMatrix = mesh.matrixWorld;\n\n\t\t/**\n\t\t * Overwritten to disable view-frustum culling by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.frustumCulled = false;\n\n\t\t/**\n\t\t * Overwritten to disable automatic matrix update. The local\n\t\t * matrix is computed manually in {@link ShadowMesh#update}.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\t/**\n\t * Updates the shadow mesh so it follows its shadow-casting reference mesh.\n\t *\n\t * @param {Plane} plane - The plane onto the shadow mesh is projected.\n\t * @param {Vector4} lightPosition4D - The light position.\n\t */\n\tupdate( plane, lightPosition4D ) {\n\n\t\t// based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm\n\n\t\tconst dot = plane.normal.x * lightPosition4D.x +\n\t\t\t  plane.normal.y * lightPosition4D.y +\n\t\t\t  plane.normal.z * lightPosition4D.z +\n\t\t\t  - plane.constant * lightPosition4D.w;\n\n\t\tconst sme = _shadowMatrix.elements;\n\n\t\tsme[ 0 ] = dot - lightPosition4D.x * plane.normal.x;\n\t\tsme[ 4 ] = - lightPosition4D.x * plane.normal.y;\n\t\tsme[ 8 ] = - lightPosition4D.x * plane.normal.z;\n\t\tsme[ 12 ] = - lightPosition4D.x * - plane.constant;\n\n\t\tsme[ 1 ] = - lightPosition4D.y * plane.normal.x;\n\t\tsme[ 5 ] = dot - lightPosition4D.y * plane.normal.y;\n\t\tsme[ 9 ] = - lightPosition4D.y * plane.normal.z;\n\t\tsme[ 13 ] = - lightPosition4D.y * - plane.constant;\n\n\t\tsme[ 2 ] = - lightPosition4D.z * plane.normal.x;\n\t\tsme[ 6 ] = - lightPosition4D.z * plane.normal.y;\n\t\tsme[ 10 ] = dot - lightPosition4D.z * plane.normal.z;\n\t\tsme[ 14 ] = - lightPosition4D.z * - plane.constant;\n\n\t\tsme[ 3 ] = - lightPosition4D.w * plane.normal.x;\n\t\tsme[ 7 ] = - lightPosition4D.w * plane.normal.y;\n\t\tsme[ 11 ] = - lightPosition4D.w * plane.normal.z;\n\t\tsme[ 15 ] = dot - lightPosition4D.w * - plane.constant;\n\n\t\tthis.matrix.multiplyMatrices( _shadowMatrix, this.meshMatrix );\n\n\t}\n\n}\n\nexport { ShadowMesh };\n"],"mappings":"OACCA,QACAC,KACAC,kBACAC,iBACAC,uBACM,QAEP,MAAMC,cAAgB,IAAIL,QAmB1B,MAAMM,mBAAmBL,KAOxB,WAAAM,CAAaC,GAEZ,MAAMC,EAAiB,IAAIP,kBAAmB,CAE7CQ,MAAO,EACPC,aAAa,EACbC,QAAS,GACTC,YAAY,EACZC,cAAc,EACdC,YAAaZ,iBACba,WAAY,EACZC,aAAcb,qBAIfc,MAAOV,EAAKW,SAAUV,GAStBW,KAAKC,cAAe,EAOpBD,KAAKE,WAAad,EAAKe,YAQvBH,KAAKI,eAAgB,EASrBJ,KAAKK,kBAAmB,CAEzB,CAQA,MAAAC,CAAQC,EAAOC,GAId,MAAMC,EAAMF,EAAMG,OAAOC,EAAIH,EAAgBG,EAC1CJ,EAAMG,OAAOE,EAAIJ,EAAgBI,EACjCL,EAAMG,OAAOG,EAAIL,EAAgBK,GAC/BN,EAAMO,SAAWN,EAAgBO,EAEhCC,EAAM/B,cAAcgC,SAE1BD,EAAK,GAAMP,EAAMD,EAAgBG,EAAIJ,EAAMG,OAAOC,EAClDK,EAAK,IAAQR,EAAgBG,EAAIJ,EAAMG,OAAOE,EAC9CI,EAAK,IAAQR,EAAgBG,EAAIJ,EAAMG,OAAOG,EAC9CG,EAAK,KAASR,EAAgBG,GAAMJ,EAAMO,SAE1CE,EAAK,IAAQR,EAAgBI,EAAIL,EAAMG,OAAOC,EAC9CK,EAAK,GAAMP,EAAMD,EAAgBI,EAAIL,EAAMG,OAAOE,EAClDI,EAAK,IAAQR,EAAgBI,EAAIL,EAAMG,OAAOG,EAC9CG,EAAK,KAASR,EAAgBI,GAAML,EAAMO,SAE1CE,EAAK,IAAQR,EAAgBK,EAAIN,EAAMG,OAAOC,EAC9CK,EAAK,IAAQR,EAAgBK,EAAIN,EAAMG,OAAOE,EAC9CI,EAAK,IAAOP,EAAMD,EAAgBK,EAAIN,EAAMG,OAAOG,EACnDG,EAAK,KAASR,EAAgBK,GAAMN,EAAMO,SAE1CE,EAAK,IAAQR,EAAgBO,EAAIR,EAAMG,OAAOC,EAC9CK,EAAK,IAAQR,EAAgBO,EAAIR,EAAMG,OAAOE,EAC9CI,EAAK,KAASR,EAAgBO,EAAIR,EAAMG,OAAOG,EAC/CG,EAAK,IAAOP,EAAMD,EAAgBO,GAAMR,EAAMO,SAE9Cd,KAAKkB,OAAOC,iBAAkBlC,cAAee,KAAKE,WAEnD,SAIQhB","ignoreList":[]}