{"version":3,"file":"node_modules/three/examples/jsm/objects/Water2.js","names":["Clock","Color","Matrix4","Mesh","RepeatWrapping","ShaderMaterial","TextureLoader","UniformsLib","UniformsUtils","Vector2","Vector4","Reflector","Refractor","Water","constructor","geometry","options","super","this","isWater","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","name","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","onBeforeRender","renderer","scene","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateTextureMatrix","delta","getDelta","config","updateFlow","visible","copy","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"sources":["node_modules/three/examples/jsm/objects/Water2.js"],"sourcesContent":["import {\n\tClock,\n\tColor,\n\tMatrix4,\n\tMesh,\n\tRepeatWrapping,\n\tShaderMaterial,\n\tTextureLoader,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2,\n\tVector4\n} from 'three';\nimport { Reflector } from '../objects/Reflector.js';\nimport { Refractor } from '../objects/Refractor.js';\n\n/** @module Water2 */\n\n/**\n * An advanced water effect that supports reflections, refractions and flow maps.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link module:Water2Mesh}.\n *\n * References:\n *\n * - {@link https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf}\n * - {@link http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html}\n *\n * @augments Mesh\n * @three_import import { Water } from 'three/addons/objects/Water2.js';\n */\nclass Water extends Mesh {\n\n\t/**\n\t * Constructs a new water instance.\n\t *\n\t * @param {BufferGeometry} geometry - The water's geometry.\n\t * @param {module:Water2~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWater = true;\n\n\t\tthis.type = 'Water';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );\n\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0;\n\t\tconst flowDirection = options.flowDirection !== undefined ? options.flowDirection : new Vector2( 1, 0 );\n\t\tconst flowSpeed = options.flowSpeed !== undefined ? options.flowSpeed : 0.03;\n\t\tconst reflectivity = options.reflectivity !== undefined ? options.reflectivity : 0.02;\n\t\tconst scale = options.scale !== undefined ? options.scale : 1;\n\t\tconst shader = options.shader !== undefined ? options.shader : Water.WaterShader;\n\n\t\tconst textureLoader = new TextureLoader();\n\n\t\tconst flowMap = options.flowMap || undefined;\n\t\tconst normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\t\tconst normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );\n\n\t\tconst cycle = 0.15; // a cycle of a flow map phase\n\t\tconst halfCycle = cycle * 0.5;\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst clock = new Clock();\n\n\t\t// internal components\n\n\t\tif ( Reflector === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component Reflector not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( Refractor === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component Refractor not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst reflector = new Reflector( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias\n\t\t} );\n\n\t\tconst refractor = new Refractor( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias\n\t\t} );\n\n\t\treflector.matrixAutoUpdate = false;\n\t\trefractor.matrixAutoUpdate = false;\n\n\t\t// material\n\n\t\tthis.material = new ShaderMaterial( {\n\t\t\tname: shader.name,\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\tshader.uniforms\n\t\t\t] ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tfog: true\n\t\t} );\n\n\t\tif ( flowMap !== undefined ) {\n\n\t\t\tthis.material.defines.USE_FLOWMAP = '';\n\t\t\tthis.material.uniforms[ 'tFlowMap' ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: flowMap\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis.material.uniforms[ 'flowDirection' ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: flowDirection\n\t\t\t};\n\n\t\t}\n\n\t\t// maps\n\n\t\tnormalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n\t\tnormalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n\n\t\tthis.material.uniforms[ 'tReflectionMap' ].value = reflector.getRenderTarget().texture;\n\t\tthis.material.uniforms[ 'tRefractionMap' ].value = refractor.getRenderTarget().texture;\n\t\tthis.material.uniforms[ 'tNormalMap0' ].value = normalMap0;\n\t\tthis.material.uniforms[ 'tNormalMap1' ].value = normalMap1;\n\n\t\t// water\n\n\t\tthis.material.uniforms[ 'color' ].value = color;\n\t\tthis.material.uniforms[ 'reflectivity' ].value = reflectivity;\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\t// initial values\n\n\t\tthis.material.uniforms[ 'config' ].value.x = 0; // flowMapOffset0\n\t\tthis.material.uniforms[ 'config' ].value.y = halfCycle; // flowMapOffset1\n\t\tthis.material.uniforms[ 'config' ].value.z = halfCycle; // halfCycle\n\t\tthis.material.uniforms[ 'config' ].value.w = scale; // scale\n\n\t\t// functions\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\tfunction updateFlow() {\n\n\t\t\tconst delta = clock.getDelta();\n\t\t\tconst config = scope.material.uniforms[ 'config' ];\n\n\t\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\n\t\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\n\n\t\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\n\t\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\n\t\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n\t\t\tif ( config.value.x >= cycle ) {\n\n\t\t\t\tconfig.value.x = 0;\n\t\t\t\tconfig.value.y = halfCycle;\n\n\t\t\t} else if ( config.value.y >= cycle ) {\n\n\t\t\t\tconfig.value.y = config.value.y - cycle;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tupdateTextureMatrix( camera );\n\t\t\tupdateFlow();\n\n\t\t\tscope.visible = false;\n\n\t\t\treflector.matrixWorld.copy( scope.matrixWorld );\n\t\t\trefractor.matrixWorld.copy( scope.matrixWorld );\n\n\t\t\treflector.onBeforeRender( renderer, scene, camera );\n\t\t\trefractor.onBeforeRender( renderer, scene, camera );\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t}\n\n}\n\nWater.WaterShader = {\n\n\tname: 'WaterShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'reflectivity': {\n\t\t\ttype: 'f',\n\t\t\tvalue: 0\n\t\t},\n\n\t\t'tReflectionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tRefractionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap0': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap1': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\ttype: 'm4',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'config': {\n\t\t\ttype: 'v4',\n\t\t\tvalue: new Vector4()\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n\n};\n\n/**\n * Constructor options of `Water`.\n *\n * @typedef {Object} module:Water2~Options\n * @property {number|Color|string} [color=0xFFFFFF] - The water color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in better quality but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in better quality but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Vector2} [flowDirection=(1,0)] - The water's flow direction.\n * @property {number} [flowSpeed=0.03] - The water's flow speed.\n * @property {number} [reflectivity=0.02] - The water's reflectivity.\n * @property {number} [scale=1] - The water's scale.\n * @property {Object} [shader] - A custom water shader.\n * @property {?Texture} [flowMap=null] - The flow map. If no flow map is assigned, the water flow is defined by `flowDirection`.\n * @property {?Texture} [normalMap0] - The first water normal map.\n * @property {?Texture} [normalMap1] -  The second water normal map.\n **/\n\nexport { Water };\n"],"mappings":"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","ignoreList":[]}