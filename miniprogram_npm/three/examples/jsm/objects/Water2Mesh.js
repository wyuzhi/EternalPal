import{Color,Mesh,Vector2,Vector3,NodeMaterial,NodeUpdateType,TempNode}from"three/webgpu";import{Fn,vec2,viewportSafeUV,viewportSharedTexture,reflector,pow,float,abs,texture,uniform,vec4,cameraPosition,positionWorld,uv,mix,vec3,normalize,max,dot,screenUV}from"three/tsl";class WaterMesh extends Mesh{constructor(e,o={}){const t=new NodeMaterial;t.transparent=!0,super(e,t),this.isWater=!0,t.colorNode=new WaterNode(o,this)}}class WaterNode extends TempNode{constructor(e,o){super("vec4"),this.waterBody=o,this.normalMap0=texture(e.normalMap0),this.normalMap1=texture(e.normalMap1),this.flowMap=texture(void 0!==e.flowMap?e.flowMap:null),this.color=uniform(void 0!==e.color?new Color(e.color):new Color(16777215)),this.flowDirection=uniform(void 0!==e.flowDirection?e.flowDirection:new Vector2(1,0)),this.flowSpeed=uniform(void 0!==e.flowSpeed?e.flowSpeed:.03),this.reflectivity=uniform(void 0!==e.reflectivity?e.reflectivity:.02),this.scale=uniform(void 0!==e.scale?e.scale:1),this.flowConfig=uniform(new Vector3),this.updateBeforeType=NodeUpdateType.RENDER,this._cycle=.15,this._halfCycle=.5*this._cycle,this._USE_FLOW=void 0!==e.flowMap}updateFlow(e){this.flowConfig.value.x+=this.flowSpeed.value*e,this.flowConfig.value.y=this.flowConfig.value.x+this._halfCycle,this.flowConfig.value.x>=this._cycle?(this.flowConfig.value.x=0,this.flowConfig.value.y=this._halfCycle):this.flowConfig.value.y>=this._cycle&&(this.flowConfig.value.y=this.flowConfig.value.y-this._cycle),this.flowConfig.value.z=this._halfCycle}updateBefore(e){this.updateFlow(e.deltaTime)}setup(){return Fn((()=>{const e=this.flowConfig.x,o=this.flowConfig.y,t=this.flowConfig.z,i=normalize(cameraPosition.sub(positionWorld));let l;l=!0===this._USE_FLOW?this.flowMap.rg.mul(2).sub(1):vec2(this.flowDirection.x,this.flowDirection.y),l.x.mulAssign(-1);const s=uv(),r=s.mul(this.scale).add(l.mul(e)),a=s.mul(this.scale).add(l.mul(o)),f=this.normalMap0.sample(r),n=this.normalMap1.sample(a),h=abs(t.sub(e)).div(t),c=mix(f,n,h),u=normalize(vec3(c.r.mul(2).sub(1),c.b,c.g.mul(2).sub(1))),d=max(dot(i,u),0),w=pow(float(1).sub(d),5).mul(float(1).sub(this.reflectivity)).add(this.reflectivity),p=u.xz.mul(.05).toVar(),m=reflector();this.waterBody.add(m.target),m.uvNode=m.uvNode.add(p);const v=screenUV.add(p),y=viewportSharedTexture(viewportSafeUV(v));return vec4(this.color,1).mul(mix(y,m,w))}))()}}export{WaterMesh};
//# sourceMappingURL=Water2Mesh.js.map