{"version":3,"file":"node_modules/three/examples/jsm/objects/Water2Mesh.js","names":["Color","Mesh","Vector2","Vector3","NodeMaterial","NodeUpdateType","TempNode","Fn","vec2","viewportSafeUV","viewportSharedTexture","reflector","pow","float","abs","texture","uniform","vec4","cameraPosition","positionWorld","uv","mix","vec3","normalize","max","dot","screenUV","WaterMesh","constructor","geometry","options","material","transparent","super","this","isWater","colorNode","WaterNode","waterBody","normalMap0","normalMap1","flowMap","undefined","color","flowDirection","flowSpeed","reflectivity","scale","flowConfig","updateBeforeType","RENDER","_cycle","_halfCycle","_USE_FLOW","updateFlow","delta","value","x","y","z","updateBefore","frame","deltaTime","setup","flowMapOffset0","flowMapOffset1","halfCycle","toEye","sub","flow","rg","mul","mulAssign","uvs","normalUv0","add","normalUv1","normalColor0","sample","normalColor1","flowLerp","div","normalColor","normal","r","b","g","theta","reflectance","offset","xz","toVar","reflectionSampler","target","uvNode","refractorUV","refractionSampler"],"sources":["node_modules/three/examples/jsm/objects/Water2Mesh.js"],"sourcesContent":["import {\n\tColor,\n\tMesh,\n\tVector2,\n\tVector3,\n\tNodeMaterial,\n\tNodeUpdateType,\n\tTempNode\n} from 'three/webgpu';\n\nimport { Fn, vec2, viewportSafeUV, viewportSharedTexture, reflector, pow, float, abs, texture, uniform, vec4, cameraPosition, positionWorld, uv, mix, vec3, normalize, max, dot, screenUV } from 'three/tsl';\n\n/** @module Water2Mesh */\n\n/**\n * An advanced water effect that supports reflections, refractions and flow maps.\n *\n * Note that this class can only be used with {@link WebGPURenderer}.\n * When using {@link WebGLRenderer}, use {@link module:Water2}.\n *\n * References:\n *\n * - {@link https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf}\n * - {@link http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html}\n *\n * @augments Mesh\n * @three_import import { WaterMesh } from 'three/addons/objects/Water2Mesh.js';\n */\nclass WaterMesh extends Mesh {\n\n\t/**\n\t * Constructs a new water mesh.\n\t *\n\t * @param {BufferGeometry} geometry - The water's geometry.\n\t * @param {module:Water2~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.transparent = true;\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWater = true;\n\n\t\tmaterial.colorNode = new WaterNode( options, this );\n\n\t}\n\n}\n\nclass WaterNode extends TempNode {\n\n\tconstructor( options, waterBody ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.waterBody = waterBody;\n\n\t\tthis.normalMap0 = texture( options.normalMap0 );\n\t\tthis.normalMap1 = texture( options.normalMap1 );\n\t\tthis.flowMap = texture( options.flowMap !== undefined ? options.flowMap : null );\n\n\t\tthis.color = uniform( options.color !== undefined ? new Color( options.color ) : new Color( 0xffffff ) );\n\t\tthis.flowDirection = uniform( options.flowDirection !== undefined ? options.flowDirection : new Vector2( 1, 0 ) );\n\t\tthis.flowSpeed = uniform( options.flowSpeed !== undefined ? options.flowSpeed : 0.03 );\n\t\tthis.reflectivity = uniform( options.reflectivity !== undefined ? options.reflectivity : 0.02 );\n\t\tthis.scale = uniform( options.scale !== undefined ? options.scale : 1 );\n\t\tthis.flowConfig = uniform( new Vector3() );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\tthis._cycle = 0.15; // a cycle of a flow map phase\n\t\tthis._halfCycle = this._cycle * 0.5;\n\n\t\tthis._USE_FLOW = options.flowMap !== undefined;\n\n\t}\n\n\tupdateFlow( delta ) {\n\n\t\tthis.flowConfig.value.x += this.flowSpeed.value * delta; // flowMapOffset0\n\t\tthis.flowConfig.value.y = this.flowConfig.value.x + this._halfCycle; // flowMapOffset1\n\n\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\n\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\n\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n\t\tif ( this.flowConfig.value.x >= this._cycle ) {\n\n\t\t\tthis.flowConfig.value.x = 0;\n\t\t\tthis.flowConfig.value.y = this._halfCycle;\n\n\t\t} else if ( this.flowConfig.value.y >= this._cycle ) {\n\n\t\t\tthis.flowConfig.value.y = this.flowConfig.value.y - this._cycle;\n\n\t\t}\n\n\t\tthis.flowConfig.value.z = this._halfCycle;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tthis.updateFlow( frame.deltaTime );\n\n\t}\n\n\tsetup() {\n\n\t\tconst outputNode = Fn( () => {\n\n\t\t\tconst flowMapOffset0 = this.flowConfig.x;\n\t\t\tconst flowMapOffset1 = this.flowConfig.y;\n\t\t\tconst halfCycle = this.flowConfig.z;\n\n\t\t\tconst toEye = normalize( cameraPosition.sub( positionWorld ) );\n\n\t\t\tlet flow;\n\n\t\t\tif ( this._USE_FLOW === true ) {\n\n\t\t\t\tflow = this.flowMap.rg.mul( 2 ).sub( 1 );\n\n\t\t\t} else {\n\n\t\t\t\tflow = vec2( this.flowDirection.x, this.flowDirection.y );\n\n\t\t\t}\n\n\t\t\tflow.x.mulAssign( - 1 );\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\n\t\t\tconst uvs = uv();\n\n\t\t\tconst normalUv0 = uvs.mul( this.scale ).add( flow.mul( flowMapOffset0 ) );\n\t\t\tconst normalUv1 = uvs.mul( this.scale ).add( flow.mul( flowMapOffset1 ) );\n\n\t\t\tconst normalColor0 = this.normalMap0.sample( normalUv0 );\n\t\t\tconst normalColor1 = this.normalMap1.sample( normalUv1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tconst flowLerp = abs( halfCycle.sub( flowMapOffset0 ) ).div( halfCycle );\n\t\t\tconst normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tconst normal = normalize( vec3( normalColor.r.mul( 2 ).sub( 1 ), normalColor.b, normalColor.g.mul( 2 ).sub( 1 ) ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tconst theta = max( dot( toEye, normal ), 0 );\n\t\t\tconst reflectance = pow( float( 1.0 ).sub( theta ), 5.0 ).mul( float( 1.0 ).sub( this.reflectivity ) ).add( this.reflectivity );\n\n\t\t\t// reflector, refractor\n\n\t\t\tconst offset = normal.xz.mul( 0.05 ).toVar();\n\n\t\t\tconst reflectionSampler = reflector();\n\t\t\tthis.waterBody.add( reflectionSampler.target );\n\t\t\treflectionSampler.uvNode = reflectionSampler.uvNode.add( offset );\n\n\t\t\tconst refractorUV = screenUV.add( offset );\n\t\t\tconst refractionSampler = viewportSharedTexture( viewportSafeUV( refractorUV ) );\n\n\t\t\t// calculate final uv coords\n\n\t\t\treturn vec4( this.color, 1.0 ).mul( mix( refractionSampler, reflectionSampler, reflectance ) );\n\n\t\t} )();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * Constructor options of `WaterMesh`.\n *\n * @typedef {Object} module:Water2Mesh~Options\n * @property {number|Color|string} [color=0xFFFFFF] - The water color.\n * @property {Vector2} [flowDirection=(1,0)] - The water's flow direction.\n * @property {number} [flowSpeed=0.03] - The water's flow speed.\n * @property {number} [reflectivity=0.02] - The water's reflectivity.\n * @property {number} [scale=1] - The water's scale.\n * @property {?Texture} [flowMap=null] - The flow map. If no flow map is assigned, the water flow is defined by `flowDirection`.\n * @property {Texture} normalMap0 - The first water normal map.\n * @property {Texture} normalMap1 - The second water normal map.\n **/\n\nexport { WaterMesh };\n"],"mappings":"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","ignoreList":[]}