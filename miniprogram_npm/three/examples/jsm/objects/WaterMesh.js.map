{"version":3,"file":"node_modules/three/examples/jsm/objects/WaterMesh.js","names":["Color","Mesh","Vector3","MeshLambertNodeMaterial","Fn","add","cameraPosition","div","normalize","positionWorld","sub","time","texture","vec2","vec3","max","dot","reflect","pow","length","float","uniform","reflector","mul","mix","diffuseColor","WaterMesh","constructor","geometry","options","material","super","this","isWaterMesh","resolution","undefined","waterNormals","alpha","size","sunColor","sunDirection","waterColor","distortionScale","noise","uv","offset","uv0","toVar","uv1","uv2","uv3","sample0","sample","sample1","sample2","sample3","getNoise","xz","surfaceNormal","xzy","worldToEye","eyeDirection","reflection","negate","direction","specularLight","diffuseLight","distance","distortion","transparent","opacityNode","receivedShadowPositionNode","setupOutgoingLight","rgb","colorNode","mirrorSampler","uvNode","target","theta","rf0","reflectance","scatter"],"sources":["node_modules/three/examples/jsm/objects/WaterMesh.js"],"sourcesContent":["import {\n\tColor,\n\tMesh,\n\tVector3,\n\tMeshLambertNodeMaterial\n} from 'three/webgpu';\n\nimport { Fn, add, cameraPosition, div, normalize, positionWorld, sub, time, texture, vec2, vec3, max, dot, reflect, pow, length, float, uniform, reflector, mul, mix, diffuseColor } from 'three/tsl';\n\n/**\n * A basic flat, reflective water effect.\n *\n * Note that this class can only be used with {@link WebGPURenderer}.\n * When using {@link WebGLRenderer}, use {@link Water}.\n *\n * References:\n *\n * - [Flat mirror for three.js]{@link https://github.com/Slayvin}\n * - [An implementation of water shader based on the flat mirror]{@link https://home.adelphi.edu/~stemkoski/}\n * - [Water shader explanations in WebGL]{@link http://29a.ch/slides/2012/webglwater/ }\n *\n * @augments Mesh\n * @three_import import { WaterMesh } from 'three/addons/objects/WaterMesh.js';\n */\nclass WaterMesh extends Mesh {\n\n\t/**\n\t * Constructs a new water mesh.\n\t *\n\t * @param {BufferGeometry} geometry - The water mesh's geometry.\n\t * @param {WaterMesh~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options ) {\n\n\t\tconst material = new MeshLambertNodeMaterial();\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWaterMesh = true;\n\n\t\t/**\n\t\t * The effect's resolution scale.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.5\n\t\t */\n\t\tthis.resolution = options.resolution !== undefined ? options.resolution : 0.5;\n\n\t\t// Uniforms\n\n\t\t/**\n\t\t * The water's normal map.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.waterNormals = texture( options.waterNormals );\n\n\t\t/**\n\t\t * The alpha value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t * @default 1\n\t\t */\n\t\tthis.alpha = uniform( options.alpha !== undefined ? options.alpha : 1.0 );\n\n\t\t/**\n\t\t * The size value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t * @default 1\n\t\t */\n\t\tthis.size = uniform( options.size !== undefined ? options.size : 1.0 );\n\n\t\t/**\n\t\t * The sun color.\n\t\t *\n\t\t * @type {UniformNode<color>}\n\t\t * @default 0xffffff\n\t\t */\n\t\tthis.sunColor = uniform( new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff ) );\n\n\t\t/**\n\t\t * The sun direction.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t * @default (0.70707,0.70707,0.0)\n\t\t */\n\t\tthis.sunDirection = uniform( options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 ) );\n\n\t\t/**\n\t\t * The water color.\n\t\t *\n\t\t * @type {UniformNode<color>}\n\t\t * @default 0x7f7f7f\n\t\t */\n\t\tthis.waterColor = uniform( new Color( options.waterColor !== undefined ? options.waterColor : 0x7f7f7f ) );\n\n\t\t/**\n\t\t * The distortion scale.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t * @default 20\n\t\t */\n\t\tthis.distortionScale = uniform( options.distortionScale !== undefined ? options.distortionScale : 20.0 );\n\n\t\t// TSL\n\n\t\tconst getNoise = Fn( ( [ uv ] ) => {\n\n\t\t\tconst offset = time;\n\n\t\t\tconst uv0 = add( div( uv, 103 ), vec2( div( offset, 17 ), div( offset, 29 ) ) ).toVar();\n\t\t\tconst uv1 = div( uv, 107 ).sub( vec2( div( offset, - 19 ), div( offset, 31 ) ) ).toVar();\n\t\t\tconst uv2 = add( div( uv, vec2( 8907.0, 9803.0 ) ), vec2( div( offset, 101 ), div( offset, 97 ) ) ).toVar();\n\t\t\tconst uv3 = sub( div( uv, vec2( 1091.0, 1027.0 ) ), vec2( div( offset, 109 ), div( offset, - 113 ) ) ).toVar();\n\n\t\t\tconst sample0 = this.waterNormals.sample( uv0 );\n\t\t\tconst sample1 = this.waterNormals.sample( uv1 );\n\t\t\tconst sample2 = this.waterNormals.sample( uv2 );\n\t\t\tconst sample3 = this.waterNormals.sample( uv3 );\n\n\t\t\tconst noise = sample0.add( sample1 ).add( sample2 ).add( sample3 );\n\n\t\t\treturn noise.mul( 0.5 ).sub( 1 );\n\n\t\t} );\n\n\t\tconst noise = getNoise( positionWorld.xz.mul( this.size ) );\n\t\tconst surfaceNormal = normalize( noise.xzy.mul( 1.5, 1.0, 1.5 ) );\n\n\t\tconst worldToEye = cameraPosition.sub( positionWorld );\n\t\tconst eyeDirection = normalize( worldToEye );\n\n\t\tconst reflection = normalize( reflect( this.sunDirection.negate(), surfaceNormal ) );\n\t\tconst direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\tconst specularLight = pow( direction, 100 ).mul( this.sunColor ).mul( 2.0 );\n\t\tconst diffuseLight = max( dot( this.sunDirection, surfaceNormal ), 0.0 ).mul( this.sunColor ).mul( 0.5 );\n\n\t\tconst distance = length( worldToEye );\n\n\t\tconst distortion = surfaceNormal.xz.mul( float( 0.001 ).add( float( 1.0 ).div( distance ) ) ).mul( this.distortionScale );\n\n\t\t// Material\n\n\t\tmaterial.transparent = true;\n\n\t\tmaterial.opacityNode = this.alpha;\n\n\t\tmaterial.receivedShadowPositionNode = positionWorld.add( distortion );\n\n\t\tmaterial.setupOutgoingLight = () => diffuseColor.rgb; // backwards compatibility\n\n\t\tmaterial.colorNode = Fn( () => {\n\n\t\t\tconst mirrorSampler = reflector();\n\t\t\tmirrorSampler.uvNode = mirrorSampler.uvNode.add( distortion );\n\t\t\tmirrorSampler.resolution = this.resolution;\n\n\t\t\tthis.add( mirrorSampler.target );\n\n\t\t\tconst theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\tconst rf0 = float( 0.3 );\n\t\t\tconst reflectance = mul( pow( float( 1.0 ).sub( theta ), 5.0 ), float( 1.0 ).sub( rf0 ) ).add( rf0 );\n\t\t\tconst scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ).mul( this.waterColor );\n\t\t\tconst albedo = mix( this.sunColor.mul( diffuseLight ).mul( 0.3 ).add( scatter ), mirrorSampler.rgb.mul( specularLight ).add( mirrorSampler.rgb.mul( 0.9 ) ).add( vec3( 0.1 ) ), reflectance );\n\n\t\t\treturn albedo;\n\n\t\t} )();\n\n\t}\n\n}\n\n/**\n * Constructor options of `WaterMesh`.\n *\n * @typedef {Object} WaterMesh~Options\n * @property {number} [resolution=0.5] - The resolution scale.\n * @property {?Texture} [waterNormals=null] - The water's normal map.\n * @property {number} [alpha=1] - The alpha value.\n * @property {number} [size=1] - The size value.\n * @property {number|Color|string} [sunColor=0xffffff] - The sun color.\n * @property {Vector3} [sunDirection=(0.70707,0.70707,0.0)] - The sun direction.\n * @property {number|Color|string} [waterColor=0x7F7F7F] - The water color.\n * @property {number} [distortionScale=20] - The distortion scale.\n **/\n\nexport { WaterMesh };\n"],"mappings":"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","ignoreList":[]}