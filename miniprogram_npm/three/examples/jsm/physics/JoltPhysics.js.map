{"version":3,"file":"node_modules/three/examples/jsm/physics/JoltPhysics.js","names":["Clock","Vector3","Quaternion","Matrix4","JOLT_PATH","frameRate","Jolt","getShape","geometry","parameters","type","sx","undefined","width","sy","height","sz","depth","BoxShape","Vec3","Math","min","radius","SphereShape","LAYER_NON_MOVING","LAYER_MOVING","NUM_OBJECT_LAYERS","setupCollisionFiltering","settings","objectFilter","ObjectLayerPairFilterTable","EnableCollision","BP_LAYER_NON_MOVING","BroadPhaseLayer","BP_LAYER_MOVING","bpInterface","BroadPhaseLayerInterfaceTable","MapObjectToBroadPhaseLayer","mObjectLayerPairFilter","mBroadPhaseLayerInterface","mObjectVsBroadPhaseLayerFilter","ObjectVsBroadPhaseLayerFilterTable","async","JoltPhysics","default","initJolt","import","JoltSettings","jolt","JoltInterface","destroy","bodyInterface","GetPhysicsSystem","GetBodyInterface","meshes","meshMap","WeakMap","_position","_quaternion","_scale","_matrix","addMesh","mesh","mass","restitution","shape","body","isInstancedMesh","array","instanceMatrix","bodies","i","count","position","fromArray","quaternion","setFromRotationMatrix","push","createBody","createInstancedBody","set","rotation","pos","x","y","z","rot","Quat","w","motion","EMotionType_Dynamic","EMotionType_Static","layer","creationSettings","BodyCreationSettings","mRestitution","CreateBody","AddBody","GetID","EActivation_Activate","clock","setInterval","deltaTime","getDelta","numSteps","Step","l","length","get","j","GetPosition","GetRotation","GetX","GetY","GetZ","GetW","compose","toArray","needsUpdate","computeBoundingSphere","addScene","scene","traverse","child","isMesh","physics","userData","setMeshPosition","index","RemoveBody","DestroyBody","GetShape","body2","setMeshVelocity","velocity"],"sources":["node_modules/three/examples/jsm/physics/JoltPhysics.js"],"sourcesContent":["import { Clock, Vector3, Quaternion, Matrix4 } from 'three';\n\nconst JOLT_PATH = 'https://cdn.jsdelivr.net/npm/jolt-physics@0.23.0/dist/jolt-physics.wasm-compat.js';\n\nconst frameRate = 60;\n\nlet Jolt = null;\n\nfunction getShape( geometry ) {\n\n\tconst parameters = geometry.parameters;\n\n\t// TODO change type to is*\n\n\tif ( geometry.type === 'BoxGeometry' ) {\n\n\t\tconst sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n\t\tconst sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n\t\tconst sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n\n\t\treturn new Jolt.BoxShape( new Jolt.Vec3( sx, sy, sz ), 0.05 * Math.min( sx, sy, sz ), null );\n\n\t} else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {\n\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 1;\n\n\t\treturn new Jolt.SphereShape( radius, null );\n\n\t}\n\n\treturn null;\n\n}\n\n// Object layers\nconst LAYER_NON_MOVING = 0;\nconst LAYER_MOVING = 1;\nconst NUM_OBJECT_LAYERS = 2;\n\nfunction setupCollisionFiltering( settings ) {\n\n\tconst objectFilter = new Jolt.ObjectLayerPairFilterTable( NUM_OBJECT_LAYERS );\n\tobjectFilter.EnableCollision( LAYER_NON_MOVING, LAYER_MOVING );\n\tobjectFilter.EnableCollision( LAYER_MOVING, LAYER_MOVING );\n\n\tconst BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer( 0 );\n\tconst BP_LAYER_MOVING = new Jolt.BroadPhaseLayer( 1 );\n\tconst NUM_BROAD_PHASE_LAYERS = 2;\n\n\tconst bpInterface = new Jolt.BroadPhaseLayerInterfaceTable( NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_NON_MOVING, BP_LAYER_NON_MOVING );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_MOVING, BP_LAYER_MOVING );\n\n\tsettings.mObjectLayerPairFilter = objectFilter;\n\tsettings.mBroadPhaseLayerInterface = bpInterface;\n\tsettings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable( settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS );\n\n}\n\n/**\n * @classdesc Can be used to include Jolt as a Physics engine into\n * `three.js` apps. The API can be initialized via:\n * ```js\n * const physics = await JoltPhysics();\n * ```\n * The component automatically imports Jolt from a CDN so make sure\n * to use the component with an active Internet connection.\n *\n * @name JoltPhysics\n * @class\n * @hideconstructor\n * @three_import import { JoltPhysics } from 'three/addons/physics/JoltPhysics.js';\n */\nasync function JoltPhysics() {\n\n\tif ( Jolt === null ) {\n\n\t\tconst { default: initJolt } = await import( `${JOLT_PATH}` );\n\t\tJolt = await initJolt();\n\n\t}\n\n\tconst settings = new Jolt.JoltSettings();\n\tsetupCollisionFiltering( settings );\n\n\tconst jolt = new Jolt.JoltInterface( settings );\n\tJolt.destroy( settings );\n\n\tconst physicsSystem = jolt.GetPhysicsSystem();\n\tconst bodyInterface = physicsSystem.GetBodyInterface();\n\n\tconst meshes = [];\n\tconst meshMap = new WeakMap();\n\n\tconst _position = new Vector3();\n\tconst _quaternion = new Quaternion();\n\tconst _scale = new Vector3( 1, 1, 1 );\n\n\tconst _matrix = new Matrix4();\n\n\tfunction addScene( scene ) {\n\n\t\tscene.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tconst physics = child.userData.physics;\n\n\t\t\t\tif ( physics ) {\n\n\t\t\t\t\taddMesh( child, physics.mass, physics.restitution );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tfunction addMesh( mesh, mass = 0, restitution = 0 ) {\n\n\t\tconst shape = getShape( mesh.geometry );\n\n\t\tif ( shape === null ) return;\n\n\t\tconst body = mesh.isInstancedMesh\n\t\t\t? createInstancedBody( mesh, mass, restitution, shape )\n\t\t\t: createBody( mesh.position, mesh.quaternion, mass, restitution, shape );\n\n\t\tif ( mass > 0 ) {\n\n\t\t\tmeshes.push( mesh );\n\t\t\tmeshMap.set( mesh, body );\n\n\t\t}\n\n\t}\n\n\tfunction createInstancedBody( mesh, mass, restitution, shape ) {\n\n\t\tconst array = mesh.instanceMatrix.array;\n\n\t\tconst bodies = [];\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tconst position = _position.fromArray( array, i * 16 + 12 );\n\t\t\tconst quaternion = _quaternion.setFromRotationMatrix( _matrix.fromArray( array, i * 16 ) ); // TODO Copilot did this\n\t\t\tbodies.push( createBody( position, quaternion, mass, restitution, shape ) );\n\n\t\t}\n\n\t\treturn bodies;\n\n\t}\n\n\tfunction createBody( position, rotation, mass, restitution, shape ) {\n\n\t\tconst pos = new Jolt.Vec3( position.x, position.y, position.z );\n\t\tconst rot = new Jolt.Quat( rotation.x, rotation.y, rotation.z, rotation.w );\n\n\t\tconst motion = mass > 0 ? Jolt.EMotionType_Dynamic : Jolt.EMotionType_Static;\n\t\tconst layer = mass > 0 ? LAYER_MOVING : LAYER_NON_MOVING;\n\n\t\tconst creationSettings = new Jolt.BodyCreationSettings( shape, pos, rot, motion, layer );\n\t\tcreationSettings.mRestitution = restitution;\n\n\t\tconst body = bodyInterface.CreateBody( creationSettings );\n\n\t\tbodyInterface.AddBody( body.GetID(), Jolt.EActivation_Activate );\n\n\t\tJolt.destroy( creationSettings );\n\n\t\treturn body;\n\n\t}\n\n\tfunction setMeshPosition( mesh, position, index = 0 ) {\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\tconst body = bodies[ index ];\n\n\t\t\tbodyInterface.RemoveBody( body.GetID() );\n\t\t\tbodyInterface.DestroyBody( body.GetID() );\n\n\t\t\tconst physics = mesh.userData.physics;\n\n\t\t\tconst shape = body.GetShape();\n\t\t\tconst body2 = createBody( position, { x: 0, y: 0, z: 0, w: 1 }, physics.mass, physics.restitution, shape );\n\n\t\t\tbodies[ index ] = body2;\n\n\t\t} else {\n\n\t\t\t// TODO: Implement this\n\n\t\t}\n\n\t}\n\n\tfunction setMeshVelocity( mesh, velocity, index = 0 ) {\n\n\t\t/*\n\t\tlet body = meshMap.get( mesh );\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tbody = body[ index ];\n\n\t\t}\n\n\t\tbody.setLinvel( velocity );\n\t\t*/\n\n\t}\n\n\t//\n\n\tconst clock = new Clock();\n\n\tfunction step() {\n\n\t\tlet deltaTime = clock.getDelta();\n\n\t\t// Don't go below 30 Hz to prevent spiral of death\n\t\tdeltaTime = Math.min( deltaTime, 1.0 / 30.0 );\n\n\t\t// When running below 55 Hz, do 2 steps instead of 1\n\t\tconst numSteps = deltaTime > 1.0 / 55.0 ? 2 : 1;\n\n\t\t// Step the physics world\n\t\tjolt.Step( deltaTime, numSteps );\n\n\t\t//\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\n\t\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\t\tconst array = mesh.instanceMatrix.array;\n\t\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\t\tfor ( let j = 0; j < bodies.length; j ++ ) {\n\n\t\t\t\t\tconst body = bodies[ j ];\n\n\t\t\t\t\tconst position = body.GetPosition();\n\t\t\t\t\tconst quaternion = body.GetRotation();\n\n\t\t\t\t\t_position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\t\t_quaternion.set( quaternion.GetX(), quaternion.GetY(), quaternion.GetZ(), quaternion.GetW() );\n\n\t\t\t\t\t_matrix.compose( _position, _quaternion, _scale ).toArray( array, j * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tmesh.computeBoundingSphere();\n\n\t\t\t} else {\n\n\t\t\t\tconst body = meshMap.get( mesh );\n\n\t\t\t\tconst position = body.GetPosition();\n\t\t\t\tconst rotation = body.GetRotation();\n\n\t\t\t\tmesh.position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\tmesh.quaternion.set( rotation.GetX(), rotation.GetY(), rotation.GetZ(), rotation.GetW() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// animate\n\n\tsetInterval( step, 1000 / frameRate );\n\n\treturn {\n\t\t/**\n\t\t * Adds the given scene to this physics simulation. Only meshes with a\n\t\t * `physics` object in their {@link Object3D#userData} field will be honored.\n\t\t * The object can be used to store the mass and restitution of the mesh. E.g.:\n\t\t * ```js\n\t\t * box.userData.physics = { mass: 1, restitution: 0 };\n\t\t * ```\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#addScene\n\t\t * @param {Object3D} scene The scene or any type of 3D object to add.\n\t\t */\n\t\taddScene: addScene,\n\n\t\t/**\n\t\t * Adds the given mesh to this physics simulation.\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#addMesh\n\t\t * @param {Mesh} mesh The mesh to add.\n\t\t * @param {number} [mass=0] The mass in kg of the mesh.\n\t\t * @param {number} [restitution=0] The restitution/friction of the mesh.\n\t\t */\n\t\taddMesh: addMesh,\n\n\t\t/**\n\t\t * Set the position of the given mesh which is part of the physics simulation. Calling this\n\t\t * method will reset the current simulated velocity of the mesh.\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#setMeshPosition\n\t\t * @param {Mesh} mesh The mesh to update the position for.\n\t\t * @param {Vector3} position - The new position.\n\t\t * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.\n\t\t */\n\t\tsetMeshPosition: setMeshPosition,\n\n\t\t// NOOP\n\t\tsetMeshVelocity: setMeshVelocity\n\t};\n\n}\n\nexport { JoltPhysics };\n"],"mappings":"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","ignoreList":[]}