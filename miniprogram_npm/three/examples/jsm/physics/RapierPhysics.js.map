{"version":3,"file":"node_modules/three/examples/jsm/physics/RapierPhysics.js","names":["Clock","Vector3","Quaternion","Matrix4","RAPIER_PATH","frameRate","_scale","ZERO","RAPIER","getShape","geometry","parameters","type","sx","undefined","width","sy","height","sz","depth","radius","ColliderDesc","roundCuboid","cuboid","ball","radiusBottom","length","cylinder","capsule","vertices","vertex","position","getAttribute","i","count","fromBufferAttribute","push","x","y","z","indices","getIndex","Uint32Array","from","Array","parseInt","keys","array","trimesh","async","RapierPhysics","import","init","gravity","world","World","meshes","meshMap","WeakMap","_vector","_quaternion","_matrix","addMesh","mesh","mass","restitution","shape","setMass","setRestitution","body","collider","isInstancedMesh","instanceMatrix","bodies","colliders","fromArray","createBody","createInstancedBody","quaternion","userData","physics","set","desc","RigidBodyDesc","dynamic","fixed","setTranslation","setRotation","createRigidBody","createCollider","clock","setInterval","timestep","getDelta","step","l","get","j","translation","copy","rotation","compose","toArray","needsUpdate","computeBoundingSphere","addScene","scene","traverse","child","isMesh","removeMesh","index","indexOf","splice","delete","isArray","removeRigidBody","removeBody","removeCollider","setMeshPosition","setAngvel","setLinvel","setMeshVelocity","velocity","addHeightfield","heights","scale","heightfield","bodyDesc"],"sources":["node_modules/three/examples/jsm/physics/RapierPhysics.js"],"sourcesContent":["import { Clock, Vector3, Quaternion, Matrix4 } from 'three';\n\nconst RAPIER_PATH = 'https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.17.3';\n\nconst frameRate = 60;\n\nconst _scale = new Vector3( 1, 1, 1 );\nconst ZERO = new Vector3();\n\nlet RAPIER = null;\n\nfunction getShape( geometry ) {\n\n\tconst parameters = geometry.parameters;\n\n\t// TODO change type to is*\n\n\tif ( geometry.type === 'RoundedBoxGeometry' ) {\n\n\t\tconst sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n\t\tconst sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n\t\tconst sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 0.1;\n\n\t\treturn RAPIER.ColliderDesc.roundCuboid( sx - radius, sy - radius, sz - radius, radius );\n\n\t} else if ( geometry.type === 'BoxGeometry' ) {\n\n\t\tconst sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n\t\tconst sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n\t\tconst sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n\n\t\treturn RAPIER.ColliderDesc.cuboid( sx, sy, sz );\n\n\t} else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {\n\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 1;\n\t\treturn RAPIER.ColliderDesc.ball( radius );\n\n\t} else if ( geometry.type === 'CylinderGeometry' ) {\n\n\t\tconst radius = parameters.radiusBottom !== undefined ? parameters.radiusBottom : 0.5;\n\t\tconst length = parameters.height !== undefined ? parameters.height : 0.5;\n\n\t\treturn RAPIER.ColliderDesc.cylinder( length / 2, radius );\n\n\t} else if ( geometry.type === 'CapsuleGeometry' ) {\n\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 0.5;\n\t\tconst length = parameters.height !== undefined ? parameters.height : 0.5;\n\n\t\treturn RAPIER.ColliderDesc.capsule( length / 2, radius );\n\n\t} else if ( geometry.type === 'BufferGeometry' ) {\n\n\t\tconst vertices = [];\n\t\tconst vertex = new Vector3();\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tvertex.fromBufferAttribute( position, i );\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\t// if the buffer is non-indexed, generate an index buffer\n\t\tconst indices = geometry.getIndex() === null\n\t\t\t? Uint32Array.from( Array( parseInt( vertices.length / 3 ) ).keys() )\n\t\t\t: geometry.getIndex().array;\n\n\t\treturn RAPIER.ColliderDesc.trimesh( vertices, indices );\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * @classdesc Can be used to include Rapier as a Physics engine into\n * `three.js` apps. The API can be initialized via:\n * ```js\n * const physics = await RapierPhysics();\n * ```\n * The component automatically imports Rapier from a CDN so make sure\n * to use the component with an active Internet connection.\n *\n * @name RapierPhysics\n * @class\n * @hideconstructor\n * @three_import import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';\n */\nasync function RapierPhysics() {\n\n\tif ( RAPIER === null ) {\n\n\t\tRAPIER = await import( `${RAPIER_PATH}` );\n\t\tawait RAPIER.init();\n\n\t}\n\n\t// Docs: https://rapier.rs/docs/api/javascript/JavaScript3D/\n\n\tconst gravity = new Vector3( 0.0, - 9.81, 0.0 );\n\tconst world = new RAPIER.World( gravity );\n\n\tconst meshes = [];\n\tconst meshMap = new WeakMap();\n\n\tconst _vector = new Vector3();\n\tconst _quaternion = new Quaternion();\n\tconst _matrix = new Matrix4();\n\n\tfunction addScene( scene ) {\n\n\t\tscene.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tconst physics = child.userData.physics;\n\n\t\t\t\tif ( physics ) {\n\n\t\t\t\t\taddMesh( child, physics.mass, physics.restitution );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tfunction addMesh( mesh, mass = 0, restitution = 0 ) {\n\n\t\tconst shape = getShape( mesh.geometry );\n\n\t\tif ( shape === null ) return;\n\n\t\tshape.setMass( mass );\n\t\tshape.setRestitution( restitution );\n\n\t\tconst { body, collider } = mesh.isInstancedMesh\n\t\t\t? createInstancedBody( mesh, mass, shape )\n\t\t\t: createBody( mesh.position, mesh.quaternion, mass, shape );\n\n\t\tif ( ! mesh.userData.physics ) mesh.userData.physics = {};\n\n\t\tmesh.userData.physics.body = body;\n\t\tmesh.userData.physics.collider = collider;\n\n\t\tif ( mass > 0 ) {\n\n\t\t\tmeshes.push( mesh );\n\t\t\tmeshMap.set( mesh, { body, collider } );\n\n\t\t}\n\n\t}\n\n\tfunction removeMesh( mesh ) {\n\n\t\tconst index = meshes.indexOf( mesh );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tmeshes.splice( index, 1 );\n\t\t\tmeshMap.delete( mesh );\n\n\t\t\tif ( ! mesh.userData.physics ) return;\n\n\t\t\tconst body = mesh.userData.physics.body;\n\t\t\tconst collider = mesh.userData.physics.collider;\n\n\t\t\tif ( body ) removeBody( body );\n\t\t\tif ( collider ) removeCollider( collider );\n\n\t\t}\n\n\t}\n\n\tfunction createInstancedBody( mesh, mass, shape ) {\n\n\t\tconst array = mesh.instanceMatrix.array;\n\n\t\tconst bodies = [];\n\t\tconst colliders = [];\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tconst position = _vector.fromArray( array, i * 16 + 12 );\n\t\t\tconst { body, collider } = createBody( position, null, mass, shape );\n\t\t\tbodies.push( body );\n\t\t\tcolliders.push( collider );\n\n\t\t}\n\n\t\treturn { body: bodies, collider: colliders };\n\n\t}\n\n\tfunction createBody( position, quaternion, mass, shape ) {\n\n\t\tconst desc = mass > 0 ? RAPIER.RigidBodyDesc.dynamic() : RAPIER.RigidBodyDesc.fixed();\n\t\tdesc.setTranslation( ...position );\n\t\tif ( quaternion !== null ) desc.setRotation( quaternion );\n\n\t\tconst body = world.createRigidBody( desc );\n\t\tconst collider = world.createCollider( shape, body );\n\n\t\treturn { body, collider };\n\n\t}\n\n\tfunction removeBody( body ) {\n\n\t\tif ( Array.isArray( body ) ) {\n\n\t\t\tfor ( let i = 0; i < body.length; i ++ ) {\n\n\t\t\t\tworld.removeRigidBody( body[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tworld.removeRigidBody( body );\n\n\t\t}\n\n\t}\n\n\tfunction removeCollider( collider ) {\n\n\t\tif ( Array.isArray( collider ) ) {\n\n\t\t\tfor ( let i = 0; i < collider.length; i ++ ) {\n\n\t\t\t\tworld.removeCollider( collider[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tworld.removeCollider( collider );\n\n\t\t}\n\n\t}\n\n\tfunction setMeshPosition( mesh, position, index = 0 ) {\n\n\t\tlet { body } = meshMap.get( mesh );\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tbody = body[ index ];\n\n\t\t}\n\n\t\tbody.setAngvel( ZERO );\n\t\tbody.setLinvel( ZERO );\n\t\tbody.setTranslation( position );\n\n\t}\n\n\tfunction setMeshVelocity( mesh, velocity, index = 0 ) {\n\n\t\tlet { body } = meshMap.get( mesh );\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tbody = body[ index ];\n\n\t\t}\n\n\t\tbody.setLinvel( velocity );\n\n\t}\n\n\tfunction addHeightfield( mesh, width, depth, heights, scale ) {\n\n\t\tconst shape = RAPIER.ColliderDesc.heightfield( width, depth, heights, scale );\n\n\t\tconst bodyDesc = RAPIER.RigidBodyDesc.fixed();\n\t\tbodyDesc.setTranslation( mesh.position.x, mesh.position.y, mesh.position.z );\n\t\tbodyDesc.setRotation( mesh.quaternion );\n\n\t\tconst body = world.createRigidBody( bodyDesc );\n\t\tworld.createCollider( shape, body );\n\n\t\tif ( ! mesh.userData.physics ) mesh.userData.physics = {};\n\t\tmesh.userData.physics.body = body;\n\n\t\treturn body;\n\n\t}\n\n\t//\n\n\tconst clock = new Clock();\n\n\tfunction step() {\n\n\t\tworld.timestep = clock.getDelta();\n\t\tworld.step();\n\n\t\t//\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\n\t\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\t\tconst array = mesh.instanceMatrix.array;\n\t\t\t\tconst { body: bodies } = meshMap.get( mesh );\n\n\t\t\t\tfor ( let j = 0; j < bodies.length; j ++ ) {\n\n\t\t\t\t\tconst body = bodies[ j ];\n\n\t\t\t\t\tconst position = body.translation();\n\t\t\t\t\t_quaternion.copy( body.rotation() );\n\n\t\t\t\t\t_matrix.compose( position, _quaternion, _scale ).toArray( array, j * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tmesh.computeBoundingSphere();\n\n\t\t\t} else {\n\n\t\t\t\tconst { body } = meshMap.get( mesh );\n\n\t\t\t\tmesh.position.copy( body.translation() );\n\t\t\t\tmesh.quaternion.copy( body.rotation() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// animate\n\n\tsetInterval( step, 1000 / frameRate );\n\n\treturn {\n\t\tRAPIER,\n\t\tworld,\n\t\t/**\n\t\t * Adds the given scene to this physics simulation. Only meshes with a\n\t\t * `physics` object in their {@link Object3D#userData} field will be honored.\n\t\t * The object can be used to store the mass and restitution of the mesh. E.g.:\n\t\t * ```js\n\t\t * box.userData.physics = { mass: 1, restitution: 0 };\n\t\t * ```\n\t\t *\n\t\t * @method\n\t\t * @name RapierPhysics#addScene\n\t\t * @param {Object3D} scene The scene or any type of 3D object to add.\n\t\t */\n\t\taddScene: addScene,\n\n\t\t/**\n\t\t * Adds the given mesh to this physics simulation.\n\t\t *\n\t\t * @method\n\t\t * @name RapierPhysics#addMesh\n\t\t * @param {Mesh} mesh The mesh to add.\n\t\t * @param {number} [mass=0] The mass in kg of the mesh.\n\t\t * @param {number} [restitution=0] The restitution/friction of the mesh.\n\t\t */\n\t\taddMesh: addMesh,\n\n\t\t/**\n\t\t * Removes the given mesh from this physics simulation.\n\t\t *\n\t\t * @method\n\t\t * @name RapierPhysics#removeMesh\n\t\t * @param {Mesh} mesh The mesh to remove.\n\t\t */\n\t\tremoveMesh: removeMesh,\n\n\t\t/**\n\t\t * Set the position of the given mesh which is part of the physics simulation. Calling this\n\t\t * method will reset the current simulated velocity of the mesh.\n\t\t *\n\t\t * @method\n\t\t * @name RapierPhysics#setMeshPosition\n\t\t * @param {Mesh} mesh The mesh to update the position for.\n\t\t * @param {Vector3} position - The new position.\n\t\t * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.\n\t\t */\n\t\tsetMeshPosition: setMeshPosition,\n\n\t\t/**\n\t\t * Set the velocity of the given mesh which is part of the physics simulation.\n\t\t *\n\t\t * @method\n\t\t * @name RapierPhysics#setMeshVelocity\n\t\t * @param {Mesh} mesh The mesh to update the velocity for.\n\t\t * @param {Vector3} velocity - The new velocity.\n\t\t * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.\n\t\t */\n\t\tsetMeshVelocity: setMeshVelocity,\n\n\t\t/**\n\t\t * Adds a heightfield terrain to the physics simulation.\n\t\t * \n\t\t * @method\n\t\t * @name RapierPhysics#addHeightfield\n\t\t * @param {Mesh} mesh - The Three.js mesh representing the terrain.\n\t\t * @param {number} width - The number of vertices along the width (x-axis) of the heightfield.\n\t\t * @param {number} depth - The number of vertices along the depth (z-axis) of the heightfield.\n\t\t * @param {Float32Array} heights - Array of height values for each vertex in the heightfield.\n\t\t * @param {Object} scale - Scale factors for the heightfield dimensions.\n\t\t * @param {number} scale.x - Scale factor for width.\n\t\t * @param {number} scale.y - Scale factor for height.\n\t\t * @param {number} scale.z - Scale factor for depth.\n\t\t * @returns {RigidBody} The created Rapier rigid body for the heightfield.\n\t\t */\n\t\taddHeightfield: addHeightfield\n\n\t};\n\n}\n\nexport { RapierPhysics };\n"],"mappings":"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","ignoreList":[]}