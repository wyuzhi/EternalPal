import{BackSide,BoxGeometry,Mesh,PerspectiveCamera,Scene,ShaderLib,ShaderMaterial,UniformsUtils}from"three";import{Pass}from"./Pass.js";class CubeTexturePass extends Pass{constructor(e,t,r=1){super(),this.camera=e,this.tCube=t,this.opacity=r,this.needsSwap=!1;const s=ShaderLib.cube;this._cubeMesh=new Mesh(new BoxGeometry(10,10,10),new ShaderMaterial({uniforms:UniformsUtils.clone(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,depthTest:!1,depthWrite:!1,side:BackSide})),Object.defineProperty(this._cubeMesh.material,"envMap",{get:function(){return this.uniforms.tCube.value}}),this._cubeScene=new Scene,this._cubeCamera=new PerspectiveCamera,this._cubeScene.add(this._cubeMesh)}render(e,t,r){const s=e.autoClear;e.autoClear=!1,this._cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix),this._cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld),this._cubeMesh.material.uniforms.tCube.value=this.tCube,this._cubeMesh.material.uniforms.tFlip.value=this.tCube.isCubeTexture&&!1===this.tCube.isRenderTargetTexture?-1:1,this._cubeMesh.material.uniforms.opacity.value=this.opacity,this._cubeMesh.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(),e.render(this._cubeScene,this._cubeCamera),e.autoClear=s}dispose(){this._cubeMesh.geometry.dispose(),this._cubeMesh.material.dispose()}}export{CubeTexturePass};
//# sourceMappingURL=CubeTexturePass.js.map