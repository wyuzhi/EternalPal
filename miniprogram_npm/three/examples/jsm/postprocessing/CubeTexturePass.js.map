{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/CubeTexturePass.js","names":["BackSide","BoxGeometry","Mesh","PerspectiveCamera","Scene","ShaderLib","ShaderMaterial","UniformsUtils","Pass","CubeTexturePass","constructor","camera","tCube","opacity","super","this","needsSwap","cubeShader","_cubeMesh","uniforms","clone","vertexShader","fragmentShader","depthTest","depthWrite","side","Object","defineProperty","material","get","value","_cubeScene","_cubeCamera","add","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","tFlip","isCubeTexture","isRenderTargetTexture","transparent","setRenderTarget","renderToScreen","clear","dispose","geometry"],"sources":["node_modules/three/examples/jsm/postprocessing/CubeTexturePass.js"],"sourcesContent":["import {\n\tBackSide,\n\tBoxGeometry,\n\tMesh,\n\tPerspectiveCamera,\n\tScene,\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass } from './Pass.js';\n\n/**\n * This pass can be used to render a cube texture over the entire screen.\n *\n * ```js\n * const cubeMap = new THREE.CubeTextureLoader().load( urls );\n *\n * const cubeTexturePass = new CubeTexturePass( camera, cubemap );\n * composer.addPass( cubeTexturePass );\n * ```\n *\n * @augments Pass\n * @three_import import { CubeTexturePass } from 'three/addons/postprocessing/CubeTexturePass.js';\n */\nclass CubeTexturePass extends Pass {\n\n\t/**\n\t * Constructs a new cube texture pass.\n\t *\n\t * @param {PerspectiveCamera} camera - The camera.\n\t * @param {CubeTexture} tCube - The cube texture to render.\n\t * @param {number} [opacity=1] - The opacity.\n\t */\n\tconstructor( camera, tCube, opacity = 1 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The cube texture to render.\n\t\t *\n\t\t * @type {CubeTexture}\n\t\t */\n\t\tthis.tCube = tCube;\n\n\t\t/**\n\t\t * The opacity.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.opacity = opacity;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t// internals\n\n\t\tconst cubeShader = ShaderLib[ 'cube' ];\n\n\t\tthis._cubeMesh = new Mesh(\n\t\t\tnew BoxGeometry( 10, 10, 10 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: UniformsUtils.clone( cubeShader.uniforms ),\n\t\t\t\tvertexShader: cubeShader.vertexShader,\n\t\t\t\tfragmentShader: cubeShader.fragmentShader,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tside: BackSide\n\t\t\t} )\n\t\t);\n\n\t\tObject.defineProperty( this._cubeMesh.material, 'envMap', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.tCube.value;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis._cubeScene = new Scene();\n\t\tthis._cubeCamera = new PerspectiveCamera();\n\t\tthis._cubeScene.add( this._cubeMesh );\n\n\t}\n\n\t/**\n\t * Performs the cube texture pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis._cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\tthis._cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );\n\n\t\tthis._cubeMesh.material.uniforms.tCube.value = this.tCube;\n\t\tthis._cubeMesh.material.uniforms.tFlip.value = ( this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\tthis._cubeMesh.material.uniforms.opacity.value = this.opacity;\n\t\tthis._cubeMesh.material.transparent = ( this.opacity < 1.0 );\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this._cubeScene, this._cubeCamera );\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._cubeMesh.geometry.dispose();\n\t\tthis._cubeMesh.material.dispose();\n\n\t}\n\n}\n\nexport { CubeTexturePass };\n"],"mappings":"OACCA,SACAC,YACAC,KACAC,kBACAC,MACAC,UACAC,eACAC,kBACM,eACEC,SAAY,YAerB,MAAMC,wBAAwBD,KAS7B,WAAAE,CAAaC,EAAQC,EAAOC,EAAU,GAErCC,QAOAC,KAAKJ,OAASA,EAOdI,KAAKH,MAAQA,EAQbG,KAAKF,QAAUA,EAQfE,KAAKC,WAAY,EAIjB,MAAMC,EAAaZ,UAAkB,KAErCU,KAAKG,UAAY,IAAIhB,KACpB,IAAID,YAAa,GAAI,GAAI,IACzB,IAAIK,eAAgB,CACnBa,SAAUZ,cAAca,MAAOH,EAAWE,UAC1CE,aAAcJ,EAAWI,aACzBC,eAAgBL,EAAWK,eAC3BC,WAAW,EACXC,YAAY,EACZC,KAAMzB,YAIR0B,OAAOC,eAAgBZ,KAAKG,UAAUU,SAAU,SAAU,CAEzDC,IAAK,WAEJ,OAAOd,KAAKI,SAASP,MAAMkB,KAE5B,IAIDf,KAAKgB,WAAa,IAAI3B,MACtBW,KAAKiB,YAAc,IAAI7B,kBACvBY,KAAKgB,WAAWE,IAAKlB,KAAKG,UAE3B,CAaA,MAAAgB,CAAQC,EAAUC,EAAaC,GAE9B,MAAMC,EAAeH,EAASI,UAC9BJ,EAASI,WAAY,EAErBxB,KAAKiB,YAAYQ,iBAAiBC,KAAM1B,KAAKJ,OAAO6B,kBACpDzB,KAAKiB,YAAYU,WAAWC,sBAAuB5B,KAAKJ,OAAOiC,aAE/D7B,KAAKG,UAAUU,SAAST,SAASP,MAAMkB,MAAQf,KAAKH,MACpDG,KAAKG,UAAUU,SAAST,SAAS0B,MAAMf,MAAUf,KAAKH,MAAMkC,gBAAsD,IAArC/B,KAAKH,MAAMmC,uBAAsC,EAAI,EAClIhC,KAAKG,UAAUU,SAAST,SAASN,QAAQiB,MAAQf,KAAKF,QACtDE,KAAKG,UAAUU,SAASoB,YAAgBjC,KAAKF,QAAU,EAEvDsB,EAASc,gBAAiBlC,KAAKmC,eAAiB,KAAOb,GAClDtB,KAAKoC,OAAQhB,EAASgB,QAC3BhB,EAASD,OAAQnB,KAAKgB,WAAYhB,KAAKiB,aAEvCG,EAASI,UAAYD,CAEtB,CAMA,OAAAc,GAECrC,KAAKG,UAAUmC,SAASD,UACxBrC,KAAKG,UAAUU,SAASwB,SAEzB,SAIQ3C","ignoreList":[]}