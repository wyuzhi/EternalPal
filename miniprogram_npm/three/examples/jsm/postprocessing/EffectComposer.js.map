{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/EffectComposer.js","names":["Clock","HalfFloatType","NoBlending","Vector2","WebGLRenderTarget","CopyShader","ShaderPass","ClearMaskPass","MaskPass","EffectComposer","constructor","renderer","renderTarget","this","_pixelRatio","getPixelRatio","undefined","size","getSize","_width","width","_height","height","type","texture","name","renderTarget1","renderTarget2","clone","writeBuffer","readBuffer","renderToScreen","passes","copyPass","material","blending","clock","swapBuffers","tmp","addPass","pass","push","setSize","insertPass","index","splice","removePass","indexOf","isLastEnabledPass","passIndex","i","length","enabled","render","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","needsSwap","context","getContext","stencil","state","buffers","setFunc","NOTEQUAL","EQUAL","setRenderTarget","reset","dispose","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio"],"sources":["node_modules/three/examples/jsm/postprocessing/EffectComposer.js"],"sourcesContent":["import {\n\tClock,\n\tHalfFloatType,\n\tNoBlending,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from './ShaderPass.js';\nimport { ClearMaskPass, MaskPass } from './MaskPass.js';\n\n/**\n * Used to implement post-processing effects in three.js.\n * The class manages a chain of post-processing passes to produce the final visual result.\n * Post-processing passes are executed in order of their addition/insertion.\n * The last pass is automatically rendered to screen.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * ```js\n * const composer = new EffectComposer( renderer );\n *\n * // adding some passes\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n *\n * const glitchPass = new GlitchPass();\n * composer.addPass( glitchPass );\n *\n * const outputPass = new OutputPass()\n * composer.addPass( outputPass );\n *\n * function animate() {\n *\n * \tcomposer.render(); // instead of renderer.render()\n *\n * }\n * ```\n *\n * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n */\nclass EffectComposer {\n\n\t/**\n\t * Constructs a new effect composer.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\n\t * be used as the internal read and write buffers. If not given, the composer creates\n\t * the buffers automatically.\n\t */\n\tconstructor( renderer, renderTarget ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = renderer.getSize( new Vector2() );\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\t/**\n\t\t * A reference to the internal write buffer. Passes usually write\n\t\t * their result into this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.writeBuffer = this.renderTarget1;\n\n\t\t/**\n\t\t * A reference to the internal read buffer. Passes usually read\n\t\t * the previous render result from this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t/**\n\t\t * Whether the final pass is rendered to the screen (default framebuffer) or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.renderToScreen = true;\n\n\t\t/**\n\t\t * An array representing the (ordered) chain of post-processing passes.\n\t\t *\n\t\t * @type {Array<Pass>}\n\t\t */\n\t\tthis.passes = [];\n\n\t\t/**\n\t\t * A copy pass used for internal swap operations.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderPass}\n\t\t */\n\t\tthis.copyPass = new ShaderPass( CopyShader );\n\t\tthis.copyPass.material.blending = NoBlending;\n\n\t\t/**\n\t\t * The internal clock for managing time data.\n\t\t *\n\t\t * @private\n\t\t * @type {Clock}\n\t\t */\n\t\tthis.clock = new Clock();\n\n\t}\n\n\t/**\n\t * Swaps the internal read/write buffers.\n\t */\n\tswapBuffers() {\n\n\t\tconst tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t}\n\n\t/**\n\t * Adds the given pass to the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to add.\n\t */\n\taddPass( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Inserts the given pass at a given index.\n\t *\n\t * @param {Pass} pass - The pass to insert.\n\t * @param {number} index - The index into the pass chain.\n\t */\n\tinsertPass( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Removes the given pass from the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to remove.\n\t */\n\tremovePass( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\n\t *\n\t * @param {number} passIndex - The pass index.\n\t * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.\n\t */\n\tisLastEnabledPass( passIndex ) {\n\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Executes all enabled post-processing passes in order to produce the final frame.\n\t *\n\t * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\n\t * its own time delta value.\n\t */\n\trender( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tlet maskActive = false;\n\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\tconst pass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\t/**\n\t * Resets the internal state of the EffectComposer.\n\t *\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\n\t * the one from the constructor. If set, it is used to setup the read and write buffers.\n\t */\n\treset( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t}\n\n\t/**\n\t * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\n\t * this method honors the current pixel ration.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\n\t * Setting the pixel ratio will automatically resize the composer.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the composer is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\n\t\tthis.copyPass.dispose();\n\n\t}\n\n}\n\nexport { EffectComposer };\n"],"mappings":"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","ignoreList":[]}