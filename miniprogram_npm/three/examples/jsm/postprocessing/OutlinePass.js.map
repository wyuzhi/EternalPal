{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/OutlinePass.js","names":["AdditiveBlending","Color","DoubleSide","HalfFloatType","Matrix4","MeshDepthMaterial","NoBlending","RGBADepthPacking","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","OutlinePass","constructor","resolution","scene","camera","selectedObjects","super","this","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","patternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","_selectionCache","Set","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","_getPrepareMaskMaterial","fragmentShader","string","type","isPerspectiveCamera","replace","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","_getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","separableBlurMaterial1","_getSeparableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","_getOverlayMaterial","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","enabled","needsSwap","_oldClearColor","oldClearAlpha","_fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","dispose","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","length","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","_updateSelectionCache","_changeVisibilityOfSelectedObjects","currentBackground","background","currentOverrideMaterial","overrideMaterial","setRenderTarget","clear","_updateTextureMatrix","_changeVisibilityOfNonSelectedObjects","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","renderToScreen","cache","gatherSelectedMeshesCallBack","object","isMesh","add","i","traverse","bVisible","mesh","visible","get","visibilityCache","selectionCache","isPoints","isLine","isLine2","isSprite","has","visibility","multiply","projectionMatrix","matrixWorldInverse","depthTexture","cameraNearFar","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2","transparent"],"sources":["node_modules/three/examples/jsm/postprocessing/OutlinePass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tHalfFloatType,\n\tMatrix4,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * A pass for rendering outlines around selected objects.\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const outlinePass = new OutlinePass( resolution, scene, camera );\n * composer.addPass( outlinePass );\n * ```\n *\n * @augments Pass\n * @three_import import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n */\nclass OutlinePass extends Pass {\n\n\t/**\n\t * Constructs a new outline pass.\n\t *\n\t * @param {Vector2} [resolution] - The effect's resolution.\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {Array<Object3D>} [selectedObjects] - The selected 3D objects that should receive an outline.\n\t *\n\t */\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.renderScene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.renderCamera = camera;\n\n\t\t/**\n\t\t * The selected 3D objects that should receive an outline.\n\t\t *\n\t\t * @type {Array<Object3D>}\n\t\t */\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\n\t\t/**\n\t\t * The visible edge color.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (1,1,1)\n\t\t */\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\n\t\t/**\n\t\t * The hidden edge color.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (0.1,0.04,0.02)\n\t\t */\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\n\t\t/**\n\t\t * Can be used for an animated glow/pulse effect.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.edgeGlow = 0.0;\n\n\t\t/**\n\t\t * Whether to use a pattern texture for to highlight selected\n\t\t * 3D objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.usePatternTexture = false;\n\n\t\t/**\n\t\t * Can be used to highlight selected 3D objects. Requires to set\n\t\t * {@link OutlinePass#usePatternTexture} to `true`.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.patternTexture = null;\n\n\t\t/**\n\t\t * The edge thickness.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.edgeThickness = 1.0;\n\n\t\t/**\n\t\t * The edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.edgeStrength = 3.0;\n\n\t\t/**\n\t\t * The downsample ratio. The effect can be rendered in a much\n\t\t * lower resolution than the beauty pass.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.downSampleRatio = 2;\n\n\t\t/**\n\t\t * The pulse period.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\t\tthis._selectionCache = new Set();\n\n\t\t/**\n\t\t * The effect's resolution.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (256,256)\n\t\t */\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this._getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, { type: HalfFloatType } );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this._getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this._getSeparableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this._getSeparableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this._getOverlayMaterial();\n\n\t\t// copy material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t\tthis.depthMaterial.dispose();\n\t\tthis.prepareMaskMaterial.dispose();\n\t\tthis.edgeDetectionMaterial.dispose();\n\t\tthis.separableBlurMaterial1.dispose();\n\t\tthis.separableBlurMaterial2.dispose();\n\t\tthis.overlayMaterial.dispose();\n\t\tthis.materialCopy.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\t/**\n\t * Performs the Outline pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\tthis._updateSelectionCache();\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis._changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tconst currentOverrideMaterial = this.renderScene.overrideMaterial;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis._changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis._updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\t\t\tthis._selectionCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\t\t\tthis.renderScene.overrideMaterial = currentOverrideMaterial;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis._fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis._fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis._fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis._fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t// internals\n\n\t_updateSelectionCache() {\n\n\t\tconst cache = this._selectionCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) cache.add( object );\n\n\t\t}\n\n\t\tcache.clear();\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\t_changeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfor ( const mesh of this._selectionCache ) {\n\n\t\t\tif ( bVisible === true ) {\n\n\t\t\t\tmesh.visible = cache.get( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tcache.set( mesh, mesh.visible );\n\t\t\t\tmesh.visible = bVisible;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_changeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst visibilityCache = this._visibilityCache;\n\t\tconst selectionCache = this._selectionCache;\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isPoints || object.isLine || object.isLine2 ) {\n\n\t\t\t\t// the visibility of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = visibilityCache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvisibilityCache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isMesh || object.isSprite) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tif ( ! selectionCache.has( object ) ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || visibilityCache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvisibilityCache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\t_updateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\t_getPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <batching_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <batching_vertex>\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\t_getEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getSeparableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n"],"mappings":"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","ignoreList":[]}