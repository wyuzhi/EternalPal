{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/RenderPixelatedPass.js","names":["WebGLRenderTarget","MeshNormalMaterial","ShaderMaterial","Vector2","Vector4","DepthTexture","NearestFilter","HalfFloatType","Pass","FullScreenQuad","RenderPixelatedPass","constructor","pixelSize","scene","camera","options","super","this","normalEdgeStrength","depthEdgeStrength","pixelatedMaterial","_createPixelatedMaterial","_resolution","_renderResolution","_normalMaterial","_beautyRenderTarget","texture","minFilter","magFilter","type","depthTexture","_normalRenderTarget","_fsQuad","dispose","setSize","width","height","set","x","y","material","uniforms","resolution","value","setPixelSize","render","renderer","writeBuffer","setRenderTarget","overrideMaterial_old","overrideMaterial","tDiffuse","tDepth","tNormal","renderToScreen","clear","vertexShader","fragmentShader"],"sources":["node_modules/three/examples/jsm/postprocessing/RenderPixelatedPass.js"],"sourcesContent":["import {\n\tWebGLRenderTarget,\n\tMeshNormalMaterial,\n\tShaderMaterial,\n\tVector2,\n\tVector4,\n\tDepthTexture,\n\tNearestFilter,\n\tHalfFloatType\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * A special type of render pass that produces a pixelated beauty pass.\n *\n * ```js\n * const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );\n * composer.addPass( renderPixelatedPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';\n */\nclass RenderPixelatedPass extends Pass {\n\n\t/**\n\t * Constructs a new render pixelated pass.\n\t *\n\t * @param {number} pixelSize - The effect's pixel size.\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {{normalEdgeStrength:number,depthEdgeStrength:number}} options - The pass options.\n\t */\n\tconstructor( pixelSize, scene, camera, options = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The effect's pixel size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.pixelSize = pixelSize;\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.3\n\t\t */\n\t\tthis.normalEdgeStrength = options.normalEdgeStrength || 0.3;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.4\n\t\t */\n\t\tthis.depthEdgeStrength = options.depthEdgeStrength || 0.4;\n\n\t\t/**\n\t\t * The pixelated material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.pixelatedMaterial = this._createPixelatedMaterial();\n\n\t\t// internals\n\n\t\tthis._resolution = new Vector2();\n\t\tthis._renderResolution = new Vector2();\n\n\t\tthis._normalMaterial = new MeshNormalMaterial();\n\n\t\tthis._beautyRenderTarget = new WebGLRenderTarget();\n\t\tthis._beautyRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.type = HalfFloatType;\n\t\tthis._beautyRenderTarget.depthTexture = new DepthTexture();\n\n\t\tthis._normalRenderTarget = new WebGLRenderTarget();\n\t\tthis._normalRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.type = HalfFloatType;\n\n\t\tthis._fsQuad = new FullScreenQuad( this.pixelatedMaterial );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._beautyRenderTarget.dispose();\n\t\tthis._normalRenderTarget.dispose();\n\n\t\tthis.pixelatedMaterial.dispose();\n\t\tthis._normalMaterial.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._resolution.set( width, height );\n\t\tthis._renderResolution.set( ( width / this.pixelSize ) | 0, ( height / this.pixelSize ) | 0 );\n\t\tconst { x, y } = this._renderResolution;\n\t\tthis._beautyRenderTarget.setSize( x, y );\n\t\tthis._normalRenderTarget.setSize( x, y );\n\t\tthis._fsQuad.material.uniforms.resolution.value.set( x, y, 1 / x, 1 / y );\n\n\t}\n\n\t/**\n\t * Sets the effect's pixel size.\n\t *\n\t * @param {number} pixelSize - The pixel size to set.\n\t */\n\tsetPixelSize( pixelSize ) {\n\n\t\tthis.pixelSize = pixelSize;\n\t\tthis.setSize( this._resolution.x, this._resolution.y );\n\n\t}\n\n\t/**\n\t * Performs the pixelation pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer/*, readBuffer , deltaTime, maskActive */ ) {\n\n\t\tconst uniforms = this._fsQuad.material.uniforms;\n\t\tuniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n\t\tuniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n\n\t\trenderer.setRenderTarget( this._beautyRenderTarget );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tconst overrideMaterial_old = this.scene.overrideMaterial;\n\t\trenderer.setRenderTarget( this._normalRenderTarget );\n\t\tthis.scene.overrideMaterial = this._normalMaterial;\n\t\trenderer.render( this.scene, this.camera );\n\t\tthis.scene.overrideMaterial = overrideMaterial_old;\n\n\t\tuniforms.tDiffuse.value = this._beautyRenderTarget.texture;\n\t\tuniforms.tDepth.value = this._beautyRenderTarget.depthTexture;\n\t\tuniforms.tNormal.value = this._normalRenderTarget.texture;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t}\n\n\t\tthis._fsQuad.render( renderer );\n\n\t}\n\n\t// internals\n\n\t_createPixelatedMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\ttDiffuse: { value: null },\n\t\t\t\ttDepth: { value: null },\n\t\t\t\ttNormal: { value: null },\n\t\t\t\tresolution: { value: new Vector4() },\n\t\t\t\tnormalEdgeStrength: { value: 0 },\n\t\t\t\tdepthEdgeStrength: { value: 0 }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0)\n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0;\n\t\t\t\t\tif (normalEdgeStrength > 0.0)\n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t}\n\n}\n\nexport { RenderPixelatedPass };\n"],"mappings":"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","ignoreList":[]}