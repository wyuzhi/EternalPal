{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/SSAARenderPass.js","names":["AdditiveBlending","Color","HalfFloatType","ShaderMaterial","UniformsUtils","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","SSAARenderPass","constructor","scene","camera","clearColor","clearAlpha","super","this","sampleLevel","unbiased","stencilBuffer","_sampleRenderTarget","_oldClearColor","_copyUniforms","clone","uniforms","_copyMaterial","vertexShader","fragmentShader","transparent","depthTest","depthWrite","premultipliedAlpha","blending","_fsQuad","dispose","setSize","width","height","render","renderer","writeBuffer","readBuffer","type","texture","name","jitterOffsets","_JitterVectors","Math","max","min","autoClear","getClearColor","oldClearAlpha","getClearAlpha","baseSampleWeight","length","value","viewOffset","fullWidth","fullHeight","offsetX","offsetY","originalViewOffset","Object","assign","view","enabled","i","jitterOffset","setViewOffset","sampleWeight","setClearColor","setRenderTarget","clear","renderToScreen","clearViewOffset"],"sources":["node_modules/three/examples/jsm/postprocessing/SSAARenderPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * Supersample Anti-Aliasing Render Pass.\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * ```js\n * const ssaaRenderPass = new SSAARenderPass( scene, camera );\n * ssaaRenderPass.sampleLevel = 3;\n * composer.addPass( ssaaRenderPass );\n * ```\n *\n * @augments Pass\n * @three_import import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';\n */\nclass SSAARenderPass extends Pass {\n\n\t/**\n\t * Constructs a new SSAA render pass.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {?(number|Color|string)} [clearColor=0x000000] - The clear color of the render pass.\n\t * @param {?number} [clearAlpha=0] - The clear alpha of the render pass.\n\t */\n\tconstructor( scene, camera, clearColor = 0x000000, clearAlpha = 0 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The sample level. Specified as n, where the number of\n\t\t * samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 4\n\t\t */\n\t\tthis.sampleLevel = 4;\n\n\t\t/**\n\t\t * Whether the pass should be unbiased or not. This property has the most\n\t\t * visible effect when rendering to a RGBA8 buffer because it mitigates\n\t\t * rounding errors. By default RGBA16F is used.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.unbiased = true;\n\n\t\t/**\n\t\t * Whether to use a stencil buffer or not. This property can't\n\t\t * be changed after the first render.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencilBuffer = false;\n\n\t\t/**\n\t\t * The clear color of the render pass.\n\t\t *\n\t\t * @type {?(number|Color|string)}\n\t\t * @default 0x000000\n\t\t */\n\t\tthis.clearColor = clearColor;\n\n\t\t/**\n\t\t * The clear alpha of the render pass.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default 0\n\t\t */\n\t\tthis.clearAlpha = clearAlpha;\n\n\t\t// internals\n\n\t\tthis._sampleRenderTarget = null;\n\n\t\tthis._oldClearColor = new Color();\n\n\t\tthis._copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\n\n\t\tthis._copyMaterial = new ShaderMaterial(\t{\n\t\t\tuniforms: this._copyUniforms,\n\t\t\tvertexShader: CopyShader.vertexShader,\n\t\t\tfragmentShader: CopyShader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tblending: AdditiveBlending\n\t\t} );\n\n\t\tthis._fsQuad = new FullScreenQuad( this._copyMaterial );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tif ( this._sampleRenderTarget ) {\n\n\t\t\tthis._sampleRenderTarget.dispose();\n\t\t\tthis._sampleRenderTarget = null;\n\n\t\t}\n\n\t\tthis._copyMaterial.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tif ( this._sampleRenderTarget )\tthis._sampleRenderTarget.setSize( width, height );\n\n\t}\n\n\t/**\n\t * Performs the SSAA render pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {\n\n\t\tif ( ! this._sampleRenderTarget ) {\n\n\t\t\tthis._sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { type: HalfFloatType, stencilBuffer: this.stencilBuffer } );\n\t\t\tthis._sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n\n\t\t}\n\n\t\tconst jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tconst oldClearAlpha = renderer.getClearAlpha();\n\n\t\tconst baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tconst roundingRange = 1 / 32;\n\t\tthis._copyUniforms[ 'tDiffuse' ].value = this._sampleRenderTarget.texture;\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: readBuffer.width,\n\t\t\tfullHeight: readBuffer.height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: readBuffer.width,\n\t\t\theight: readBuffer.height\n\n\t\t};\n\n\t\tconst originalViewOffset = Object.assign( {}, this.camera.view );\n\n\t\tif ( originalViewOffset.enabled ) Object.assign( viewOffset, originalViewOffset );\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\tfor ( let i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\tconst jitterOffset = jitterOffsets[ i ];\n\n\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\tthis.camera.setViewOffset(\n\n\t\t\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\t\t\tviewOffset.width, viewOffset.height\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tlet sampleWeight = baseSampleWeight;\n\n\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tconst uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\n\t\t\t}\n\n\t\t\tthis._copyUniforms[ 'opacity' ].value = sampleWeight;\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\trenderer.setRenderTarget( this._sampleRenderTarget );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : writeBuffer );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\tif ( this.camera.setViewOffset && originalViewOffset.enabled ) {\n\n\t\t\tthis.camera.setViewOffset(\n\n\t\t\t\toriginalViewOffset.fullWidth, originalViewOffset.fullHeight,\n\n\t\t\t\toriginalViewOffset.offsetX, originalViewOffset.offsetY,\n\n\t\t\t\toriginalViewOffset.width, originalViewOffset.height\n\n\t\t\t);\n\n\t\t} else if ( this.camera.clearViewOffset ) {\n\n\t\t\tthis.camera.clearViewOffset();\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t}\n\n}\n\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { SSAARenderPass };\n"],"mappings":"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","ignoreList":[]}