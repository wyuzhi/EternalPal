{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/ShaderPass.js","names":["ShaderMaterial","UniformsUtils","Pass","FullScreenQuad","ShaderPass","constructor","shader","textureID","super","this","uniforms","material","clone","name","undefined","defines","Object","assign","vertexShader","fragmentShader","_fsQuad","render","renderer","writeBuffer","readBuffer","value","texture","renderToScreen","setRenderTarget","clear","autoClearColor","autoClearDepth","autoClearStencil","dispose"],"sources":["node_modules/three/examples/jsm/postprocessing/ShaderPass.js"],"sourcesContent":["import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * This pass can be used to create a post processing effect\n * with a raw GLSL shader object. Useful for implementing custom\n * effects.\n *\n * ```js\n * const fxaaPass = new ShaderPass( FXAAShader );\n * composer.addPass( fxaaPass );\n * ```\n *\n * @augments Pass\n * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n */\nclass ShaderPass extends Pass {\n\n\t/**\n\t * Constructs a new shader pass.\n\t *\n\t * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\n\t * defines and uniforms. It's also valid to pass a custom shader material.\n\t * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\n\t * the read buffer.\n\t */\n\tconstructor( shader, textureID = 'tDiffuse' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the texture uniform that should sample the read buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'tDiffuse'\n\t\t */\n\t\tthis.textureID = textureID;\n\n\t\t/**\n\t\t * The pass uniforms.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tthis.uniforms = null;\n\n\t\t/**\n\t\t * The pass material.\n\t\t *\n\t\t * @type {?ShaderMaterial}\n\t\t */\n\t\tthis.material = null;\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\t/**\n\t * Performs the shader pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis._fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n"],"mappings":"OACCA,eACAC,kBACM,eACEC,KAAMC,mBAAsB,YAerC,MAAMC,mBAAmBF,KAUxB,WAAAG,CAAaC,EAAQC,EAAY,YAEhCC,QAQAC,KAAKF,UAAYA,EAOjBE,KAAKC,SAAW,KAOhBD,KAAKE,SAAW,KAEXL,aAAkBN,gBAEtBS,KAAKC,SAAWJ,EAAOI,SAEvBD,KAAKE,SAAWL,GAELA,IAEXG,KAAKC,SAAWT,cAAcW,MAAON,EAAOI,UAE5CD,KAAKE,SAAW,IAAIX,eAAgB,CAEnCa,UAAwBC,IAAhBR,EAAOO,KAAuBP,EAAOO,KAAO,cACpDE,QAASC,OAAOC,OAAQ,CAAC,EAAGX,EAAOS,SACnCL,SAAUD,KAAKC,SACfQ,aAAcZ,EAAOY,aACrBC,eAAgBb,EAAOa,kBAQzBV,KAAKW,QAAU,IAAIjB,eAAgBM,KAAKE,SAEzC,CAaA,MAAAU,CAAQC,EAAUC,EAAaC,GAEzBf,KAAKC,SAAUD,KAAKF,aAExBE,KAAKC,SAAUD,KAAKF,WAAYkB,MAAQD,EAAWE,SAIpDjB,KAAKW,QAAQT,SAAWF,KAAKE,SAExBF,KAAKkB,gBAETL,EAASM,gBAAiB,MAC1BnB,KAAKW,QAAQC,OAAQC,KAIrBA,EAASM,gBAAiBL,GAErBd,KAAKoB,OAAQP,EAASO,MAAOP,EAASQ,eAAgBR,EAASS,eAAgBT,EAASU,kBAC7FvB,KAAKW,QAAQC,OAAQC,GAIvB,CAMA,OAAAW,GAECxB,KAAKE,SAASsB,UAEdxB,KAAKW,QAAQa,SAEd,SAIQ7B","ignoreList":[]}