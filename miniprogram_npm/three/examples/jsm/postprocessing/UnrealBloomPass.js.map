{"version":3,"file":"node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","names":["AdditiveBlending","Color","HalfFloatType","MeshBasicMaterial","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","constructor","resolution","strength","radius","threshold","super","this","undefined","x","y","clearColor","needsSwap","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","type","texture","name","generateMipmaps","i","renderTargetHorizontal","push","renderTargetVertical","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","separableBlurMaterials","kernelSizeArray","_getSeparableBlurMaterial","compositeMaterial","_getCompositeMaterial","bloomTintColors","copyUniforms","blendMaterial","blending","depthTest","depthWrite","transparent","_oldClearColor","_oldClearAlpha","_basic","_fsQuad","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","coefficients","exp","defines","KERNEL_RADIUS","colorTexture","invSize","direction","gaussianCoefficients","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","bloomStrength","bloomFactors","bloomRadius"],"sources":["node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * This pass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * When using this pass, tone mapping must be enabled in the renderer settings.\n *\n * Reference:\n * - [Bloom in Unreal Engine]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/}\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );\n * composer.addPass( bloomPass );\n * ```\n *\n * @augments Pass\n * @three_import import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n */\nclass UnrealBloomPass extends Pass {\n\n\t/**\n\t * Constructs a new Unreal Bloom pass.\n\t *\n\t * @param {Vector2} [resolution] - The effect's resolution.\n\t * @param {number} [strength=1] - The Bloom strength.\n\t * @param {number} radius - The Bloom radius.\n\t * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t */\n\tconstructor( resolution, strength = 1, radius, threshold ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The Bloom strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.strength = strength;\n\n\t\t/**\n\t\t * The Bloom radius.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t\t/**\n\t\t * The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.threshold = threshold;\n\n\t\t/**\n\t\t * The effect's resolution.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (256,256)\n\t\t */\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t/**\n\t\t * The effect's clear color\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (0,0,0)\n\t\t */\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t// internals\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this._getSeparableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this._getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tthis.copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: CopyShader.vertexShader,\n\t\t\tfragmentShader: CopyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis._oldClearAlpha = 1;\n\n\t\tthis._basic = new MeshBasicMaterial();\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis._basic.dispose();\n\n\t\t//\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs the Bloom pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis._oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis._fsQuad.material = this._basic;\n\t\t\tthis._basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis._fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis._fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis._fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis._fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this._oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\t// internals\n\n\t_getSeparableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"],"mappings":"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","ignoreList":[]}