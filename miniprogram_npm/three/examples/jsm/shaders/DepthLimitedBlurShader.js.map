{"version":3,"file":"node_modules/three/examples/jsm/shaders/DepthLimitedBlurShader.js","names":["Vector2","DepthLimitedBlurShader","name","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","weights","i","push","gaussian","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate","x","Math","exp","sqrt","PI"],"sources":["node_modules/three/examples/jsm/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import {\n\tVector2\n} from 'three';\n\n/**\n * @module DepthLimitedBlurShader\n * @three_import import { DepthLimitedBlurShader, BlurShaderUtils } from 'three/addons/shaders/DepthLimitedBlurShader.js';\n */\n\n/**\n * TODO\n *\n * Used by {@link SAOPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst DepthLimitedBlurShader = {\n\n\tname: 'DepthLimitedBlurShader',\n\n\tdefines: {\n\t\t'KERNEL_RADIUS': 4,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\n\tuniforms: {\n\t\t'tDiffuse': { value: null },\n\t\t'size': { value: new Vector2( 512, 512 ) },\n\t\t'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },\n\t\t'sampleWeights': { value: [ 1.0 ] },\n\t\t'tDepth': { value: null },\n\t\t'cameraNear': { value: 10 },\n\t\t'cameraFar': { value: 1000 },\n\t\t'depthCutoff': { value: 10 },\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\t#include <common>\n\n\t\tuniform vec2 size;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tvInvSize = 1.0 / size;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float depthCutoff;\n\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = -getViewZ( depth );\n\t\t\tbool rBreak = false, lBreak = false;\n\n\t\t\tfloat weightSum = sampleWeights[0];\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n\t\t\t\tif( ! rBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n\t\t\t\tif( ! lBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = diffuseSum / weightSum;\n\t\t}`\n\n};\n\nconst BlurShaderUtils = {\n\n\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\tconst weights = [];\n\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t}\n\n\t\treturn weights;\n\n\t},\n\n\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\tconst offsets = [];\n\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t}\n\n\t\treturn offsets;\n\n\t},\n\n\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\tmaterial.defines[ 'KERNEL_RADIUS' ] = kernelRadius;\n\t\tmaterial.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\tmaterial.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\tmaterial.needsUpdate = true;\n\n\t}\n\n};\n\nfunction gaussian( x, stdDev ) {\n\n\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n}\n\nexport { DepthLimitedBlurShader, BlurShaderUtils };\n"],"mappings":"OACCA,YACM,QAeP,MAAMC,uBAAyB,CAE9BC,KAAM,yBAENC,QAAS,CACRC,cAAiB,EACjBC,cAAiB,EACjBC,mBAAsB,GAGvBC,SAAU,CACTC,SAAY,CAAEC,MAAO,MACrBC,KAAQ,CAAED,MAAO,IAAIT,QAAS,IAAK,MACnCW,gBAAmB,CAAEF,MAAO,CAAE,IAAIT,QAAS,EAAG,KAC9CY,cAAiB,CAAEH,MAAO,CAAE,IAC5BI,OAAU,CAAEJ,MAAO,MACnBK,WAAc,CAAEL,MAAO,IACvBM,UAAa,CAAEN,MAAO,KACtBO,YAAe,CAAEP,MAAO,KAGzBQ,aAAwB,yQAgBxBC,eAA0B,ijEA8ErBC,gBAAkB,CAEvBC,oBAAqB,SAAWC,EAAcC,GAE7C,MAAMC,EAAU,GAEhB,IAAM,IAAIC,EAAI,EAAGA,GAAKH,EAAcG,IAEnCD,EAAQE,KAAMC,SAAUF,EAAGF,IAI5B,OAAOC,CAER,EAEAI,oBAAqB,SAAWN,EAAcO,GAE7C,MAAMC,EAAU,GAEhB,IAAM,IAAIL,EAAI,EAAGA,GAAKH,EAAcG,IAEnCK,EAAQJ,KAAMG,EAAYE,QAAQC,eAAgBP,IAInD,OAAOK,CAER,EAEAG,UAAW,SAAWC,EAAUZ,EAAcC,EAAQM,GAErDK,EAAS9B,QAAyB,cAAIkB,EACtCY,EAAS1B,SAA4B,gBAAEE,MAAQU,gBAAgBQ,oBAAqBN,EAAcO,GAClGK,EAAS1B,SAA0B,cAAEE,MAAQU,gBAAgBC,oBAAqBC,EAAcC,GAChGW,EAASC,aAAc,CAExB,GAID,SAASR,SAAUS,EAAGb,GAErB,OAAOc,KAAKC,KAASF,EAAIA,GAAgBb,EAASA,EAAjB,KAAkCc,KAAKE,KAAM,EAAMF,KAAKG,IAAOjB,EAEjG,QAESrB,uBAAwBkB","ignoreList":[]}