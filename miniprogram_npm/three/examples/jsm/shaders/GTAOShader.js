import{DataTexture,Matrix4,RepeatWrapping,Vector2,Vector3}from"three";const GTAOShader={name:"GTAOShader",defines:{PERSPECTIVE_CAMERA:1,SAMPLES:16,NORMAL_VECTOR_TYPE:1,DEPTH_SWIZZLING:"x",SCREEN_SPACE_RADIUS:0,SCREEN_SPACE_RADIUS_SCALE:100,SCENE_CLIP_BOX:0},uniforms:{tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},resolution:{value:new Vector2},cameraNear:{value:null},cameraFar:{value:null},cameraProjectionMatrix:{value:new Matrix4},cameraProjectionMatrixInverse:{value:new Matrix4},cameraWorldMatrix:{value:new Matrix4},radius:{value:.25},distanceExponent:{value:1},thickness:{value:1},distanceFallOff:{value:1},scale:{value:1},sceneBoxMin:{value:new Vector3(-1,-1,-1)},sceneBoxMax:{value:new Vector3(1,1,1)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\t\tvarying vec2 vUv;\n\t\tuniform highp sampler2D tNormal;\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\t\tuniform vec2 resolution;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\tuniform mat4 cameraWorldMatrix;\n\t\tuniform float radius;\n\t\tuniform float distanceExponent;\n\t\tuniform float thickness;\n\t\tuniform float distanceFallOff;\n\t\tuniform float scale;\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tuniform vec3 sceneBoxMin;\n\t\t\tuniform vec3 sceneBoxMax;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\t#ifndef FRAGMENT_OUTPUT\n\t\t#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)\n\t\t#endif\n\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\n\t\t}\n\n\t\tfloat getDepth(const vec2 uv) {\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat fetchDepth(const ivec2 uv) {\n\t\t\treturn texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat getViewZ(const in float depth) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\n\t\t\tivec2 p = ivec2(uv * size);\n\t\t\tfloat c0 = fetchDepth(p);\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\n\t\t\tvec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\n\t\t\tvec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\n\t\t\treturn normalize(cross(dpdx, dpdy));\n\t\t}\n\n\t\tvec3 getViewNormal(const vec2 uv) {\n\t\t\t#if NORMAL_VECTOR_TYPE == 2\n\t\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#elif NORMAL_VECTOR_TYPE == 1\n\t\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#else\n\t\t\t\treturn computeNormalFromDepth(uv);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getSceneUvAndDepth(vec3 sampleViewPos) {\n\t\t\tvec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);\n\t\t\tvec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;\n\t\t\tfloat sampleSceneDepth = getDepth(sampleUv);\n\t\t\treturn vec3(sampleUv, sampleSceneDepth);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth(vUv.xy);\n\t\t\tif (depth >= 1.0) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\n\n\t\t\tfloat radiusToUse = radius;\n\t\t\tfloat distanceFalloffToUse = thickness;\n\t\t\t#if SCREEN_SPACE_RADIUS == 1\n\t\t\t\tfloat radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;\n\t\t\t\tradiusToUse *= radiusScale;\n\t\t\t\tdistanceFalloffToUse *= radiusScale;\n\t\t\t#endif\n\n\t\t\t#if SCENE_CLIP_BOX == 1\n\t\t\t\tvec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;\n\t\t\t\tfloat boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));\n\t\t\t\tif (boxDistance > radiusToUse) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\n\t\t\tvec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;\n\t\t\tvec3 tangent = normalize(vec3(randomVec.xy, 0.));\n\t\t\tvec3 bitangent = vec3(-tangent.y, tangent.x, 0.);\n\t\t\tmat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));\n\n\t\t\tconst int DIRECTIONS = SAMPLES < 30 ? 3 : 5;\n\t\t\tconst int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;\n\t\t\tfloat ao = 0.0;\n\t\t\tfor (int i = 0; i < DIRECTIONS; ++i) {\n\n\t\t\t\tfloat angle = float(i) / float(DIRECTIONS) * PI;\n\t\t\t\tvec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);\n\t\t\t\tsampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);\n\n\t\t\t\tvec3 viewDir = normalize(-viewPos.xyz);\n\t\t\t\tvec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));\n\t\t\t\tvec3 sliceTangent = cross(sliceBitangent, viewDir);\n\t\t\t\tvec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));\n\n\t\t\t\tvec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);\n\t\t\t\tvec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));\n\n\t\t\t\tfor (int j = 0; j < STEPS; ++j) {\n\t\t\t\t\tvec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);\n\n\t\t\t\t\tvec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);\n\t\t\t\t\tvec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tvec3 viewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);\n\t\t\t\t\tsampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tviewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);\n\t\t\t\tfloat nx = dot(normalInSlice, sliceTangent);\n\t\t\t\tfloat ny = dot(normalInSlice, viewDir);\n\t\t\t\tfloat nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);\n\t\t\t\tfloat nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);\n\t\t\t\tfloat occlusion = nx * nxb + ny * nyb;\n\t\t\t\tao += occlusion;\n\t\t\t}\n\n\t\t\tao = clamp(ao / float(DIRECTIONS), 0., 1.);\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));\n\t\t#endif\n\t\t\tao = pow(ao, scale);\n\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\n\t\t}"},GTAODepthShader={name:"GTAODepthShader",defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:"\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\t\tuniform sampler2D tDepth;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}"},GTAOBlendShader={name:"GTAOBlendShader",uniforms:{tDiffuse:{value:null},intensity:{value:1}},vertexShader:"\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\t\tuniform float intensity;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);\n\t\t}"};function generateMagicSquareNoise(t=5){const e=Math.floor(t)%2==0?Math.floor(t)+1:Math.floor(t),n=generateMagicSquare(e),o=n.length,a=new Uint8Array(4*o);for(let t=0;t<o;++t){const e=n[t],i=2*Math.PI*e/o,r=new Vector3(Math.cos(i),Math.sin(i),0).normalize();a[4*t]=255*(.5*r.x+.5),a[4*t+1]=255*(.5*r.y+.5),a[4*t+2]=127,a[4*t+3]=255}const i=new DataTexture(a,e,e);return i.wrapS=RepeatWrapping,i.wrapT=RepeatWrapping,i.needsUpdate=!0,i}function generateMagicSquare(t){const e=Math.floor(t)%2==0?Math.floor(t)+1:Math.floor(t),n=e*e,o=Array(n).fill(0);let a=Math.floor(e/2),i=e-1;for(let t=1;t<=n;)-1===a&&i===e?(i=e-2,a=0):(i===e&&(i=0),a<0&&(a=e-1)),0===o[a*e+i]?(o[a*e+i]=t++,i++,a--):(i-=2,a++);return o}export{generateMagicSquareNoise,GTAOShader,GTAODepthShader,GTAOBlendShader};
//# sourceMappingURL=GTAOShader.js.map