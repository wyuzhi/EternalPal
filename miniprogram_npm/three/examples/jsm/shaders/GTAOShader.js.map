{"version":3,"file":"node_modules/three/examples/jsm/shaders/GTAOShader.js","names":["DataTexture","Matrix4","RepeatWrapping","Vector2","Vector3","GTAOShader","name","defines","PERSPECTIVE_CAMERA","SAMPLES","NORMAL_VECTOR_TYPE","DEPTH_SWIZZLING","SCREEN_SPACE_RADIUS","SCREEN_SPACE_RADIUS_SCALE","SCENE_CLIP_BOX","uniforms","tNormal","value","tDepth","tNoise","resolution","cameraNear","cameraFar","cameraProjectionMatrix","cameraProjectionMatrixInverse","cameraWorldMatrix","radius","distanceExponent","thickness","distanceFallOff","scale","sceneBoxMin","sceneBoxMax","vertexShader","fragmentShader","GTAODepthShader","GTAOBlendShader","tDiffuse","intensity","generateMagicSquareNoise","size","noiseSize","Math","floor","magicSquare","generateMagicSquare","noiseSquareSize","length","data","Uint8Array","inx","iAng","angle","PI","randomVec","cos","sin","normalize","x","y","noiseTexture","wrapS","wrapT","needsUpdate","Array","fill","i","j","num"],"sources":["node_modules/three/examples/jsm/shaders/GTAOShader.js"],"sourcesContent":["import {\n\tDataTexture,\n\tMatrix4,\n\tRepeatWrapping,\n\tVector2,\n\tVector3,\n} from 'three';\n\n/**\n * @module GTAOShader\n * @three_import import { GTAOShader } from 'three/addons/shaders/GTAOShader.js';\n */\n\n/**\n * GTAO shader. Use by {@link GTAOPass}.\n *\n * References:\n * - [Practical Realtime Strategies for Accurate Indirect Occlusion]{@link https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf}.\n * - [Horizon-Based Indirect Lighting (HBIL)]{@link https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf}\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GTAOShader = {\n\n\tname: 'GTAOShader',\n\n\tdefines: {\n\t\tPERSPECTIVE_CAMERA: 1,\n\t\tSAMPLES: 16,\n\t\tNORMAL_VECTOR_TYPE: 1,\n\t\tDEPTH_SWIZZLING: 'x',\n\t\tSCREEN_SPACE_RADIUS: 0,\n\t\tSCREEN_SPACE_RADIUS_SCALE: 100.0,\n\t\tSCENE_CLIP_BOX: 0,\n\t},\n\n\tuniforms: {\n\t\ttNormal: { value: null },\n\t\ttDepth: { value: null },\n\t\ttNoise: { value: null },\n\t\tresolution: { value: new Vector2() },\n\t\tcameraNear: { value: null },\n\t\tcameraFar: { value: null },\n\t\tcameraProjectionMatrix: { value: new Matrix4() },\n\t\tcameraProjectionMatrixInverse: { value: new Matrix4() },\n\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\tradius: { value: 0.25 },\n\t\tdistanceExponent: { value: 1. },\n\t\tthickness: { value: 1. },\n\t\tdistanceFallOff: { value: 1. },\n\t\tscale: { value: 1. },\n\t\tsceneBoxMin: { value: new Vector3( - 1, - 1, - 1 ) },\n\t\tsceneBoxMax: { value: new Vector3( 1, 1, 1 ) },\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\t\tuniform highp sampler2D tNormal;\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\t\tuniform vec2 resolution;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\tuniform mat4 cameraWorldMatrix;\n\t\tuniform float radius;\n\t\tuniform float distanceExponent;\n\t\tuniform float thickness;\n\t\tuniform float distanceFallOff;\n\t\tuniform float scale;\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tuniform vec3 sceneBoxMin;\n\t\t\tuniform vec3 sceneBoxMax;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\t#ifndef FRAGMENT_OUTPUT\n\t\t#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)\n\t\t#endif\n\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\n\t\t}\n\n\t\tfloat getDepth(const vec2 uv) {\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat fetchDepth(const ivec2 uv) {\n\t\t\treturn texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat getViewZ(const in float depth) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\n\t\t\tivec2 p = ivec2(uv * size);\n\t\t\tfloat c0 = fetchDepth(p);\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\n\t\t\tvec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\n\t\t\tvec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\n\t\t\treturn normalize(cross(dpdx, dpdy));\n\t\t}\n\n\t\tvec3 getViewNormal(const vec2 uv) {\n\t\t\t#if NORMAL_VECTOR_TYPE == 2\n\t\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#elif NORMAL_VECTOR_TYPE == 1\n\t\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#else\n\t\t\t\treturn computeNormalFromDepth(uv);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getSceneUvAndDepth(vec3 sampleViewPos) {\n\t\t\tvec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);\n\t\t\tvec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;\n\t\t\tfloat sampleSceneDepth = getDepth(sampleUv);\n\t\t\treturn vec3(sampleUv, sampleSceneDepth);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth(vUv.xy);\n\t\t\tif (depth >= 1.0) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\n\n\t\t\tfloat radiusToUse = radius;\n\t\t\tfloat distanceFalloffToUse = thickness;\n\t\t\t#if SCREEN_SPACE_RADIUS == 1\n\t\t\t\tfloat radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;\n\t\t\t\tradiusToUse *= radiusScale;\n\t\t\t\tdistanceFalloffToUse *= radiusScale;\n\t\t\t#endif\n\n\t\t\t#if SCENE_CLIP_BOX == 1\n\t\t\t\tvec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;\n\t\t\t\tfloat boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));\n\t\t\t\tif (boxDistance > radiusToUse) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\n\t\t\tvec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;\n\t\t\tvec3 tangent = normalize(vec3(randomVec.xy, 0.));\n\t\t\tvec3 bitangent = vec3(-tangent.y, tangent.x, 0.);\n\t\t\tmat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));\n\n\t\t\tconst int DIRECTIONS = SAMPLES < 30 ? 3 : 5;\n\t\t\tconst int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;\n\t\t\tfloat ao = 0.0;\n\t\t\tfor (int i = 0; i < DIRECTIONS; ++i) {\n\n\t\t\t\tfloat angle = float(i) / float(DIRECTIONS) * PI;\n\t\t\t\tvec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);\n\t\t\t\tsampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);\n\n\t\t\t\tvec3 viewDir = normalize(-viewPos.xyz);\n\t\t\t\tvec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));\n\t\t\t\tvec3 sliceTangent = cross(sliceBitangent, viewDir);\n\t\t\t\tvec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));\n\n\t\t\t\tvec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);\n\t\t\t\tvec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));\n\n\t\t\t\tfor (int j = 0; j < STEPS; ++j) {\n\t\t\t\t\tvec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);\n\n\t\t\t\t\tvec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);\n\t\t\t\t\tvec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tvec3 viewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);\n\t\t\t\t\tsampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tviewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);\n\t\t\t\tfloat nx = dot(normalInSlice, sliceTangent);\n\t\t\t\tfloat ny = dot(normalInSlice, viewDir);\n\t\t\t\tfloat nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);\n\t\t\t\tfloat nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);\n\t\t\t\tfloat occlusion = nx * nxb + ny * nyb;\n\t\t\t\tao += occlusion;\n\t\t\t}\n\n\t\t\tao = clamp(ao / float(DIRECTIONS), 0., 1.);\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));\n\t\t#endif\n\t\t\tao = pow(ao, scale);\n\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\n\t\t}`\n\n};\n\n/**\n * GTAO depth shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAODepthShader = {\n\n\tname: 'GTAODepthShader',\n\n\tdefines: {\n\t\tPERSPECTIVE_CAMERA: 1\n\t},\n\n\tuniforms: {\n\t\ttDepth: { value: null },\n\t\tcameraNear: { value: null },\n\t\tcameraFar: { value: null },\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform sampler2D tDepth;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}`\n\n};\n\n/**\n * GTAO blend shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAOBlendShader = {\n\n\tname: 'GTAOBlendShader',\n\n\tuniforms: {\n\t\ttDiffuse: { value: null },\n\t\tintensity: { value: 1.0 }\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform float intensity;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);\n\t\t}`\n\n};\n\n\nfunction generateMagicSquareNoise( size = 5 ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst magicSquare = generateMagicSquare( noiseSize );\n\tconst noiseSquareSize = magicSquare.length;\n\tconst data = new Uint8Array( noiseSquareSize * 4 );\n\n\tfor ( let inx = 0; inx < noiseSquareSize; ++ inx ) {\n\n\t\tconst iAng = magicSquare[ inx ];\n\t\tconst angle = ( 2 * Math.PI * iAng ) / noiseSquareSize;\n\t\tconst randomVec = new Vector3(\n\t\t\tMath.cos( angle ),\n\t\t\tMath.sin( angle ),\n\t\t\t0\n\t\t).normalize();\n\t\tdata[ inx * 4 ] = ( randomVec.x * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 1 ] = ( randomVec.y * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 2 ] = 127;\n\t\tdata[ inx * 4 + 3 ] = 255;\n\n\t}\n\n\tconst noiseTexture = new DataTexture( data, noiseSize, noiseSize );\n\tnoiseTexture.wrapS = RepeatWrapping;\n\tnoiseTexture.wrapT = RepeatWrapping;\n\tnoiseTexture.needsUpdate = true;\n\n\treturn noiseTexture;\n\n}\n\nfunction generateMagicSquare( size ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst noiseSquareSize = noiseSize * noiseSize;\n\tconst magicSquare = Array( noiseSquareSize ).fill( 0 );\n\tlet i = Math.floor( noiseSize / 2 );\n\tlet j = noiseSize - 1;\n\n\tfor ( let num = 1; num <= noiseSquareSize; ) {\n\n\t\tif ( i === - 1 && j === noiseSize ) {\n\n\t\t\tj = noiseSize - 2;\n\t\t\ti = 0;\n\n\t\t} else {\n\n\t\t\tif ( j === noiseSize ) {\n\n\t\t\t\tj = 0;\n\n\t\t\t}\n\n\t\t\tif ( i < 0 ) {\n\n\t\t\t\ti = noiseSize - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( magicSquare[ i * noiseSize + j ] !== 0 ) {\n\n\t\t\tj -= 2;\n\t\t\ti ++;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\tmagicSquare[ i * noiseSize + j ] = num ++;\n\n\t\t}\n\n\t\tj ++;\n\t\ti --;\n\n\t}\n\n\treturn magicSquare;\n\n}\n\n\nexport { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader };\n"],"mappings":"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","ignoreList":[]}