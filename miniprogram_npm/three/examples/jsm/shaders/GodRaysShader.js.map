{"version":3,"file":"node_modules/three/examples/jsm/shaders/GodRaysShader.js","names":["Color","Vector3","GodRaysDepthMaskShader","name","uniforms","tInput","value","vertexShader","fragmentShader","GodRaysGenerateShader","fStepSize","vSunPositionScreenSpace","GodRaysCombineShader","tColors","tGodRays","fGodRayIntensity","GodRaysFakeSunShader","fAspect","sunColor","bgColor"],"sources":["node_modules/three/examples/jsm/shaders/GodRaysShader.js"],"sourcesContent":["import {\n\tColor,\n\tVector3\n} from 'three';\n\n/**\n * @module GodRaysShader\n * @three_import import * as GodRaysShader from 'three/addons/shaders/GodRaysShader.js';\n */\n\n/**\n * God-rays (crepuscular rays)\n *\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n * Blurs a mask generated from the depth map along radial lines emanating from the light\n * source. The blur repeatedly applies a blur filter of increasing support but constant\n * sample count to produce a blur filter with large support.\n *\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n * just 6 samples per pass produced acceptable results. The blur is applied three times,\n * with decreasing filter support. The result is equivalent to a single pass with\n * 6*6*6 = 216 samples.\n *\n * References:\n * - [Sousa2008, Crysis Next Gen Effects, GDC2008]{@link http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GodRaysDepthMaskShader = {\n\n\tname: 'GodRaysDepthMaskShader',\n\n\tuniforms: {\n\n\t\ttInput: {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t vUv = uv;\n\t\t gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t }`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tInput;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\n\n\t\t}`\n\n};\n\n\n/**\n * The god-ray generation shader.\n *\n * First pass:\n *\n * The depth map is blurred along radial lines towards the \"sun\". The\n * output is written to a temporary render target (I used a 1/4 sized\n * target).\n *\n * Pass two & three:\n *\n * The results of the previous pass are re-blurred, each time with a\n * decreased distance between samples.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GodRaysGenerateShader = {\n\n\tname: 'GodRaysGenerateShader',\n\n\tuniforms: {\n\n\t\ttInput: {\n\t\t\tvalue: null\n\t\t},\n\t\tfStepSize: {\n\t\t\tvalue: 1.0\n\t\t},\n\t\tvSunPositionScreenSpace: {\n\t\t\tvalue: new Vector3()\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t vUv = uv;\n\t\t gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t }`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#define TAPS_PER_PASS 6.0\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tInput;\n\n\t\tuniform vec3 vSunPositionScreenSpace;\n\t\tuniform float fStepSize; // filter step size\n\n\t\tvoid main() {\n\n\t\t// delta from current pixel to \"sun\" position\n\n\t\t\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\n\t\t\tfloat dist = length( delta );\n\n\t\t// Step vector (uv space)\n\n\t\t\tvec2 stepv = fStepSize * delta / dist;\n\n\t\t// Number of iterations between pixel and sun\n\n\t\t\tfloat iters = dist/fStepSize;\n\n\t\t\tvec2 uv = vUv.xy;\n\t\t\tfloat col = 0.0;\n\n\t\t// This breaks ANGLE in Chrome 22\n\t\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n\t\t/*\n\t\t// Unrolling didn't do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so i've just left the loop\n\n\t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n\n\t\t// Accumulate samples, making sure we don't walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t// mode, with a black border color. I don't think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n\t\t\"\tuv += stepv;\",\n\n\t\t\"}\",\n\t\t*/\n\n\t\t// Unrolling loop manually makes it work in ANGLE\n\n\t\t\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays\n\n\t\t\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t// Should technically be dividing by 'iters but 'TAPS_PER_PASS' smooths out\n\t\t// objectionable artifacts, in particular near the sun position. The side\n\t\t// effect is that the result is darker than it should be around the sun, as\n\t\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t\t// When the result is inverted (in the shader 'godrays_combine this produces\n\t\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\t\t\tgl_FragColor = vec4( col/TAPS_PER_PASS );\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}`\n\n};\n\n/**\n * Additively applies god rays from texture tGodRays to a background (tColors).\n * fGodRayIntensity attenuates the god rays.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GodRaysCombineShader = {\n\n\tname: 'GodRaysCombineShader',\n\n\tuniforms: {\n\n\t\ttColors: {\n\t\t\tvalue: null\n\t\t},\n\n\t\ttGodRays: {\n\t\t\tvalue: null\n\t\t},\n\n\t\tfGodRayIntensity: {\n\t\t\tvalue: 0.69\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColors;\n\t\tuniform sampler2D tGodRays;\n\n\t\tuniform float fGodRayIntensity;\n\n\t\tvoid main() {\n\n\t\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t\t// before being combined with tColors\n\n\t\t\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}`\n\n};\n\n\n/**\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n * cheaper/faster/simpler to implement this as a simple sun sprite.\n *\n * @constant\n * @type {Object}\n */\nconst GodRaysFakeSunShader = {\n\n\tname: 'GodRaysFakeSunShader',\n\n\tuniforms: {\n\n\t\tvSunPositionScreenSpace: {\n\t\t\tvalue: new Vector3()\n\t\t},\n\n\t\tfAspect: {\n\t\t\tvalue: 1.0\n\t\t},\n\n\t\tsunColor: {\n\t\t\tvalue: new Color( 0xffee00 )\n\t\t},\n\n\t\tbgColor: {\n\t\t\tvalue: new Color( 0x000000 )\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform vec3 vSunPositionScreenSpace;\n\t\tuniform float fAspect;\n\n\t\tuniform vec3 sunColor;\n\t\tuniform vec3 bgColor;\n\n\t\tvoid main() {\n\n\t\t\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\n\n\t\t// Correct for aspect ratio\n\n\t\t\tdiff.x *= fAspect;\n\n\t\t\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n\t\t\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n\t\t\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\n\t\t\tgl_FragColor.w = 1.0;\n\n\t\t}`\n\n};\n\nexport { GodRaysDepthMaskShader, GodRaysGenerateShader, GodRaysCombineShader, GodRaysFakeSunShader };\n"],"mappings":"OACCA,MACAC,YACM,QA0BP,MAAMC,uBAAyB,CAE9BC,KAAM,yBAENC,SAAU,CAETC,OAAQ,CACPC,MAAO,OAKTC,aAAwB,2JAWxBC,eAA0B,4JAgCrBC,sBAAwB,CAE7BN,KAAM,wBAENC,SAAU,CAETC,OAAQ,CACPC,MAAO,MAERI,UAAW,CACVJ,MAAO,GAERK,wBAAyB,CACxBL,MAAO,IAAIL,UAKbM,aAAwB,2JAWxBC,eAA0B,stFA+FrBI,qBAAuB,CAE5BT,KAAM,uBAENC,SAAU,CAETS,QAAS,CACRP,MAAO,MAGRQ,SAAU,CACTR,MAAO,MAGRS,iBAAkB,CACjBT,MAAO,MAKTC,aAAwB,8JAWxBC,eAA0B,+gBA8BrBQ,qBAAuB,CAE5Bb,KAAM,uBAENC,SAAU,CAETO,wBAAyB,CACxBL,MAAO,IAAIL,SAGZgB,QAAS,CACRX,MAAO,GAGRY,SAAU,CACTZ,MAAO,IAAIN,MAAO,WAGnBmB,QAAS,CACRb,MAAO,IAAIN,MAAO,KAKpBO,aAAwB,8JAWxBC,eAA0B,qjBA4BlBN,uBAAwBO,sBAAuBG,qBAAsBI","ignoreList":[]}