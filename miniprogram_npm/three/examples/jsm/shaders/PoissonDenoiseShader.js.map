{"version":3,"file":"node_modules/three/examples/jsm/shaders/PoissonDenoiseShader.js","names":["Matrix4","Vector2","Vector3","PoissonDenoiseShader","name","defines","SAMPLES","SAMPLE_VECTORS","generatePdSamplePointInitializer","NORMAL_VECTOR_TYPE","DEPTH_VALUE_SOURCE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","resolution","cameraProjectionMatrixInverse","lumaPhi","depthPhi","normalPhi","radius","index","vertexShader","fragmentShader","samples","rings","radiusExponent","poissonDisk","generateDenoiseSamples","glslCode","i","sample","x","y","z","numSamples","numRings","angle","Math","PI","pow","push","cos","sin"],"sources":["node_modules/three/examples/jsm/shaders/PoissonDenoiseShader.js"],"sourcesContent":["import {\n\tMatrix4,\n\tVector2,\n\tVector3,\n} from 'three';\n\n/**\n * @module PoissonDenoiseShader\n * @three_import import { PoissonDenoiseShader } from 'three/addons/shaders/PoissonDenoiseShader.js';\n */\n\n/**\n * Poisson Denoise Shader.\n *\n * References:\n * - [Self-Supervised Poisson-Gaussian Denoising]{@link https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf}.\n * - [Poisson2Sparse: Self-Supervised Poisson Denoising From a Single Image]{@link https://arxiv.org/pdf/2206.01856.pdf}\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst PoissonDenoiseShader = {\n\n\tname: 'PoissonDenoiseShader',\n\n\tdefines: {\n\t\t'SAMPLES': 16,\n\t\t'SAMPLE_VECTORS': generatePdSamplePointInitializer( 16, 2, 1 ),\n\t\t'NORMAL_VECTOR_TYPE': 1,\n\t\t'DEPTH_VALUE_SOURCE': 0,\n\t},\n\n\tuniforms: {\n\t\t'tDiffuse': { value: null },\n\t\t'tNormal': { value: null },\n\t\t'tDepth': { value: null },\n\t\t'tNoise': { value: null },\n\t\t'resolution': { value: new Vector2() },\n\t\t'cameraProjectionMatrixInverse': { value: new Matrix4() },\n\t\t'lumaPhi': { value: 5. },\n\t\t'depthPhi': { value: 5. },\n\t\t'normalPhi': { value: 5. },\n\t\t'radius': { value: 4. },\n\t\t'index': { value: 0 }\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\t\tuniform vec2 resolution;\n\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\tuniform float lumaPhi;\n\t\tuniform float depthPhi;\n\t\tuniform float normalPhi;\n\t\tuniform float radius;\n\t\tuniform int index;\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\t#ifndef SAMPLE_LUMINANCE\n\t\t#define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)\n\t\t#endif\n\n\t\t#ifndef FRAGMENT_OUTPUT\n\t\t#define FRAGMENT_OUTPUT vec4(denoised, 1.)\n\t\t#endif\n\n\t\tfloat getLuminance(const in vec3 a) {\n\t\t\treturn SAMPLE_LUMINANCE;\n\t\t}\n\n\t\tconst vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;\n\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\n\t\t}\n\n\t\tfloat getDepth(const vec2 uv) {\n\t\t#if DEPTH_VALUE_SOURCE == 1\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).a;\n\t\t#else\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).r;\n\t\t#endif\n\t\t}\n\n\t\tfloat fetchDepth(const ivec2 uv) {\n\t\t\t#if DEPTH_VALUE_SOURCE == 1\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).a;\n\t\t\t#else\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).r;\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\n\t\t\tivec2 p = ivec2(uv * size);\n\t\t\tfloat c0 = fetchDepth(p);\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\n\t\t\tvec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\n\t\t\tvec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\n\t\t\treturn normalize(cross(dpdx, dpdy));\n\t\t}\n\n\t\tvec3 getViewNormal(const vec2 uv) {\n\t\t#if NORMAL_VECTOR_TYPE == 2\n\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\n\t\t#elif NORMAL_VECTOR_TYPE == 1\n\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\n\t\t#else\n\t\t\treturn computeNormalFromDepth(uv);\n\t\t#endif\n\t\t}\n\n\t\tvoid denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout float totalWeight) {\n\t\t\tvec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);\n\t\t\tfloat sampleDepth = getDepth(sampleUv);\n\t\t\tvec3 sampleNormal = getViewNormal(sampleUv);\n\t\t\tvec3 neighborColor = sampleTexel.rgb;\n\t\t\tvec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);\n\n\t\t\tfloat normalDiff = dot(viewNormal, sampleNormal);\n\t\t\tfloat normalSimilarity = pow(max(normalDiff, 0.), normalPhi);\n\t\t\tfloat lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));\n\t\t\tfloat lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);\n\t\t\tfloat depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));\n\t\t\tfloat depthSimilarity = max(1. - depthDiff / depthPhi, 0.);\n\t\t\tfloat w = lumaSimilarity * depthSimilarity * normalSimilarity;\n\n\t\t\tdenoised += w * neighborColor;\n\t\t\ttotalWeight += w;\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth(vUv.xy);\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\n\t\t\tif (depth == 1. || dot(viewNormal, viewNormal) == 0.) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec4 texel = textureLod(tDiffuse, vUv, 0.0);\n\t\t\tvec3 center = texel.rgb;\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\n\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\n      \t\tvec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));\n    \t\tmat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);\n\n\t\t\tfloat totalWeight = 1.0;\n\t\t\tvec3 denoised = texel.rgb;\n\t\t\tfor (int i = 0; i < SAMPLES; i++) {\n\t\t\t\tvec3 sampleDir = poissonDisk[i];\n\t\t\t\tvec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);\n\t\t\t\tvec2 sampleUv = vUv + offset;\n\t\t\t\tdenoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);\n\t\t\t}\n\n\t\t\tif (totalWeight > 0.) {\n\t\t\t\tdenoised /= totalWeight;\n\t\t\t}\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\n\t\t}`\n\n};\n\nfunction generatePdSamplePointInitializer( samples, rings, radiusExponent ) {\n\n\tconst poissonDisk = generateDenoiseSamples(\n\t\tsamples,\n\t\trings,\n\t\tradiusExponent,\n\t);\n\n\tlet glslCode = 'vec3[SAMPLES](';\n\n\tfor ( let i = 0; i < samples; i ++ ) {\n\n\t\tconst sample = poissonDisk[ i ];\n\t\tglslCode += `vec3(${sample.x}, ${sample.y}, ${sample.z})${( i < samples - 1 ) ? ',' : ')'}`;\n\n\t}\n\n\treturn glslCode;\n\n}\n\nfunction generateDenoiseSamples( numSamples, numRings, radiusExponent ) {\n\n\tconst samples = [];\n\n\tfor ( let i = 0; i < numSamples; i ++ ) {\n\n\t\tconst angle = 2 * Math.PI * numRings * i / numSamples;\n\t\tconst radius = Math.pow( i / ( numSamples - 1 ), radiusExponent );\n\t\tsamples.push( new Vector3( Math.cos( angle ), Math.sin( angle ), radius ) );\n\n\t}\n\n\treturn samples;\n\n}\n\nexport { generatePdSamplePointInitializer, PoissonDenoiseShader };\n"],"mappings":"OACCA,QACAC,QACAC,YACM,QAiBP,MAAMC,qBAAuB,CAE5BC,KAAM,uBAENC,QAAS,CACRC,QAAW,GACXC,eAAkBC,iCAAkC,GAAI,EAAG,GAC3DC,mBAAsB,EACtBC,mBAAsB,GAGvBC,SAAU,CACTC,SAAY,CAAEC,MAAO,MACrBC,QAAW,CAAED,MAAO,MACpBE,OAAU,CAAEF,MAAO,MACnBG,OAAU,CAAEH,MAAO,MACnBI,WAAc,CAAEJ,MAAO,IAAIZ,SAC3BiB,8BAAiC,CAAEL,MAAO,IAAIb,SAC9CmB,QAAW,CAAEN,MAAO,GACpBO,SAAY,CAAEP,MAAO,GACrBQ,UAAa,CAAER,MAAO,GACtBS,OAAU,CAAET,MAAO,GACnBU,MAAS,CAAEV,MAAO,IAGnBW,aAAwB,0JASxBC,eAA0B,8jKA8I3B,SAASjB,iCAAkCkB,EAASC,EAAOC,GAE1D,MAAMC,EAAcC,uBACnBJ,EACAC,EACAC,GAGD,IAAIG,EAAW,iBAEf,IAAM,IAAIC,EAAI,EAAGA,EAAIN,EAASM,IAAO,CAEpC,MAAMC,EAASJ,EAAaG,GAC5BD,GAAY,QAAQE,EAAOC,MAAMD,EAAOE,MAAMF,EAAOG,KAAOJ,EAAIN,EAAU,EAAM,IAAM,KAEvF,CAEA,OAAOK,CAER,CAEA,SAASD,uBAAwBO,EAAYC,EAAUV,GAEtD,MAAMF,EAAU,GAEhB,IAAM,IAAIM,EAAI,EAAGA,EAAIK,EAAYL,IAAO,CAEvC,MAAMO,EAAQ,EAAIC,KAAKC,GAAKH,EAAWN,EAAIK,EACrCf,EAASkB,KAAKE,IAAKV,GAAMK,EAAa,GAAKT,GACjDF,EAAQiB,KAAM,IAAIzC,QAASsC,KAAKI,IAAKL,GAASC,KAAKK,IAAKN,GAASjB,GAElE,CAEA,OAAOI,CAER,QAESlB,iCAAkCL","ignoreList":[]}