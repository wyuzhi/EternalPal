import{toFloatType}from"./TranspilerUtils.js";export class ASTNode{constructor(){this.isASTNode=!0,this.linker={reference:null,accesses:[],assignments:[]},this.parent=null}get isNumericExpression(){return!1}get hasAssignment(){return!0===this.isAssignment||null!==this.parent&&this.parent.hasAssignment}getType(){return this.type||null}getParent(t=[]){return null===this.parent?t:(t.push(this.parent),this.parent.getParent(t))}initialize(){for(const t in this)if(this[t]&&this[t].isASTNode)this[t].parent=this;else if(Array.isArray(this[t])){const s=this[t];for(const t of s)t&&t.isASTNode&&(t.parent=this)}}}export class Comment extends ASTNode{constructor(t){super(),this.comment=t,this.isComment=!0,this.initialize()}}export class Program extends ASTNode{constructor(t=[]){super(),this.body=t,this.isProgram=!0,this.initialize()}}export class VariableDeclaration extends ASTNode{constructor(t,s,i=null,e=null,r=!1){super(),this.type=t,this.name=s,this.value=i,this.next=e,this.immutable=r,this.isVariableDeclaration=!0,this.initialize()}get isAssignment(){return null!==this.value}}export class Uniform extends ASTNode{constructor(t,s){super(),this.type=t,this.name=s,this.isUniform=!0,this.initialize()}}export class Varying extends ASTNode{constructor(t,s){super(),this.type=t,this.name=s,this.isVarying=!0,this.initialize()}}export class FunctionParameter extends ASTNode{constructor(t,s,i=null,e=!0){super(),this.type=t,this.name=s,this.qualifier=i,this.immutable=e,this.isFunctionParameter=!0,this.initialize()}}export class FunctionDeclaration extends ASTNode{constructor(t,s,i=[],e=[]){super(),this.type=t,this.name=s,this.params=i,this.body=e,this.isFunctionDeclaration=!0,this.initialize()}}export class Expression extends ASTNode{constructor(t){super(),this.expression=t,this.isExpression=!0,this.initialize()}}export class Ternary extends ASTNode{constructor(t,s,i){super(),this.cond=t,this.left=s,this.right=i,this.isTernary=!0,this.initialize()}}export class Operator extends ASTNode{constructor(t,s,i){super(),this.type=t,this.left=s,this.right=i,this.isOperator=!0,this.initialize()}get isAssignment(){return/^(=|\+=|-=|\*=|\/=|%=|<<=|>>=|>>>=|&=|\^=|\|=)$/.test(this.type)}get isNumericExpression(){return!(!this.left.isNumericExpression||!this.right.isNumericExpression)}getType(){const t=this.left.getType(),s=this.right.getType();return t===s?t:toFloatType(t)===toFloatType(s)?toFloatType(t):null}}export class Unary extends ASTNode{constructor(t,s,i=!1){super(),this.type=t,this.expression=s,this.after=i,this.isUnary=!0,this.initialize()}get isAssignment(){return/^(\+\+|--)$/.test(this.type)}get isNumericExpression(){return!!this.expression.isNumber}}export class Number extends ASTNode{constructor(t,s="float"){super(),this.type=s,this.value=t,this.isNumber=!0,this.initialize()}get isNumericExpression(){return!0}}export class String extends ASTNode{constructor(t){super(),this.value=t,this.isString=!0,this.initialize()}}export class Conditional extends ASTNode{constructor(t=null,s=[]){super(),this.cond=t,this.body=s,this.elseConditional=null,this.isConditional=!0,this.initialize()}}export class FunctionCall extends ASTNode{constructor(t,s=[]){super(),this.name=t,this.params=s,this.isFunctionCall=!0,this.initialize()}}export class Return extends ASTNode{constructor(t){super(),this.value=t,this.isReturn=!0,this.initialize()}}export class Discard extends ASTNode{constructor(){super(),this.isDiscard=!0,this.initialize()}}export class Continue extends ASTNode{constructor(){super(),this.isContinue=!0,this.initialize()}}export class Break extends ASTNode{constructor(){super(),this.isBreak=!0,this.initialize()}}export class Accessor extends ASTNode{constructor(t){super(),this.property=t,this.isAccessor=!0,this.initialize()}getType(){return this.linker.reference?this.linker.reference.getType():super.getType()}}export class StaticElement extends ASTNode{constructor(t){super(),this.value=t,this.isStaticElement=!0,this.initialize()}}export class DynamicElement extends ASTNode{constructor(t){super(),this.value=t,this.isDynamicElement=!0,this.initialize()}}export class AccessorElements extends ASTNode{constructor(t,s=[]){super(),this.object=t,this.elements=s,this.isAccessorElements=!0,this.initialize()}}export class For extends ASTNode{constructor(t,s,i,e=[]){super(),this.initialization=t,this.condition=s,this.afterthought=i,this.body=e,this.isFor=!0,this.initialize()}}export class While extends ASTNode{constructor(t,s=[]){super(),this.condition=t,this.body=s,this.isWhile=!0,this.initialize()}}export class Switch extends ASTNode{constructor(t,s){super(),this.discriminant=t,this.cases=s,this.isSwitch=!0,this.initialize()}}export class SwitchCase extends ASTNode{constructor(t,s=null){super(),this.body=t,this.conditions=s,this.isDefault=null===s,this.isSwitchCase=!0,this.initialize()}}
//# sourceMappingURL=AST.js.map