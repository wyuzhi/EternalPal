import{Program,FunctionDeclaration,Switch,For,AccessorElements,Ternary,Varying,DynamicElement,StaticElement,FunctionParameter,Unary,Conditional,VariableDeclaration,Operator,Number,String,FunctionCall,Return,Accessor,Uniform,Discard,SwitchCase,Continue,Break,While,Comment}from"./AST.js";import{isType}from"./TranspilerUtils.js";const unaryOperators=["+","-","~","!","++","--"],arithmeticOperators=["*","/","%","+","-","<<",">>"],precedenceOperators=["/","*","%","-","+","<<",">>","<",">","<=",">=","==","!=","&","^","|","&&","^^","||","?","=","+=","-=","*=","/=","%=","^=","&=","|=","<<=",">>=",","].reverse(),associativityRightToLeft=["=","+=","-=","*=","/=","%=","^=","&=","|=","<<=",">>=",",","?",":"],glslToTSL={inversesqrt:"inverseSqrt"},samplers=["sampler1D","sampler2D","sampler2DArray","sampler2DShadow","sampler2DArrayShadow","isampler2D","isampler2DArray","usampler2D","usampler2DArray"],samplersCube=["samplerCube","samplerCubeShadow","usamplerCube","isamplerCube"],samplers3D=["sampler3D","isampler3D","usampler3D"],spaceRegExp=/^((\t| )\n*)+/,lineRegExp=/^\n+/,commentRegExp=/^\/\*[\s\S]*?\*\//,inlineCommentRegExp=/^\/\/.*?(?=\n|$)/,numberRegExp=/^((0x\w+)|(\.?\d+\.?\d*((e-?\d+)|\w)?))/,stringDoubleRegExp=/^(\"((?:[^"\\]|\\.)*)\")/,stringSingleRegExp=/^(\'((?:[^'\\]|\\.)*)\')/,literalRegExp=/^[A-Za-z](\w|\.)*/,operatorsRegExp=new RegExp("^(\\"+["<<=",">>=","++","--","<<",">>","+=","-=","*=","/=","%=","&=","^^","^=","|=","<=",">=","==","!=","&&","||","(",")","[","]","{","}",".",",",";","!","=","~","*","/","%","+","-","<",">","&","^","|","?",":","#"].join("$").split("").join("\\").replace(/\\\$/g,"|")+")");function getFunctionName(e){return glslToTSL[e]||e}function getGroupDelta(e){return"("===e||"["===e||"{"===e?1:")"===e||"]"===e||"}"===e?-1:0}class Token{constructor(e,s,t,r){this.tokenizer=e,this.type=s,this.str=t,this.pos=r,this.isTag=!1,this.tags=null}get endPos(){return this.pos+this.str.length}get isNumber(){return this.type===Token.NUMBER}get isString(){return this.type===Token.STRING}get isLiteral(){return this.type===Token.LITERAL}get isOperator(){return this.type===Token.OPERATOR}}Token.LINE="line",Token.COMMENT="comment",Token.NUMBER="number",Token.STRING="string",Token.LITERAL="literal",Token.OPERATOR="operator";const TokenParserList=[{type:Token.LINE,regexp:lineRegExp,isTag:!0},{type:Token.COMMENT,regexp:commentRegExp,isTag:!0},{type:Token.COMMENT,regexp:inlineCommentRegExp,isTag:!0},{type:Token.NUMBER,regexp:numberRegExp},{type:Token.STRING,regexp:stringDoubleRegExp,group:2},{type:Token.STRING,regexp:stringSingleRegExp,group:2},{type:Token.LITERAL,regexp:literalRegExp},{type:Token.OPERATOR,regexp:operatorsRegExp}];class Tokenizer{constructor(e){this.source=e,this.position=0,this.tokens=[]}tokenize(){let e=this.readToken();for(;e;)this.tokens.push(e),e=this.readToken();return this}skip(...e){let s=this.source.substr(this.position),t=e.length;for(;t--;){const r=e[t].exec(s),n=r?r[0].length:0;n>0&&(this.position+=n,s=this.source.substr(this.position),t=e.length)}return s}nextToken(){const e=this.skip(spaceRegExp);for(var s=0;s<TokenParserList.length;s++){const t=TokenParserList[s],r=t.regexp.exec(e);if(r){const e=new Token(this,t.type,r[t.group||0],this.position);return e.isTag=t.isTag,this.position+=r[0].length,e}}}readToken(){let e=this.nextToken();if(e&&e.isTag){const s=[];for(;e.isTag;)if(s.push(e),e=this.nextToken(),!e)return;e.tags=s}return e}}class GLSLDecoder{constructor(){this.index=0,this.tokenizer=null,this.keywords=[],this.addPolyfill("gl_FragCoord","vec3 gl_FragCoord = vec3( screenCoordinate.x, screenCoordinate.y.oneMinus(), screenCoordinate.z );")}addPolyfill(e,s){return this.keywords.push({name:e,polyfill:s}),this}get tokens(){return this.tokenizer.tokens}readToken(){return this.tokens[this.index++]}getToken(e=0){return this.tokens[this.index+e]}getTokensUntil(e,s,t=0){const r=[];let n=0;for(let i=t;i<s.length;i++){const t=s[i];if(n+=getGroupDelta(t.str),r.push(t),0===n&&t.str===e)break}return r}readTokensUntil(e){const s=this.getTokensUntil(e,this.tokens,this.index);return this.index+=s.length,s}parseExpressionFromTokens(e){if(0===e.length)return null;const s=e[0],t=e[e.length-1];let r=0;for(const s of precedenceOperators){const t=(t,n=!1)=>{const i=e[t];if(r+=getGroupDelta(i.str),i.isOperator&&0!==t&&t!==e.length-1&&(!n||!arithmeticOperators.includes(e[t-1].str))){if(0===r&&i.str===s){if("?"===s){const s=e.slice(0,t),r=this.getTokensUntil(":",e,t+1).slice(0,-1),n=e.slice(t+r.length+2),i=this.parseExpressionFromTokens(s),o=this.parseExpressionFromTokens(r),a=this.parseExpressionFromTokens(n);return new Ternary(i,o,a)}{const r=this.parseExpressionFromTokens(e.slice(0,t)),n=this.parseExpressionFromTokens(e.slice(t+1,e.length));return new Operator(s,r,n)}}if(n){if(r>0)return this.parseExpressionFromTokens(e.slice(t))}else if(r<0)return this.parseExpressionFromTokens(e.slice(0,t))}};if(associativityRightToLeft.includes(s))for(let s=0;s<e.length;s++){const e=t(s);if(e)return e}else for(let s=e.length-1;s>=0;s--){const e=t(s,!0);if(e)return e}}if(s.isOperator)for(const t of unaryOperators)if(s.str===t){const s=this.parseExpressionFromTokens(e.slice(1));return new Unary(t,s)}if(t.isOperator)for(const s of unaryOperators)if(t.str===s){const t=this.parseExpressionFromTokens(e.slice(0,e.length-1));return new Unary(s,t,!0)}if("("===s.str){const s=this.getTokensUntil(")",e),t=this.parseExpressionFromTokens(s.slice(1,s.length-1)),r=e[s.length];if(r){const n=e.slice(s.length+1),i=this.parseExpressionFromTokens(n);return new Operator(r.str,t,i)}return t}if(s.isNumber){let e;const t=/^(0x)/.test(s.str);e=t?"int":/u$|U$/.test(s.str)?"uint":/f|e|\./.test(s.str)?"float":"int";let r=s.str.replace(/u|U|i$/,"");return!1===t&&(r=r.replace(/f$/,"")),new Number(r,e)}if(s.isString)return new String(s.str);if(s.isLiteral){if("return"===s.str)return new Return(this.parseExpressionFromTokens(e.slice(1)));if("discard"===s.str)return new Discard;if("continue"===s.str)return new Continue;if("break"===s.str)return new Break;const t=e[1];if(t){if("("===t.str){const t=this.getTokensUntil(")",e,1).slice(1,-1),r=this.parseFunctionParametersFromTokens(t),n=new FunctionCall(getFunctionName(s.str),r),i=e.slice(3+t.length);if(i.length>0){const e=this.parseAccessorElementsFromTokens(i);return new AccessorElements(n,e)}return n}if("["===t.str){const t=this.parseAccessorElementsFromTokens(e.slice(1));return new AccessorElements(new Accessor(s.str),t)}}return new Accessor(s.str)}}parseAccessorElementsFromTokens(e){const s=[];let t=e;for(;t.length>0;){const e=t[0];if("["===e.str){const e=this.getTokensUntil("]",t),r=this.parseExpressionFromTokens(e.slice(1,e.length-1));t=t.slice(e.length),s.push(new DynamicElement(r))}else{if("."!==e.str){console.error("Unknown accessor expression",e);break}{const e=t.slice(1,2),r=this.parseExpressionFromTokens(e);t=t.slice(2),s.push(new StaticElement(r))}}}return s}parseFunctionParametersFromTokens(e){if(0===e.length)return[];const s=[];let t=this.parseExpressionFromTokens(e);for(;","===t.type;)s.push(t.left),t=t.right;return s.push(t),s}parseExpression(){const e=this.readTokensUntil(";");return this.parseExpressionFromTokens(e.slice(0,e.length-1))}parseFunctionParams(e){const s=[];for(let t=0;t<e.length;t++){const r="const"===e[t].str;r&&t++;let n=e[t].str;/^(in|out|inout)$/.test(n)?t++:n=null;const i=e[t++].str,o=e[t++].str;if(s.push(new FunctionParameter(i,o,n,r)),e[t]&&","!==e[t].str)throw new Error('Expected ","')}return s}parseFunction(){const e=this.readToken().str,s=this.readToken().str,t=this.readTokensUntil(")"),r=this.parseFunctionParams(t.slice(1,t.length-1)),n=this.parseBlock();return new FunctionDeclaration(e,s,r,n)}parseVariablesFromToken(e,s){let t=0;const r="const"===e[0].str;r&&t++,s=s||e[t++].str;const n=e[t++].str;let i=null,o=null;if(e[t]){const r=this.getTokensUntil(",",e,t);if("="===r[0].str){const e=r.slice(1);","===e[e.length-1].str&&e.pop(),i=this.parseExpressionFromTokens(e)}const n=e.slice(r.length+(t-1));n[0]&&","===n[0].str&&(o=this.parseVariablesFromToken(n.slice(1),s))}return new VariableDeclaration(s,n,i,o,r)}parseVariables(){const e=this.readTokensUntil(";");return this.parseVariablesFromToken(e.slice(0,e.length-1))}parseUniform(){const e=this.readTokensUntil(";");let s=e[1].str;const t=e[2].str;return samplers.includes(s)?s="texture":samplersCube.includes(s)?s="cubeTexture":samplers3D.includes(s)&&(s="texture3D"),new Uniform(s,t)}parseVarying(){const e=this.readTokensUntil(";"),s=e[1].str,t=e[2].str;return new Varying(s,t)}parseReturn(){this.readToken();const e=this.parseExpression();return new Return(e)}parseWhile(){this.readToken();const e=this.readTokensUntil(")").slice(1,-1),s=this.parseExpressionFromTokens(e);let t;t="{"===this.getToken().str?this.parseBlock():[this.parseExpression()];return new While(s,t)}parseFor(){this.readToken();const e=this.readTokensUntil(")").slice(1,-1),s=this.getTokensUntil(";",e,0).slice(0,-1),t=this.getTokensUntil(";",e,s.length+1).slice(0,-1),r=e.slice(s.length+t.length+2);let n;n=s[0]&&isType(s[0].str)?this.parseVariablesFromToken(s):this.parseExpressionFromTokens(s);const i=this.parseExpressionFromTokens(t),o=this.parseExpressionFromTokens(r);let a;a="{"===this.getToken().str?this.parseBlock():[this.parseExpression()];return new For(n,i,o,a)}parseSwitch(){this.readToken();const e=this.readTokensUntil(")"),s=this.parseExpressionFromTokens(e.slice(1,-1));if("{"!==this.getToken().str)throw new Error("Expected '{' after switch(...) ");this.readToken();const t=this.parseSwitchCases();return new Switch(s,t)}parseSwitchCases(){const e=[];let s=this.getToken(),t=null;const r=e=>"case"===e.str||"default"===e.str;for(;r(s);){if(this.readToken(),"case"===s.str){const e=this.readTokensUntil(":"),s=this.parseExpressionFromTokens(e.slice(0,-1));t=t||[],t.push(s)}else this.readTokensUntil(":"),t=null;s=this.getToken(),r(s)||(e.push(new SwitchCase(this.parseBlock(),t)),s=this.getToken(),t=null)}return e}parseIf(){const e=()=>{this.readToken();const e=this.readTokensUntil(")");return this.parseExpressionFromTokens(e.slice(1,e.length-1))},s=()=>{let e;return e="{"===this.getToken().str?this.parseBlock():[this.parseExpression()],e},t=new Conditional(e(),s());let r=t;for(;this.getToken()&&"else"===this.getToken().str;){this.readToken();const t=r;let n=null;"if"===this.getToken().str&&(n=e()),r=new Conditional(n,s()),r.parent=t,t.elseConditional=r}return t}parseBlock(){const e=[];"{"===this.getToken().str&&this.readToken();let s=0;for(;this.index<this.tokens.length;){const t=this.getToken();let r=null;if(s+=getGroupDelta(t.str),0===s&&("case"===t.str||"default"===t.str))return e;if(s<0)return this.readToken(),e;if(t.tags){let s=null;for(const r of t.tags)if(r.type===Token.COMMENT){const t=r.str.replace(/\t/g,"");s&&!0===s.isComment?s.comment+="\n"+t:(s=new Comment(t),e.push(s))}}(t.isLiteral||t.isOperator)&&(r="const"===t.str?this.parseVariables():"uniform"===t.str?this.parseUniform():"varying"===t.str?this.parseVarying():isType(t.str)?"("===this.getToken(2).str?this.parseFunction():this.parseVariables():"return"===t.str?this.parseReturn():"if"===t.str?this.parseIf():"for"===t.str?this.parseFor():"while"===t.str?this.parseWhile():"switch"===t.str?this.parseSwitch():this.parseExpression()),r?e.push(r):this.index++}return e}parse(e){let s="";for(const t of this.keywords)new RegExp(`(^|\\b)${t.name}($|\\b)`,"gm").test(e)&&(s+=t.polyfill+"\n");s&&(s="// Polyfills\n\n"+s+"\n"),this.index=0,this.tokenizer=new Tokenizer(s+e).tokenize();const t=this.parseBlock();return new Program(t)}}export default GLSLDecoder;
//# sourceMappingURL=GLSLDecoder.js.map