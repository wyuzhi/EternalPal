{"version":3,"file":"node_modules/three/examples/jsm/transpiler/GLSLDecoder.js","names":["Program","FunctionDeclaration","Switch","For","AccessorElements","Ternary","Varying","DynamicElement","StaticElement","FunctionParameter","Unary","Conditional","VariableDeclaration","Operator","Number","String","FunctionCall","Return","Accessor","Uniform","Discard","SwitchCase","Continue","Break","While","Comment","isType","unaryOperators","arithmeticOperators","precedenceOperators","reverse","associativityRightToLeft","glslToTSL","inversesqrt","samplers","samplersCube","samplers3D","spaceRegExp","lineRegExp","commentRegExp","inlineCommentRegExp","numberRegExp","stringDoubleRegExp","stringSingleRegExp","literalRegExp","operatorsRegExp","RegExp","join","split","replace","getFunctionName","str","getGroupDelta","Token","constructor","tokenizer","type","pos","this","isTag","tags","endPos","length","isNumber","NUMBER","isString","STRING","isLiteral","LITERAL","isOperator","OPERATOR","LINE","COMMENT","TokenParserList","regexp","group","Tokenizer","source","position","tokens","tokenize","token","readToken","push","skip","params","remainingCode","substr","i","exec","skipLength","nextToken","parser","result","GLSLDecoder","index","keywords","addPolyfill","name","polyfill","getToken","offset","getTokensUntil","output","groupIndex","readTokensUntil","parseExpressionFromTokens","firstToken","lastToken","operator","parseToken","inverse","includes","conditionTokens","slice","leftTokens","rightTokens","condition","left","right","isHex","test","secondToken","internalTokens","paramsTokens","parseFunctionParametersFromTokens","functionCall","accessTokens","elements","parseAccessorElementsFromTokens","currentTokens","accessorTokens","element","console","error","current","parseExpression","parseFunctionParams","immutable","qualifier","Error","parseFunction","body","parseBlock","parseVariablesFromToken","init","next","initTokens","expressionTokens","pop","nextTokens","parseVariables","parseUniform","parseVarying","parseReturn","expression","parseWhile","parseFor","forTokens","initializationTokens","afterthoughtTokens","initialization","afterthought","parseSwitch","switchDeterminantTokens","discriminant","cases","parseSwitchCases","conditions","isCase","caseTokens","caseStatement","parseIf","parseIfExpression","condTokens","parseIfBlock","conditional","previous","parent","elseConditional","statement","lastStatement","tag","isComment","comment","parse","keyword"],"sources":["node_modules/three/examples/jsm/transpiler/GLSLDecoder.js"],"sourcesContent":["import { Program, FunctionDeclaration, Switch, For, AccessorElements, Ternary, Varying, DynamicElement, StaticElement, FunctionParameter, Unary, Conditional, VariableDeclaration, Operator, Number, String, FunctionCall, Return, Accessor, Uniform, Discard, SwitchCase, Continue, Break, While, Comment } from './AST.js';\n\nimport { isType } from './TranspilerUtils.js';\n\nconst unaryOperators = [\n\t'+', '-', '~', '!', '++', '--'\n];\n\nconst arithmeticOperators = [\n\t'*', '/', '%', '+', '-', '<<', '>>'\n];\n\nconst precedenceOperators = [\n\t'/', '*', '%',\n\t'-', '+',\n\t'<<', '>>',\n\t'<', '>', '<=', '>=',\n\t'==', '!=',\n\t'&',\n\t'^',\n\t'|',\n\t'&&',\n\t'^^',\n\t'||',\n\t'?',\n\t'=',\n\t'+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',\n\t','\n].reverse();\n\nconst associativityRightToLeft = [\n\t'=',\n\t'+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',\n\t',',\n\t'?',\n\t':'\n];\n\nconst glslToTSL = {\n\tinversesqrt: 'inverseSqrt'\n};\n\nconst samplers = [ 'sampler1D', 'sampler2D', 'sampler2DArray', 'sampler2DShadow', 'sampler2DArrayShadow', 'isampler2D', 'isampler2DArray', 'usampler2D', 'usampler2DArray' ];\nconst samplersCube = [ 'samplerCube', 'samplerCubeShadow', 'usamplerCube', 'isamplerCube' ];\nconst samplers3D = [ 'sampler3D', 'isampler3D', 'usampler3D' ];\n\nconst spaceRegExp = /^((\\t| )\\n*)+/;\nconst lineRegExp = /^\\n+/;\nconst commentRegExp = /^\\/\\*[\\s\\S]*?\\*\\//;\nconst inlineCommentRegExp = /^\\/\\/.*?(?=\\n|$)/;\n\nconst numberRegExp = /^((0x\\w+)|(\\.?\\d+\\.?\\d*((e-?\\d+)|\\w)?))/;\nconst stringDoubleRegExp = /^(\\\"((?:[^\"\\\\]|\\\\.)*)\\\")/;\nconst stringSingleRegExp = /^(\\'((?:[^'\\\\]|\\\\.)*)\\')/;\nconst literalRegExp = /^[A-Za-z](\\w|\\.)*/;\nconst operatorsRegExp = new RegExp( '^(\\\\' + [\n\t'<<=', '>>=', '++', '--', '<<', '>>', '+=', '-=', '*=', '/=', '%=', '&=', '^^', '^=', '|=',\n\t'<=', '>=', '==', '!=', '&&', '||',\n\t'(', ')', '[', ']', '{', '}',\n\t'.', ',', ';', '!', '=', '~', '*', '/', '%', '+', '-', '<', '>', '&', '^', '|', '?', ':', '#'\n].join( '$' ).split( '' ).join( '\\\\' ).replace( /\\\\\\$/g, '|' ) + ')' );\n\nfunction getFunctionName( str ) {\n\n\treturn glslToTSL[ str ] || str;\n\n}\n\nfunction getGroupDelta( str ) {\n\n\tif ( str === '(' || str === '[' || str === '{' ) return 1;\n\tif ( str === ')' || str === ']' || str === '}' ) return - 1;\n\n\treturn 0;\n\n}\n\nclass Token {\n\n\tconstructor( tokenizer, type, str, pos ) {\n\n\t\tthis.tokenizer = tokenizer;\n\n\t\tthis.type = type;\n\n\t\tthis.str = str;\n\t\tthis.pos = pos;\n\n\t\tthis.isTag = false;\n\n\t\tthis.tags = null;\n\n\t}\n\n\tget endPos() {\n\n\t\treturn this.pos + this.str.length;\n\n\t}\n\n\tget isNumber() {\n\n\t\treturn this.type === Token.NUMBER;\n\n\t}\n\n\tget isString() {\n\n\t\treturn this.type === Token.STRING;\n\n\t}\n\n\tget isLiteral() {\n\n\t\treturn this.type === Token.LITERAL;\n\n\t}\n\n\tget isOperator() {\n\n\t\treturn this.type === Token.OPERATOR;\n\n\t}\n\n}\n\nToken.LINE = 'line';\nToken.COMMENT = 'comment';\nToken.NUMBER = 'number';\nToken.STRING = 'string';\nToken.LITERAL = 'literal';\nToken.OPERATOR = 'operator';\n\nconst TokenParserList = [\n\t{ type: Token.LINE, regexp: lineRegExp, isTag: true },\n\t{ type: Token.COMMENT, regexp: commentRegExp, isTag: true },\n\t{ type: Token.COMMENT, regexp: inlineCommentRegExp, isTag: true },\n\t{ type: Token.NUMBER, regexp: numberRegExp },\n\t{ type: Token.STRING, regexp: stringDoubleRegExp, group: 2 },\n\t{ type: Token.STRING, regexp: stringSingleRegExp, group: 2 },\n\t{ type: Token.LITERAL, regexp: literalRegExp },\n\t{ type: Token.OPERATOR, regexp: operatorsRegExp }\n];\n\nclass Tokenizer {\n\n\tconstructor( source ) {\n\n\t\tthis.source = source;\n\t\tthis.position = 0;\n\n\t\tthis.tokens = [];\n\n\t}\n\n\ttokenize() {\n\n\t\tlet token = this.readToken();\n\n\t\twhile ( token ) {\n\n\t\t\tthis.tokens.push( token );\n\n\t\t\ttoken = this.readToken();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tskip( ...params ) {\n\n\t\tlet remainingCode = this.source.substr( this.position );\n\t\tlet i = params.length;\n\n\t\twhile ( i -- ) {\n\n\t\t\tconst skip = params[ i ].exec( remainingCode );\n\t\t\tconst skipLength = skip ? skip[ 0 ].length : 0;\n\n\t\t\tif ( skipLength > 0 ) {\n\n\t\t\t\tthis.position += skipLength;\n\n\t\t\t\tremainingCode = this.source.substr( this.position );\n\n\t\t\t\t// re-skip, new remainingCode is generated\n\t\t\t\t// maybe exist previous regexp non detected\n\t\t\t\ti = params.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn remainingCode;\n\n\t}\n\n\tnextToken() {\n\n\t\tconst remainingCode = this.skip( spaceRegExp );\n\n\t\tfor ( var i = 0; i < TokenParserList.length; i ++ ) {\n\n\t\t\tconst parser = TokenParserList[ i ];\n\t\t\tconst result = parser.regexp.exec( remainingCode );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tconst token = new Token( this, parser.type, result[ parser.group || 0 ], this.position );\n\t\t\t\ttoken.isTag = parser.isTag;\n\n\t\t\t\tthis.position += result[ 0 ].length;\n\n\t\t\t\treturn token;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treadToken() {\n\n\t\tlet token = this.nextToken();\n\n\t\tif ( token && token.isTag ) {\n\n\t\t\tconst tags = [];\n\n\t\t\twhile ( token.isTag ) {\n\n\t\t\t\ttags.push( token );\n\n\t\t\t\ttoken = this.nextToken();\n\n\t\t\t\tif ( ! token ) return;\n\n\t\t\t}\n\n\t\t\ttoken.tags = tags;\n\n\t\t}\n\n\t\treturn token;\n\n\t}\n\n}\n\nclass GLSLDecoder {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.tokenizer = null;\n\t\tthis.keywords = [];\n\n\t\tthis.addPolyfill( 'gl_FragCoord', 'vec3 gl_FragCoord = vec3( screenCoordinate.x, screenCoordinate.y.oneMinus(), screenCoordinate.z );' );\n\n\t}\n\n\taddPolyfill( name, polyfill ) {\n\n\t\tthis.keywords.push( { name, polyfill } );\n\n\t\treturn this;\n\n\t}\n\n\tget tokens() {\n\n\t\treturn this.tokenizer.tokens;\n\n\t}\n\n\treadToken() {\n\n\t\treturn this.tokens[ this.index ++ ];\n\n\t}\n\n\tgetToken( offset = 0 ) {\n\n\t\treturn this.tokens[ this.index + offset ];\n\n\t}\n\n\tgetTokensUntil( str, tokens, offset = 0 ) {\n\n\t\tconst output = [];\n\n\t\tlet groupIndex = 0;\n\n\t\tfor ( let i = offset; i < tokens.length; i ++ ) {\n\n\t\t\tconst token = tokens[ i ];\n\n\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\toutput.push( token );\n\n\t\t\tif ( groupIndex === 0 && token.str === str ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\treadTokensUntil( str ) {\n\n\t\tconst tokens = this.getTokensUntil( str, this.tokens, this.index );\n\n\t\tthis.index += tokens.length;\n\n\t\treturn tokens;\n\n\t}\n\n\tparseExpressionFromTokens( tokens ) {\n\n\t\tif ( tokens.length === 0 ) return null;\n\n\t\tconst firstToken = tokens[ 0 ];\n\t\tconst lastToken = tokens[ tokens.length - 1 ];\n\n\t\t// precedence operators\n\n\t\tlet groupIndex = 0;\n\n\t\tfor ( const operator of precedenceOperators ) {\n\n\t\t\tconst parseToken = ( i, inverse = false ) => {\n\n\t\t\t\tconst token = tokens[ i ];\n\n\t\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\t\tif ( ! token.isOperator || i === 0 || i === tokens.length - 1 ) return;\n\n\t\t\t\t// important for negate operator after arithmetic operator: a * -1, a * -( b )\n\t\t\t\tif ( inverse && arithmeticOperators.includes( tokens[ i - 1 ].str ) ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( groupIndex === 0 && token.str === operator ) {\n\n\t\t\t\t\tif ( operator === '?' ) {\n\n\t\t\t\t\t\tconst conditionTokens = tokens.slice( 0, i );\n\t\t\t\t\t\tconst leftTokens = this.getTokensUntil( ':', tokens, i + 1 ).slice( 0, - 1 );\n\t\t\t\t\t\tconst rightTokens = tokens.slice( i + leftTokens.length + 2 );\n\n\t\t\t\t\t\tconst condition = this.parseExpressionFromTokens( conditionTokens );\n\t\t\t\t\t\tconst left = this.parseExpressionFromTokens( leftTokens );\n\t\t\t\t\t\tconst right = this.parseExpressionFromTokens( rightTokens );\n\n\t\t\t\t\t\treturn new Ternary( condition, left, right );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst left = this.parseExpressionFromTokens( tokens.slice( 0, i ) );\n\t\t\t\t\t\tconst right = this.parseExpressionFromTokens( tokens.slice( i + 1, tokens.length ) );\n\n\t\t\t\t\t\treturn new Operator( operator, left, right );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( inverse ) {\n\n\t\t\t\t\tif ( groupIndex > 0 ) {\n\n\t\t\t\t\t\treturn this.parseExpressionFromTokens( tokens.slice( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( groupIndex < 0 ) {\n\n\t\t\t\t\t\treturn this.parseExpressionFromTokens( tokens.slice( 0, i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tif ( associativityRightToLeft.includes( operator ) ) {\n\n\t\t\t\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\t\t\t\tconst result = parseToken( i );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = tokens.length - 1; i >= 0; i -- ) {\n\n\t\t\t\t\tconst result = parseToken( i, true );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// unary operators (before)\n\n\t\tif ( firstToken.isOperator ) {\n\n\t\t\tfor ( const operator of unaryOperators ) {\n\n\t\t\t\tif ( firstToken.str === operator ) {\n\n\t\t\t\t\tconst right = this.parseExpressionFromTokens( tokens.slice( 1 ) );\n\n\t\t\t\t\treturn new Unary( operator, right );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// unary operators (after)\n\n\t\tif ( lastToken.isOperator ) {\n\n\t\t\tfor ( const operator of unaryOperators ) {\n\n\t\t\t\tif ( lastToken.str === operator ) {\n\n\t\t\t\t\tconst left = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );\n\n\t\t\t\t\treturn new Unary( operator, left, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// groups\n\n\t\tif ( firstToken.str === '(' ) {\n\n\t\t\tconst leftTokens = this.getTokensUntil( ')', tokens );\n\n\t\t\tconst left = this.parseExpressionFromTokens( leftTokens.slice( 1, leftTokens.length - 1 ) );\n\n\t\t\tconst operator = tokens[ leftTokens.length ];\n\n\t\t\tif ( operator ) {\n\n\t\t\t\tconst rightTokens = tokens.slice( leftTokens.length + 1 );\n\t\t\t\tconst right = this.parseExpressionFromTokens( rightTokens );\n\n\t\t\t\treturn new Operator( operator.str, left, right );\n\n\t\t\t}\n\n\t\t\treturn left;\n\n\t\t}\n\n\t\t// primitives and accessors\n\n\t\tif ( firstToken.isNumber ) {\n\n\t\t\tlet type;\n\n\t\t\tconst isHex = /^(0x)/.test( firstToken.str );\n\n\t\t\tif ( isHex ) type = 'int';\n\t\t\telse if ( /u$|U$/.test( firstToken.str ) ) type = 'uint';\n\t\t\telse if ( /f|e|\\./.test( firstToken.str ) ) type = 'float';\n\t\t\telse type = 'int';\n\n\t\t\tlet str = firstToken.str.replace( /u|U|i$/, '' );\n\n\t\t\tif ( isHex === false ) {\n\n\t\t\t\tstr = str.replace( /f$/, '' );\n\n\t\t\t}\n\n\t\t\treturn new Number( str, type );\n\n\t\t} else if ( firstToken.isString ) {\n\n\t\t\treturn new String( firstToken.str );\n\n\t\t} else if ( firstToken.isLiteral ) {\n\n\t\t\tif ( firstToken.str === 'return' ) {\n\n\t\t\t\treturn new Return( this.parseExpressionFromTokens( tokens.slice( 1 ) ) );\n\n\t\t\t} else if ( firstToken.str === 'discard' ) {\n\n\t\t\t\treturn new Discard();\n\n\t\t\t} else if ( firstToken.str === 'continue' ) {\n\n\t\t\t\treturn new Continue();\n\n\t\t\t} else if ( firstToken.str === 'break' ) {\n\n\t\t\t\treturn new Break();\n\n\t\t\t}\n\n\t\t\tconst secondToken = tokens[ 1 ];\n\n\t\t\tif ( secondToken ) {\n\n\t\t\t\tif ( secondToken.str === '(' ) {\n\n\t\t\t\t\t// function call\n\n\t\t\t\t\tconst internalTokens = this.getTokensUntil( ')', tokens, 1 ).slice( 1, - 1 );\n\n\t\t\t\t\tconst paramsTokens = this.parseFunctionParametersFromTokens( internalTokens );\n\n\t\t\t\t\tconst functionCall = new FunctionCall( getFunctionName( firstToken.str ), paramsTokens );\n\n\t\t\t\t\tconst accessTokens = tokens.slice( 3 + internalTokens.length );\n\n\t\t\t\t\tif ( accessTokens.length > 0 ) {\n\n\t\t\t\t\t\tconst elements = this.parseAccessorElementsFromTokens( accessTokens );\n\n\t\t\t\t\t\treturn new AccessorElements( functionCall, elements );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn functionCall;\n\n\t\t\t\t} else if ( secondToken.str === '[' ) {\n\n\t\t\t\t\t// array accessor\n\n\t\t\t\t\tconst elements = this.parseAccessorElementsFromTokens( tokens.slice( 1 ) );\n\n\t\t\t\t\treturn new AccessorElements( new Accessor( firstToken.str ), elements );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Accessor( firstToken.str );\n\n\t\t}\n\n\t}\n\n\tparseAccessorElementsFromTokens( tokens ) {\n\n\t\tconst elements = [];\n\n\t\tlet currentTokens = tokens;\n\n\t\twhile ( currentTokens.length > 0 ) {\n\n\t\t\tconst token = currentTokens[ 0 ];\n\n\t\t\tif ( token.str === '[' ) {\n\n\t\t\t\tconst accessorTokens = this.getTokensUntil( ']', currentTokens );\n\n\t\t\t\tconst element = this.parseExpressionFromTokens( accessorTokens.slice( 1, accessorTokens.length - 1 ) );\n\n\t\t\t\tcurrentTokens = currentTokens.slice( accessorTokens.length );\n\n\t\t\t\telements.push( new DynamicElement( element ) );\n\n\t\t\t} else if ( token.str === '.' ) {\n\n\t\t\t\tconst accessorTokens = currentTokens.slice( 1, 2 );\n\n\t\t\t\tconst element = this.parseExpressionFromTokens( accessorTokens );\n\n\t\t\t\tcurrentTokens = currentTokens.slice( 2 );\n\n\t\t\t\telements.push( new StaticElement( element ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'Unknown accessor expression', token );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn elements;\n\n\t}\n\n\tparseFunctionParametersFromTokens( tokens ) {\n\n\t\tif ( tokens.length === 0 ) return [];\n\n\t\tconst expression = this.parseExpressionFromTokens( tokens );\n\t\tconst params = [];\n\n\t\tlet current = expression;\n\n\t\twhile ( current.type === ',' ) {\n\n\t\t\tparams.push( current.left );\n\n\t\t\tcurrent = current.right;\n\n\t\t}\n\n\t\tparams.push( current );\n\n\t\treturn params;\n\n\t}\n\n\tparseExpression() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tconst exp = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );\n\n\t\treturn exp;\n\n\t}\n\n\tparseFunctionParams( tokens ) {\n\n\t\tconst params = [];\n\n\t\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\t\tconst immutable = tokens[ i ].str === 'const';\n\t\t\tif ( immutable ) i ++;\n\n\t\t\tlet qualifier = tokens[ i ].str;\n\n\t\t\tif ( /^(in|out|inout)$/.test( qualifier ) ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = null;\n\n\t\t\t}\n\n\t\t\tconst type = tokens[ i ++ ].str;\n\t\t\tconst name = tokens[ i ++ ].str;\n\n\t\t\tparams.push( new FunctionParameter( type, name, qualifier, immutable ) );\n\n\t\t\tif ( tokens[ i ] && tokens[ i ].str !== ',' ) throw new Error( 'Expected \",\"' );\n\n\t\t}\n\n\t\treturn params;\n\n\t}\n\n\tparseFunction() {\n\n\t\tconst type = this.readToken().str;\n\t\tconst name = this.readToken().str;\n\n\t\tconst paramsTokens = this.readTokensUntil( ')' );\n\n\t\tconst params = this.parseFunctionParams( paramsTokens.slice( 1, paramsTokens.length - 1 ) );\n\t\tconst body = this.parseBlock();\n\n\t\tconst func = new FunctionDeclaration( type, name, params, body );\n\n\t\treturn func;\n\n\t}\n\n\tparseVariablesFromToken( tokens, type ) {\n\n\t\tlet index = 0;\n\t\tconst immutable = tokens[ 0 ].str === 'const';\n\n\t\tif ( immutable ) index ++;\n\n\t\ttype = type || tokens[ index ++ ].str;\n\t\tconst name = tokens[ index ++ ].str;\n\n\t\tconst token = tokens[ index ];\n\n\t\tlet init = null;\n\t\tlet next = null;\n\n\t\tif ( token ) {\n\n\t\t\tconst initTokens = this.getTokensUntil( ',', tokens, index );\n\n\t\t\tif ( initTokens[ 0 ].str === '=' ) {\n\n\t\t\t\tconst expressionTokens = initTokens.slice( 1 );\n\t\t\t\tif ( expressionTokens[ expressionTokens.length - 1 ].str === ',' ) expressionTokens.pop();\n\n\t\t\t\tinit = this.parseExpressionFromTokens( expressionTokens );\n\n\t\t\t}\n\n\t\t\tconst nextTokens = tokens.slice( initTokens.length + ( index - 1 ) );\n\n\t\t\tif ( nextTokens[ 0 ] && nextTokens[ 0 ].str === ',' ) {\n\n\t\t\t\tnext = this.parseVariablesFromToken( nextTokens.slice( 1 ), type );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst variable = new VariableDeclaration( type, name, init, next, immutable );\n\n\t\treturn variable;\n\n\t}\n\n\tparseVariables() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\treturn this.parseVariablesFromToken( tokens.slice( 0, tokens.length - 1 ) );\n\n\t}\n\n\tparseUniform() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tlet type = tokens[ 1 ].str;\n\t\tconst name = tokens[ 2 ].str;\n\n\t\t// GLSL to TSL types\n\n\t\tif ( samplers.includes( type ) ) type = 'texture';\n\t\telse if ( samplersCube.includes( type ) ) type = 'cubeTexture';\n\t\telse if ( samplers3D.includes( type ) ) type = 'texture3D';\n\n\t\treturn new Uniform( type, name );\n\n\t}\n\n\tparseVarying() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tconst type = tokens[ 1 ].str;\n\t\tconst name = tokens[ 2 ].str;\n\n\t\treturn new Varying( type, name );\n\n\t}\n\n\tparseReturn() {\n\n\t\tthis.readToken(); // skip 'return'\n\n\t\tconst expression = this.parseExpression();\n\n\t\treturn new Return( expression );\n\n\t}\n\n\tparseWhile() {\n\n\t\tthis.readToken(); // skip 'while'\n\n\t\tconst conditionTokens = this.readTokensUntil( ')' ).slice( 1, - 1 );\n\t\tconst condition = this.parseExpressionFromTokens( conditionTokens );\n\n\t\tlet body;\n\n\t\tif ( this.getToken().str === '{' ) {\n\n\t\t\tbody = this.parseBlock();\n\n\t\t} else {\n\n\t\t\tbody = [ this.parseExpression() ];\n\n\t\t}\n\n\t\tconst statement = new While( condition, body );\n\n\t\treturn statement;\n\n\t}\n\n\tparseFor() {\n\n\t\tthis.readToken(); // skip 'for'\n\n\t\tconst forTokens = this.readTokensUntil( ')' ).slice( 1, - 1 );\n\n\t\tconst initializationTokens = this.getTokensUntil( ';', forTokens, 0 ).slice( 0, - 1 );\n\t\tconst conditionTokens = this.getTokensUntil( ';', forTokens, initializationTokens.length + 1 ).slice( 0, - 1 );\n\t\tconst afterthoughtTokens = forTokens.slice( initializationTokens.length + conditionTokens.length + 2 );\n\n\t\tlet initialization;\n\n\t\tif ( initializationTokens[ 0 ] && isType( initializationTokens[ 0 ].str ) ) {\n\n\t\t\tinitialization = this.parseVariablesFromToken( initializationTokens );\n\n\t\t} else {\n\n\t\t\tinitialization = this.parseExpressionFromTokens( initializationTokens );\n\n\t\t}\n\n\t\tconst condition = this.parseExpressionFromTokens( conditionTokens );\n\t\tconst afterthought = this.parseExpressionFromTokens( afterthoughtTokens );\n\n\t\tlet body;\n\n\t\tif ( this.getToken().str === '{' ) {\n\n\t\t\tbody = this.parseBlock();\n\n\t\t} else {\n\n\t\t\tbody = [ this.parseExpression() ];\n\n\t\t}\n\n\t\tconst statement = new For( initialization, condition, afterthought, body );\n\n\t\treturn statement;\n\n\t}\n\n\tparseSwitch() {\n\n\t\tthis.readToken(); // Skip 'switch'\n\n\t\tconst switchDeterminantTokens = this.readTokensUntil( ')' );\n\n\t\t// Parse expression between parentheses. Index 1: char after '('. Index -1: char before ')'\n\t\tconst discriminant = this.parseExpressionFromTokens( switchDeterminantTokens.slice( 1, - 1 ) );\n\n\t\t// Validate curly braces\n\t\tif ( this.getToken().str !== '{' ) {\n\n\t\t\tthrow new Error( 'Expected \\'{\\' after switch(...) ' );\n\n\t\t}\n\n\t\tthis.readToken(); // Skip '{'\n\n\t\tconst cases = this.parseSwitchCases();\n\n\t\tconst switchStatement = new Switch( discriminant, cases );\n\n\t\treturn switchStatement;\n\n\t}\n\n\tparseSwitchCases() {\n\n\t\tconst cases = [];\n\n\t\tlet token = this.getToken();\n\t\tlet conditions = null;\n\n\t\tconst isCase = ( token ) => token.str === 'case' || token.str === 'default';\n\n\t\twhile ( isCase( token ) ) {\n\n\t\t\tthis.readToken(); // Skip 'case' or 'default'\n\n\t\t\tif ( token.str === 'case' ) {\n\n\t\t\t\tconst caseTokens = this.readTokensUntil( ':' );\n\t\t\t\tconst caseStatement = this.parseExpressionFromTokens( caseTokens.slice( 0, - 1 ) );\n\n\t\t\t\tconditions = conditions || [];\n\t\t\t\tconditions.push( caseStatement );\n\n\t\t\t} else {\n\n\t\t\t\tthis.readTokensUntil( ':' ); // Skip 'default:'\n\n\t\t\t\tconditions = null;\n\n\t\t\t}\n\n\t\t\ttoken = this.getToken();\n\n\t\t\tif ( isCase( token ) ) {\n\n\t\t\t\t// If the next token is another case/default, continue parsing\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tcases.push( new SwitchCase( this.parseBlock(), conditions ) );\n\n\t\t\ttoken = this.getToken();\n\n\t\t\tconditions = null;\n\n\t\t}\n\n\t\treturn cases;\n\n\t}\n\n\tparseIf() {\n\n\t\tconst parseIfExpression = () => {\n\n\t\t\tthis.readToken(); // skip 'if'\n\n\t\t\tconst condTokens = this.readTokensUntil( ')' );\n\n\t\t\treturn this.parseExpressionFromTokens( condTokens.slice( 1, condTokens.length - 1 ) );\n\n\t\t};\n\n\t\tconst parseIfBlock = () => {\n\n\t\t\tlet body;\n\n\t\t\tif ( this.getToken().str === '{' ) {\n\n\t\t\t\tbody = this.parseBlock();\n\n\t\t\t} else {\n\n\t\t\t\tbody = [ this.parseExpression() ];\n\n\t\t\t}\n\n\t\t\treturn body;\n\n\t\t};\n\n\t\t//\n\n\t\t// Parse the first if statement\n\t\tconst conditional = new Conditional( parseIfExpression(), parseIfBlock() );\n\n\t\t//\n\n\t\tlet current = conditional;\n\n\t\twhile ( this.getToken() && this.getToken().str === 'else' ) {\n\n\t\t\tthis.readToken(); // skip 'else'\n\n\t\t\t// Assign the current if/else statement as the previous within the chain of conditionals\n\t\t\tconst previous = current;\n\n\t\t\tlet expression = null;\n\n\t\t\t// If an 'else if' statement, parse the conditional within the if\n\t\t\tif ( this.getToken().str === 'if' ) {\n\n\t\t\t\t// Current conditional now equal to next conditional in the chain\n\t\t\t\texpression = parseIfExpression();\n\n\t\t\t}\n\n\t\t\tcurrent = new Conditional( expression, parseIfBlock() );\n\t\t\tcurrent.parent = previous;\n\n\t\t\t// n - 1 conditional's else statement assigned to new if/else statement\n\t\t\tprevious.elseConditional = current;\n\n\t\t}\n\n\t\treturn conditional;\n\n\t}\n\n\tparseBlock() {\n\n\t\tconst body = [];\n\n\t\tconst firstToken = this.getToken();\n\n\t\tif ( firstToken.str === '{' ) {\n\n\t\t\tthis.readToken(); // skip '{'\n\n\t\t}\n\n\t\tlet groupIndex = 0;\n\n\t\twhile ( this.index < this.tokens.length ) {\n\n\t\t\tconst token = this.getToken();\n\n\t\t\tlet statement = null;\n\n\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\tif ( groupIndex === 0 && ( token.str === 'case' || token.str === 'default' ) ) {\n\n\t\t\t\treturn body; // switch case or default statement, return body\n\n\t\t\t} else if ( groupIndex < 0 ) {\n\n\t\t\t\tthis.readToken(); // skip '}'\n\n\t\t\t\treturn body;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( token.tags ) {\n\n\t\t\t\tlet lastStatement = null;\n\n\t\t\t\tfor ( const tag of token.tags ) {\n\n\t\t\t\t\tif ( tag.type === Token.COMMENT ) {\n\n\t\t\t\t\t\tconst str = tag.str.replace( /\\t/g, '' );\n\n\t\t\t\t\t\tif ( ! lastStatement || lastStatement.isComment !== true ) {\n\n\t\t\t\t\t\t\tlastStatement = new Comment( str );\n\t\t\t\t\t\t\tbody.push( lastStatement );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlastStatement.comment += '\\n' + str;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( token.isLiteral || token.isOperator ) {\n\n\t\t\t\tif ( token.str === 'const' ) {\n\n\t\t\t\t\tstatement = this.parseVariables();\n\n\t\t\t\t} else if ( token.str === 'uniform' ) {\n\n\t\t\t\t\tstatement = this.parseUniform();\n\n\t\t\t\t} else if ( token.str === 'varying' ) {\n\n\t\t\t\t\tstatement = this.parseVarying();\n\n\t\t\t\t} else if ( isType( token.str ) ) {\n\n\t\t\t\t\tif ( this.getToken( 2 ).str === '(' ) {\n\n\t\t\t\t\t\tstatement = this.parseFunction();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstatement = this.parseVariables();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( token.str === 'return' ) {\n\n\t\t\t\t\tstatement = this.parseReturn();\n\n\t\t\t\t} else if ( token.str === 'if' ) {\n\n\t\t\t\t\tstatement = this.parseIf();\n\n\t\t\t\t} else if ( token.str === 'for' ) {\n\n\t\t\t\t\tstatement = this.parseFor();\n\n\t\t\t\t} else if ( token.str === 'while' ) {\n\n\t\t\t\t\tstatement = this.parseWhile();\n\n\t\t\t\t} else if ( token.str === 'switch' ) {\n\n\t\t\t\t\tstatement = this.parseSwitch();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstatement = this.parseExpression();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( statement ) {\n\n\t\t\t\tbody.push( statement );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn body;\n\n\t}\n\n\tparse( source ) {\n\n\t\tlet polyfill = '';\n\n\t\tfor ( const keyword of this.keywords ) {\n\n\t\t\tif ( new RegExp( `(^|\\\\b)${ keyword.name }($|\\\\b)`, 'gm' ).test( source ) ) {\n\n\t\t\t\tpolyfill += keyword.polyfill + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( polyfill ) {\n\n\t\t\tpolyfill = '// Polyfills\\n\\n' + polyfill + '\\n';\n\n\t\t}\n\n\t\tthis.index = 0;\n\t\tthis.tokenizer = new Tokenizer( polyfill + source ).tokenize();\n\n\t\tconst body = this.parseBlock();\n\t\tconst program = new Program( body );\n\n\t\treturn program;\n\n\n\t}\n\n}\n\nexport default GLSLDecoder;\n"],"mappings":"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","ignoreList":[]}