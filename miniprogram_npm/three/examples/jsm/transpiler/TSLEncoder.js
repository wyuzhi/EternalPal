import{REVISION}from"three/webgpu";import*as TSL from"three/tsl";import{VariableDeclaration,Accessor}from"./AST.js";import{isExpression,isPrimitive}from"./TranspilerUtils.js";const opLib={"=":"assign","+":"add","-":"sub","*":"mul","/":"div","%":"remainder","<":"lessThan",">":"greaterThan","<=":"lessThanEqual",">=":"greaterThanEqual","==":"equal","!=":"notEqual","&&":"and","||":"or","^^":"xor","&":"bitAnd","|":"bitOr","^":"bitXor","<<":"shiftLeft",">>":"shiftRight","+=":"addAssign","-=":"subAssign","*=":"mulAssign","/=":"divAssign","%=":"remainderAssign","^=":"bitXorAssign","&=":"bitAndAssign","|=":"bitOrAssign","<<=":"shiftLeftAssign",">>=":"shiftRightAssign"},unaryLib={"+":"","-":"negate","~":"bitNot","!":"not","++":"increment","--":"decrement"},textureLookupFunctions=["texture","texture2D","texture3D","textureCube","textureLod","texelFetch","textureGrad"];class TSLEncoder{constructor(){this.tab="",this.imports=new Set,this.global=new Set,this.overloadings=new Map,this.iife=!1,this.reference=!1,this.block=null}addImport(t){t=t.split(".")[0],void 0!==TSL[t]&&!1===this.global.has(t)&&this.imports.add(t)}emitUniform(t){let e=`const ${t.name} = `;return this.global.add(t.name),!0===this.reference?(this.addImport("reference"),e+=`reference( 'value', '${t.type}', uniforms[ '${t.name}' ] )`):"texture"===t.type?(this.addImport("texture"),e+="texture( /* <THREE.Texture> */ )"):"cubeTexture"===t.type?(this.addImport("cubeTexture"),e+="cubeTexture( /* <THREE.CubeTexture> */ )"):"texture3D"===t.type?(this.addImport("texture3D"),e+="texture3D( /* <THREE.Data3DTexture> */ )"):(this.addImport("uniform"),e+=`uniform( '${t.type}' )`),e}emitExpression(t,e=null){let i;if(t.isAccessor)null===t.linker.reference&&this.addImport(t.property),i=t.property;else if(t.isNumber)i=t.value;else if(t.isString)i="'"+t.value+"'";else if(t.isOperator){const s=opLib[t.type]||t.type,n=this.emitExpression(t.left,e),o=this.emitExpression(t.right,e);if(t.isNumericExpression)return n+" "+t.type+" "+o;isPrimitive(n)?(i=s+"( "+n+", "+o+" )",this.addImport(s)):i="."===s?n+s+o:n+"."+s+"( "+o+" )"}else if(t.isFunctionCall){const e=[];for(const i of t.params)e.push(this.emitExpression(i));if(textureLookupFunctions.includes(t.name))i=`${e[0]}.sample( ${e[1]} )`,"texture"===t.name||"texture2D"===t.name||"texture3D"===t.name||"textureCube"===t.name?3===e.length&&(i+=`.bias( ${e[2]} )`):"textureLod"===t.name?i+=`.level( ${e[2]} )`:"textureGrad"===t.name?i+=`.grad( ${e[2]}, ${e[3]} )`:"texelFetch"===t.name&&(i+=".setSampler( false )");else{this.addImport(t.name);const s=e.length>0?" "+e.join(", ")+" ":"";i=`${t.name}(${s})`}}else if(t.isReturn)i="return",t.value&&(i+=" "+this.emitExpression(t.value));else if(t.isDiscard)this.addImport("Discard"),i="Discard()";else if(t.isBreak)this.addImport("Break"),i="Break()";else if(t.isContinue)this.addImport("Continue"),i="Continue()";else if(t.isAccessorElements){i=this.emitExpression(t.object);for(const e of t.elements)if(e.isStaticElement)i+="."+this.emitExpression(e.value);else if(e.isDynamicElement){const t=this.emitExpression(e.value);isPrimitive(t)?i+=`[ ${t} ]`:i+=`.element( ${t} )`}}else if(t.isDynamicElement)i=this.emitExpression(t.value);else if(t.isStaticElement)i=this.emitExpression(t.value);else if(t.isFor)i=this.emitFor(t);else if(t.isWhile)i=this.emitWhile(t);else if(t.isSwitch)i=this.emitSwitch(t);else if(t.isVariableDeclaration)i=this.emitVariables(t);else if(t.isUniform)i=this.emitUniform(t);else if(t.isVarying)i=this.emitVarying(t);else if(t.isTernary)i=this.emitTernary(t);else if(t.isConditional)i=this.emitConditional(t);else if(t.isUnary&&t.expression.isNumber&&"-"===t.type)i="- "+t.expression.value,"float"!==t.expression.type&&(i=t.expression.type+"( "+i+" )",this.addImport(t.expression.type));else if(t.isUnary){let e=unaryLib[t.type];t.hasAssignment&&!1===t.after&&(e+="Before");const s=this.emitExpression(t.expression);isPrimitive(s)?(this.addImport(e),i=e+"( "+s+" )"):i=s+"."+e+"()"}else console.warn("Unknown node type",t);return i||(i="/* unknown statement */"),i}emitBody(t){let e="";this.tab+="\t";for(const i of t)e+=this.emitExtraLine(i,t),i.isComment?e+=this.emitComment(i,t):this.block&&this.block.isSwitchCase&&i.isBreak||(e+=this.tab+this.emitExpression(i),"}"!==e.slice(-1)&&(e+=";"),e+="\n");return e=e.slice(0,-1),this.tab=this.tab.slice(0,-1),e}emitTernary(t){const e=this.emitExpression(t.cond),i=this.emitExpression(t.left),s=this.emitExpression(t.right);return this.addImport("select"),`select( ${e}, ${i}, ${s} )`}emitConditional(t){let e=`If( ${this.emitExpression(t.cond)}, () => {\n\n${this.emitBody(t.body)}\n\n${this.tab}} )`,i=t;for(;i.elseConditional;){const t=this.emitBody(i.elseConditional.body);if(i.elseConditional.cond){e+=`.ElseIf( ${this.emitExpression(i.elseConditional.cond)}, () => {\n\n${t}\n\n${this.tab}} )`}else e+=`.Else( () => {\n\n${t}\n\n${this.tab}} )`;i=i.elseConditional}return this.imports.add("If"),e}emitLoop(t){const e=this.emitExpression(t.initialization.value),i=this.emitExpression(t.condition.right),s=t.initialization.name,n=t.initialization.type,o=t.condition.type,r="i"!==s?`, name: '${s}'`:"",a="int"!==n?`, type: '${n}'`:"",h="<"!==o?`, condition: '${o}'`:"";let l="";t.afterthought.isUnary?"++"!==t.afterthought.type&&(l=`, update: '${t.afterthought.type}'`):t.afterthought.isOperator&&(l=t.afterthought.right.isAccessor||t.afterthought.right.isNumber?`, update: ${this.emitExpression(t.afterthought.right)}`:`, update: ( { i } ) => ${this.emitExpression(t.afterthought)}`);let m=`Loop( { start: ${e}, end: ${i+r+a+h+l} }, ( { ${s} } ) => {\n\n`;return m+=this.emitBody(t.body)+"\n\n",m+=this.tab+"} )",this.imports.add("Loop"),m}emitSwitch(t){const e=this.emitExpression(t.discriminant);this.tab+="\t";let i=`Switch( ${e} )\n${this.tab}`;const s=this.block;for(const e of t.cases){let t;if(this.block=e,e.isDefault)t=this.emitBody(e.body),i+=".Default( ";else{const s=[];for(const t of e.conditions)s.push(this.emitExpression(t));t=this.emitBody(e.body),i+=`.Case( ${s.join(", ")}, `}i+=`() => {\n\n${t}\n\n${this.tab}} )`}return this.block=s,this.tab=this.tab.slice(0,-1),this.imports.add("Switch"),i}emitFor(t){const{initialization:e,condition:i,afterthought:s}=t;return e&&e.isVariableDeclaration&&null===e.next&&i&&i.left.isAccessor&&i.left.property===e.name&&s&&(s.isUnary&&e.name===s.expression.property||s.isOperator&&e.name===s.left.property)?this.emitLoop(t):this.emitForWhile(t)}emitForWhile(t){const e=this.emitExpression(t.initialization),i=this.emitExpression(t.condition),s=this.emitExpression(t.afterthought);this.tab+="\t";let n="{\n\n"+this.tab+e+";\n\n";return n+=`${this.tab}Loop( ${i}, () => {\n\n`,n+=this.emitBody(t.body)+"\n\n",n+=this.tab+"\t"+s+";\n\n",n+=this.tab+"} )\n\n",this.tab=this.tab.slice(0,-1),n+=this.tab+"}",this.imports.add("Loop"),n}emitWhile(t){let e=`Loop( ${this.emitExpression(t.condition)}, () => {\n\n`;return e+=this.emitBody(t.body)+"\n\n",e+=this.tab+"} )",this.imports.add("Loop"),e}emitVariables(t,e=!0){const{name:i,type:s,value:n,next:o}=t;let r=e?"const ":"";if(r+=i,n){let e=this.emitExpression(n);n.isNumericExpression&&(e=`${s}( ${e} )`,this.addImport(s)),t.linker.assignments.length>0?r+=" = "+e+".toVar()":r+=" = "+e}else r+=` = property( '${s}' )`,this.addImport("property");return o&&(r+=", "+this.emitVariables(o,!1)),r}emitVarying(t){const{name:e,type:i}=t;return this.addImport("varying"),this.addImport(i),`const ${e} = varying( ${i}(), '${e}' )`}emitOverloadingFunction(t){const{name:e}=t[0];this.addImport("overloadingFn");return`${!1===this.iife?"export ":""}const ${e} = /*@__PURE__*/ overloadingFn( [ ${t.map((e=>e.name+"_"+t.indexOf(e))).join(", ")} ] );\n`}emitFunction(t){const{name:e,type:i}=t,s=[],n=[],o=[];let r=!1;for(const e of t.params){let t=e.name;e.linker.assignments.length>0&&(t+="_immutable",o.push(e)),e.qualifier&&("inout"!==e.qualifier&&"out"!==e.qualifier||(r=!0)),n.push(e.name+": '"+e.type+"'"),s.push(t)}for(const e of o){const i=new VariableDeclaration(e.type,e.name,new Accessor(e.name+"_immutable"),null,!0);i.parent=e.parent,i.linker.assignments.push(i),t.body.unshift(i)}const a=s.length>0?" [ "+s.join(", ")+" ] ":"",h=this.emitBody(t.body);let l=e,m=null;if(this.overloadings.has(e)){const i=this.overloadings.get(e);if(i.length>1){const e=i.indexOf(t);l+="_"+e,e===i.length-1&&(m=i)}}let p=`${!1===this.iife?"export ":""}const ${l} = /*@__PURE__*/ Fn( (${a}) => {\n\n${h}\n\n${this.tab}}`;return!1!==t.layout&&!1===r&&(p+=", { "+n.join(", ")+", return: '"+i+"' }"),p+=" );\n",this.imports.add("Fn"),this.global.add(t.name),null!==m&&(p+="\n"+this.emitOverloadingFunction(m)),p}emitComment(t,e){const i=e.indexOf(t),s=e[i-1],n=e[i+1];let o="";return s&&isExpression(s)&&(o+="\n"),o+=this.tab+t.comment.replace(/\n/g,"\n"+this.tab)+"\n",n&&isExpression(n)&&(o+="\n"),o}emitExtraLine(t,e){const i=e.indexOf(t),s=e[i-1];if(void 0===s)return"";if(t.isReturn)return"\n";const n=isExpression(s),o=isExpression(t);return n!==o||!n&&!o?"\n":""}emit(t){let e="\n";this.iife&&(this.tab+="\t");const i=this.overloadings;for(const e of t.body)e.isFunctionDeclaration&&(!1===i.has(e.name)&&i.set(e.name,[]),i.get(e.name).push(e));for(const i of t.body)e+=this.emitExtraLine(i,t.body),i.isComment?e+=this.emitComment(i,t.body):i.isFunctionDeclaration?e+=this.tab+this.emitFunction(i):e+=this.tab+this.emitExpression(i)+";\n";const s=[...this.imports],n=[...this.global];let o="// Three.js Transpiler r"+REVISION+"\n\n",r="";return this.iife?(o+="( function ( TSL, uniforms ) {\n\n",o+=s.length>0?"\tconst { "+s.join(", ")+" } = TSL;\n":"",r+=n.length>0?"\treturn { "+n.join(", ")+" };\n":"",r+="\n} );"):o+=s.length>0?"import { "+s.join(", ")+" } from 'three/tsl';\n":"",o+e+r}}export default TSLEncoder;
//# sourceMappingURL=TSLEncoder.js.map