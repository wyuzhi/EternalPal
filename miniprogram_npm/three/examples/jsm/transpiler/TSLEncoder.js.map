{"version":3,"file":"node_modules/three/examples/jsm/transpiler/TSLEncoder.js","names":["REVISION","TSL","VariableDeclaration","Accessor","isExpression","isPrimitive","opLib","unaryLib","textureLookupFunctions","TSLEncoder","constructor","this","tab","imports","Set","global","overloadings","Map","iife","reference","block","addImport","name","split","undefined","has","add","emitUniform","node","code","type","emitExpression","output","isAccessor","linker","property","isNumber","value","isString","isOperator","opFn","left","right","isNumericExpression","isFunctionCall","params","parameter","push","includes","length","paramsStr","join","isReturn","isDiscard","isBreak","isContinue","isAccessorElements","object","element","elements","isStaticElement","isDynamicElement","isFor","emitFor","isWhile","emitWhile","isSwitch","emitSwitch","isVariableDeclaration","emitVariables","isUniform","isVarying","emitVarying","isTernary","emitTernary","isConditional","emitConditional","isUnary","expression","hasAssignment","after","exp","console","warn","emitBody","body","statement","emitExtraLine","isComment","emitComment","isSwitchCase","slice","condStr","cond","leftStr","rightStr","ifStr","current","elseConditional","elseBodyStr","emitLoop","start","initialization","end","condition","nameParam","typeParam","conditionParam","updateParam","afterthought","loopStr","switchNode","discriminantString","discriminant","switchString","previousBlock","switchCase","cases","caseBodyString","isDefault","caseConditions","conditions","next","emitForWhile","forStr","whileStr","isRoot","varStr","valueStr","assignments","emitOverloadingFunction","nodes","map","indexOf","emitFunction","inputs","mutableParams","hasPointer","param","qualifier","mutableParam","parent","unshift","bodyStr","fnName","overloadingNodes","get","index","funcStr","layout","previous","comment","replace","lastExp","currExp","emit","ast","isFunctionDeclaration","set","exports","header","footer"],"sources":["node_modules/three/examples/jsm/transpiler/TSLEncoder.js"],"sourcesContent":["import { REVISION } from 'three/webgpu';\nimport * as TSL from 'three/tsl';\n\nimport { VariableDeclaration, Accessor } from './AST.js';\nimport { isExpression, isPrimitive } from './TranspilerUtils.js';\n\nconst opLib = {\n\t'=': 'assign',\n\t'+': 'add',\n\t'-': 'sub',\n\t'*': 'mul',\n\t'/': 'div',\n\t'%': 'remainder',\n\t'<': 'lessThan',\n\t'>': 'greaterThan',\n\t'<=': 'lessThanEqual',\n\t'>=': 'greaterThanEqual',\n\t'==': 'equal',\n\t'!=': 'notEqual',\n\t'&&': 'and',\n\t'||': 'or',\n\t'^^': 'xor',\n\t'&': 'bitAnd',\n\t'|': 'bitOr',\n\t'^': 'bitXor',\n\t'<<': 'shiftLeft',\n\t'>>': 'shiftRight',\n\t'+=': 'addAssign',\n\t'-=': 'subAssign',\n\t'*=': 'mulAssign',\n\t'/=': 'divAssign',\n\t'%=': 'remainderAssign',\n\t'^=': 'bitXorAssign',\n\t'&=': 'bitAndAssign',\n\t'|=': 'bitOrAssign',\n\t'<<=': 'shiftLeftAssign',\n\t'>>=': 'shiftRightAssign'\n};\n\nconst unaryLib = {\n\t'+': '', // positive\n\t'-': 'negate',\n\t'~': 'bitNot',\n\t'!': 'not',\n\t'++': 'increment', // incrementBefore\n\t'--': 'decrement' // decrementBefore\n};\n\nconst textureLookupFunctions = [ 'texture', 'texture2D', 'texture3D', 'textureCube', 'textureLod', 'texelFetch', 'textureGrad' ];\n\nclass TSLEncoder {\n\n\tconstructor() {\n\n\t\tthis.tab = '';\n\t\tthis.imports = new Set();\n\t\tthis.global = new Set();\n\t\tthis.overloadings = new Map();\n\t\tthis.iife = false;\n\t\tthis.reference = false;\n\n\t\tthis.block = null;\n\n\t}\n\n\taddImport( name ) {\n\n\t\t// import only if it's a node\n\n\t\tname = name.split( '.' )[ 0 ];\n\n\t\tif ( TSL[ name ] !== undefined && this.global.has( name ) === false ) {\n\n\t\t\tthis.imports.add( name );\n\n\t\t}\n\n\t}\n\n\temitUniform( node ) {\n\n\t\tlet code = `const ${ node.name } = `;\n\t\tthis.global.add( node.name );\n\n\t\tif ( this.reference === true ) {\n\n\t\t\tthis.addImport( 'reference' );\n\n\t\t\t//code += `reference( '${ node.name }', '${ node.type }', uniforms )`;\n\n\t\t\t// legacy\n\t\t\tcode += `reference( 'value', '${ node.type }', uniforms[ '${ node.name }' ] )`;\n\n\t\t} else {\n\n\t\t\tif ( node.type === 'texture' ) {\n\n\t\t\t\tthis.addImport( 'texture' );\n\n\t\t\t\tcode += 'texture( /* <THREE.Texture> */ )';\n\n\t\t\t} else if ( node.type === 'cubeTexture' ) {\n\n\t\t\t\tthis.addImport( 'cubeTexture' );\n\n\t\t\t\tcode += 'cubeTexture( /* <THREE.CubeTexture> */ )';\n\n\t\t\t} else if ( node.type === 'texture3D' ) {\n\n\t\t\t\tthis.addImport( 'texture3D' );\n\n\t\t\t\tcode += 'texture3D( /* <THREE.Data3DTexture> */ )';\n\n\t\t\t} else {\n\n\t\t\t\t// default uniform\n\n\t\t\t\tthis.addImport( 'uniform' );\n\n\t\t\t\tcode += `uniform( '${ node.type }' )`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\temitExpression( node, output = null ) {\n\n\t\tlet code;\n\n\t\tif ( node.isAccessor ) {\n\n\t\t\tif ( node.linker.reference === null ) {\n\n\t\t\t\tthis.addImport( node.property );\n\n\t\t\t}\n\n\t\t\tcode = node.property;\n\n\t\t} else if ( node.isNumber ) {\n\n\t\t\tcode = node.value;\n\n\t\t} else if ( node.isString ) {\n\n\t\t\tcode = '\\'' + node.value + '\\'';\n\n\t\t} else if ( node.isOperator ) {\n\n\t\t\tconst opFn = opLib[ node.type ] || node.type;\n\n\t\t\tconst left = this.emitExpression( node.left, output );\n\t\t\tconst right = this.emitExpression( node.right, output );\n\n\t\t\tif ( node.isNumericExpression ) {\n\n\t\t\t\treturn left + ' ' + node.type + ' ' + right;\n\n\t\t\t}\n\n\t\t\tif ( isPrimitive( left ) ) {\n\n\t\t\t\tcode = opFn + '( ' + left + ', ' + right + ' )';\n\n\t\t\t\tthis.addImport( opFn );\n\n\t\t\t} else if ( opFn === '.' ) {\n\n\t\t\t\tcode = left + opFn + right;\n\n\t\t\t} else {\n\n\t\t\t\tcode = left + '.' + opFn + '( ' + right + ' )';\n\n\t\t\t}\n\n\t\t} else if ( node.isFunctionCall ) {\n\n\t\t\tconst params = [];\n\n\t\t\tfor ( const parameter of node.params ) {\n\n\t\t\t\tparams.push( this.emitExpression( parameter ) );\n\n\t\t\t}\n\n\t\t\t// handle texture lookup function calls in separate branch\n\n\t\t\tif ( textureLookupFunctions.includes( node.name ) ) {\n\n\t\t\t\tcode = `${ params[ 0 ] }.sample( ${ params[ 1 ] } )`;\n\n\t\t\t\tif ( node.name === 'texture' || node.name === 'texture2D' || node.name === 'texture3D' || node.name === 'textureCube' ) {\n\n\t\t\t\t\tif ( params.length === 3 ) {\n\n\t\t\t\t\t\tcode += `.bias( ${ params[ 2 ] } )`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( node.name === 'textureLod' ) {\n\n\t\t\t\t\tcode += `.level( ${ params[ 2 ] } )`;\n\n\t\t\t\t} else if ( node.name === 'textureGrad' ) {\n\n\t\t\t\t\tcode += `.grad( ${ params[ 2 ] }, ${ params[ 3 ] } )`;\n\n\t\t\t\t} else if ( node.name === 'texelFetch' ) {\n\n\t\t\t\t\tcode += '.setSampler( false )';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.addImport( node.name );\n\n\t\t\t\tconst paramsStr = params.length > 0 ? ' ' + params.join( ', ' ) + ' ' : '';\n\n\t\t\t\tcode = `${ node.name }(${ paramsStr })`;\n\n\t\t\t}\n\n\t\t} else if ( node.isReturn ) {\n\n\t\t\tcode = 'return';\n\n\t\t\tif ( node.value ) {\n\n\t\t\t\tcode += ' ' + this.emitExpression( node.value );\n\n\t\t\t}\n\n\t\t} else if ( node.isDiscard ) {\n\n\t\t\tthis.addImport( 'Discard' );\n\n\t\t\tcode = 'Discard()';\n\n\t\t} else if ( node.isBreak ) {\n\n\t\t\tthis.addImport( 'Break' );\n\n\t\t\tcode = 'Break()';\n\n\t\t} else if ( node.isContinue ) {\n\n\t\t\tthis.addImport( 'Continue' );\n\n\t\t\tcode = 'Continue()';\n\n\t\t} else if ( node.isAccessorElements ) {\n\n\t\t\tcode = this.emitExpression( node.object );\n\n\t\t\tfor ( const element of node.elements ) {\n\n\t\t\t\tif ( element.isStaticElement ) {\n\n\t\t\t\t\tcode += '.' + this.emitExpression( element.value );\n\n\t\t\t\t} else if ( element.isDynamicElement ) {\n\n\t\t\t\t\tconst value = this.emitExpression( element.value );\n\n\t\t\t\t\tif ( isPrimitive( value ) ) {\n\n\t\t\t\t\t\tcode += `[ ${ value } ]`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcode += `.element( ${ value } )`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( node.isDynamicElement ) {\n\n\t\t\tcode = this.emitExpression( node.value );\n\n\t\t} else if ( node.isStaticElement ) {\n\n\t\t\tcode = this.emitExpression( node.value );\n\n\t\t} else if ( node.isFor ) {\n\n\t\t\tcode = this.emitFor( node );\n\n\t\t} else if ( node.isWhile ) {\n\n\t\t\tcode = this.emitWhile( node );\n\n\t\t} else if ( node.isSwitch ) {\n\n\t\t\tcode = this.emitSwitch( node );\n\n\t\t} else if ( node.isVariableDeclaration ) {\n\n\t\t\tcode = this.emitVariables( node );\n\n\t\t} else if ( node.isUniform ) {\n\n\t\t\tcode = this.emitUniform( node );\n\n\t\t} else if ( node.isVarying ) {\n\n\t\t\tcode = this.emitVarying( node );\n\n\t\t} else if ( node.isTernary ) {\n\n\t\t\tcode = this.emitTernary( node );\n\n\t\t} else if ( node.isConditional ) {\n\n\t\t\tcode = this.emitConditional( node );\n\n\t\t} else if ( node.isUnary && node.expression.isNumber && node.type === '-' ) {\n\n\t\t\tcode = '- ' + node.expression.value;\n\n\t\t\tif ( node.expression.type !== 'float' ) {\n\n\t\t\t\tcode = node.expression.type + '( ' + code + ' )';\n\n\t\t\t\tthis.addImport( node.expression.type );\n\n\t\t\t}\n\n\t\t} else if ( node.isUnary ) {\n\n\t\t\tlet type = unaryLib[ node.type ];\n\n\t\t\tif ( node.hasAssignment ) {\n\n\t\t\t\tif ( node.after === false ) {\n\n\t\t\t\t\ttype += 'Before';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst exp = this.emitExpression( node.expression );\n\n\t\t\tif ( isPrimitive( exp ) ) {\n\n\t\t\t\tthis.addImport( type );\n\n\t\t\t\tcode = type + '( ' + exp + ' )';\n\n\t\t\t} else {\n\n\t\t\t\tcode = exp + '.' + type + '()';\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'Unknown node type', node );\n\n\t\t}\n\n\t\tif ( ! code ) code = '/* unknown statement */';\n\n\t\treturn code;\n\n\t}\n\n\temitBody( body ) {\n\n\t\tlet code = '';\n\n\t\tthis.tab += '\\t';\n\n\t\tfor ( const statement of body ) {\n\n\t\t\tcode += this.emitExtraLine( statement, body );\n\n\t\t\tif ( statement.isComment ) {\n\n\t\t\t\tcode += this.emitComment( statement, body );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( this.block && this.block.isSwitchCase ) {\n\n\t\t\t\tif ( statement.isBreak ) continue; // skip break statements in switch cases\n\n\t\t\t}\n\n\t\t\tcode += this.tab + this.emitExpression( statement );\n\n\t\t\tif ( code.slice( - 1 ) !== '}' ) code += ';';\n\n\t\t\tcode += '\\n';\n\n\t\t}\n\n\t\tcode = code.slice( 0, - 1 ); // remove the last extra line\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn code;\n\n\n\t}\n\n\temitTernary( node ) {\n\n\t\tconst condStr = this.emitExpression( node.cond );\n\t\tconst leftStr = this.emitExpression( node.left );\n\t\tconst rightStr = this.emitExpression( node.right );\n\n\t\tthis.addImport( 'select' );\n\n\t\treturn `select( ${ condStr }, ${ leftStr }, ${ rightStr } )`;\n\n\t}\n\n\temitConditional( node ) {\n\n\t\tconst condStr = this.emitExpression( node.cond );\n\t\tconst bodyStr = this.emitBody( node.body );\n\n\t\tlet ifStr = `If( ${ condStr }, () => {\n\n${ bodyStr }\n\n${ this.tab }} )`;\n\n\t\tlet current = node;\n\n\t\twhile ( current.elseConditional ) {\n\n\t\t\tconst elseBodyStr = this.emitBody( current.elseConditional.body );\n\n\t\t\tif ( current.elseConditional.cond ) {\n\n\t\t\t\tconst elseCondStr = this.emitExpression( current.elseConditional.cond );\n\n\t\t\t\tifStr += `.ElseIf( ${ elseCondStr }, () => {\n\n${ elseBodyStr }\n\n${ this.tab }} )`;\n\n\t\t\t} else {\n\n\t\t\t\tifStr += `.Else( () => {\n\n${ elseBodyStr }\n\n${ this.tab }} )`;\n\n\t\t\t}\n\n\t\t\tcurrent = current.elseConditional;\n\n\n\t\t}\n\n\t\tthis.imports.add( 'If' );\n\n\t\treturn ifStr;\n\n\t}\n\n\temitLoop( node ) {\n\n\t\tconst start = this.emitExpression( node.initialization.value );\n\t\tconst end = this.emitExpression( node.condition.right );\n\n\t\tconst name = node.initialization.name;\n\t\tconst type = node.initialization.type;\n\t\tconst condition = node.condition.type;\n\n\t\tconst nameParam = name !== 'i' ? `, name: '${ name }'` : '';\n\t\tconst typeParam = type !== 'int' ? `, type: '${ type }'` : '';\n\t\tconst conditionParam = condition !== '<' ? `, condition: '${ condition }'` : '';\n\n\t\tlet updateParam = '';\n\n\t\tif ( node.afterthought.isUnary ) {\n\n\t\t\tif ( node.afterthought.type !== '++' ) {\n\n\t\t\t\tupdateParam = `, update: '${ node.afterthought.type }'`;\n\n\t\t\t}\n\n\t\t} else if ( node.afterthought.isOperator ) {\n\n\t\t\tif ( node.afterthought.right.isAccessor || node.afterthought.right.isNumber ) {\n\n\t\t\t\tupdateParam = `, update: ${ this.emitExpression( node.afterthought.right ) }`;\n\n\t\t\t} else {\n\n\t\t\t\tupdateParam = `, update: ( { i } ) => ${ this.emitExpression( node.afterthought ) }`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet loopStr = `Loop( { start: ${ start }, end: ${ end + nameParam + typeParam + conditionParam + updateParam } }, ( { ${ name } } ) => {\\n\\n`;\n\n\t\tloopStr += this.emitBody( node.body ) + '\\n\\n';\n\n\t\tloopStr += this.tab + '} )';\n\n\t\tthis.imports.add( 'Loop' );\n\n\t\treturn loopStr;\n\n\t}\n\n\n\temitSwitch( switchNode ) {\n\n\t\tconst discriminantString = this.emitExpression( switchNode.discriminant );\n\n\t\tthis.tab += '\\t';\n\n\t\tlet switchString = `Switch( ${ discriminantString } )\\n${ this.tab }`;\n\n\t\tconst previousBlock = this.block;\n\n\t\tfor ( const switchCase of switchNode.cases ) {\n\n\t\t\tthis.block = switchCase;\n\n\t\t\tlet caseBodyString;\n\n\t\t\tif ( ! switchCase.isDefault ) {\n\n\t\t\t\tconst caseConditions = [ ];\n\n\t\t\t\tfor ( const condition of switchCase.conditions ) {\n\n\t\t\t\t\tcaseConditions.push( this.emitExpression( condition ) );\n\n\t\t\t\t}\n\n\t\t\t\tcaseBodyString = this.emitBody( switchCase.body );\n\n\t\t\t\tswitchString += `.Case( ${ caseConditions.join( ', ' ) }, `;\n\n\t\t\t} else {\n\n\t\t\t\tcaseBodyString = this.emitBody( switchCase.body );\n\n\t\t\t\tswitchString += '.Default( ';\n\n\t\t\t}\n\n\t\t\tswitchString += `() => {\n\n${ caseBodyString }\n\n${ this.tab }} )`;\n\n\t\t}\n\n\t\tthis.block = previousBlock;\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\tthis.imports.add( 'Switch' );\n\n\t\treturn switchString;\n\n\t}\n\n\temitFor( node ) {\n\n\t\tconst { initialization, condition, afterthought } = node;\n\n\t\tif ( ( initialization && initialization.isVariableDeclaration && initialization.next === null ) &&\n\t\t\t( condition && condition.left.isAccessor && condition.left.property === initialization.name ) &&\n\t\t\t( afterthought && (\n\t\t\t\t( afterthought.isUnary && ( initialization.name === afterthought.expression.property ) ) ||\n\t\t\t\t( afterthought.isOperator && ( initialization.name === afterthought.left.property ) )\n\t\t\t) )\n\t\t) {\n\n\t\t\treturn this.emitLoop( node );\n\n\t\t}\n\n\t\treturn this.emitForWhile( node );\n\n\t}\n\n\temitForWhile( node ) {\n\n\t\tconst initialization = this.emitExpression( node.initialization );\n\t\tconst condition = this.emitExpression( node.condition );\n\t\tconst afterthought = this.emitExpression( node.afterthought );\n\n\t\tthis.tab += '\\t';\n\n\t\tlet forStr = '{\\n\\n' + this.tab + initialization + ';\\n\\n';\n\t\tforStr += `${ this.tab }Loop( ${ condition }, () => {\\n\\n`;\n\n\t\tforStr += this.emitBody( node.body ) + '\\n\\n';\n\n\t\tforStr += this.tab + '\\t' + afterthought + ';\\n\\n';\n\n\t\tforStr += this.tab + '} )\\n\\n';\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\tforStr += this.tab + '}';\n\n\t\tthis.imports.add( 'Loop' );\n\n\t\treturn forStr;\n\n\t}\n\n\temitWhile( node ) {\n\n\t\tconst condition = this.emitExpression( node.condition );\n\n\t\tlet whileStr = `Loop( ${ condition }, () => {\\n\\n`;\n\n\t\twhileStr += this.emitBody( node.body ) + '\\n\\n';\n\n\t\twhileStr += this.tab + '} )';\n\n\t\tthis.imports.add( 'Loop' );\n\n\t\treturn whileStr;\n\n\t}\n\n\temitVariables( node, isRoot = true ) {\n\n\t\tconst { name, type, value, next } = node;\n\n\t\tlet varStr = isRoot ? 'const ' : '';\n\t\tvarStr += name;\n\n\t\tif ( value ) {\n\n\t\t\tlet valueStr = this.emitExpression( value );\n\n\t\t\tif ( value.isNumericExpression ) {\n\n\t\t\t\t// convert JS primitive to node\n\n\t\t\t\tvalueStr = `${ type }( ${ valueStr } )`;\n\n\t\t\t\tthis.addImport( type );\n\n\t\t\t}\n\n\t\t\tif ( node.linker.assignments.length > 0 ) {\n\n\t\t\t\tvarStr += ' = ' + valueStr + '.toVar()';\n\n\t\t\t} else {\n\n\t\t\t\tvarStr += ' = ' + valueStr;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvarStr += ` = property( '${ type }' )`;\n\n\t\t\tthis.addImport( 'property' );\n\n\t\t}\n\n\t\tif ( next ) {\n\n\t\t\tvarStr += ', ' + this.emitVariables( next, false );\n\n\t\t}\n\n\t\treturn varStr;\n\n\t}\n\n\temitVarying( node ) {\n\n\t\tconst { name, type } = node;\n\n\t\tthis.addImport( 'varying' );\n\t\tthis.addImport( type );\n\n\t\treturn `const ${ name } = varying( ${ type }(), '${ name }' )`;\n\n\t}\n\n\temitOverloadingFunction( nodes ) {\n\n\t\tconst { name } = nodes[ 0 ];\n\n\t\tthis.addImport( 'overloadingFn' );\n\n\t\tconst prefix = this.iife === false ? 'export ' : '';\n\n\t\treturn `${ prefix }const ${ name } = /*@__PURE__*/ overloadingFn( [ ${ nodes.map( node => node.name + '_' + nodes.indexOf( node ) ).join( ', ' ) } ] );\\n`;\n\n\t}\n\n\temitFunction( node ) {\n\n\t\tconst { name, type } = node;\n\n\t\tconst params = [];\n\t\tconst inputs = [];\n\t\tconst mutableParams = [];\n\n\t\tlet hasPointer = false;\n\n\t\tfor ( const param of node.params ) {\n\n\t\t\tlet name = param.name;\n\n\t\t\tif ( param.linker.assignments.length > 0 ) {\n\n\t\t\t\tname = name + '_immutable';\n\n\t\t\t\tmutableParams.push( param );\n\n\t\t\t}\n\n\t\t\tif ( param.qualifier ) {\n\n\t\t\t\tif ( param.qualifier === 'inout' || param.qualifier === 'out' ) {\n\n\t\t\t\t\thasPointer = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tinputs.push( param.name + ': \\'' + param.type + '\\'' );\n\t\t\tparams.push( name );\n\n\t\t}\n\n\t\tfor ( const param of mutableParams ) {\n\n\t\t\tconst mutableParam = new VariableDeclaration( param.type, param.name, new Accessor( param.name + '_immutable' ), null, true );\n\t\t\tmutableParam.parent = param.parent; // link to the original node\n\t\t\tmutableParam.linker.assignments.push( mutableParam );\n\n\t\t\tnode.body.unshift( mutableParam );\n\n\t\t}\n\n\t\tconst paramsStr = params.length > 0 ? ' [ ' + params.join( ', ' ) + ' ] ' : '';\n\t\tconst bodyStr = this.emitBody( node.body );\n\n\t\tlet fnName = name;\n\t\tlet overloadingNodes = null;\n\n\t\tif ( this.overloadings.has( name ) ) {\n\n\t\t\tconst overloadings = this.overloadings.get( name );\n\n\t\t\tif ( overloadings.length > 1 ) {\n\n\t\t\t\tconst index = overloadings.indexOf( node );\n\n\t\t\t\tfnName += '_' + index;\n\n\t\t\t\tif ( index === overloadings.length - 1 ) {\n\n\t\t\t\t\toverloadingNodes = overloadings;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst prefix = this.iife === false ? 'export ' : '';\n\n\t\tlet funcStr = `${ prefix }const ${ fnName } = /*@__PURE__*/ Fn( (${ paramsStr }) => {\n\n${ bodyStr }\n\n${ this.tab }}`;\n\n\t\tif ( node.layout !== false && hasPointer === false ) {\n\n\t\t\tfuncStr += ', { ' + inputs.join( ', ' ) + ', return: \\'' + type + '\\' }';\n\n\t\t}\n\n\t\tfuncStr += ' );\\n';\n\n\t\tthis.imports.add( 'Fn' );\n\n\t\tthis.global.add( node.name );\n\n\t\tif ( overloadingNodes !== null ) {\n\n\t\t\tfuncStr += '\\n' + this.emitOverloadingFunction( overloadingNodes );\n\n\t\t}\n\n\t\treturn funcStr;\n\n\t}\n\n\temitComment( statement, body ) {\n\n\t\tconst index = body.indexOf( statement );\n\t\tconst previous = body[ index - 1 ];\n\t\tconst next = body[ index + 1 ];\n\n\t\tlet output = '';\n\n\t\tif ( previous && isExpression( previous ) ) {\n\n\t\t\toutput += '\\n';\n\n\t\t}\n\n\t\toutput += this.tab + statement.comment.replace( /\\n/g, '\\n' + this.tab ) + '\\n';\n\n\t\tif ( next && isExpression( next ) ) {\n\n\t\t\toutput += '\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\temitExtraLine( statement, body ) {\n\n\t\tconst index = body.indexOf( statement );\n\t\tconst previous = body[ index - 1 ];\n\n\t\tif ( previous === undefined ) return '';\n\n\t\tif ( statement.isReturn ) return '\\n';\n\n\t\tconst lastExp = isExpression( previous );\n\t\tconst currExp = isExpression( statement );\n\n\t\tif ( lastExp !== currExp || ( ! lastExp && ! currExp ) ) return '\\n';\n\n\t\treturn '';\n\n\t}\n\n\temit( ast ) {\n\n\t\tlet code = '\\n';\n\n\t\tif ( this.iife ) this.tab += '\\t';\n\n\t\tconst overloadings = this.overloadings;\n\n\t\tfor ( const statement of ast.body ) {\n\n\t\t\tif ( statement.isFunctionDeclaration ) {\n\n\t\t\t\tif ( overloadings.has( statement.name ) === false ) {\n\n\t\t\t\t\toverloadings.set( statement.name, [] );\n\n\t\t\t\t}\n\n\t\t\t\toverloadings.get( statement.name ).push( statement );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const statement of ast.body ) {\n\n\t\t\tcode += this.emitExtraLine( statement, ast.body );\n\n\t\t\tif ( statement.isComment ) {\n\n\t\t\t\tcode += this.emitComment( statement, ast.body );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( statement.isFunctionDeclaration ) {\n\n\t\t\t\tcode += this.tab + this.emitFunction( statement );\n\n\t\t\t} else {\n\n\t\t\t\tcode += this.tab + this.emitExpression( statement ) + ';\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst imports = [ ...this.imports ];\n\t\tconst exports = [ ...this.global ];\n\n\t\tlet header = '// Three.js Transpiler r' + REVISION + '\\n\\n';\n\t\tlet footer = '';\n\n\t\tif ( this.iife ) {\n\n\t\t\theader += '( function ( TSL, uniforms ) {\\n\\n';\n\n\t\t\theader += imports.length > 0 ? '\\tconst { ' + imports.join( ', ' ) + ' } = TSL;\\n' : '';\n\t\t\tfooter += exports.length > 0 ? '\\treturn { ' + exports.join( ', ' ) + ' };\\n' : '';\n\n\t\t\tfooter += '\\n} );';\n\n\t\t} else {\n\n\t\t\theader += imports.length > 0 ? 'import { ' + imports.join( ', ' ) + ' } from \\'three/tsl\\';\\n' : '';\n\n\t\t}\n\n\t\treturn header + code + footer;\n\n\t}\n\n}\n\nexport default TSLEncoder;\n"],"mappings":"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","ignoreList":[]}