import{REVISION}from"three/webgpu";import{VariableDeclaration,Accessor}from"./AST.js";import{isExpression}from"./TranspilerUtils.js";const typeMap={float:"f32",int:"i32",uint:"u32",bool:"bool",vec2:"vec2f",ivec2:"vec2i",uvec2:"vec2u",bvec2:"vec2b",vec3:"vec3f",ivec3:"vec3i",uvec3:"vec3u",bvec3:"vec3b",vec4:"vec4f",ivec4:"vec4i",uvec4:"vec4u",bvec4:"vec4b",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>",texture:"texture_2d<f32>",textureCube:"texture_cube<f32>",texture3D:"texture_3d<f32>"},wgslLib={abs:"abs",acos:"acos",asin:"asin",atan:"atan",atan2:"atan2",ceil:"ceil",clamp:"clamp",cos:"cos",cross:"cross",degrees:"degrees",distance:"distance",dot:"dot",exp:"exp",exp2:"exp2",faceforward:"faceForward",floor:"floor",fract:"fract",inverse:"inverse",inversesqrt:"inverseSqrt",length:"length",log:"log",log2:"log2",max:"max",min:"min",mix:"mix",normalize:"normalize",pow:"pow",radians:"radians",reflect:"reflect",refract:"refract",round:"round",sign:"sign",sin:"sin",smoothstep:"smoothstep",sqrt:"sqrt",step:"step",tan:"tan",transpose:"transpose",trunc:"trunc",dFdx:"dpdx",dFdy:"dpdy",fwidth:"fwidth",texture:"textureSample",texture2D:"textureSample",texture3D:"textureSample",textureCube:"textureSample",textureLod:"textureSampleLevel",texelFetch:"textureLoad",textureGrad:"textureSampleGrad"};class WGSLEncoder{constructor(){this.tab="",this.functions=new Map,this.uniforms=[],this.varyings=[],this.structs=new Map,this.polyfills=new Map,this.groupIndex=0}getWgslType(e){return typeMap[e]||e}emitExpression(e){if(!e)return"";let t;if(e.isAccessor){const s=this.uniforms.find((t=>t.name===e.property));if(s&&!s.type.includes("texture"))return`uniforms.${e.property}`;t=e.property}else if(e.isNumber)t=e.value,"float"!==e.type||t.includes(".")||(t+=".0");else if(e.isOperator){const s=this.emitExpression(e.left),i=this.emitExpression(e.right);t=`${s} ${e.type} ${i}`,!0!==e.parent.isAssignment&&e.parent.isOperator&&(t=`( ${t} )`)}else if(e.isFunctionCall){const s=wgslLib[e.name]||e.name;if("mod"===s){const s=e.params.map((e=>this.emitExpression(e))),i=e.params.map((e=>e.getType())),n="mod_"+i.join("_");!1===this.polyfills.has(n)&&this.polyfills.set(n,`fn ${n}( x: ${this.getWgslType(i[0])}, y: ${this.getWgslType(i[1])} ) -> ${this.getWgslType(i[0])} {\n\n\treturn x - y * floor( x / y );\n\n}`),t=`${n}( ${s.join(", ")} )`}else if(s.startsWith("texture"))t=this.emitTextureAccess(e);else{const i=e.params.map((e=>this.emitExpression(e)));t=typeMap[s]?this.getWgslType(s):s,i.length>0?t+="( "+i.join(", ")+" )":t+="()"}}else if(e.isReturn)t="return",e.value&&(t+=" "+this.emitExpression(e.value));else if(e.isDiscard)t="discard";else if(e.isBreak)!0!==e.parent.isSwitchCase&&(t="break");else if(e.isContinue)t="continue";else if(e.isAccessorElements){t=this.emitExpression(e.object);for(const s of e.elements){const e=this.emitExpression(s.value);s.isStaticElement?t+="."+e:s.isDynamicElement&&(t+=`[${e}]`)}}else if(e.isFor)t=this.emitFor(e);else if(e.isWhile)t=this.emitWhile(e);else if(e.isSwitch)t=this.emitSwitch(e);else if(e.isVariableDeclaration)t=this.emitVariables(e);else{if(e.isUniform)return this.uniforms.push(e),"";if(e.isVarying)return this.varyings.push(e),"";if(e.isTernary){const s=this.emitExpression(e.cond),i=this.emitExpression(e.left);t=`select( ${this.emitExpression(e.right)}, ${i}, ${s} )`}else if(e.isConditional)t=this.emitConditional(e);else if(e.isUnary){const s=this.emitExpression(e.expression);if("++"===e.type||"--"===e.type){t=`${s} = ${s} ${"++"===e.type?"+":"-"} 1`}else t=`${e.type}${s}`}else console.warn("Unknown node type in WGSL Encoder:",e),t=`/* unknown node: ${e.constructor.name} */`}return t}emitTextureAccess(e){const t=wgslLib[e.name],s=this.emitExpression(e.params[0]),i=this.emitExpression(e.params[1]),n=`${s}_sampler`;let r;switch(e.name){case"texture":case"texture2D":case"texture3D":case"textureCube":if(r=`${t}(${s}, ${n}, ${i}`,3===e.params.length){r=`textureSampleBias(${s}, ${n}, ${i}, ${this.emitExpression(e.params[2])})`}else r+=")";break;case"textureLod":r=`${t}(${s}, ${n}, ${i}, ${this.emitExpression(e.params[2])})`;break;case"textureGrad":r=`${t}(${s}, ${n}, ${i}, ${this.emitExpression(e.params[2])}, ${this.emitExpression(e.params[3])})`;break;case"texelFetch":r=`${t}(${s}, ${this.emitExpression(e.params[1])}, ${e.params.length>2?this.emitExpression(e.params[2]):"0"})`;break;default:r=`/* unsupported texture op: ${e.name} */`}return r}emitBody(e){let t="";this.tab+="\t";for(const s of e){if(t+=this.emitExtraLine(s,e),s.isComment){t+=this.emitComment(s,e);continue}const i=this.emitExpression(s);i&&(t+=this.tab+i,i.endsWith("}")||i.endsWith("{")||(t+=";"),t+="\n")}return this.tab=this.tab.slice(0,-1),t.slice(0,-1)}emitConditional(e){let t=`if ( ${this.emitExpression(e.cond)} ) {\n\n${this.emitBody(e.body)}\n\n${this.tab}}`,s=e;for(;s.elseConditional;){s=s.elseConditional;const e=this.emitBody(s.body);if(s.cond){t+=` else if ( ${this.emitExpression(s.cond)} ) {\n\n${e}\n\n${this.tab}}`}else t+=` else {\n\n${e}\n\n${this.tab}}`}return t}emitFor(e){return`for ( ${this.emitExpression(e.initialization)}; ${this.emitExpression(e.condition)}; ${this.emitExpression(e.afterthought)} ) {\n\n${this.emitBody(e.body)}\n\n${this.tab}}`}emitWhile(e){return`while ( ${this.emitExpression(e.condition)} ) {\n\n${this.emitBody(e.body)}\n\n${this.tab}}`}emitSwitch(e){let t=`switch ( ${this.emitExpression(e.discriminant)} ) {\n\n`;this.tab+="\t";for(const s of e.cases){const e=this.emitBody(s.body);if(s.isDefault)t+=`${this.tab}default: {\n\n${e}\n\n${this.tab}}\n\n`;else{const i=s.conditions.map((e=>this.emitExpression(e))).join(", ");t+=`${this.tab}case ${i}: {\n\n${e}\n\n${this.tab}}\n\n`}}return this.tab=this.tab.slice(0,-1),t+=`${this.tab}}`,t}emitVariables(e){const t=[];let s=e;for(;s;){const e=this.getWgslType(s.type);let i,n="";s.value&&(n=` = ${this.emitExpression(s.value)}`),s.linker&&(i=s.linker.assignments.length>0?"var":s.value&&s.value.isNumericExpression?"const":"let"),t.push(`${i} ${s.name}: ${e}${n}`),s=s.next}return t.join(";\n"+this.tab)}emitFunction(e){const t=e.name,s=this.getWgslType(e.type),i=[],n=[...e.body];for(const t of e.params){const e=t.name;let s=this.getWgslType(t.type);if("inout"!==t.qualifier&&"out"!==t.qualifier)if(t.linker&&t.linker.assignments.length>0){const r=`${e}_in`;i.push(`${r}: ${s}`);const o=new Accessor(r);o.isAccessor=!0,o.property=r;const a=new VariableDeclaration(t.type,t.name,o);a.linker={assignments:[!0]},n.unshift(a)}else i.push(`${e}: ${s}`);else s=`ptr<function, ${s}>`,i.push(`${e}: ${s}`)}return`fn ${t}(${i.length>0?" "+i.join(", ")+" ":""})${s&&"void"!==s?` -> ${s}`:""} {\n\n${this.emitBody(n)}\n\n${this.tab}}`}emitComment(e,t){const s=t.indexOf(e),i=t[s-1],n=t[s+1];let r="";return i&&isExpression(i)&&(r+="\n"),r+=this.tab+e.comment.replace(/\n/g,"\n"+this.tab)+"\n",n&&isExpression(n)&&(r+="\n"),r}emitExtraLine(e,t){const s=t.indexOf(e),i=t[s-1];if(void 0===i)return"";if(e.isReturn)return"\n";const n=isExpression(i),r=isExpression(e);return n!==r||!n&&!r?"\n":""}emit(e){const t="// Three.js Transpiler r"+REVISION+"\n\n";let s="",i="",n="";for(const t of e.body)t.isFunctionDeclaration?this.functions.set(t.name,t):t.isUniform?this.uniforms.push(t):t.isVarying&&this.varyings.push(t);if(this.uniforms.length>0){let e=0;const t=[],i=[];for(const s of this.uniforms)s.type.includes("texture")?(i.push(`@group(${this.groupIndex}) @binding(${e++}) var ${s.name}: ${this.getWgslType(s.type)};`),i.push(`@group(${this.groupIndex}) @binding(${e++}) var ${s.name}_sampler: sampler;`)):t.push(`\t${s.name}: ${this.getWgslType(s.type)},`);t.length>0&&(s+="struct Uniforms {\n",s+=t.join("\n"),s+="\n};\n",s+=`@group(${this.groupIndex}) @binding(${e++}) var<uniform> uniforms: Uniforms;\n\n`),s+=i.join("\n")+"\n\n"}if(this.varyings.length>0){s+="struct Varyings {\n";let e=0;for(const t of this.varyings)s+=`\t@location(${e++}) ${t.name}: ${this.getWgslType(t.type)},\n`;s+="};\n\n"}for(const t of e.body)i+=this.emitExtraLine(t,e.body),t.isFunctionDeclaration?i+=this.emitFunction(t)+"\n":t.isComment?i+=this.emitComment(t,e.body):t.isUniform||t.isVarying||(i+=this.emitExpression(t)+";\n");for(const e of this.polyfills.values())n=`${e}\n\n`;return t+n+s+i.trimEnd()+"\n"}}export default WGSLEncoder;
//# sourceMappingURL=WGSLEncoder.js.map