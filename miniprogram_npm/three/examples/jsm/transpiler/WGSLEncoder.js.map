{"version":3,"file":"node_modules/three/examples/jsm/transpiler/WGSLEncoder.js","names":["REVISION","VariableDeclaration","Accessor","isExpression","typeMap","float","int","uint","bool","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","mat4","texture","textureCube","texture3D","wgslLib","abs","acos","asin","atan","atan2","ceil","clamp","cos","cross","degrees","distance","dot","exp","exp2","faceforward","floor","fract","inverse","inversesqrt","length","log","log2","max","min","mix","normalize","pow","radians","reflect","refract","round","sign","sin","smoothstep","sqrt","step","tan","transpose","trunc","dFdx","dFdy","fwidth","texture2D","textureLod","texelFetch","textureGrad","WGSLEncoder","constructor","this","tab","functions","Map","uniforms","varyings","structs","polyfills","groupIndex","getWgslType","type","emitExpression","node","code","isAccessor","uniform","find","u","name","property","includes","isNumber","value","isOperator","left","right","parent","isAssignment","isFunctionCall","fnName","snippets","params","map","p","types","getType","modFnName","join","has","set","startsWith","emitTextureAccess","isReturn","isDiscard","isBreak","isSwitchCase","isContinue","isAccessorElements","object","element","elements","isStaticElement","isDynamicElement","isFor","emitFor","isWhile","emitWhile","isSwitch","emitSwitch","isVariableDeclaration","emitVariables","isUniform","push","isVarying","isTernary","cond","isConditional","emitConditional","isUnary","expr","expression","console","warn","wgslFn","textureName","uv","samplerName","emitBody","body","statement","emitExtraLine","isComment","emitComment","statementCode","endsWith","slice","ifStr","current","elseConditional","elseBodyStr","initialization","condition","afterthought","switchStr","discriminant","switchCase","cases","isDefault","conditions","c","declarations","keyword","valueStr","linker","assignments","isNumericExpression","next","emitFunction","returnType","param","paramName","paramType","qualifier","immutableParamName","immutableAccessor","mutableVar","unshift","index","indexOf","previous","output","comment","replace","undefined","lastExp","currExp","emit","ast","header","globals","dependencies","isFunctionDeclaration","bindingIndex","uniformStructMembers","textureGlobals","location","varying","values","trimEnd"],"sources":["node_modules/three/examples/jsm/transpiler/WGSLEncoder.js"],"sourcesContent":["import { REVISION } from 'three/webgpu';\n\nimport { VariableDeclaration, Accessor } from './AST.js';\nimport { isExpression } from './TranspilerUtils.js';\n\n// Note: This is a simplified list. A complete implementation would need more mappings.\nconst typeMap = {\n\t'float': 'f32',\n\t'int': 'i32',\n\t'uint': 'u32',\n\t'bool': 'bool',\n\t'vec2': 'vec2f',\n\t'ivec2': 'vec2i',\n\t'uvec2': 'vec2u',\n\t'bvec2': 'vec2b',\n\t'vec3': 'vec3f',\n\t'ivec3': 'vec3i',\n\t'uvec3': 'vec3u',\n\t'bvec3': 'vec3b',\n\t'vec4': 'vec4f',\n\t'ivec4': 'vec4i',\n\t'uvec4': 'vec4u',\n\t'bvec4': 'vec4b',\n\t'mat3': 'mat3x3<f32>',\n\t'mat4': 'mat4x4<f32>',\n\t'texture': 'texture_2d<f32>',\n\t'textureCube': 'texture_cube<f32>',\n\t'texture3D': 'texture_3d<f32>',\n};\n\n// GLSL to WGSL built-in function mapping\nconst wgslLib = {\n\t'abs': 'abs',\n\t'acos': 'acos',\n\t'asin': 'asin',\n\t'atan': 'atan',\n\t'atan2': 'atan2',\n\t'ceil': 'ceil',\n\t'clamp': 'clamp',\n\t'cos': 'cos',\n\t'cross': 'cross',\n\t'degrees': 'degrees',\n\t'distance': 'distance',\n\t'dot': 'dot',\n\t'exp': 'exp',\n\t'exp2': 'exp2',\n\t'faceforward': 'faceForward',\n\t'floor': 'floor',\n\t'fract': 'fract',\n\t'inverse': 'inverse',\n\t'inversesqrt': 'inverseSqrt',\n\t'length': 'length',\n\t'log': 'log',\n\t'log2': 'log2',\n\t'max': 'max',\n\t'min': 'min',\n\t'mix': 'mix',\n\t'normalize': 'normalize',\n\t'pow': 'pow',\n\t'radians': 'radians',\n\t'reflect': 'reflect',\n\t'refract': 'refract',\n\t'round': 'round',\n\t'sign': 'sign',\n\t'sin': 'sin',\n\t'smoothstep': 'smoothstep',\n\t'sqrt': 'sqrt',\n\t'step': 'step',\n\t'tan': 'tan',\n\t'transpose': 'transpose',\n\t'trunc': 'trunc',\n\t'dFdx': 'dpdx',\n\t'dFdy': 'dpdy',\n\t'fwidth': 'fwidth',\n\t// Texture functions are handled separately\n\t'texture': 'textureSample',\n\t'texture2D': 'textureSample',\n\t'texture3D': 'textureSample',\n\t'textureCube': 'textureSample',\n\t'textureLod': 'textureSampleLevel',\n\t'texelFetch': 'textureLoad',\n\t'textureGrad': 'textureSampleGrad',\n};\n\nclass WGSLEncoder {\n\n\tconstructor() {\n\n\t\tthis.tab = '';\n\t\tthis.functions = new Map();\n\t\tthis.uniforms = [];\n\t\tthis.varyings = [];\n\t\tthis.structs = new Map();\n\t\tthis.polyfills = new Map();\n\n\t\t// Assume a single group for simplicity\n\t\tthis.groupIndex = 0;\n\n\t}\n\n\tgetWgslType( type ) {\n\n\t\treturn typeMap[ type ] || type;\n\n\t}\n\n\temitExpression( node ) {\n\n\t\tif ( ! node ) return '';\n\n\t\tlet code;\n\n\t\tif ( node.isAccessor ) {\n\n\t\t\t// Check if this accessor is part of a uniform struct\n\t\t\tconst uniform = this.uniforms.find( u => u.name === node.property );\n\n\t\t\tif ( uniform && ! uniform.type.includes( 'texture' ) ) {\n\n\t\t\t\treturn `uniforms.${node.property}`;\n\n\t\t\t}\n\n\t\t\tcode = node.property;\n\n\t\t} else if ( node.isNumber ) {\n\n\t\t\tcode = node.value;\n\n\t\t\t// WGSL requires floating point numbers to have a decimal\n\t\t\tif ( node.type === 'float' && ! code.includes( '.' ) ) {\n\n\t\t\t\tcode += '.0';\n\n\t\t\t}\n\n\t\t} else if ( node.isOperator ) {\n\n\t\t\tconst left = this.emitExpression( node.left );\n\t\t\tconst right = this.emitExpression( node.right );\n\n\t\t\tcode = `${ left } ${ node.type } ${ right }`;\n\n\t\t\tif ( node.parent.isAssignment !== true && node.parent.isOperator ) {\n\n\t\t\t\tcode = `( ${ code } )`;\n\n\t\t\t}\n\n\t\t} else if ( node.isFunctionCall ) {\n\n\t\t\tconst fnName = wgslLib[ node.name ] || node.name;\n\n\t\t\tif ( fnName === 'mod' ) {\n\n\t\t\t\tconst snippets = node.params.map( p => this.emitExpression( p ) );\n\t\t\t\tconst types = node.params.map( p => p.getType() );\n\n\t\t\t\tconst modFnName = 'mod_' + types.join( '_' );\n\n\t\t\t\tif ( this.polyfills.has( modFnName ) === false ) {\n\n\t\t\t\t\tthis.polyfills.set( modFnName, `fn ${ modFnName }( x: ${ this.getWgslType( types[ 0 ] ) }, y: ${ this.getWgslType( types[ 1 ] ) } ) -> ${ this.getWgslType( types[ 0 ] ) } {\n\n\treturn x - y * floor( x / y );\n\n}` );\n\n\t\t\t\t}\n\n\t\t\t\tcode = `${ modFnName }( ${ snippets.join( ', ' ) } )`;\n\n\t\t\t} else if ( fnName.startsWith( 'texture' ) ) {\n\n\t\t\t\t// Handle texture functions separately due to sampler handling\n\n\t\t\t\tcode = this.emitTextureAccess( node );\n\n\t\t\t} else {\n\n\t\t\t\tconst params = node.params.map( p => this.emitExpression( p ) );\n\n\t\t\t\tif ( typeMap[ fnName ] ) {\n\n\t\t\t\t\t// Handle type constructors like vec3(...)\n\n\t\t\t\t\tcode = this.getWgslType( fnName );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode = fnName;\n\n\t\t\t\t}\n\n\t\t\t\tif ( params.length > 0 ) {\n\n\t\t\t\t\tcode += '( ' + params.join( ', ' ) + ' )';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += '()';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( node.isReturn ) {\n\n\t\t\tcode = 'return';\n\n\t\t\tif ( node.value ) {\n\n\t\t\t\tcode += ' ' + this.emitExpression( node.value );\n\n\t\t\t}\n\n\t\t} else if ( node.isDiscard ) {\n\n\t\t\tcode = 'discard';\n\n\t\t} else if ( node.isBreak ) {\n\n\t\t\tif ( node.parent.isSwitchCase !== true ) {\n\n\t\t\t\tcode = 'break';\n\n\t\t\t}\n\n\t\t} else if ( node.isContinue ) {\n\n\t\t\tcode = 'continue';\n\n\t\t} else if ( node.isAccessorElements ) {\n\n\t\t\tcode = this.emitExpression( node.object );\n\n\t\t\tfor ( const element of node.elements ) {\n\n\t\t\t\tconst value = this.emitExpression( element.value );\n\n\t\t\t\tif ( element.isStaticElement ) {\n\n\t\t\t\t\tcode += '.' + value;\n\n\t\t\t\t} else if ( element.isDynamicElement ) {\n\n\t\t\t\t\tcode += `[${value}]`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( node.isFor ) {\n\n\t\t\tcode = this.emitFor( node );\n\n\t\t} else if ( node.isWhile ) {\n\n\t\t\tcode = this.emitWhile( node );\n\n\t\t} else if ( node.isSwitch ) {\n\n\t\t\tcode = this.emitSwitch( node );\n\n\t\t} else if ( node.isVariableDeclaration ) {\n\n\t\t\tcode = this.emitVariables( node );\n\n\t\t} else if ( node.isUniform ) {\n\n\t\t\tthis.uniforms.push( node );\n\t\t\treturn ''; // Defer emission to the header\n\n\t\t} else if ( node.isVarying ) {\n\n\t\t\tthis.varyings.push( node );\n\t\t\treturn ''; // Defer emission to the header\n\n\t\t} else if ( node.isTernary ) {\n\n\t\t\tconst cond = this.emitExpression( node.cond );\n\t\t\tconst left = this.emitExpression( node.left );\n\t\t\tconst right = this.emitExpression( node.right );\n\n\t\t\t// WGSL's equivalent to the ternary operator is select(false_val, true_val, condition)\n\t\t\tcode = `select( ${ right }, ${ left }, ${ cond } )`;\n\n\t\t} else if ( node.isConditional ) {\n\n\t\t\tcode = this.emitConditional( node );\n\n\t\t} else if ( node.isUnary ) {\n\n\t\t\tconst expr = this.emitExpression( node.expression );\n\n\t\t\tif ( node.type === '++' || node.type === '--' ) {\n\n\t\t\t\tconst op = node.type === '++' ? '+' : '-';\n\n\t\t\t\tcode = `${ expr } = ${ expr } ${ op } 1`;\n\n\t\t\t} else {\n\n\t\t\t\tcode = `${ node.type }${ expr }`;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'Unknown node type in WGSL Encoder:', node );\n\n\t\t\tcode = `/* unknown node: ${ node.constructor.name } */`;\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\temitTextureAccess( node ) {\n\n\t\tconst wgslFn = wgslLib[ node.name ];\n\t\tconst textureName = this.emitExpression( node.params[ 0 ] );\n\t\tconst uv = this.emitExpression( node.params[ 1 ] );\n\n\t\t// WGSL requires explicit samplers. We assume a naming convention.\n\t\tconst samplerName = `${textureName}_sampler`;\n\n\t\tlet code;\n\n\t\tswitch ( node.name ) {\n\n\t\t\tcase 'texture':\n\t\t\tcase 'texture2D':\n\t\t\tcase 'texture3D':\n\t\t\tcase 'textureCube':\n\t\t\t\t// format: textureSample(texture, sampler, coords, [offset])\n\t\t\t\tcode = `${wgslFn}(${textureName}, ${samplerName}, ${uv}`;\n\t\t\t\t// Handle optional bias parameter (note: WGSL uses textureSampleBias)\n\t\t\t\tif ( node.params.length === 3 ) {\n\n\t\t\t\t\tconst bias = this.emitExpression( node.params[ 2 ] );\n\t\t\t\t\tcode = `textureSampleBias(${textureName}, ${samplerName}, ${uv}, ${bias})`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += ')';\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'textureLod':\n\t\t\t\t// format: textureSampleLevel(texture, sampler, coords, level)\n\t\t\t\tconst lod = this.emitExpression( node.params[ 2 ] );\n\t\t\t\tcode = `${wgslFn}(${textureName}, ${samplerName}, ${uv}, ${lod})`;\n\t\t\t\tbreak;\n\n\t\t\tcase 'textureGrad':\n\t\t\t\t// format: textureSampleGrad(texture, sampler, coords, ddx, ddy)\n\t\t\t\tconst ddx = this.emitExpression( node.params[ 2 ] );\n\t\t\t\tconst ddy = this.emitExpression( node.params[ 3 ] );\n\t\t\t\tcode = `${wgslFn}(${textureName}, ${samplerName}, ${uv}, ${ddx}, ${ddy})`;\n\t\t\t\tbreak;\n\n\t\t\tcase 'texelFetch':\n\t\t\t\t// format: textureLoad(texture, coords, [level])\n\t\t\t\tconst coords = this.emitExpression( node.params[ 1 ] ); // should be ivec\n\t\t\t\tconst lodFetch = node.params.length > 2 ? this.emitExpression( node.params[ 2 ] ) : '0';\n\t\t\t\tcode = `${wgslFn}(${textureName}, ${coords}, ${lodFetch})`;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcode = `/* unsupported texture op: ${node.name} */`;\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\temitBody( body ) {\n\n\t\tlet code = '';\n\t\tthis.tab += '\\t';\n\n\t\tfor ( const statement of body ) {\n\n\t\t\tcode += this.emitExtraLine( statement, body );\n\n\t\t\tif ( statement.isComment ) {\n\n\t\t\t\tcode += this.emitComment( statement, body );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst statementCode = this.emitExpression( statement );\n\n\t\t\tif ( statementCode ) {\n\n\t\t\t\tcode += this.tab + statementCode;\n\n\t\t\t\tif ( ! statementCode.endsWith( '}' ) && ! statementCode.endsWith( '{' ) ) {\n\n\t\t\t\t\tcode += ';';\n\n\t\t\t\t}\n\n\t\t\t\tcode += '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\t\treturn code.slice( 0, - 1 ); // remove the last extra line\n\n\t}\n\n\temitConditional( node ) {\n\n\t\tconst condStr = this.emitExpression( node.cond );\n\t\tconst bodyStr = this.emitBody( node.body );\n\n\t\tlet ifStr = `if ( ${ condStr } ) {\\n\\n${ bodyStr }\\n\\n${ this.tab }}`;\n\n\t\tlet current = node;\n\n\t\twhile ( current.elseConditional ) {\n\n\t\t\tcurrent = current.elseConditional;\n\t\t\tconst elseBodyStr = this.emitBody( current.body );\n\n\t\t\tif ( current.cond ) { // This is an 'else if'\n\n\t\t\t\tconst elseCondStr = this.emitExpression( current.cond );\n\n\t\t\t\tifStr += ` else if ( ${ elseCondStr } ) {\\n\\n${ elseBodyStr }\\n\\n${ this.tab }}`;\n\n\t\t\t} else { // This is an 'else'\n\n\t\t\t\tifStr += ` else {\\n\\n${ elseBodyStr }\\n\\n${ this.tab }}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifStr;\n\n\t}\n\n\temitFor( node ) {\n\n\t\tconst init = this.emitExpression( node.initialization );\n\t\tconst cond = this.emitExpression( node.condition );\n\t\tconst after = this.emitExpression( node.afterthought );\n\t\tconst body = this.emitBody( node.body );\n\n\t\treturn `for ( ${ init }; ${ cond }; ${ after } ) {\\n\\n${ body }\\n\\n${ this.tab }}`;\n\n\t}\n\n\temitWhile( node ) {\n\n\t\tconst cond = this.emitExpression( node.condition );\n\t\tconst body = this.emitBody( node.body );\n\n\t\treturn `while ( ${ cond } ) {\\n\\n${ body }\\n\\n${ this.tab }}`;\n\n\t}\n\n\temitSwitch( node ) {\n\n\t\tconst discriminant = this.emitExpression( node.discriminant );\n\n\t\tlet switchStr = `switch ( ${ discriminant } ) {\\n\\n`;\n\n\t\tthis.tab += '\\t';\n\n\t\tfor ( const switchCase of node.cases ) {\n\n\t\t\tconst body = this.emitBody( switchCase.body );\n\n\t\t\tif ( switchCase.isDefault ) {\n\n\t\t\t\tswitchStr += `${ this.tab }default: {\\n\\n${ body }\\n\\n${ this.tab }}\\n\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst cases = switchCase.conditions.map( c => this.emitExpression( c ) ).join( ', ' );\n\n\t\t\t\tswitchStr += `${ this.tab }case ${ cases }: {\\n\\n${ body }\\n\\n${ this.tab }}\\n\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\tswitchStr += `${this.tab}}`;\n\n\t\treturn switchStr;\n\n\t}\n\n\temitVariables( node ) {\n\n\t\tconst declarations = [];\n\n\t\tlet current = node;\n\n\t\twhile ( current ) {\n\n\t\t\tconst type = this.getWgslType( current.type );\n\n\t\t\tlet valueStr = '';\n\n\t\t\tif ( current.value ) {\n\n\t\t\t\tvalueStr = ` = ${this.emitExpression( current.value )}`;\n\n\t\t\t}\n\n\t\t\t// The AST linker tracks if a variable is ever reassigned.\n\t\t\t// If so, use 'var'; otherwise, use 'let'.\n\n\t\t\tlet keyword;\n\n\t\t\tif ( current.linker ) {\n\n\t\t\t\tif ( current.linker.assignments.length > 0 ) {\n\n\t\t\t\t\tkeyword = 'var'; // Reassigned variable\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( current.value && current.value.isNumericExpression ) {\n\n\t\t\t\t\t\tkeyword = 'const'; // Immutable numeric expression\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tkeyword = 'let'; // Immutable variable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarations.push( `${ keyword } ${ current.name }: ${ type }${ valueStr }` );\n\n\t\t\tcurrent = current.next;\n\n\t\t}\n\n\t\t// In WGSL, multiple declarations in one line are not supported, so join with semicolons.\n\t\treturn declarations.join( ';\\n' + this.tab );\n\n\t}\n\n\temitFunction( node ) {\n\n\t\tconst name = node.name;\n\t\tconst returnType = this.getWgslType( node.type );\n\n\t\tconst params = [];\n\t\t// We will prepend to a copy of the body, not the original AST node.\n\t\tconst body = [ ...node.body ];\n\n\t\tfor ( const param of node.params ) {\n\n\t\t\tconst paramName = param.name;\n\t\t\tlet paramType = this.getWgslType( param.type );\n\n\t\t\t// Handle 'inout' and 'out' qualifiers using pointers. They are already mutable.\n\t\t\tif ( param.qualifier === 'inout' || param.qualifier === 'out' ) {\n\n\t\t\t\tparamType = `ptr<function, ${paramType}>`;\n\t\t\t\tparams.push( `${paramName}: ${paramType}` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// If the parameter is reassigned within the function, we need to\n\t\t\t// create a local, mutable variable that shadows the parameter's name.\n\t\t\tif ( param.linker && param.linker.assignments.length > 0 ) {\n\n\t\t\t\t// 1. Rename the incoming parameter to avoid name collision.\n\t\t\t\tconst immutableParamName = `${paramName}_in`;\n\t\t\t\tparams.push( `${immutableParamName}: ${paramType}` );\n\n\t\t\t\t// 2. Create a new Accessor node for the renamed immutable parameter.\n\t\t\t\tconst immutableAccessor = new Accessor( immutableParamName );\n\t\t\t\timmutableAccessor.isAccessor = true;\n\t\t\t\timmutableAccessor.property = immutableParamName;\n\n\t\t\t\t// 3. Create a new VariableDeclaration node for the mutable local variable.\n\t\t\t\t// This new variable will have the original parameter's name.\n\t\t\t\tconst mutableVar = new VariableDeclaration( param.type, param.name, immutableAccessor );\n\n\t\t\t\t// 4. Mark this new variable as mutable so `emitVariables` uses `var`.\n\t\t\t\tmutableVar.linker = { assignments: [ true ] };\n\n\t\t\t\t// 5. Prepend this new declaration to the function's body.\n\t\t\t\tbody.unshift( mutableVar );\n\n\t\t\t} else {\n\n\t\t\t\t// This parameter is not reassigned, so treat it as a normal immutable parameter.\n\t\t\t\tparams.push( `${paramName}: ${paramType}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst paramsStr = params.length > 0 ? ' ' + params.join( ', ' ) + ' ' : '';\n\t\tconst returnStr = ( returnType && returnType !== 'void' ) ? ` -> ${returnType}` : '';\n\n\t\t// Emit the function body, which now includes our injected variable declarations.\n\t\tconst bodyStr = this.emitBody( body );\n\n\t\treturn `fn ${name}(${paramsStr})${returnStr} {\\n\\n${bodyStr}\\n\\n${this.tab}}`;\n\n\t}\n\n\temitComment( statement, body ) {\n\n\t\tconst index = body.indexOf( statement );\n\t\tconst previous = body[ index - 1 ];\n\t\tconst next = body[ index + 1 ];\n\n\t\tlet output = '';\n\n\t\tif ( previous && isExpression( previous ) ) {\n\n\t\t\toutput += '\\n';\n\n\t\t}\n\n\t\toutput += this.tab + statement.comment.replace( /\\n/g, '\\n' + this.tab ) + '\\n';\n\n\t\tif ( next && isExpression( next ) ) {\n\n\t\t\toutput += '\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\temitExtraLine( statement, body ) {\n\n\t\tconst index = body.indexOf( statement );\n\t\tconst previous = body[ index - 1 ];\n\n\t\tif ( previous === undefined ) return '';\n\n\t\tif ( statement.isReturn ) return '\\n';\n\n\t\tconst lastExp = isExpression( previous );\n\t\tconst currExp = isExpression( statement );\n\n\t\tif ( lastExp !== currExp || ( ! lastExp && ! currExp ) ) return '\\n';\n\n\t\treturn '';\n\n\t}\n\n\temit( ast ) {\n\n\t\tconst header = '// Three.js Transpiler r' + REVISION + '\\n\\n';\n\n\t\tlet globals = '';\n\t\tlet functions = '';\n\t\tlet dependencies = '';\n\n\t\t// 1. Pre-process to find all global declarations\n\t\tfor ( const statement of ast.body ) {\n\n\t\t\tif ( statement.isFunctionDeclaration ) {\n\n\t\t\t\tthis.functions.set( statement.name, statement );\n\n\t\t\t} else if ( statement.isUniform ) {\n\n\t\t\t\tthis.uniforms.push( statement );\n\n\t\t\t} else if ( statement.isVarying ) {\n\n\t\t\t\tthis.varyings.push( statement );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 2. Build resource bindings (uniforms, textures, samplers)\n\t\tif ( this.uniforms.length > 0 ) {\n\n\t\t\tlet bindingIndex = 0;\n\t\t\tconst uniformStructMembers = [];\n\t\t\tconst textureGlobals = [];\n\n\t\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\t\t// Textures are declared as separate global variables, not in the UBO\n\t\t\t\tif ( uniform.type.includes( 'texture' ) ) {\n\n\t\t\t\t\ttextureGlobals.push( `@group(${this.groupIndex}) @binding(${bindingIndex ++}) var ${uniform.name}: ${this.getWgslType( uniform.type )};` );\n\t\t\t\t\ttextureGlobals.push( `@group(${this.groupIndex}) @binding(${bindingIndex ++}) var ${uniform.name}_sampler: sampler;` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniformStructMembers.push( `\\t${uniform.name}: ${this.getWgslType( uniform.type )},` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Create a UBO struct if there are any non-texture uniforms\n\t\t\tif ( uniformStructMembers.length > 0 ) {\n\n\t\t\t\tglobals += 'struct Uniforms {\\n';\n\t\t\t\tglobals += uniformStructMembers.join( '\\n' );\n\t\t\t\tglobals += '\\n};\\n';\n\t\t\t\tglobals += `@group(${this.groupIndex}) @binding(${bindingIndex ++}) var<uniform> uniforms: Uniforms;\\n\\n`;\n\n\t\t\t}\n\n\t\t\t// Add the texture and sampler globals\n\t\t\tglobals += textureGlobals.join( '\\n' ) + '\\n\\n';\n\n\t\t}\n\n\t\t// 3. Build varying structs for stage I/O\n\t\t// This is a simplification; a full implementation would need to know the shader stage.\n\t\tif ( this.varyings.length > 0 ) {\n\n\t\t\tglobals += 'struct Varyings {\\n';\n\t\t\tlet location = 0;\n\t\t\tfor ( const varying of this.varyings ) {\n\n\t\t\t\tglobals += `\\t@location(${location ++}) ${varying.name}: ${this.getWgslType( varying.type )},\\n`;\n\n\t\t\t}\n\n\t\t\tglobals += '};\\n\\n';\n\n\t\t}\n\n\t\t// 4. Emit all functions and other global statements\n\t\tfor ( const statement of ast.body ) {\n\n\t\t\tfunctions += this.emitExtraLine( statement, ast.body );\n\n\t\t\tif ( statement.isFunctionDeclaration ) {\n\n\t\t\t\tfunctions += this.emitFunction( statement ) + '\\n';\n\n\t\t\t} else if ( statement.isComment ) {\n\n\t\t\t\tfunctions += this.emitComment( statement, ast.body );\n\n\t\t\t} else if ( ! statement.isUniform && ! statement.isVarying ) {\n\n\t\t\t\t// Handle other top-level statements like 'const'\n\t\t\t\tfunctions += this.emitExpression( statement ) + ';\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 4. Build dependencies\n\t\tfor ( const value of this.polyfills.values() ) {\n\n\t\t\tdependencies = `${ value }\\n\\n`;\n\n\t\t}\n\n\t\treturn header + dependencies + globals + functions.trimEnd() + '\\n';\n\n\t}\n\n}\n\nexport default WGSLEncoder;\n"],"mappings":"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","ignoreList":[]}