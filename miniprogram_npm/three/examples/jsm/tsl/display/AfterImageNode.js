import{RenderTarget,Vector2,QuadMesh,NodeMaterial,RendererUtils,TempNode,NodeUpdateType}from"three/webgpu";import{nodeObject,Fn,float,uv,texture,passTexture,uniform,sign,max,convertToTexture}from"three/tsl";const _size=new Vector2,_quadMeshComp=new QuadMesh;let _rendererState;class AfterImageNode extends TempNode{static get type(){return"AfterImageNode"}constructor(e,t=.96){super("vec4"),this.textureNode=e,this.textureNodeOld=texture(null),this.damp=uniform(t),this._compRT=new RenderTarget(1,1,{depthBuffer:!1}),this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new RenderTarget(1,1,{depthBuffer:!1}),this._oldRT.texture.name="AfterImageNode.old",this._textureNode=passTexture(this,this._compRT.texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=this.textureNode,o=r.value.type;this._compRT.texture.type=o,this._oldRT.texture.type=o,t.getDrawingBufferSize(_size),this.setSize(_size.x,_size.y);const s=r.value;this.textureNodeOld.value=this._oldRT.texture,_quadMeshComp.material=this._materialComposed,t.setRenderTarget(this._compRT),_quadMeshComp.render(t);const d=this._oldRT;this._oldRT=this._compRT,this._compRT=d,r.value=s,RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=this.textureNode,r=this.textureNodeOld;r.uvNode=t.uvNode||uv();const o=Fn((()=>{const e=r.sample().toVar(),o=t.sample().toVar(),s=float(.1).toConst(),d=max(sign(e.sub(s)),0);return e.mulAssign(this.damp.mul(d)),max(o,e)})),s=this._materialComposed||(this._materialComposed=new NodeMaterial);s.name="AfterImage",s.fragmentNode=o();return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._compRT.dispose(),this._oldRT.dispose()}}export const afterImage=(e,t)=>nodeObject(new AfterImageNode(convertToTexture(e),t));export default AfterImageNode;
//# sourceMappingURL=AfterImageNode.js.map