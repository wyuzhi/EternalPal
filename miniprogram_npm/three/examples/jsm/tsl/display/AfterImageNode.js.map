{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/AfterImageNode.js","names":["RenderTarget","Vector2","QuadMesh","NodeMaterial","RendererUtils","TempNode","NodeUpdateType","nodeObject","Fn","float","uv","texture","passTexture","uniform","sign","max","convertToTexture","_size","_quadMeshComp","_rendererState","AfterImageNode","type","constructor","textureNode","damp","super","this","textureNodeOld","_compRT","depthBuffer","name","_oldRT","_textureNode","updateBeforeType","FRAME","getTextureNode","setSize","width","height","updateBefore","frame","renderer","resetRendererState","textureType","value","getDrawingBufferSize","x","y","currentTexture","material","_materialComposed","setRenderTarget","render","temp","restoreRendererState","setup","builder","uvNode","afterImg","texelOld","sample","toVar","texelNew","threshold","toConst","m","sub","mulAssign","mul","materialComposed","fragmentNode","getNodeProperties","dispose","afterImage","node"],"sources":["node_modules/three/examples/jsm/tsl/display/AfterImageNode.js"],"sourcesContent":["import { RenderTarget, Vector2, QuadMesh, NodeMaterial, RendererUtils, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, texture, passTexture, uniform, sign, max, convertToTexture } from 'three/tsl';\n\nconst _size = /*@__PURE__*/ new Vector2();\nconst _quadMeshComp = /*@__PURE__*/ new QuadMesh();\n\nlet _rendererState;\n\n/**\n * Post processing node for creating an after image effect.\n *\n * @augments TempNode\n * @three_import import { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';\n */\nclass AfterImageNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AfterImageNode';\n\n\t}\n\n\t/**\n\t * Constructs a new after image node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {number} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.\n\t */\n\tconstructor( textureNode, damp = 0.96 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The texture represents the pervious frame.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNodeOld = texture( null );\n\n\t\t/**\n\t\t * How quickly the after-image fades. A higher value means the after-image\n\t\t * persists longer, while a lower value means it fades faster. Should be in\n\t\t * the range `[0, 1]`.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.damp = uniform( damp );\n\n\t\t/**\n\t\t * The render target used for compositing the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._compRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._compRT.texture.name = 'AfterImageNode.comp';\n\n\t\t/**\n\t\t * The render target that represents the previous frame.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._oldRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._oldRT.texture.name = 'AfterImageNode.old';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._compRT.texture );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._compRT.setSize( width, height );\n\t\tthis._oldRT.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst textureType = map.type;\n\n\t\tthis._compRT.texture.type = textureType;\n\t\tthis._oldRT.texture.type = textureType;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis.setSize( _size.x, _size.y );\n\n\t\tconst currentTexture = textureNode.value;\n\n\t\tthis.textureNodeOld.value = this._oldRT.texture;\n\n\t\t// comp\n\t\t_quadMeshComp.material = this._materialComposed;\n\n\t\trenderer.setRenderTarget( this._compRT );\n\t\t_quadMeshComp.render( renderer );\n\n\t\t// Swap the textures\n\n\t\tconst temp = this._oldRT;\n\t\tthis._oldRT = this._compRT;\n\t\tthis._compRT = temp;\n\n\t\t//\n\n\t\ttextureNode.value = currentTexture;\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst textureNodeOld = this.textureNodeOld;\n\n\t\t//\n\n\t\ttextureNodeOld.uvNode = textureNode.uvNode || uv();\n\n\t\tconst afterImg = Fn( () => {\n\n\t\t\tconst texelOld = textureNodeOld.sample().toVar();\n\t\t\tconst texelNew = textureNode.sample().toVar();\n\n\t\t\tconst threshold = float( 0.1 ).toConst();\n\n\t\t\t// m acts as a mask. It's 1 if the previous pixel was \"bright enough\" (above the threshold) and 0 if it wasn't.\n\t\t\tconst m = max( sign( texelOld.sub( threshold ) ), 0.0 );\n\n\t\t\t// This is where the after-image fades:\n\t\t\t//\n\t\t\t// - If m is 0, texelOld is multiplied by 0, effectively clearing the after-image for that pixel.\n\t\t\t// - If m is 1, texelOld is multiplied by \"damp\". Since \"damp\" is between 0 and 1, this reduces the color value of\n\t\t\t// texelOld, making it darker and causing it to fade.\n\t\t\ttexelOld.mulAssign( this.damp.mul( m ) );\n\n\t\t\treturn max( texelNew, texelOld );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst materialComposed = this._materialComposed || ( this._materialComposed = new NodeMaterial() );\n\t\tmaterialComposed.name = 'AfterImage';\n\t\tmaterialComposed.fragmentNode = afterImg();\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._compRT.dispose();\n\t\tthis._oldRT.dispose();\n\n\t}\n\n}\n\n/**\n * TSL function for creating an after image node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {number} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.\n * @returns {AfterImageNode}\n */\nexport const afterImage = ( node, damp ) => nodeObject( new AfterImageNode( convertToTexture( node ), damp ) );\n\nexport default AfterImageNode;\n"],"mappings":"OAASA,aAAcC,QAASC,SAAUC,aAAcC,cAAeC,SAAUC,mBAAsB,sBAC9FC,WAAYC,GAAIC,MAAOC,GAAIC,QAASC,YAAaC,QAASC,KAAMC,IAAKC,qBAAwB,YAEtG,MAAMC,MAAsB,IAAIhB,QAC1BiB,cAA8B,IAAIhB,SAExC,IAAIiB,eAQJ,MAAMC,uBAAuBf,SAE5B,eAAWgB,GAEV,MAAO,gBAER,CAQA,WAAAC,CAAaC,EAAaC,EAAO,KAEhCC,MAAO,QAOPC,KAAKH,YAAcA,EAOnBG,KAAKC,eAAiBhB,QAAS,MAS/Be,KAAKF,KAAOX,QAASW,GAQrBE,KAAKE,QAAU,IAAI5B,aAAc,EAAG,EAAG,CAAE6B,aAAa,IACtDH,KAAKE,QAAQjB,QAAQmB,KAAO,sBAQ5BJ,KAAKK,OAAS,IAAI/B,aAAc,EAAG,EAAG,CAAE6B,aAAa,IACrDH,KAAKK,OAAOpB,QAAQmB,KAAO,qBAQ3BJ,KAAKM,aAAepB,YAAac,KAAMA,KAAKE,QAAQjB,SASpDe,KAAKO,iBAAmB3B,eAAe4B,KAExC,CAOA,cAAAC,GAEC,OAAOT,KAAKM,YAEb,CAQA,OAAAI,CAASC,EAAOC,GAEfZ,KAAKE,QAAQQ,QAASC,EAAOC,GAC7BZ,KAAKK,OAAOK,QAASC,EAAOC,EAE7B,CAOA,YAAAC,CAAcC,GAEb,MAAMC,SAAEA,GAAaD,EAErBrB,eAAiBf,cAAcsC,mBAAoBD,EAAUtB,gBAI7D,MAAMI,EAAcG,KAAKH,YAGnBoB,EAFMpB,EAAYqB,MAEAvB,KAExBK,KAAKE,QAAQjB,QAAQU,KAAOsB,EAC5BjB,KAAKK,OAAOpB,QAAQU,KAAOsB,EAE3BF,EAASI,qBAAsB5B,OAE/BS,KAAKU,QAASnB,MAAM6B,EAAG7B,MAAM8B,GAE7B,MAAMC,EAAiBzB,EAAYqB,MAEnClB,KAAKC,eAAeiB,MAAQlB,KAAKK,OAAOpB,QAGxCO,cAAc+B,SAAWvB,KAAKwB,kBAE9BT,EAASU,gBAAiBzB,KAAKE,SAC/BV,cAAckC,OAAQX,GAItB,MAAMY,EAAO3B,KAAKK,OAClBL,KAAKK,OAASL,KAAKE,QACnBF,KAAKE,QAAUyB,EAIf9B,EAAYqB,MAAQI,EAEpB5C,cAAckD,qBAAsBb,EAAUtB,eAE/C,CAQA,KAAAoC,CAAOC,GAEN,MAAMjC,EAAcG,KAAKH,YACnBI,EAAiBD,KAAKC,eAI5BA,EAAe8B,OAASlC,EAAYkC,QAAU/C,KAE9C,MAAMgD,EAAWlD,IAAI,KAEpB,MAAMmD,EAAWhC,EAAeiC,SAASC,QACnCC,EAAWvC,EAAYqC,SAASC,QAEhCE,EAAYtD,MAAO,IAAMuD,UAGzBC,EAAIlD,IAAKD,KAAM6C,EAASO,IAAKH,IAAe,GASlD,OAFAJ,EAASQ,UAAWzC,KAAKF,KAAK4C,IAAKH,IAE5BlD,IAAK+C,EAAUH,EAAU,IAM3BU,EAAmB3C,KAAKwB,oBAAuBxB,KAAKwB,kBAAoB,IAAI/C,cAClFkE,EAAiBvC,KAAO,aACxBuC,EAAiBC,aAAeZ,IAQhC,OALmBF,EAAQe,kBAAmB7C,MACnCH,YAAcA,EAIlBG,KAAKM,YAEb,CAMA,OAAAwC,GAEC9C,KAAKE,QAAQ4C,UACb9C,KAAKK,OAAOyC,SAEb,SAaM,MAAMC,WAAa,CAAEC,EAAMlD,IAAUjB,WAAY,IAAIa,eAAgBJ,iBAAkB0D,GAAQlD,mBAEvFJ","ignoreList":[]}