import{HalfFloatType,RenderTarget,Vector2,Vector3,TempNode,QuadMesh,NodeMaterial,RendererUtils,NodeUpdateType}from"three/webgpu";import{nodeObject,Fn,float,uv,passTexture,uniform,Loop,texture,luminance,smoothstep,mix,vec4,uniformArray,add,int}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2,_BlurDirectionX=new Vector2(1,0),_BlurDirectionY=new Vector2(0,1);let _rendererState;class BloomNode extends TempNode{static get type(){return"BloomNode"}constructor(e,t=1,r=0,s=0){super("vec4"),this.inputNode=e,this.strength=uniform(t),this.radius=uniform(r),this.threshold=uniform(s),this.smoothWidth=uniform(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this._nMips;e++){const t=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType});t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(t);const r=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType});r.texture.name="UnrealBloomPass.v"+e,r.texture.generateMipmaps=!1,this._renderTargetsVertical.push(r)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=texture(this._renderTargetBright.texture),this._textureNodeBlur0=texture(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=texture(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=texture(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=texture(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=texture(this._renderTargetsVertical[4].texture),this._textureOutput=passTexture(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureOutput}setSize(e,t){let r=Math.round(e/2),s=Math.round(t/2);this._renderTargetBright.setSize(r,s);for(let e=0;e<this._nMips;e++)this._renderTargetsHorizontal[e].setSize(r,s),this._renderTargetsVertical[e].setSize(r,s),this._separableBlurMaterials[e].invSize.value.set(1/r,1/s),r=Math.round(r/2),s=Math.round(s/2)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=t.getDrawingBufferSize(_size);this.setSize(r.width,r.height),t.setRenderTarget(this._renderTargetBright),_quadMesh.material=this._highPassFilterMaterial,_quadMesh.render(t);let s=this._renderTargetBright;for(let e=0;e<this._nMips;e++)_quadMesh.material=this._separableBlurMaterials[e],this._separableBlurMaterials[e].colorTexture.value=s.texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionX,t.setRenderTarget(this._renderTargetsHorizontal[e]),_quadMesh.render(t),this._separableBlurMaterials[e].colorTexture.value=this._renderTargetsHorizontal[e].texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionY,t.setRenderTarget(this._renderTargetsVertical[e]),_quadMesh.render(t),s=this._renderTargetsVertical[e];t.setRenderTarget(this._renderTargetsHorizontal[0]),_quadMesh.material=this._compositeMaterial,_quadMesh.render(t),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=Fn((()=>{const e=this.inputNode,t=luminance(e.rgb),r=smoothstep(this.threshold,this.threshold.add(this.smoothWidth),t);return mix(vec4(0),e,r)}));this._highPassFilterMaterial=this._highPassFilterMaterial||new NodeMaterial,this._highPassFilterMaterial.fragmentNode=t().context(e.getSharedContext()),this._highPassFilterMaterial.name="Bloom_highPass",this._highPassFilterMaterial.needsUpdate=!0;const r=[6,10,14,18,22];for(let t=0;t<this._nMips;t++)this._separableBlurMaterials.push(this._getSeparableBlurMaterial(e,r[t]));const s=uniformArray([1,.8,.6,.4,.2]),a=uniformArray([new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1)]),i=Fn((([e,t])=>{const r=float(1.2).sub(e);return mix(e,r,t)})).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),o=Fn((()=>{const e=i(s.element(0),this.radius).mul(vec4(a.element(0),1)).mul(this._textureNodeBlur0),t=i(s.element(1),this.radius).mul(vec4(a.element(1),1)).mul(this._textureNodeBlur1),r=i(s.element(2),this.radius).mul(vec4(a.element(2),1)).mul(this._textureNodeBlur2),o=i(s.element(3),this.radius).mul(vec4(a.element(3),1)).mul(this._textureNodeBlur3),n=i(s.element(4),this.radius).mul(vec4(a.element(4),1)).mul(this._textureNodeBlur4);return e.add(t).add(r).add(o).add(n).mul(this.strength)}));return this._compositeMaterial=this._compositeMaterial||new NodeMaterial,this._compositeMaterial.fragmentNode=o().context(e.getSharedContext()),this._compositeMaterial.name="Bloom_comp",this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let e=0;e<this._renderTargetsHorizontal.length;e++)this._renderTargetsHorizontal[e].dispose();for(let e=0;e<this._renderTargetsVertical.length;e++)this._renderTargetsVertical[e].dispose();this._renderTargetBright.dispose()}_getSeparableBlurMaterial(e,t){const r=[],s=t/3;for(let e=0;e<t;e++)r.push(.39894*Math.exp(-.5*e*e/(s*s))/s);const a=texture(null),i=uniformArray(r),o=uniform(new Vector2),n=uniform(new Vector2(.5,.5)),l=uv(),h=e=>a.sample(e),u=Fn((()=>{const e=h(l).rgb.mul(i.element(0)).toVar();return Loop({start:int(1),end:int(t),type:"int",condition:"<"},(({i:t})=>{const r=float(t),s=i.element(t),a=n.mul(o).mul(r),u=h(l.add(a)).rgb,d=h(l.sub(a)).rgb;e.addAssign(add(u,d).mul(s))})),vec4(e,1)})),d=new NodeMaterial;return d.fragmentNode=u().context(e.getSharedContext()),d.name="Bloom_separable",d.needsUpdate=!0,d.colorTexture=a,d.direction=n,d.invSize=o,d}}export const bloom=(e,t,r,s)=>nodeObject(new BloomNode(nodeObject(e),t,r,s));export default BloomNode;
//# sourceMappingURL=BloomNode.js.map