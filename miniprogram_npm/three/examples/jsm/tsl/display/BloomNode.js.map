{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/BloomNode.js","names":["HalfFloatType","RenderTarget","Vector2","Vector3","TempNode","QuadMesh","NodeMaterial","RendererUtils","NodeUpdateType","nodeObject","Fn","float","uv","passTexture","uniform","Loop","texture","luminance","smoothstep","mix","vec4","uniformArray","add","int","_quadMesh","_size","_BlurDirectionX","_BlurDirectionY","_rendererState","BloomNode","type","constructor","inputNode","strength","radius","threshold","super","this","smoothWidth","_renderTargetsHorizontal","_renderTargetsVertical","_nMips","_renderTargetBright","depthBuffer","name","generateMipmaps","i","renderTargetHorizontal","push","renderTargetVertical","_compositeMaterial","_highPassFilterMaterial","_separableBlurMaterials","_textureNodeBright","_textureNodeBlur0","_textureNodeBlur1","_textureNodeBlur2","_textureNodeBlur3","_textureNodeBlur4","_textureOutput","updateBeforeType","FRAME","getTextureNode","setSize","width","height","resx","Math","round","resy","invSize","value","set","updateBefore","frame","renderer","resetRendererState","size","getDrawingBufferSize","setRenderTarget","material","render","inputRenderTarget","colorTexture","direction","restoreRendererState","setup","builder","luminosityHighPass","texel","v","rgb","alpha","fragmentNode","context","getSharedContext","needsUpdate","kernelSizeArray","_getSeparableBlurMaterial","bloomFactors","bloomTintColors","lerpBloomFactor","factor","mirrorFactor","sub","setLayout","inputs","compositePass","color0","element","mul","color1","color2","color3","color4","dispose","length","kernelRadius","coefficients","sigma","exp","gaussianCoefficients","uvNode","sampleTexel","sample","separableBlurPass","diffuseSum","toVar","start","end","condition","x","w","uvOffset","sample1","sample2","addAssign","separableBlurMaterial","bloom","node"],"sources":["node_modules/three/examples/jsm/tsl/display/BloomNode.js"],"sourcesContent":["import { HalfFloatType, RenderTarget, Vector2, Vector3, TempNode, QuadMesh, NodeMaterial, RendererUtils, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, passTexture, uniform, Loop, texture, luminance, smoothstep, mix, vec4, uniformArray, add, int } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\n\nconst _BlurDirectionX = /*@__PURE__*/ new Vector2( 1.0, 0.0 );\nconst _BlurDirectionY = /*@__PURE__*/ new Vector2( 0.0, 1.0 );\n\nlet _rendererState;\n\n/**\n * Post processing node for creating a bloom effect.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n * const scenePassColor = scenePass.getTextureNode( 'output' );\n *\n * const bloomPass = bloom( scenePassColor );\n *\n * postProcessing.outputNode = scenePassColor.add( bloomPass );\n * ```\n * By default, the node affects the entire image. For a selective bloom,\n * use the `emissive` material property to control which objects should\n * contribute to bloom or not. This can be achieved via MRT.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n * scenePass.setMRT( mrt( {\n * \toutput,\n * \temissive\n * } ) );\n *\n * const scenePassColor = scenePass.getTextureNode( 'output' );\n * const emissivePass = scenePass.getTextureNode( 'emissive' );\n *\n * const bloomPass = bloom( emissivePass );\n * postProcessing.outputNode = scenePassColor.add( bloomPass );\n * ```\n * @augments TempNode\n * @three_import import { bloom } from 'three/addons/tsl/display/BloomNode.js';\n */\nclass BloomNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BloomNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bloom node.\n\t *\n\t * @param {Node<vec4>} inputNode - The node that represents the input of the effect.\n\t * @param {number} [strength=1] - The strength of the bloom.\n\t * @param {number} [radius=0] - The radius of the bloom.\n\t * @param {number} [threshold=0] - The luminance threshold limits which bright areas contribute to the bloom effect.\n\t */\n\tconstructor( inputNode, strength = 1, radius = 0, threshold = 0 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The node that represents the input of the effect.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.inputNode = inputNode;\n\n\t\t/**\n\t\t * The strength of the bloom.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.strength = uniform( strength );\n\n\t\t/**\n\t\t * The radius of the bloom.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.radius = uniform( radius );\n\n\t\t/**\n\t\t * The luminance threshold limits which bright areas contribute to the bloom effect.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.threshold = uniform( threshold );\n\n\t\t/**\n\t\t * Can be used to tweak the extracted luminance from the scene.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.smoothWidth = uniform( 0.01 );\n\n\t\t/**\n\t\t * An array that holds the render targets for the horizontal blur passes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<RenderTarget>}\n\t\t */\n\t\tthis._renderTargetsHorizontal = [];\n\n\t\t/**\n\t\t * An array that holds the render targets for the vertical blur passes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<RenderTarget>}\n\t\t */\n\t\tthis._renderTargetsVertical = [];\n\n\t\t/**\n\t\t * The number if blur mips.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._nMips = 5;\n\n\t\t/**\n\t\t * The render target for the luminance pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBright = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis._renderTargetBright.texture.generateMipmaps = false;\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis._renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis._renderTargetsVertical.push( renderTargetVertical );\n\n\t\t}\n\n\t\t/**\n\t\t * The material for the composite pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?NodeMaterial}\n\t\t */\n\t\tthis._compositeMaterial = null;\n\n\t\t/**\n\t\t * The material for the luminance pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?NodeMaterial}\n\t\t */\n\t\tthis._highPassFilterMaterial = null;\n\n\t\t/**\n\t\t * The materials for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<NodeMaterial>}\n\t\t */\n\t\tthis._separableBlurMaterials = [];\n\n\t\t/**\n\t\t * The result of the luminance pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBright = texture( this._renderTargetBright.texture );\n\n\t\t/**\n\t\t * The result of the first blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur0 = texture( this._renderTargetsVertical[ 0 ].texture );\n\n\t\t/**\n\t\t * The result of the second blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur1 = texture( this._renderTargetsVertical[ 1 ].texture );\n\n\t\t/**\n\t\t * The result of the third blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur2 = texture( this._renderTargetsVertical[ 2 ].texture );\n\n\t\t/**\n\t\t * The result of the fourth blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur3 = texture( this._renderTargetsVertical[ 3 ].texture );\n\n\t\t/**\n\t\t * The result of the fifth blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur4 = texture( this._renderTargetsVertical[ 4 ].texture );\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureOutput = passTexture( this, this._renderTargetsHorizontal[ 0 ].texture );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureOutput;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis._renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tthis._renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis._renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis._separableBlurMaterials[ i ].invSize.value.set( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t// 1. Extract bright areas\n\n\t\trenderer.setRenderTarget( this._renderTargetBright );\n\t\t_quadMesh.material = this._highPassFilterMaterial;\n\t\t_quadMesh.render( renderer );\n\n\t\t// 2. Blur all the mips progressively\n\n\t\tlet inputRenderTarget = this._renderTargetBright;\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\t_quadMesh.material = this._separableBlurMaterials[ i ];\n\n\t\t\tthis._separableBlurMaterials[ i ].colorTexture.value = inputRenderTarget.texture;\n\t\t\tthis._separableBlurMaterials[ i ].direction.value = _BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this._renderTargetsHorizontal[ i ] );\n\t\t\t_quadMesh.render( renderer );\n\n\t\t\tthis._separableBlurMaterials[ i ].colorTexture.value = this._renderTargetsHorizontal[ i ].texture;\n\t\t\tthis._separableBlurMaterials[ i ].direction.value = _BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this._renderTargetsVertical[ i ] );\n\t\t\t_quadMesh.render( renderer );\n\n\t\t\tinputRenderTarget = this._renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// 3. Composite all the mips\n\n\t\trenderer.setRenderTarget( this._renderTargetsHorizontal[ 0 ] );\n\t\t_quadMesh.material = this._compositeMaterial;\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\t// luminosity high pass material\n\n\t\tconst luminosityHighPass = Fn( () => {\n\n\t\t\tconst texel = this.inputNode;\n\t\t\tconst v = luminance( texel.rgb );\n\n\t\t\tconst alpha = smoothstep( this.threshold, this.threshold.add( this.smoothWidth ), v );\n\n\t\t\treturn mix( vec4( 0 ), texel, alpha );\n\n\t\t} );\n\n\t\tthis._highPassFilterMaterial = this._highPassFilterMaterial || new NodeMaterial();\n\t\tthis._highPassFilterMaterial.fragmentNode = luminosityHighPass().context( builder.getSharedContext() );\n\t\tthis._highPassFilterMaterial.name = 'Bloom_highPass';\n\t\tthis._highPassFilterMaterial.needsUpdate = true;\n\n\t\t// gaussian blur materials\n\n\t\t// These sizes have been changed to account for the altered coefficents-calculation to avoid blockiness,\n\t\t// while retaining the same blur-strength. For details see https://github.com/mrdoob/three.js/pull/31528\n\t\tconst kernelSizeArray = [ 6, 10, 14, 18, 22 ]; \n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tthis._separableBlurMaterials.push( this._getSeparableBlurMaterial( builder, kernelSizeArray[ i ] ) );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tconst bloomFactors = uniformArray( [ 1.0, 0.8, 0.6, 0.4, 0.2 ] );\n\t\tconst bloomTintColors = uniformArray( [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ] );\n\n\t\tconst lerpBloomFactor = Fn( ( [ factor, radius ] ) => {\n\n\t\t\tconst mirrorFactor = float( 1.2 ).sub( factor );\n\t\t\treturn mix( factor, mirrorFactor, radius );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'lerpBloomFactor',\n\t\t\ttype: 'float',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'factor', type: 'float' },\n\t\t\t\t{ name: 'radius', type: 'float' },\n\t\t\t]\n\t\t} );\n\n\n\t\tconst compositePass = Fn( () => {\n\n\t\t\tconst color0 = lerpBloomFactor( bloomFactors.element( 0 ), this.radius ).mul( vec4( bloomTintColors.element( 0 ), 1.0 ) ).mul( this._textureNodeBlur0 );\n\t\t\tconst color1 = lerpBloomFactor( bloomFactors.element( 1 ), this.radius ).mul( vec4( bloomTintColors.element( 1 ), 1.0 ) ).mul( this._textureNodeBlur1 );\n\t\t\tconst color2 = lerpBloomFactor( bloomFactors.element( 2 ), this.radius ).mul( vec4( bloomTintColors.element( 2 ), 1.0 ) ).mul( this._textureNodeBlur2 );\n\t\t\tconst color3 = lerpBloomFactor( bloomFactors.element( 3 ), this.radius ).mul( vec4( bloomTintColors.element( 3 ), 1.0 ) ).mul( this._textureNodeBlur3 );\n\t\t\tconst color4 = lerpBloomFactor( bloomFactors.element( 4 ), this.radius ).mul( vec4( bloomTintColors.element( 4 ), 1.0 ) ).mul( this._textureNodeBlur4 );\n\n\t\t\tconst sum = color0.add( color1 ).add( color2 ).add( color3 ).add( color4 );\n\n\t\t\treturn sum.mul( this.strength );\n\n\t\t} );\n\n\t\tthis._compositeMaterial = this._compositeMaterial || new NodeMaterial();\n\t\tthis._compositeMaterial.fragmentNode = compositePass().context( builder.getSharedContext() );\n\t\tthis._compositeMaterial.name = 'Bloom_comp';\n\t\tthis._compositeMaterial.needsUpdate = true;\n\n\t\t//\n\n\t\treturn this._textureOutput;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this._renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis._renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this._renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis._renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis._renderTargetBright.dispose();\n\n\t}\n\n\t/**\n\t * Create a separable blur material for the given kernel radius.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {number} kernelRadius - The kernel radius.\n\t * @return {NodeMaterial}\n\t */\n\t_getSeparableBlurMaterial( builder, kernelRadius ) {\n\n\t\tconst coefficients = [];\n\t\tconst sigma = kernelRadius / 3;\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\n\n\t\t}\n\n\t\t//\n\n\t\tconst colorTexture = texture( null );\n\t\tconst gaussianCoefficients = uniformArray( coefficients );\n\t\tconst invSize = uniform( new Vector2() );\n\t\tconst direction = uniform( new Vector2( 0.5, 0.5 ) );\n\n\t\tconst uvNode = uv();\n\t\tconst sampleTexel = ( uv ) => colorTexture.sample( uv );\n\n\t\tconst separableBlurPass = Fn( () => {\n\n\t\t\tconst diffuseSum = sampleTexel( uvNode ).rgb.mul( gaussianCoefficients.element( 0 ) ).toVar();\n\n\t\t\tLoop( { start: int( 1 ), end: int( kernelRadius ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = gaussianCoefficients.element( i );\n\t\t\t\tconst uvOffset = direction.mul( invSize ).mul( x );\n\t\t\t\tconst sample1 = sampleTexel( uvNode.add( uvOffset ) ).rgb;\n\t\t\t\tconst sample2 = sampleTexel( uvNode.sub( uvOffset ) ).rgb;\n\t\t\t\tdiffuseSum.addAssign( add( sample1, sample2 ).mul( w ) );\t\t\n\n\t\t\t} );\n\n\t\t\treturn vec4( diffuseSum, 1.0 );\n\n\t\t} );\n\n\t\tconst separableBlurMaterial = new NodeMaterial();\n\t\tseparableBlurMaterial.fragmentNode = separableBlurPass().context( builder.getSharedContext() );\n\t\tseparableBlurMaterial.name = 'Bloom_separable';\n\t\tseparableBlurMaterial.needsUpdate = true;\n\n\t\t// uniforms\n\t\tseparableBlurMaterial.colorTexture = colorTexture;\n\t\tseparableBlurMaterial.direction = direction;\n\t\tseparableBlurMaterial.invSize = invSize;\n\n\t\treturn separableBlurMaterial;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bloom effect.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {number} [strength=1] - The strength of the bloom.\n * @param {number} [radius=0] - The radius of the bloom.\n * @param {number} [threshold=0] - The luminance threshold limits which bright areas contribute to the bloom effect.\n * @returns {BloomNode}\n */\nexport const bloom = ( node, strength, radius, threshold ) => nodeObject( new BloomNode( nodeObject( node ), strength, radius, threshold ) );\n\nexport default BloomNode;\n"],"mappings":"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","ignoreList":[]}