{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/ChromaticAberrationNode.js","names":["Vector2","TempNode","nodeObject","Fn","uniform","convertToTexture","float","vec4","uv","NodeUpdateType","ChromaticAberrationNode","type","constructor","textureNode","strengthNode","centerNode","scaleNode","super","this","updateBeforeType","FRAME","_invSize","updateBefore","map","value","set","image","width","height","setup","uvNode","ApplyChromaticAberration","strength","center","scale","offset","sub","distance","length","redScale","add","mul","greenScale","blueScale","aberrationStrength","redUV","greenUV","blueUV","rOffset","gOffset","bOffset","finalRedUV","finalGreenUV","finalBlueUV","r","sample","g","b","a","setLayout","name","inputs","chromaticAberrationFn","chromaticAberration","node"],"sources":["node_modules/three/examples/jsm/tsl/display/ChromaticAberrationNode.js"],"sourcesContent":["import { Vector2, TempNode } from 'three/webgpu';\nimport {\n\tnodeObject,\n\tFn,\n\tuniform,\n\tconvertToTexture,\n\tfloat,\n\tvec4,\n\tuv,\n\tNodeUpdateType,\n} from 'three/tsl';\n\n/**\n * Post processing node for applying chromatic aberration effect.\n * This effect simulates the color fringing that occurs in real camera lenses\n * by separating and offsetting the red, green, and blue channels.\n *\n * @augments TempNode\n * @three_import import { chromaticAberration } from 'three/addons/tsl/display/ChromaticAberrationNode.js';\n */\nclass ChromaticAberrationNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ChromaticAberrationNode';\n\n\t}\n\n\t/**\n\t * Constructs a new chromatic aberration node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node} strengthNode - The strength of the chromatic aberration effect as a node.\n\t * @param {Node} centerNode - The center point of the effect as a node.\n\t * @param {Node} scaleNode - The scale factor for stepped scaling from center as a node.\n\t */\n\tconstructor( textureNode, strengthNode, centerNode, scaleNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {texture}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A node holding the strength of the effect.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.strengthNode = strengthNode;\n\n\t\t/**\n\t\t * A node holding the center point of the effect.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.centerNode = centerNode;\n\n\t\t/**\n\t\t * A node holding the scale factor for stepped scaling.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst ApplyChromaticAberration = Fn( ( [ uv, strength, center, scale ] ) => {\n\n\t\t\t// Calculate distance from center\n\t\t\tconst offset = uv.sub( center );\n\t\t\tconst distance = offset.length();\n\n\t\t\t// Create stepped scaling zones based on distance\n\t\t\t// Each channel gets different scaling steps\n\t\t\tconst redScale = float( 1.0 ).add( scale.mul( 0.02 ).mul( strength ) ); // Red channel scaled outward\n\t\t\tconst greenScale = float( 1.0 ); // Green stays at original scale\n\t\t\tconst blueScale = float( 1.0 ).sub( scale.mul( 0.02 ).mul( strength ) ); // Blue channel scaled inward\n\n\t\t\t// Create radial distortion based on distance from center\n\t\t\tconst aberrationStrength = strength.mul( distance );\n\n\t\t\t// Calculate scaled UV coordinates for each channel\n\t\t\tconst redUV = center.add( offset.mul( redScale ) );\n\t\t\tconst greenUV = center.add( offset.mul( greenScale ) );\n\t\t\tconst blueUV = center.add( offset.mul( blueScale ) );\n\n\t\t\t// Apply additional chromatic offset based on aberration strength\n\t\t\tconst rOffset = offset.mul( aberrationStrength ).mul( float( 0.01 ) );\n\t\t\tconst gOffset = offset.mul( aberrationStrength ).mul( float( 0.0 ) );\n\t\t\tconst bOffset = offset.mul( aberrationStrength ).mul( float( - 0.01 ) );\n\n\t\t\t// Final UV coordinates combining scale and chromatic aberration\n\t\t\tconst finalRedUV = redUV.add( rOffset );\n\t\t\tconst finalGreenUV = greenUV.add( gOffset );\n\t\t\tconst finalBlueUV = blueUV.add( bOffset );\n\n\t\t\t// Sample texture for each channel\n\t\t\tconst r = textureNode.sample( finalRedUV ).r;\n\t\t\tconst g = textureNode.sample( finalGreenUV ).g;\n\t\t\tconst b = textureNode.sample( finalBlueUV ).b;\n\n\t\t\t// Get original alpha\n\t\t\tconst a = textureNode.sample( uv ).a;\n\n\t\t\treturn vec4( r, g, b, a );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'ChromaticAberrationShader',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'uv', type: 'vec2' },\n\t\t\t\t{ name: 'strength', type: 'float' },\n\t\t\t\t{ name: 'center', type: 'vec2' },\n\t\t\t\t{ name: 'scale', type: 'float' },\n\t\t\t\t{ name: 'invSize', type: 'vec2' }\n\t\t\t]\n\t\t} );\n\n\t\tconst chromaticAberrationFn = Fn( () => {\n\n\t\t\treturn ApplyChromaticAberration(\n\t\t\t\tuvNode,\n\t\t\t\tthis.strengthNode,\n\t\t\t\tthis.centerNode,\n\t\t\t\tthis.scaleNode,\n\t\t\t\tthis._invSize\n\t\t\t);\n\n\t\t} );\n\n\t\tconst outputNode = chromaticAberrationFn();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ChromaticAberrationNode;\n\n/**\n * TSL function for creating a chromatic aberration node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node|number} [strength=1.0] - The strength of the chromatic aberration effect as a node or value.\n * @param {Node|Vector2} [center=null] - The center point of the effect as a node or value. If null, uses screen center (0.5, 0.5).\n * @param {Node|number} [scale=1.1] - The scale factor for stepped scaling from center as a node or value.\n * @returns {ChromaticAberrationNode}\n */\nexport const chromaticAberration = ( node, strength = 1.0, center = null, scale = 1.1 ) => {\n\n\treturn nodeObject(\n\t\tnew ChromaticAberrationNode(\n\t\t\tconvertToTexture( node ),\n\t\t\tnodeObject( strength ),\n\t\t\tnodeObject( center ),\n\t\t\tnodeObject( scale )\n\t\t)\n\t);\n};\n"],"mappings":"OAASA,QAASC,aAAgB,sBAEjCC,WACAC,GACAC,QACAC,iBACAC,MACAC,KACAC,GACAC,mBACM,YAUP,MAAMC,gCAAgCT,SAErC,eAAWU,GAEV,MAAO,yBAER,CAUA,WAAAC,CAAaC,EAAaC,EAAcC,EAAYC,GAEnDC,MAAO,QAOPC,KAAKL,YAAcA,EASnBK,KAAKC,iBAAmBV,eAAeW,MAOvCF,KAAKJ,aAAeA,EAOpBI,KAAKH,WAAaA,EAOlBG,KAAKF,UAAYA,EAQjBE,KAAKG,SAAWjB,QAAS,IAAIJ,QAE9B,CAOA,YAAAsB,GAEC,MAAMC,EAAML,KAAKL,YAAYW,MAC7BN,KAAKG,SAASG,MAAMC,IAAK,EAAIF,EAAIG,MAAMC,MAAO,EAAIJ,EAAIG,MAAME,OAE7D,CAQA,KAAAC,GAEC,MAAMhB,EAAcK,KAAKL,YACnBiB,EAASjB,EAAYiB,QAAUtB,KAE/BuB,EAA2B5B,IAAI,EAAIK,EAAIwB,EAAUC,EAAQC,MAG9D,MAAMC,EAAS3B,EAAG4B,IAAKH,GACjBI,EAAWF,EAAOG,SAIlBC,EAAWjC,MAAO,GAAMkC,IAAKN,EAAMO,IAAK,KAAOA,IAAKT,IACpDU,EAAapC,MAAO,GACpBqC,EAAYrC,MAAO,GAAM8B,IAAKF,EAAMO,IAAK,KAAOA,IAAKT,IAGrDY,EAAqBZ,EAASS,IAAKJ,GAGnCQ,EAAQZ,EAAOO,IAAKL,EAAOM,IAAKF,IAChCO,EAAUb,EAAOO,IAAKL,EAAOM,IAAKC,IAClCK,EAASd,EAAOO,IAAKL,EAAOM,IAAKE,IAGjCK,EAAUb,EAAOM,IAAKG,GAAqBH,IAAKnC,MAAO,MACvD2C,EAAUd,EAAOM,IAAKG,GAAqBH,IAAKnC,MAAO,IACvD4C,EAAUf,EAAOM,IAAKG,GAAqBH,IAAKnC,OAAS,MAGzD6C,EAAaN,EAAML,IAAKQ,GACxBI,EAAeN,EAAQN,IAAKS,GAC5BI,EAAcN,EAAOP,IAAKU,GAG1BI,EAAIzC,EAAY0C,OAAQJ,GAAaG,EACrCE,EAAI3C,EAAY0C,OAAQH,GAAeI,EACvCC,EAAI5C,EAAY0C,OAAQF,GAAcI,EAGtCC,EAAI7C,EAAY0C,OAAQ/C,GAAKkD,EAEnC,OAAOnD,KAAM+C,EAAGE,EAAGC,EAAGC,EAAG,IAEtBC,UAAW,CACdC,KAAM,4BACNjD,KAAM,OACNkD,OAAQ,CACP,CAAED,KAAM,KAAMjD,KAAM,QACpB,CAAEiD,KAAM,WAAYjD,KAAM,SAC1B,CAAEiD,KAAM,SAAUjD,KAAM,QACxB,CAAEiD,KAAM,QAASjD,KAAM,SACvB,CAAEiD,KAAM,UAAWjD,KAAM,WAkB3B,OAd8BR,IAAI,IAE1B4B,EACND,EACAZ,KAAKJ,aACLI,KAAKH,WACLG,KAAKF,UACLE,KAAKG,WAKYyC,EAIpB,iBAIcpD,+BAaR,MAAMqD,oBAAsB,CAAEC,EAAMhC,EAAW,EAAKC,EAAS,KAAMC,EAAQ,MAE1EhC,WACN,IAAIQ,wBACHL,iBAAkB2D,GAClB9D,WAAY8B,GACZ9B,WAAY+B,GACZ/B,WAAYgC","ignoreList":[]}