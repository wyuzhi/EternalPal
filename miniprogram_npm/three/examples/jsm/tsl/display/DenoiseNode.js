import{DataTexture,RepeatWrapping,Vector2,Vector3,TempNode}from"three/webgpu";import{texture,getNormalFromDepth,getViewPosition,convertToTexture,nodeObject,Fn,float,NodeUpdateType,uv,uniform,Loop,luminance,vec2,vec3,vec4,uniformArray,int,dot,max,pow,abs,If,textureSize,sin,cos,mat2,PI,property}from"three/tsl";import{SimplexNoise}from"../../math/SimplexNoise.js";class DenoiseNode extends TempNode{static get type(){return"DenoiseNode"}constructor(e,t,o,i){super("vec4"),this.textureNode=e,this.depthNode=t,this.normalNode=o,this.noiseNode=texture(generateDefaultNoise()),this.lumaPhi=uniform(5),this.depthPhi=uniform(5),this.normalPhi=uniform(5),this.radius=uniform(5),this.index=uniform(0),this.updateBeforeType=NodeUpdateType.FRAME,this._resolution=uniform(new Vector2),this._sampleVectors=uniformArray(generateDenoiseSamples(16,2,1)),this._cameraProjectionMatrixInverse=uniform(i.projectionMatrixInverse)}updateBefore(){const e=this.textureNode.value;this._resolution.value.set(e.image.width,e.image.height)}setup(){const e=uv(),t=e=>this.textureNode.sample(e),o=e=>this.depthNode.sample(e).x,i=e=>null!==this.normalNode?this.normalNode.sample(e).rgb.normalize():getNormalFromDepth(e,this.depthNode.value,this._cameraProjectionMatrixInverse),r=e=>this.noiseNode.sample(e),n=Fn((([e,r,n,s])=>{const a=t(s).toVar(),u=o(s).toVar(),m=i(s).toVar(),d=a.rgb,l=getViewPosition(s,u,this._cameraProjectionMatrixInverse).toVar(),h=dot(r,m).toVar(),p=pow(max(h,0),this.normalPhi).toVar(),c=abs(luminance(d).sub(luminance(e))).toVar(),x=max(float(1).sub(c.div(this.lumaPhi)),0).toVar(),f=abs(dot(n.sub(l),r)).toVar(),g=max(float(1).sub(f.div(this.depthPhi)),0),v=x.mul(g).mul(p);return vec4(d.mul(v),v)})),s=Fn((([e])=>{const s=o(e).toVar(),a=i(e).toVar(),u=t(e).toVar(),m=property("vec4");return If(s.greaterThanEqual(1).or(dot(a,a).equal(0)),(()=>{m.assign(u)})).Else((()=>{const t=vec3(u.rgb),o=getViewPosition(e,s,this._cameraProjectionMatrixInverse).toConst(),i=textureSize(this.noiseNode,0);let d=vec2(e.x,e.y.oneMinus());d=d.mul(this._resolution.div(i));const l=r(d).toVar(),h=sin(l.element(this.index.mod(4).mul(2).mul(PI))),p=cos(l.element(this.index.mod(4).mul(2).mul(PI))),c=vec2(h,p),x=mat2(c.x,c.y.negate(),c.x,c.y),f=float(1).toVar(),g=vec3(u.rgb).toVar();Loop({start:int(0),end:int(16),type:"int",condition:"<"},(({i:i})=>{const r=this._sampleVectors.element(i),s=x.mul(r.xy.mul(float(1).add(r.z.mul(this.radius.sub(1))))).div(this._resolution),u=e.add(s),m=n(t,a,o,u);g.addAssign(m.xyz),f.addAssign(m.w)})),If(f.greaterThan(float(0)),(()=>{g.divAssign(f)})),m.assign(vec4(g,u.a))})),m}));return Fn((()=>s(e)))()}}export default DenoiseNode;function generateDenoiseSamples(e,t,o){const i=[];for(let r=0;r<e;r++){const n=2*Math.PI*t*r/e,s=Math.pow(r/(e-1),o);i.push(new Vector3(Math.cos(n),Math.sin(n),s))}return i}function generateDefaultNoise(e=64){const t=new SimplexNoise,o=new Uint8Array(e*e*4);for(let i=0;i<e;i++)for(let r=0;r<e;r++){const n=i,s=r;o[4*(i*e+r)]=255*(.5*t.noise(n,s)+.5),o[4*(i*e+r)+1]=255*(.5*t.noise(n+e,s)+.5),o[4*(i*e+r)+2]=255*(.5*t.noise(n,s+e)+.5),o[4*(i*e+r)+3]=255*(.5*t.noise(n+e,s+e)+.5)}const i=new DataTexture(o,e,e);return i.wrapS=RepeatWrapping,i.wrapT=RepeatWrapping,i.needsUpdate=!0,i}export const denoise=(e,t,o,i)=>nodeObject(new DenoiseNode(convertToTexture(e),nodeObject(t),nodeObject(o),i));
//# sourceMappingURL=DenoiseNode.js.map