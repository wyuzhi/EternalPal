{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/DenoiseNode.js","names":["DataTexture","RepeatWrapping","Vector2","Vector3","TempNode","texture","getNormalFromDepth","getViewPosition","convertToTexture","nodeObject","Fn","float","NodeUpdateType","uv","uniform","Loop","luminance","vec2","vec3","vec4","uniformArray","int","dot","max","pow","abs","If","textureSize","sin","cos","mat2","PI","property","SimplexNoise","DenoiseNode","type","constructor","textureNode","depthNode","normalNode","camera","super","this","noiseNode","generateDefaultNoise","lumaPhi","depthPhi","normalPhi","radius","index","updateBeforeType","FRAME","_resolution","_sampleVectors","generateDenoiseSamples","_cameraProjectionMatrixInverse","projectionMatrixInverse","updateBefore","map","value","set","image","width","height","setup","uvNode","sampleTexture","sample","sampleDepth","x","sampleNormal","rgb","normalize","sampleNoise","denoiseSample","center","viewNormal","viewPosition","sampleUv","texel","toVar","depth","normal","neighborColor","viewPos","normalDiff","normalSimilarity","lumaDiff","sub","lumaSimilarity","div","depthDiff","depthSimilarity","w","mul","denoise","result","greaterThanEqual","or","equal","assign","Else","toConst","noiseResolution","noiseUv","y","oneMinus","noiseTexel","element","mod","noiseVec","rotationMatrix","negate","totalWeight","denoised","start","end","condition","i","sampleDir","offset","xy","add","z","sampleResult","addAssign","xyz","greaterThan","divAssign","a","output","numSamples","numRings","radiusExponent","samples","angle","Math","push","size","simplex","data","Uint8Array","j","noise","noiseTexture","wrapS","wrapT","needsUpdate","node"],"sources":["node_modules/three/examples/jsm/tsl/display/DenoiseNode.js"],"sourcesContent":["import { DataTexture, RepeatWrapping, Vector2, Vector3, TempNode } from 'three/webgpu';\nimport { texture, getNormalFromDepth, getViewPosition, convertToTexture, nodeObject, Fn, float, NodeUpdateType, uv, uniform, Loop, luminance, vec2, vec3, vec4, uniformArray, int, dot, max, pow, abs, If, textureSize, sin, cos, mat2, PI, property } from 'three/tsl';\nimport { SimplexNoise } from '../../math/SimplexNoise.js';\n\n/**\n * Post processing node for denoising data like raw screen-space ambient occlusion output.\n * Denoise can noticeably improve the quality of ambient occlusion but also add quite some\n * overhead to the post processing setup. It's best to make its usage optional (e.g. via\n * graphic settings).\n *\n * Reference: {@link https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf}.\n *\n * @augments TempNode\n * @three_import import { denoise } from 'three/addons/tsl/display/DenoiseNode.js';\n */\nclass DenoiseNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'DenoiseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new denoise node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect (e.g. AO).\n\t * @param {Node<float>} depthNode - A node that represents the scene's depth.\n\t * @param {?Node<vec3>} normalNode - A node that represents the scene's normals.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( textureNode, depthNode, normalNode, camera ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect (e.g. AO).\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * A node that represents the scene's depth.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the scene's normals. If no normals are passed to the\n\t\t * constructor (because MRT is not available), normals can be automatically\n\t\t * reconstructed from depth values in the shader.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t\t/**\n\t\t * The node represents the internal noise texture.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.noiseNode = texture( generateDefaultNoise() );\n\n\t\t/**\n\t\t * The luma Phi value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.lumaPhi = uniform( 5 );\n\n\t\t/**\n\t\t * The depth Phi value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.depthPhi = uniform( 5 );\n\n\t\t/**\n\t\t * The normal Phi value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.normalPhi = uniform( 5 );\n\n\t\t/**\n\t\t * The radius.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.radius = uniform( 5 );\n\n\t\t/**\n\t\t * The index.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.index = uniform( 0 );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The resolution of the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._resolution = uniform( new Vector2() );\n\n\t\t/**\n\t\t * An array of sample vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformArrayNode<vec3>}\n\t\t */\n\t\tthis._sampleVectors = uniformArray( generateDenoiseSamples( 16, 2, 1 ) );\n\n\t\t/**\n\t\t * Represents the inverse projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrixInverse = uniform( camera.projectionMatrixInverse );\n\n\t}\n\n\t/**\n\t * This method is used to update internal uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore() {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tthis._resolution.value.set( map.image.width, map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst uvNode = uv();\n\n\t\tconst sampleTexture = ( uv ) => this.textureNode.sample( uv );\n\t\tconst sampleDepth = ( uv ) => this.depthNode.sample( uv ).x;\n\t\tconst sampleNormal = ( uv ) => ( this.normalNode !== null ) ? this.normalNode.sample( uv ).rgb.normalize() : getNormalFromDepth( uv, this.depthNode.value, this._cameraProjectionMatrixInverse );\n\t\tconst sampleNoise = ( uv ) => this.noiseNode.sample( uv );\n\n\t\tconst denoiseSample = Fn( ( [ center, viewNormal, viewPosition, sampleUv ] ) => {\n\n\t\t\tconst texel = sampleTexture( sampleUv ).toVar();\n\t\t\tconst depth = sampleDepth( sampleUv ).toVar();\n\t\t\tconst normal = sampleNormal( sampleUv ).toVar();\n\t\t\tconst neighborColor = texel.rgb;\n\t\t\tconst viewPos = getViewPosition( sampleUv, depth, this._cameraProjectionMatrixInverse ).toVar();\n\n\t\t\tconst normalDiff = dot( viewNormal, normal ).toVar();\n\t\t\tconst normalSimilarity = pow( max( normalDiff, 0 ), this.normalPhi ).toVar();\n\t\t\tconst lumaDiff = abs( luminance( neighborColor ).sub( luminance( center ) ) ).toVar();\n\t\t\tconst lumaSimilarity = max( float( 1.0 ).sub( lumaDiff.div( this.lumaPhi ) ), 0 ).toVar();\n\t\t\tconst depthDiff = abs( dot( viewPosition.sub( viewPos ), viewNormal ) ).toVar();\n\t\t\tconst depthSimilarity = max( float( 1.0 ).sub( depthDiff.div( this.depthPhi ) ), 0 );\n\t\t\tconst w = lumaSimilarity.mul( depthSimilarity ).mul( normalSimilarity );\n\n\t\t\treturn vec4( neighborColor.mul( w ), w );\n\n\t\t} );\n\n\t\tconst denoise = Fn( ( [ uvNode ] ) => {\n\n\t\t\tconst depth = sampleDepth( uvNode ).toVar();\n\t\t\tconst viewNormal = sampleNormal( uvNode ).toVar();\n\n\t\t\tconst texel = sampleTexture( uvNode ).toVar();\n\t\t\tconst result = property( 'vec4' );\n\n\t\t\tIf( depth.greaterThanEqual( 1.0 ).or( dot( viewNormal, viewNormal ).equal( 0.0 ) ), () => {\n\n\t\t\t\tresult.assign( texel );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tconst center = vec3( texel.rgb );\n\n\t\t\t\tconst viewPosition = getViewPosition( uvNode, depth, this._cameraProjectionMatrixInverse ).toConst();\n\n\t\t\t\tconst noiseResolution = textureSize( this.noiseNode, 0 );\n\t\t\t\tlet noiseUv = vec2( uvNode.x, uvNode.y.oneMinus() );\n\t\t\t\tnoiseUv = noiseUv.mul( this._resolution.div( noiseResolution ) );\n\t\t\t\tconst noiseTexel = sampleNoise( noiseUv ).toVar();\n\n\t\t\t\tconst x = sin( noiseTexel.element( this.index.mod( 4 ).mul( 2 ).mul( PI ) ) );\n\t\t\t\tconst y = cos( noiseTexel.element( this.index.mod( 4 ).mul( 2 ).mul( PI ) ) );\n\n\t\t\t\tconst noiseVec = vec2( x, y );\n\t\t\t\tconst rotationMatrix = mat2( noiseVec.x, noiseVec.y.negate(), noiseVec.x, noiseVec.y );\n\n\t\t\t\tconst totalWeight = float( 1.0 ).toVar();\n\t\t\t\tconst denoised = vec3( texel.rgb ).toVar();\n\n\t\t\t\tLoop( { start: int( 0 ), end: int( 16 ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\t\tconst sampleDir = this._sampleVectors.element( i );\n\t\t\t\t\tconst offset = rotationMatrix.mul( sampleDir.xy.mul( float( 1.0 ).add( sampleDir.z.mul( this.radius.sub( 1 ) ) ) ) ).div( this._resolution );\n\t\t\t\t\tconst sampleUv = uvNode.add( offset );\n\n\t\t\t\t\tconst sampleResult = denoiseSample( center, viewNormal, viewPosition, sampleUv );\n\n\t\t\t\t\tdenoised.addAssign( sampleResult.xyz );\n\t\t\t\t\ttotalWeight.addAssign( sampleResult.w );\n\n\t\t\t\t} );\n\n\t\t\t\tIf( totalWeight.greaterThan( float( 0 ) ), () => {\n\n\t\t\t\t\tdenoised.divAssign( totalWeight );\n\n\t\t\t\t} );\n\n\t\t\t\tresult.assign( vec4( denoised, texel.a ) );\n\n\t\t\t} );\n\n\t\t\treturn result;\n\n\t\t}/*, { uv: 'vec2', return: 'vec4' }*/ );\n\n\t\tconst output = Fn( () => {\n\n\t\t\treturn denoise( uvNode );\n\n\t\t} );\n\n\t\tconst outputNode = output();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default DenoiseNode;\n\n/**\n * Generates denoise samples based on the given parameters.\n *\n * @param {number} numSamples - The number of samples.\n * @param {number} numRings - The number of rings.\n * @param {number} radiusExponent - The radius exponent.\n * @return {Array<Vector3>} The denoise samples.\n */\nfunction generateDenoiseSamples( numSamples, numRings, radiusExponent ) {\n\n\tconst samples = [];\n\n\tfor ( let i = 0; i < numSamples; i ++ ) {\n\n\t\tconst angle = 2 * Math.PI * numRings * i / numSamples;\n\t\tconst radius = Math.pow( i / ( numSamples - 1 ), radiusExponent );\n\t\tsamples.push( new Vector3( Math.cos( angle ), Math.sin( angle ), radius ) );\n\n\t}\n\n\treturn samples;\n\n}\n\n/**\n * Generates a default noise texture for the given size.\n *\n * @param {number} [size=64] - The texture size.\n * @return {DataTexture} The generated noise texture.\n */\nfunction generateDefaultNoise( size = 64 ) {\n\n\tconst simplex = new SimplexNoise();\n\n\tconst arraySize = size * size * 4;\n\tconst data = new Uint8Array( arraySize );\n\n\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\tconst x = i;\n\t\t\tconst y = j;\n\n\t\t\tdata[ ( i * size + j ) * 4 ] = ( simplex.noise( x, y ) * 0.5 + 0.5 ) * 255;\n\t\t\tdata[ ( i * size + j ) * 4 + 1 ] = ( simplex.noise( x + size, y ) * 0.5 + 0.5 ) * 255;\n\t\t\tdata[ ( i * size + j ) * 4 + 2 ] = ( simplex.noise( x, y + size ) * 0.5 + 0.5 ) * 255;\n\t\t\tdata[ ( i * size + j ) * 4 + 3 ] = ( simplex.noise( x + size, y + size ) * 0.5 + 0.5 ) * 255;\n\n\t\t}\n\n\t}\n\n\tconst noiseTexture = new DataTexture( data, size, size );\n\tnoiseTexture.wrapS = RepeatWrapping;\n\tnoiseTexture.wrapT = RepeatWrapping;\n\tnoiseTexture.needsUpdate = true;\n\n\treturn noiseTexture;\n\n}\n\n/**\n * TSL function for creating a denoise effect.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that represents the input of the effect (e.g. AO).\n * @param {Node<float>} depthNode - A node that represents the scene's depth.\n * @param {?Node<vec3>} normalNode - A node that represents the scene's normals.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @returns {DenoiseNode}\n */\nexport const denoise = ( node, depthNode, normalNode, camera ) => nodeObject( new DenoiseNode( convertToTexture( node ), nodeObject( depthNode ), nodeObject( normalNode ), camera ) );\n"],"mappings":"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","ignoreList":[]}