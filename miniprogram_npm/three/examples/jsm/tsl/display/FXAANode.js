import{Vector2,TempNode}from"three/webgpu";import{nodeObject,Fn,uniformArray,select,float,NodeUpdateType,uv,dot,clamp,uniform,convertToTexture,smoothstep,bool,vec2,vec3,If,Loop,max,min,Break,abs}from"three/tsl";class FXAANode extends TempNode{static get type(){return"FXAANode"}constructor(e){super("vec4"),this.textureNode=e,this.updateBeforeType=NodeUpdateType.FRAME,this._invSize=uniform(new Vector2)}updateBefore(){const e=this.textureNode.value;this._invSize.value.set(1/e.image.width,1/e.image.height)}setup(){const e=this.textureNode.bias(-100),s=e.uvNode||uv(),a=float(6),t=float(8),n=uniformArray([1,1.5,2,2,2,4]),o=float(.0312),r=float(.063),u=float(1),l=Fn((([s])=>e.sample(s))),d=Fn((([e])=>dot(l(e).rgb,vec3(.3,.59,.11)))),i=Fn((([e,s,a,t])=>{const n=s.add(e.mul(vec2(a,t)));return d(n)})),m=Fn((([e,s])=>{const m=((e,s)=>{const a=d(s),t=i(e,s,0,-1),n=i(e,s,1,0),o=i(e,s,0,1),r=i(e,s,-1,0),u=i(e,s,1,-1),l=i(e,s,-1,-1),m=i(e,s,1,1),c=i(e,s,-1,1),g=max(o,n,t,r,a),b=min(o,n,t,r,a),p=g.sub(b);return{m:a,n:t,e:n,s:o,w:r,ne:u,nw:l,se:m,sw:c,highest:g,lowest:b,contrast:p}})(s,e);If((e=>{const s=max(o,r.mul(e.highest));return e.contrast.lessThan(s)})(m),(()=>l(e)));const c=(e=>{let s=float(2).mul(e.s.add(e.e).add(e.n).add(e.w));s=s.add(e.se.add(e.sw).add(e.ne).add(e.nw)),s=s.mul(1/12),s=abs(s.sub(e.m)),s=clamp(s.div(max(e.contrast,0)),0,1);const a=smoothstep(0,1,s);return a.mul(a).mul(u)})(m),g=((e,s)=>{const a=abs(s.s.add(s.n).sub(s.m.mul(2))).mul(2).add(abs(s.se.add(s.ne).sub(s.e.mul(2))).add(abs(s.sw.add(s.nw).sub(s.w.mul(2))))),t=abs(s.e.add(s.w).sub(s.m.mul(2))).mul(2).add(abs(s.se.add(s.sw).sub(s.s.mul(2))).add(abs(s.ne.add(s.nw).sub(s.n.mul(2))))),n=a.greaterThanEqual(t),o=select(n,s.s,s.e),r=select(n,s.n,s.w),u=abs(o.sub(s.m)),l=abs(r.sub(s.m)),d=select(n,e.y,e.x).toVar(),i=float().toVar(),m=float().toVar();return If(u.lessThan(l),(()=>{d.assign(d.negate()),i.assign(r),m.assign(l)})).Else((()=>{i.assign(o),m.assign(u)})),{isHorizontal:n,pixelStep:d,oppositeLuminance:i,gradient:m}})(s,m),b=((e,s,o,r)=>{const u=r.toVar(),l=vec2().toVar();If(o.isHorizontal,(()=>{u.y.addAssign(o.pixelStep.mul(.5)),l.assign(vec2(e.x,0))})).Else((()=>{u.x.addAssign(o.pixelStep.mul(.5)),l.assign(vec2(0,e.y))}));const i=s.m.add(o.oppositeLuminance).mul(.5),m=o.gradient.mul(.25),c=u.add(l.mul(n.element(0))).toVar(),g=d(c).sub(i).toVar(),b=abs(g).greaterThanEqual(m).toVar();Loop({start:1,end:a},(({i:e})=>{If(b,(()=>{Break()})),c.addAssign(l.mul(n.element(e))),g.assign(d(c).sub(i)),b.assign(abs(g).greaterThanEqual(m))})),If(b.not(),(()=>{c.addAssign(l.mul(t))}));const p=u.sub(l.mul(n.element(0))).toVar(),f=d(p).sub(i).toVar(),h=abs(f).greaterThanEqual(m).toVar();Loop({start:1,end:a},(({i:e})=>{If(h,(()=>{Break()})),p.subAssign(l.mul(n.element(e))),f.assign(d(p).sub(i)),h.assign(abs(f).greaterThanEqual(m))})),If(h.not(),(()=>{p.subAssign(l.mul(t))}));const x=float().toVar(),v=float().toVar();If(o.isHorizontal,(()=>{x.assign(c.x.sub(r.x)),v.assign(r.x.sub(p.x))})).Else((()=>{x.assign(c.y.sub(r.y)),v.assign(r.y.sub(p.y))}));const T=float().toVar(),A=bool().toVar();If(x.lessThanEqual(v),(()=>{T.assign(x),A.assign(g.greaterThanEqual(0))})).Else((()=>{T.assign(v),A.assign(f.greaterThanEqual(0))}));const V=float().toVar();return If(A.equal(s.m.sub(i).greaterThanEqual(0)),(()=>{V.assign(0)})).Else((()=>{V.assign(float(.5).sub(T.div(x.add(v))))})),V})(s,m,g,e),p=max(c,b),f=e.toVar();return If(g.isHorizontal,(()=>{f.y.addAssign(g.pixelStep.mul(p))})).Else((()=>{f.x.addAssign(g.pixelStep.mul(p))})),l(f)})).setLayout({name:"FxaaPixelShader",type:"vec4",inputs:[{name:"uv",type:"vec2"},{name:"texSize",type:"vec2"}]});return Fn((()=>m(s,this._invSize)))()}}export default FXAANode;export const fxaa=e=>nodeObject(new FXAANode(convertToTexture(e)));
//# sourceMappingURL=FXAANode.js.map