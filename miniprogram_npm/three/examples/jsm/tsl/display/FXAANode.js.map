{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/FXAANode.js","names":["Vector2","TempNode","nodeObject","Fn","uniformArray","select","float","NodeUpdateType","uv","dot","clamp","uniform","convertToTexture","smoothstep","bool","vec2","vec3","If","Loop","max","min","Break","abs","FXAANode","type","constructor","textureNode","super","this","updateBeforeType","FRAME","_invSize","updateBefore","map","value","set","image","width","height","setup","bias","uvNode","EDGE_STEP_COUNT","EDGE_GUESS","EDGE_STEPS","_ContrastThreshold","_RelativeThreshold","_SubpixelBlending","Sample","sample","SampleLuminance","rgb","SampleLuminanceOffset","texSize","uOffset","vOffset","shiftedUv","add","mul","ApplyFXAA","luminance","m","n","e","s","w","ne","nw","se","sw","highest","lowest","contrast","sub","SampleLuminanceNeighborhood","l","threshold","lessThan","ShouldSkipPixel","pixelBlend","f","div","blendFactor","DeterminePixelBlendFactor","edge","horizontal","vertical","isHorizontal","greaterThanEqual","pLuminance","nLuminance","pGradient","nGradient","pixelStep","y","x","toVar","oppositeLuminance","gradient","assign","negate","Else","DetermineEdge","edgeBlend","uvEdge","edgeStep","addAssign","edgeLuminance","gradientThreshold","puv","element","pLuminanceDelta","pAtEnd","start","end","i","not","nuv","nLuminanceDelta","nAtEnd","subAssign","pDistance","nDistance","shortestDistance","deltaSign","lessThanEqual","equal","DetermineEdgeBlendFactor","finalBlend","finalUv","setLayout","name","inputs","fxaa","node"],"sources":["node_modules/three/examples/jsm/tsl/display/FXAANode.js"],"sourcesContent":["import { Vector2, TempNode } from 'three/webgpu';\nimport { nodeObject, Fn, uniformArray, select, float, NodeUpdateType, uv, dot, clamp, uniform, convertToTexture, smoothstep, bool, vec2, vec3, If, Loop, max, min, Break, abs } from 'three/tsl';\n\n/**\n * Post processing node for applying FXAA. This node requires sRGB input\n * so tone mapping and color space conversion must happen before the anti-aliasing.\n *\n * @augments TempNode\n * @three_import import { fxaa } from 'three/addons/tsl/display/FXAANode.js';\n */\nclass FXAANode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FXAANode';\n\n\t}\n\n\t/**\n\t * Constructs a new FXAA node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst textureNode = this.textureNode.bias( - 100 );\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst EDGE_STEP_COUNT = float( 6 );\n\t\tconst EDGE_GUESS = float( 8.0 );\n\t\tconst EDGE_STEPS = uniformArray( [ 1.0, 1.5, 2.0, 2.0, 2.0, 4.0 ] );\n\n\t\tconst _ContrastThreshold = float( 0.0312 );\n\t\tconst _RelativeThreshold = float( 0.063 );\n\t\tconst _SubpixelBlending = float( 1.0 );\n\n\t\tconst Sample = Fn( ( [ uv ] ) => {\n\n\t\t\treturn textureNode.sample( uv );\n\n\t\t} );\n\n\t\tconst SampleLuminance = Fn( ( [ uv ] ) => {\n\n\t\t\treturn dot( Sample( uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\n\n\t\t} );\n\n\t\tconst SampleLuminanceOffset = Fn( ( [ texSize, uv, uOffset, vOffset ] ) => {\n\n\t\t\tconst shiftedUv = uv.add( texSize.mul( vec2( uOffset, vOffset ) ) );\n\t\t\treturn SampleLuminance( shiftedUv );\n\n\t\t} );\n\n\t\tconst ShouldSkipPixel = ( l ) => {\n\n\t\t\tconst threshold = max( _ContrastThreshold, _RelativeThreshold.mul( l.highest ) );\n\t\t\treturn l.contrast.lessThan( threshold );\n\n\t\t};\n\n\t\tconst SampleLuminanceNeighborhood = ( texSize, uv ) => {\n\n\t\t\tconst m = SampleLuminance( uv );\n\n\t\t\tconst n = SampleLuminanceOffset( texSize, uv, 0.0, - 1.0 );\n\t\t\tconst e = SampleLuminanceOffset( texSize, uv, 1.0, 0.0 );\n\t\t\tconst s = SampleLuminanceOffset( texSize, uv, 0.0, 1.0 );\n\t\t\tconst w = SampleLuminanceOffset( texSize, uv, - 1.0, 0.0 );\n\n\t\t\tconst ne = SampleLuminanceOffset( texSize, uv, 1.0, - 1.0 );\n\t\t\tconst nw = SampleLuminanceOffset( texSize, uv, - 1.0, - 1.0 );\n\t\t\tconst se = SampleLuminanceOffset( texSize, uv, 1.0, 1.0 );\n\t\t\tconst sw = SampleLuminanceOffset( texSize, uv, - 1.0, 1.0 );\n\n\t\t\tconst highest = max( s, e, n, w, m );\n\t\t\tconst lowest = min( s, e, n, w, m );\n\t\t\tconst contrast = highest.sub( lowest );\n\n\t\t\treturn { m, n, e, s, w, ne, nw, se, sw, highest, lowest, contrast };\n\n\t\t};\n\n\t\tconst DeterminePixelBlendFactor = ( l ) => {\n\n\t\t\tlet f = float( 2.0 ).mul( l.s.add( l.e ).add( l.n ).add( l.w ) );\n\t\t\tf = f.add( l.se.add( l.sw ).add( l.ne ).add( l.nw ) );\n\t\t\tf = f.mul( 1.0 / 12.0 );\n\t\t\tf = abs( f.sub( l.m ) );\n\t\t\tf = clamp( f.div( max( l.contrast, 0 ) ), 0.0, 1.0 );\n\n\t\t\tconst blendFactor = smoothstep( 0.0, 1.0, f );\n\t\t\treturn blendFactor.mul( blendFactor ).mul( _SubpixelBlending );\n\n\t\t};\n\n\t\tconst DetermineEdge = ( texSize, l ) => {\n\n\t\t\tconst horizontal =\n\t\t\t\tabs( l.s.add( l.n ).sub( l.m.mul( 2.0 ) ) ).mul( 2.0 ).add(\n\t\t\t\t\tabs( l.se.add( l.ne ).sub( l.e.mul( 2.0 ) ) ).add(\n\t\t\t\t\t\tabs( l.sw.add( l.nw ).sub( l.w.mul( 2.0 ) ) )\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst vertical =\n\t\t\t\tabs( l.e.add( l.w ).sub( l.m.mul( 2.0 ) ) ).mul( 2.0 ).add(\n\t\t\t\t\tabs( l.se.add( l.sw ).sub( l.s.mul( 2.0 ) ) ).add(\n\t\t\t\t\t\tabs( l.ne.add( l.nw ).sub( l.n.mul( 2.0 ) ) )\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst isHorizontal = horizontal.greaterThanEqual( vertical );\n\n\t\t\tconst pLuminance = select( isHorizontal, l.s, l.e );\n\t\t\tconst nLuminance = select( isHorizontal, l.n, l.w );\n\t\t\tconst pGradient = abs( pLuminance.sub( l.m ) );\n\t\t\tconst nGradient = abs( nLuminance.sub( l.m ) );\n\n\t\t\tconst pixelStep = select( isHorizontal, texSize.y, texSize.x ).toVar();\n\t\t\tconst oppositeLuminance = float().toVar();\n\t\t\tconst gradient = float().toVar();\n\n\t\t\tIf( pGradient.lessThan( nGradient ), () => {\n\n\t\t\t\tpixelStep.assign( pixelStep.negate() );\n\t\t\t\toppositeLuminance.assign( nLuminance );\n\t\t\t\tgradient.assign( nGradient );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\toppositeLuminance.assign( pLuminance );\n\t\t\t\tgradient.assign( pGradient );\n\n\t\t\t} );\n\n\t\t\treturn { isHorizontal, pixelStep, oppositeLuminance, gradient };\n\n\t\t};\n\n\t\tconst DetermineEdgeBlendFactor = ( texSize, l, e, uv ) => {\n\n\t\t\tconst uvEdge = uv.toVar();\n\t\t\tconst edgeStep = vec2().toVar();\n\t\t\tIf( e.isHorizontal, () => {\n\n\t\t\t\tuvEdge.y.addAssign( e.pixelStep.mul( 0.5 ) );\n\t\t\t\tedgeStep.assign( vec2( texSize.x, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tuvEdge.x.addAssign( e.pixelStep.mul( 0.5 ) );\n\t\t\t\tedgeStep.assign( vec2( 0.0, texSize.y ) );\n\n\t\t\t} );\n\n\t\t\tconst edgeLuminance = l.m.add( e.oppositeLuminance ).mul( 0.5 );\n\t\t\tconst gradientThreshold = e.gradient.mul( 0.25 );\n\n\t\t\tconst puv = uvEdge.add( edgeStep.mul( EDGE_STEPS.element( 0 ) ) ).toVar();\n\t\t\tconst pLuminanceDelta = SampleLuminance( puv ).sub( edgeLuminance ).toVar();\n\t\t\tconst pAtEnd = abs( pLuminanceDelta ).greaterThanEqual( gradientThreshold ).toVar();\n\n\t\t\tLoop( { start: 1, end: EDGE_STEP_COUNT }, ( { i } ) => {\n\n\t\t\t\tIf( pAtEnd, () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\tpuv.addAssign( edgeStep.mul( EDGE_STEPS.element( i ) ) );\n\t\t\t\tpLuminanceDelta.assign( SampleLuminance( puv ).sub( edgeLuminance ) );\n\t\t\t\tpAtEnd.assign( abs( pLuminanceDelta ).greaterThanEqual( gradientThreshold ) );\n\n\t\t\t} );\n\n\t\t\tIf( pAtEnd.not(), () => {\n\n\t\t\t\tpuv.addAssign( edgeStep.mul( EDGE_GUESS ) );\n\n\t\t\t} );\n\n\t\t\tconst nuv = uvEdge.sub( edgeStep.mul( EDGE_STEPS.element( 0 ) ) ).toVar();\n\t\t\tconst nLuminanceDelta = SampleLuminance( nuv ).sub( edgeLuminance ).toVar();\n\t\t\tconst nAtEnd = abs( nLuminanceDelta ).greaterThanEqual( gradientThreshold ).toVar();\n\n\t\t\tLoop( { start: 1, end: EDGE_STEP_COUNT }, ( { i } ) => {\n\n\t\t\t\tIf( nAtEnd, () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\tnuv.subAssign( edgeStep.mul( EDGE_STEPS.element( i ) ) );\n\t\t\t\tnLuminanceDelta.assign( SampleLuminance( nuv ).sub( edgeLuminance ) );\n\t\t\t\tnAtEnd.assign( abs( nLuminanceDelta ).greaterThanEqual( gradientThreshold ) );\n\n\t\t\t} );\n\n\t\t\tIf( nAtEnd.not(), () => {\n\n\t\t\t\tnuv.subAssign( edgeStep.mul( EDGE_GUESS ) );\n\n\t\t\t} );\n\n\t\t\tconst pDistance = float().toVar();\n\t\t\tconst nDistance = float().toVar();\n\n\t\t\tIf( e.isHorizontal, () => {\n\n\t\t\t\tpDistance.assign( puv.x.sub( uv.x ) );\n\t\t\t\tnDistance.assign( uv.x.sub( nuv.x ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tpDistance.assign( puv.y.sub( uv.y ) );\n\t\t\t\tnDistance.assign( uv.y.sub( nuv.y ) );\n\n\t\t\t} );\n\n\t\t\tconst shortestDistance = float().toVar();\n\t\t\tconst deltaSign = bool().toVar();\n\n\t\t\tIf( pDistance.lessThanEqual( nDistance ), () => {\n\n\t\t\t\tshortestDistance.assign( pDistance );\n\t\t\t\tdeltaSign.assign( pLuminanceDelta.greaterThanEqual( 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tshortestDistance.assign( nDistance );\n\t\t\t\tdeltaSign.assign( nLuminanceDelta.greaterThanEqual( 0.0 ) );\n\n\t\t\t} );\n\n\t\t\tconst blendFactor = float().toVar();\n\n\t\t\tIf( deltaSign.equal( l.m.sub( edgeLuminance ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\tblendFactor.assign( 0.0 );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tblendFactor.assign( float( 0.5 ).sub( shortestDistance.div( pDistance.add( nDistance ) ) ) );\n\n\t\t\t} );\n\n\t\t\treturn blendFactor;\n\n\t\t};\n\n\t\tconst ApplyFXAA = Fn( ( [ uv, texSize ] ) => {\n\n\t\t\tconst luminance = SampleLuminanceNeighborhood( texSize, uv );\n\t\t\tIf( ShouldSkipPixel( luminance ), () => {\n\n\t\t\t\treturn Sample( uv );\n\n\t\t\t} );\n\n\t\t\tconst pixelBlend = DeterminePixelBlendFactor( luminance );\n\t\t\tconst edge = DetermineEdge( texSize, luminance );\n\t\t\tconst edgeBlend = DetermineEdgeBlendFactor( texSize, luminance, edge, uv );\n\n\t\t\tconst finalBlend = max( pixelBlend, edgeBlend );\n\t\t\tconst finalUv = uv.toVar();\n\n\t\t\tIf( edge.isHorizontal, () => {\n\n\t\t\t\tfinalUv.y.addAssign( edge.pixelStep.mul( finalBlend ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tfinalUv.x.addAssign( edge.pixelStep.mul( finalBlend ) );\n\n\t\t\t} );\n\n\t\t\treturn Sample( finalUv );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'FxaaPixelShader',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'uv', type: 'vec2' },\n\t\t\t\t{ name: 'texSize', type: 'vec2' },\n\t\t\t]\n\t\t} );\n\n\t\tconst fxaa = Fn( () => {\n\n\t\t\treturn ApplyFXAA( uvNode, this._invSize );\n\n\t\t} );\n\n\t\tconst outputNode = fxaa();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default FXAANode;\n\n/**\n * TSL function for creating a FXAA node for anti-aliasing via post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @returns {FXAANode}\n */\nexport const fxaa = ( node ) => nodeObject( new FXAANode( convertToTexture( node ) ) );\n"],"mappings":"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","ignoreList":[]}