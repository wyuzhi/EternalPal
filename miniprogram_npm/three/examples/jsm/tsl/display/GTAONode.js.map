{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/GTAONode.js","names":["DataTexture","RenderTarget","RepeatWrapping","Vector2","Vector3","TempNode","QuadMesh","NodeMaterial","RendererUtils","reference","logarithmicDepthToViewZ","viewZToPerspectiveDepth","getNormalFromDepth","getScreenPosition","getViewPosition","nodeObject","Fn","float","NodeUpdateType","uv","uniform","Loop","vec2","vec3","vec4","int","dot","max","pow","abs","If","textureSize","sin","cos","PI","texture","passTexture","mat3","add","normalize","mul","cross","div","mix","sqrt","sub","acos","clamp","_quadMesh","_size","_rendererState","GTAONode","type","constructor","depthNode","normalNode","camera","super","this","resolutionScale","updateBeforeType","FRAME","_aoRenderTarget","depthBuffer","name","radius","resolution","thickness","distanceExponent","distanceFallOff","scale","samples","_noiseNode","generateMagicSquareNoise","_cameraProjectionMatrix","projectionMatrix","_cameraProjectionMatrixInverse","projectionMatrixInverse","_cameraNear","_cameraFar","_material","_textureNode","getTextureNode","setSize","width","height","Math","round","value","set","updateBefore","frame","renderer","resetRendererState","size","getDrawingBufferSize","material","setClearColor","setRenderTarget","render","restoreRendererState","setup","builder","uvNode","sampleDepth","depth","sample","r","logarithmicDepthBuffer","viewZ","sampleNoise","sampleNormal","rgb","ao","toVar","greaterThanEqual","discard","viewPosition","viewNormal","radiusToUse","noiseResolution","noiseUv","x","y","oneMinus","noiseTexel","randomVec","xyz","tangent","xy","bitangent","kernelMatrix","DIRECTIONS","lessThan","select","STEPS","start","end","condition","i","angle","sampleDir","w","viewDir","negate","sliceBitangent","sliceTangent","normalInSlice","tangentToNormalInSlice","cosHorizons","j","sampleViewOffset","sampleScreenPositionX","sampleDepthX","viewDeltaX","z","sampleCosHorizon","addAssign","sampleScreenPositionY","sampleDepthY","viewDeltaY","sinHorizons","nx","ny","nxb","nyb","occlusion","assign","fragmentNode","context","getSharedContext","needsUpdate","dispose","noiseSize","floor","magicSquare","generateMagicSquare","noiseSquareSize","length","data","Uint8Array","inx","iAng","noiseTexture","wrapS","wrapT","Array","fill","num"],"sources":["node_modules/three/examples/jsm/tsl/display/GTAONode.js"],"sourcesContent":["import { DataTexture, RenderTarget, RepeatWrapping, Vector2, Vector3, TempNode, QuadMesh, NodeMaterial, RendererUtils } from 'three/webgpu';\nimport { reference, logarithmicDepthToViewZ, viewZToPerspectiveDepth, getNormalFromDepth, getScreenPosition, getViewPosition, nodeObject, Fn, float, NodeUpdateType, uv, uniform, Loop, vec2, vec3, vec4, int, dot, max, pow, abs, If, textureSize, sin, cos, PI, texture, passTexture, mat3, add, normalize, mul, cross, div, mix, sqrt, sub, acos, clamp } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n/**\n * Post processing node for applying Ground Truth Ambient Occlusion (GTAO) to a scene.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n * scenePass.setMRT( mrt( {\n * \toutput: output,\n * \tnormal: normalView\n * } ) );\n *\n * const scenePassColor = scenePass.getTextureNode( 'output' );\n * const scenePassNormal = scenePass.getTextureNode( 'normal' );\n * const scenePassDepth = scenePass.getTextureNode( 'depth' );\n *\n * const aoPass = ao( scenePassDepth, scenePassNormal, camera );\n *\n * postProcessing.outputNod = aoPass.getTextureNode().mul( scenePassColor );\n * ```\n *\n * Reference: {@link https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf}.\n *\n * @augments TempNode\n * @three_import import { ao } from 'three/addons/tsl/display/GTAONode.js';\n */\nclass GTAONode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'GTAONode';\n\n\t}\n\n\t/**\n\t * Constructs a new GTAO node.\n\t *\n\t * @param {Node<float>} depthNode - A node that represents the scene's depth.\n\t * @param {?Node<vec3>} normalNode - A node that represents the scene's normals.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( depthNode, normalNode, camera ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * A node that represents the scene's depth.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the scene's normals. If no normals are passed to the\n\t\t * constructor (because MRT is not available), normals can be automatically\n\t\t * reconstructed from depth values in the shader.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t\t/**\n\t\t * The resolution scale. By default the effect is rendered in full resolution\n\t\t * for best quality but a value of `0.5` should be sufficient for most scenes.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.resolutionScale = 1;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The render target the ambient occlusion is rendered into.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._aoRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._aoRenderTarget.texture.name = 'GTAONode.AO';\n\n\t\t// uniforms\n\n\t\t/**\n\t\t * The radius of the ambient occlusion.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.radius = uniform( 0.25 );\n\n\t\t/**\n\t\t * The resolution of the effect. Can be scaled via\n\t\t * `resolutionScale`.\n\t\t *\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis.resolution = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The thickness of the ambient occlusion.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.thickness = uniform( 1 );\n\n\t\t/**\n\t\t * Another option to tweak the occlusion. The recommended range is\n\t\t * `[1,2]` for attenuating the AO.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.distanceExponent = uniform( 1 );\n\n\t\t/**\n\t\t * The distance fall off value of the ambient occlusion.\n\t\t * A lower value leads to a larger AO effect. The value\n\t\t * should lie in the range `[0,1]`.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.distanceFallOff = uniform( 1 );\n\n\t\t/**\n\t\t * The scale of the ambient occlusion.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.scale = uniform( 1 );\n\n\t\t/**\n\t\t * How many samples are used to compute the AO.\n\t\t * A higher value results in better quality but also\n\t\t * in a more expensive runtime behavior.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.samples = uniform( 16 );\n\n\t\t/**\n\t\t * The node represents the internal noise texture used by the AO.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._noiseNode = texture( generateMagicSquareNoise() );\n\n\t\t/**\n\t\t * Represents the projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrix = uniform( camera.projectionMatrix );\n\n\t\t/**\n\t\t * Represents the inverse projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrixInverse = uniform( camera.projectionMatrixInverse );\n\n\t\t/**\n\t\t * Represents the near value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\n\n\t\t/**\n\t\t * Represents the far value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\n\n\t\t/**\n\t\t * The material that is used to render the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._material = new NodeMaterial();\n\t\tthis._material.name = 'GTAO';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._aoRenderTarget.texture );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\twidth = Math.round( this.resolutionScale * width );\n\t\theight = Math.round( this.resolutionScale * height );\n\n\t\tthis.resolution.value.set( width, height );\n\t\tthis._aoRenderTarget.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t_quadMesh.material = this._material;\n\n\t\t// clear\n\n\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t// ao\n\n\t\trenderer.setRenderTarget( this._aoRenderTarget );\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst uvNode = uv();\n\n\t\tconst sampleDepth = ( uv ) => {\n\n\t\t\tconst depth = this.depthNode.sample( uv ).r;\n\n\t\t\tif ( builder.renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tconst viewZ = logarithmicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t\treturn viewZToPerspectiveDepth( viewZ, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\treturn depth;\n\n\t\t};\n\n\t\tconst sampleNoise = ( uv ) => this._noiseNode.sample( uv );\n\t\tconst sampleNormal = ( uv ) => ( this.normalNode !== null ) ? this.normalNode.sample( uv ).rgb.normalize() : getNormalFromDepth( uv, this.depthNode.value, this._cameraProjectionMatrixInverse );\n\n\t\tconst ao = Fn( () => {\n\n\t\t\tconst depth = sampleDepth( uvNode ).toVar();\n\n\t\t\tdepth.greaterThanEqual( 1.0 ).discard();\n\n\t\t\tconst viewPosition = getViewPosition( uvNode, depth, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\tconst viewNormal = sampleNormal( uvNode ).toVar();\n\n\t\t\tconst radiusToUse = this.radius;\n\n\t\t\tconst noiseResolution = textureSize( this._noiseNode, 0 );\n\t\t\tlet noiseUv = vec2( uvNode.x, uvNode.y.oneMinus() );\n\t\t\tnoiseUv = noiseUv.mul( this.resolution.div( noiseResolution ) );\n\t\t\tconst noiseTexel = sampleNoise( noiseUv );\n\t\t\tconst randomVec = noiseTexel.xyz.mul( 2.0 ).sub( 1.0 );\n\t\t\tconst tangent = vec3( randomVec.xy, 0.0 ).normalize();\n\t\t\tconst bitangent = vec3( tangent.y.mul( - 1.0 ), tangent.x, 0.0 );\n\t\t\tconst kernelMatrix = mat3( tangent, bitangent, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\tconst DIRECTIONS = this.samples.lessThan( 30 ).select( 3, 5 ).toVar();\n\t\t\tconst STEPS = add( this.samples, DIRECTIONS.sub( 1 ) ).div( DIRECTIONS ).toVar();\n\n\t\t\tconst ao = float( 0 ).toVar();\n\n\t\t\tLoop( { start: int( 0 ), end: DIRECTIONS, type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\tconst angle = float( i ).div( float( DIRECTIONS ) ).mul( PI ).toVar();\n\t\t\t\tconst sampleDir = vec4( cos( angle ), sin( angle ), 0., add( 0.5, mul( 0.5, noiseTexel.w ) ) );\n\t\t\t\tsampleDir.xyz = normalize( kernelMatrix.mul( sampleDir.xyz ) );\n\n\t\t\t\tconst viewDir = normalize( viewPosition.xyz.negate() ).toVar();\n\t\t\t\tconst sliceBitangent = normalize( cross( sampleDir.xyz, viewDir ) ).toVar();\n\t\t\t\tconst sliceTangent = cross( sliceBitangent, viewDir );\n\t\t\t\tconst normalInSlice = normalize( viewNormal.sub( sliceBitangent.mul( dot( viewNormal, sliceBitangent ) ) ) );\n\n\t\t\t\tconst tangentToNormalInSlice = cross( normalInSlice, sliceBitangent ).toVar();\n\t\t\t\tconst cosHorizons = vec2( dot( viewDir, tangentToNormalInSlice ), dot( viewDir, tangentToNormalInSlice.negate() ) ).toVar();\n\n\t\t\t\tLoop( { end: STEPS, type: 'int', name: 'j', condition: '<' }, ( { j } ) => {\n\n\t\t\t\t\tconst sampleViewOffset = sampleDir.xyz.mul( radiusToUse ).mul( sampleDir.w ).mul( pow( div( float( j ).add( 1.0 ), float( STEPS ) ), this.distanceExponent ) );\n\n\t\t\t\t\t// x\n\n\t\t\t\t\tconst sampleScreenPositionX = getScreenPosition( viewPosition.add( sampleViewOffset ), this._cameraProjectionMatrix ).toVar();\n\t\t\t\t\tconst sampleDepthX = sampleDepth( sampleScreenPositionX ).toVar();\n\t\t\t\t\tconst sampleSceneViewPositionX = getViewPosition( sampleScreenPositionX, sampleDepthX, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\t\t\tconst viewDeltaX = sampleSceneViewPositionX.sub( viewPosition ).toVar();\n\n\t\t\t\t\tIf( abs( viewDeltaX.z ).lessThan( this.thickness ), () => {\n\n\t\t\t\t\t\tconst sampleCosHorizon = dot( viewDir, normalize( viewDeltaX ) );\n\t\t\t\t\t\tcosHorizons.x.addAssign( max( 0, mul( sampleCosHorizon.sub( cosHorizons.x ), mix( 1.0, float( 2.0 ).div( float( j ).add( 2 ) ), this.distanceFallOff ) ) ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// y\n\n\t\t\t\t\tconst sampleScreenPositionY = getScreenPosition( viewPosition.sub( sampleViewOffset ), this._cameraProjectionMatrix ).toVar();\n\t\t\t\t\tconst sampleDepthY = sampleDepth( sampleScreenPositionY ).toVar();\n\t\t\t\t\tconst sampleSceneViewPositionY = getViewPosition( sampleScreenPositionY, sampleDepthY, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\t\t\tconst viewDeltaY = sampleSceneViewPositionY.sub( viewPosition ).toVar();\n\n\t\t\t\t\tIf( abs( viewDeltaY.z ).lessThan( this.thickness ), () => {\n\n\t\t\t\t\t\tconst sampleCosHorizon = dot( viewDir, normalize( viewDeltaY ) );\n\t\t\t\t\t\tcosHorizons.y.addAssign( max( 0, mul( sampleCosHorizon.sub( cosHorizons.y ), mix( 1.0, float( 2.0 ).div( float( j ).add( 2 ) ), this.distanceFallOff ) ) ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t\tconst sinHorizons = sqrt( sub( 1.0, cosHorizons.mul( cosHorizons ) ) ).toVar();\n\t\t\t\tconst nx = dot( normalInSlice, sliceTangent );\n\t\t\t\tconst ny = dot( normalInSlice, viewDir );\n\t\t\t\tconst nxb = mul( 0.5, acos( cosHorizons.y ).sub( acos( cosHorizons.x ) ).add( sinHorizons.x.mul( cosHorizons.x ).sub( sinHorizons.y.mul( cosHorizons.y ) ) ) );\n\t\t\t\tconst nyb = mul( 0.5, sub( 2.0, cosHorizons.x.mul( cosHorizons.x ) ).sub( cosHorizons.y.mul( cosHorizons.y ) ) );\n\t\t\t\tconst occlusion = nx.mul( nxb ).add( ny.mul( nyb ) );\n\t\t\t\tao.addAssign( occlusion );\n\n\t\t\t} );\n\n\t\t\tao.assign( clamp( ao.div( DIRECTIONS ), 0, 1 ) );\n\t\t\tao.assign( pow( ao, this.scale ) );\n\n\t\t\treturn vec4( vec3( ao ), 1.0 );\n\n\t\t} );\n\n\t\tthis._material.fragmentNode = ao().context( builder.getSharedContext() );\n\t\tthis._material.needsUpdate = true;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._aoRenderTarget.dispose();\n\n\t\tthis._material.dispose();\n\n\t}\n\n}\n\nexport default GTAONode;\n\n/**\n * Generates the AO's noise texture for the given size.\n *\n * @param {number} [size=5] - The noise size.\n * @return {DataTexture} The generated noise texture.\n */\nfunction generateMagicSquareNoise( size = 5 ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst magicSquare = generateMagicSquare( noiseSize );\n\tconst noiseSquareSize = magicSquare.length;\n\tconst data = new Uint8Array( noiseSquareSize * 4 );\n\n\tfor ( let inx = 0; inx < noiseSquareSize; ++ inx ) {\n\n\t\tconst iAng = magicSquare[ inx ];\n\t\tconst angle = ( 2 * Math.PI * iAng ) / noiseSquareSize;\n\t\tconst randomVec = new Vector3(\n\t\t\tMath.cos( angle ),\n\t\t\tMath.sin( angle ),\n\t\t\t0\n\t\t).normalize();\n\t\tdata[ inx * 4 ] = ( randomVec.x * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 1 ] = ( randomVec.y * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 2 ] = 127;\n\t\tdata[ inx * 4 + 3 ] = 255;\n\n\t}\n\n\tconst noiseTexture = new DataTexture( data, noiseSize, noiseSize );\n\tnoiseTexture.wrapS = RepeatWrapping;\n\tnoiseTexture.wrapT = RepeatWrapping;\n\tnoiseTexture.needsUpdate = true;\n\n\treturn noiseTexture;\n\n}\n\n/**\n * Computes an array of magic square values required to generate the noise texture.\n *\n * @param {number} size - The noise size.\n * @return {Array<number>} The magic square values.\n */\nfunction generateMagicSquare( size ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst noiseSquareSize = noiseSize * noiseSize;\n\tconst magicSquare = Array( noiseSquareSize ).fill( 0 );\n\tlet i = Math.floor( noiseSize / 2 );\n\tlet j = noiseSize - 1;\n\n\tfor ( let num = 1; num <= noiseSquareSize; ) {\n\n\t\tif ( i === - 1 && j === noiseSize ) {\n\n\t\t\tj = noiseSize - 2;\n\t\t\ti = 0;\n\n\t\t} else {\n\n\t\t\tif ( j === noiseSize ) {\n\n\t\t\t\tj = 0;\n\n\t\t\t}\n\n\t\t\tif ( i < 0 ) {\n\n\t\t\t\ti = noiseSize - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( magicSquare[ i * noiseSize + j ] !== 0 ) {\n\n\t\t\tj -= 2;\n\t\t\ti ++;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\tmagicSquare[ i * noiseSize + j ] = num ++;\n\n\t\t}\n\n\t\tj ++;\n\t\ti --;\n\n\t}\n\n\treturn magicSquare;\n\n}\n\n/**\n * TSL function for creating a Ground Truth Ambient Occlusion (GTAO) effect.\n *\n * @tsl\n * @function\n * @param {Node<float>} depthNode - A node that represents the scene's depth.\n * @param {?Node<vec3>} normalNode - A node that represents the scene's normals.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @returns {GTAONode}\n */\nexport const ao = ( depthNode, normalNode, camera ) => nodeObject( new GTAONode( nodeObject( depthNode ), nodeObject( normalNode ), camera ) );\n"],"mappings":"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","ignoreList":[]}