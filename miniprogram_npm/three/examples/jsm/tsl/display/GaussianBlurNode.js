import{RenderTarget,Vector2,NodeMaterial,RendererUtils,QuadMesh,TempNode,NodeUpdateType}from"three/webgpu";import{nodeObject,Fn,float,uv,uniform,convertToTexture,vec2,vec4,passTexture,premultiplyAlpha,unpremultiplyAlpha}from"three/tsl";const _quadMesh=new QuadMesh;let _rendererState;class GaussianBlurNode extends TempNode{static get type(){return"GaussianBlurNode"}constructor(e,t=null,r=4){super("vec4"),this.textureNode=e,this.directionNode=t,this.sigma=r,this._invSize=uniform(new Vector2),this._passDirection=uniform(new Vector2),this._horizontalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=passTexture(this,this._verticalRT.texture),this._textureNode.uvNode=e.uvNode,this.updateBeforeType=NodeUpdateType.FRAME,this.resolution=new Vector2(1,1),this.premultipliedAlpha=!1}setPremultipliedAlpha(e){return this.premultipliedAlpha=e,this}getPremultipliedAlpha(){return this.premultipliedAlpha}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=this.textureNode,i=r.value,s=r.value;_quadMesh.material=this._material,this.setSize(i.image.width,i.image.height);const a=i.type;this._horizontalRT.texture.type=a,this._verticalRT.texture.type=a,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),_quadMesh.render(t),r.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),_quadMesh.render(t),r.value=s,RendererUtils.restoreRendererState(t,_rendererState)}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode,r=uv(),i=vec2(this.directionNode||1);let s,a;this.premultipliedAlpha?(s=e=>premultiplyAlpha(t.sample(e)),a=e=>unpremultiplyAlpha(e)):(s=e=>t.sample(e),a=e=>e);const o=Fn((()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),o=this._invSize,u=i.mul(this._passDirection),n=vec4(s(r).mul(t[0])).toVar();for(let i=1;i<e;i++){const e=float(i),a=float(t[i]),l=vec2(u.mul(o.mul(e))).toVar(),d=s(r.add(l)),h=s(r.sub(l));n.addAssign(d.add(h).mul(a))}return a(n)})),u=this._material||(this._material=new NodeMaterial);u.fragmentNode=o().context(e.getSharedContext()),u.name="Gaussian_blur",u.needsUpdate=!0;return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._horizontalRT.dispose(),this._verticalRT.dispose()}_getCoefficients(e){const t=[],r=e/3;for(let i=0;i<e;i++)t.push(.39894*Math.exp(-.5*i*i/(r*r))/r);return t}}export default GaussianBlurNode;export const gaussianBlur=(e,t,r)=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r));export const premultipliedGaussianBlur=(e,t,r)=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r).setPremultipliedAlpha(!0));
//# sourceMappingURL=GaussianBlurNode.js.map