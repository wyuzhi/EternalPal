{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/GaussianBlurNode.js","names":["RenderTarget","Vector2","NodeMaterial","RendererUtils","QuadMesh","TempNode","NodeUpdateType","nodeObject","Fn","float","uv","uniform","convertToTexture","vec2","vec4","passTexture","premultiplyAlpha","unpremultiplyAlpha","_quadMesh","_rendererState","GaussianBlurNode","type","constructor","textureNode","directionNode","sigma","super","this","_invSize","_passDirection","_horizontalRT","depthBuffer","texture","name","_verticalRT","_textureNode","uvNode","updateBeforeType","FRAME","resolution","premultipliedAlpha","setPremultipliedAlpha","value","getPremultipliedAlpha","setSize","width","height","Math","max","round","x","y","set","updateBefore","frame","renderer","resetRendererState","map","currentTexture","material","_material","image","textureType","setRenderTarget","render","restoreRendererState","getTextureNode","setup","builder","sampleTexture","output","sample","color","blur","kernelSize","gaussianCoefficients","_getCoefficients","invSize","direction","mul","diffuseSum","toVar","i","w","uvOffset","sample1","add","sample2","sub","addAssign","fragmentNode","context","getSharedContext","needsUpdate","getNodeProperties","dispose","kernelRadius","coefficients","push","exp","gaussianBlur","node","premultipliedGaussianBlur"],"sources":["node_modules/three/examples/jsm/tsl/display/GaussianBlurNode.js"],"sourcesContent":["import { RenderTarget, Vector2, NodeMaterial, RendererUtils, QuadMesh, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, uniform, convertToTexture, vec2, vec4, passTexture, premultiplyAlpha, unpremultiplyAlpha } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\nlet _rendererState;\n\n/**\n * Post processing node for creating a gaussian blur effect.\n *\n * @augments TempNode\n * @three_import import { gaussianBlur, premultipliedGaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';\n */\nclass GaussianBlurNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'GaussianBlurNode';\n\n\t}\n\n\t/**\n\t * Constructs a new gaussian blur node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n\t * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n\t */\n\tconstructor( textureNode, directionNode = null, sigma = 4 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Defines the direction and radius of the blur.\n\t\t *\n\t\t * @type {Node<vec2|float>}\n\t\t */\n\t\tthis.directionNode = directionNode;\n\n\t\t/**\n\t\t * Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.sigma = sigma;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\t/**\n\t\t * Gaussian blur is applied in two passes (horizontal, vertical).\n\t\t * This node controls the direction of each pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._passDirection = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The render target used for the horizontal pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._horizontalRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n\n\t\t/**\n\t\t * The render target used for the vertical pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._verticalRT = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._verticalRT.texture );\n\t\tthis._textureNode.uvNode = textureNode.uvNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Controls the resolution of the effect.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (1,1)\n\t\t */\n\t\tthis.resolution = new Vector2( 1, 1 );\n\n\t\t/**\n\t\t * Whether the effect should use premultiplied alpha or not. Set this to `true`\n\t\t * if you are going to blur texture input with transparency.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.premultipliedAlpha = false;\n\n\t}\n\n\t/**\n\t * Sets the given premultiplied alpha value.\n\t *\n\t * @param {boolean} value - Whether the effect should use premultiplied alpha or not.\n\t * @return {GaussianBlurNode} height - A reference to this node.\n\t */\n\tsetPremultipliedAlpha( value ) {\n\n\t\tthis.premultipliedAlpha = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the premultiplied alpha value.\n\t *\n\t * @return {boolean} Whether the effect should use premultiplied alpha or not.\n\t */\n\tgetPremultipliedAlpha() {\n\n\t\treturn this.premultipliedAlpha;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\twidth = Math.max( Math.round( width * this.resolution.x ), 1 );\n\t\theight = Math.max( Math.round( height * this.resolution.y ), 1 );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\t\tthis._horizontalRT.setSize( width, height );\n\t\tthis._verticalRT.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst currentTexture = textureNode.value;\n\n\t\t_quadMesh.material = this._material;\n\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\tconst textureType = map.type;\n\n\t\tthis._horizontalRT.texture.type = textureType;\n\t\tthis._verticalRT.texture.type = textureType;\n\n\t\t// horizontal\n\n\t\trenderer.setRenderTarget( this._horizontalRT );\n\n\t\tthis._passDirection.value.set( 1, 0 );\n\n\t\t_quadMesh.render( renderer );\n\n\t\t// vertical\n\n\t\ttextureNode.value = this._horizontalRT.texture;\n\t\trenderer.setRenderTarget( this._verticalRT );\n\n\t\tthis._passDirection.value.set( 0, 1 );\n\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\ttextureNode.value = currentTexture;\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\n\t\t//\n\n\t\tconst uvNode = uv();\n\t\tconst directionNode = vec2( this.directionNode || 1 );\n\n\t\tlet sampleTexture, output;\n\n\t\tif ( this.premultipliedAlpha ) {\n\n\t\t\t// https://lisyarus.github.io/blog/posts/blur-coefficients-generator.html\n\n\t\t\tsampleTexture = ( uv ) => premultiplyAlpha( textureNode.sample( uv ) );\n\t\t\toutput = ( color ) => unpremultiplyAlpha( color );\n\n\t\t} else {\n\n\t\t\tsampleTexture = ( uv ) => textureNode.sample( uv );\n\t\t\toutput = ( color ) => color;\n\n\t\t}\n\n\t\tconst blur = Fn( () => {\n\n\t\t\tconst kernelSize = 3 + ( 2 * this.sigma );\n\t\t\tconst gaussianCoefficients = this._getCoefficients( kernelSize );\n\n\t\t\tconst invSize = this._invSize;\n\t\t\tconst direction = directionNode.mul( this._passDirection );\n\n\t\t\tconst diffuseSum = vec4( sampleTexture( uvNode ).mul( gaussianCoefficients[ 0 ] ) ).toVar();\n\n\t\t\tfor ( let i = 1; i < kernelSize; i ++ ) {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = float( gaussianCoefficients[ i ] );\n\n\t\t\t\tconst uvOffset = vec2( direction.mul( invSize.mul( x ) ) ).toVar();\n\n\t\t\t\tconst sample1 = sampleTexture( uvNode.add( uvOffset ) );\n\t\t\t\tconst sample2 = sampleTexture( uvNode.sub( uvOffset ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\t\t\t}\n\n\t\t\treturn output( diffuseSum );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst material = this._material || ( this._material = new NodeMaterial() );\n\t\tmaterial.fragmentNode = blur().context( builder.getSharedContext() );\n\t\tmaterial.name = 'Gaussian_blur';\n\t\tmaterial.needsUpdate = true;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._horizontalRT.dispose();\n\t\tthis._verticalRT.dispose();\n\n\t}\n\n\t/**\n\t * Computes gaussian coefficients depending on the given kernel radius.\n\t *\n\t * @private\n\t * @param {number} kernelRadius - The kernel radius.\n\t * @return {Array<number>}\n\t */\n\t_getCoefficients( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\t\tconst sigma = kernelRadius / 3;\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\n\n\t\t}\n\n\t\treturn coefficients;\n\n\t}\n\n}\n\nexport default GaussianBlurNode;\n\n/**\n * TSL function for creating a gaussian blur node for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n * @returns {GaussianBlurNode}\n */\nexport const gaussianBlur = ( node, directionNode, sigma ) => nodeObject( new GaussianBlurNode( convertToTexture( node ), directionNode, sigma ) );\n\n/**\n * TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {Node<vec2|float>} directionNode - Defines the direction and radius of the blur.\n * @param {number} sigma - Controls the kernel of the blur filter. Higher values mean a wider blur radius.\n * @returns {GaussianBlurNode}\n */\nexport const premultipliedGaussianBlur = ( node, directionNode, sigma ) => nodeObject( new GaussianBlurNode( convertToTexture( node ), directionNode, sigma ).setPremultipliedAlpha( true ) );\n"],"mappings":"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","ignoreList":[]}