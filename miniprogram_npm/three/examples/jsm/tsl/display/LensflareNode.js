import{RenderTarget,Vector2,TempNode,NodeUpdateType,QuadMesh,RendererUtils,NodeMaterial}from"three/webgpu";import{convertToTexture,nodeObject,Fn,passTexture,uv,vec2,vec3,vec4,max,float,sub,int,Loop,fract,pow,distance}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class LensflareNode extends TempNode{static get type(){return"LensflareNode"}constructor(e,t={}){super("vec4"),this.textureNode=e;const{ghostTint:r=vec3(1,1,1),threshold:o=float(.5),ghostSamples:s=float(4),ghostSpacing:a=float(.25),ghostAttenuationFactor:n=float(25),downSampleRatio:d=4}=t;this.ghostTintNode=nodeObject(r),this.thresholdNode=nodeObject(o),this.ghostSamplesNode=nodeObject(s),this.ghostSpacingNode=nodeObject(a),this.ghostAttenuationFactorNode=nodeObject(n),this.downSampleRatio=d,this.updateBeforeType=NodeUpdateType.FRAME,this._renderTarget=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTarget.texture.name="LensflareNode",this._material=new NodeMaterial,this._material.name="LensflareNode",this._textureNode=passTexture(this,this._renderTarget.texture)}getTextureNode(){return this._textureNode}setSize(e,t){const r=Math.round(e/this.downSampleRatio),o=Math.round(t/this.downSampleRatio);this._renderTarget.setSize(r,o)}updateBefore(e){const{renderer:t}=e,r=t.getDrawingBufferSize(_size);this.setSize(r.width,r.height),_rendererState=RendererUtils.resetRendererState(t,_rendererState),_quadMesh.material=this._material,t.setMRT(null),t.setRenderTarget(this._renderTarget),_quadMesh.render(t),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=Fn((()=>{const e=uv().oneMinus().toVar(),t=sub(vec2(.5),e).mul(this.ghostSpacingNode).toVar(),r=vec4().toVar();return Loop({start:int(0),end:int(this.ghostSamplesNode),type:"int",condition:"<"},(({i:o})=>{const s=fract(e.add(t.mul(float(o)))).toVar(),a=distance(s,vec2(.5)),n=pow(a.oneMinus(),this.ghostAttenuationFactorNode);let d=this.textureNode.sample(s).rgb;d=max(d.sub(this.thresholdNode),vec3(0)).mul(this.ghostTintNode),r.addAssign(d.mul(n))})),r}));return this._material.fragmentNode=t().context(e.getSharedContext()),this._material.needsUpdate=!0,this._textureNode}dispose(){this._renderTarget.dispose(),this._material.dispose()}}export default LensflareNode;export const lensflare=(e,t)=>nodeObject(new LensflareNode(convertToTexture(e),t));
//# sourceMappingURL=LensflareNode.js.map