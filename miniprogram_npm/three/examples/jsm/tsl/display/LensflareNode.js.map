{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/LensflareNode.js","names":["RenderTarget","Vector2","TempNode","NodeUpdateType","QuadMesh","RendererUtils","NodeMaterial","convertToTexture","nodeObject","Fn","passTexture","uv","vec2","vec3","vec4","max","float","sub","int","Loop","fract","pow","distance","_quadMesh","_size","_rendererState","LensflareNode","type","constructor","textureNode","params","super","this","ghostTint","threshold","ghostSamples","ghostSpacing","ghostAttenuationFactor","downSampleRatio","ghostTintNode","thresholdNode","ghostSamplesNode","ghostSpacingNode","ghostAttenuationFactorNode","updateBeforeType","FRAME","_renderTarget","depthBuffer","texture","name","_material","_textureNode","getTextureNode","setSize","width","height","resx","Math","round","resy","updateBefore","frame","renderer","size","getDrawingBufferSize","resetRendererState","material","setMRT","setRenderTarget","render","restoreRendererState","setup","builder","lensflare","texCoord","oneMinus","toVar","ghostVec","mul","result","start","end","condition","i","sampleUv","add","d","weight","sample","rgb","addAssign","fragmentNode","context","getSharedContext","needsUpdate","dispose","node"],"sources":["node_modules/three/examples/jsm/tsl/display/LensflareNode.js"],"sourcesContent":["import { RenderTarget, Vector2, TempNode, NodeUpdateType, QuadMesh, RendererUtils, NodeMaterial } from 'three/webgpu';\nimport { convertToTexture, nodeObject, Fn, passTexture, uv, vec2, vec3, vec4, max, float, sub, int, Loop, fract, pow, distance } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\nlet _rendererState;\n\n/**\n * Post processing node for adding a bloom-based lens flare effect. This effect\n * requires that you extract the bloom of the scene via a bloom pass first.\n *\n * References:\n * - {@link https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html}.\n * - {@link https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html}.\n *\n * @augments TempNode\n * @three_import import { lensflare } from 'three/addons/tsl/display/LensflareNode.js';\n */\nclass LensflareNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'LensflareNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lens flare node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the scene's bloom.\n\t * @param {Object} params - The parameter object for configuring the effect.\n\t * @param {Node<vec3> | Color} [params.ghostTint=vec3(1, 1, 1)] - Defines the tint of the flare/ghosts.\n\t * @param {Node<float> | number} [params.threshold=float(0.5)] - Controls the size and strength of the effect. A higher threshold results in smaller flares.\n\t * @param {Node<float> | number} [params.ghostSamples=float(4)] - Represents the number of flares/ghosts per bright spot which pivot around the center.\n\t * @param {Node<float> | number} [params.ghostSpacing=float(0.25)] - Defines the spacing of the flares/ghosts.\n\t * @param {Node<float> | number} [params.ghostAttenuationFactor=float(25)] - Defines the attenuation factor of flares/ghosts.\n\t * @param {number} [params.downSampleRatio=4] - Defines how downsampling since the effect is usually not rendered at full resolution.\n\t */\n\tconstructor( textureNode, params = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the scene's bloom.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\tconst {\n\t\t\tghostTint = vec3( 1, 1, 1 ),\n\t\t\tthreshold = float( 0.5 ),\n\t\t\tghostSamples = float( 4 ),\n\t\t\tghostSpacing = float( 0.25 ),\n\t\t\tghostAttenuationFactor = float( 25 ),\n\t\t\tdownSampleRatio = 4\n\t\t} = params;\n\n\t\t/**\n\t\t * Defines the tint of the flare/ghosts.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.ghostTintNode = nodeObject( ghostTint );\n\n\t\t/**\n\t\t * Controls the size and strength of the effect. A higher threshold results in smaller flares.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.thresholdNode = nodeObject( threshold );\n\n\t\t/**\n\t\t * Represents the number of flares/ghosts per bright spot which pivot around the center.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.ghostSamplesNode = nodeObject( ghostSamples );\n\n\t\t/**\n\t\t * Defines the spacing of the flares/ghosts.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.ghostSpacingNode = nodeObject( ghostSpacing );\n\n\t\t/**\n\t\t * Defines the attenuation factor of flares/ghosts.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.ghostAttenuationFactorNode = nodeObject( ghostAttenuationFactor );\n\n\t\t/**\n\t\t * Defines how downsampling since the effect is usually not rendered at full resolution.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.downSampleRatio = downSampleRatio;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The internal render target of the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTarget = new RenderTarget( 1, 1, { depthBuffer: false } );\n\t\tthis._renderTarget.texture.name = 'LensflareNode';\n\n\t\t/**\n\t\t * The node material that holds the effect's TSL code.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._material = new NodeMaterial();\n\t\tthis._material.name = 'LensflareNode';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._renderTarget.texture );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tconst resx = Math.round( width / this.downSampleRatio );\n\t\tconst resy = Math.round( height / this.downSampleRatio );\n\n\t\tthis._renderTarget.setSize( resx, resy );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t_quadMesh.material = this._material;\n\n\t\t// clear\n\n\t\trenderer.setMRT( null );\n\n\t\t// lensflare\n\n\t\trenderer.setRenderTarget( this._renderTarget );\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst lensflare = Fn( () => {\n\n\t\t\t// flip uvs so lens flare pivot around the image center\n\n\t\t\tconst texCoord = uv().oneMinus().toVar();\n\n\t\t\t// ghosts are positioned along this vector\n\n\t\t\tconst ghostVec = sub( vec2( 0.5 ), texCoord ).mul( this.ghostSpacingNode ).toVar();\n\n\t\t\t// sample ghosts\n\n\t\t\tconst result = vec4().toVar();\n\n\t\t\tLoop( { start: int( 0 ), end: int( this.ghostSamplesNode ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\t// use fract() to ensure that the texture coordinates wrap around\n\n\t\t\t\tconst sampleUv = fract( texCoord.add( ghostVec.mul( float( i ) ) ) ).toVar();\n\n\t\t\t\t// reduce contributions from samples at the screen edge\n\n\t\t\t\tconst d = distance( sampleUv, vec2( 0.5 ) );\n\t\t\t\tconst weight = pow( d.oneMinus(), this.ghostAttenuationFactorNode );\n\n\t\t\t\t// accumulate\n\n\t\t\t\tlet sample = this.textureNode.sample( sampleUv ).rgb;\n\n\t\t\t\tsample = max( sample.sub( this.thresholdNode ), vec3( 0 ) ).mul( this.ghostTintNode );\n\n\t\t\t\tresult.addAssign( sample.mul( weight ) );\n\n\t\t\t} );\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t\tthis._material.fragmentNode = lensflare().context( builder.getSharedContext() );\n\t\tthis._material.needsUpdate = true;\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._renderTarget.dispose();\n\t\tthis._material.dispose();\n\n\t}\n\n}\n\nexport default LensflareNode;\n\n/**\n * TSL function for creating a bloom-based lens flare effect.\n *\n * @tsl\n * @function\n * @param {TextureNode} node - The node that represents the scene's bloom.\n * @param {Object} params - The parameter object for configuring the effect.\n * @param {Node<vec3> | Color} [params.ghostTint=vec3(1, 1, 1)] - Defines the tint of the flare/ghosts.\n * @param {Node<float> | number} [params.threshold=float(0.5)] - Controls the size and strength of the effect. A higher threshold results in smaller flares.\n * @param {Node<float> | number} [params.ghostSamples=float(4)] - Represents the number of flares/ghosts per bright spot which pivot around the center.\n * @param {Node<float> | number} [params.ghostSpacing=float(0.25)] - Defines the spacing of the flares/ghosts.\n * @param {Node<float> | number} [params.ghostAttenuationFactor=float(25)] - Defines the attenuation factor of flares/ghosts.\n * @param {number} [params.downSampleRatio=4] - Defines how downsampling since the effect is usually not rendered at full resolution.\n * @returns {LensflareNode}\n */\nexport const lensflare = ( node, params ) => nodeObject( new LensflareNode( convertToTexture( node ), params ) );\n"],"mappings":"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","ignoreList":[]}