import{DepthTexture,FloatType,RenderTarget,Vector2,TempNode,QuadMesh,NodeMaterial,RendererUtils,NodeUpdateType}from"three/webgpu";import{Loop,int,exp,min,float,mul,uv,vec2,vec3,Fn,textureSize,orthographicDepthToViewZ,screenUV,nodeObject,uniform,vec4,passTexture,texture,perspectiveDepthToViewZ,positionView,reference}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2,_BLUR_DIRECTION_X=new Vector2(1,0),_BLUR_DIRECTION_Y=new Vector2(0,1);let _rendererState;class OutlineNode extends TempNode{static get type(){return"OutlineNode"}constructor(e,t,r={}){super("vec4");const{selectedObjects:a=[],edgeThickness:i=float(1),edgeGlow:s=float(0),downSampleRatio:n=2}=r;this.scene=e,this.camera=t,this.selectedObjects=a,this.edgeThicknessNode=nodeObject(i),this.edgeGlowNode=nodeObject(s),this.downSampleRatio=n,this.updateBeforeType=NodeUpdateType.FRAME,this._renderTargetDepthBuffer=new RenderTarget,this._renderTargetDepthBuffer.depthTexture=new DepthTexture,this._renderTargetDepthBuffer.depthTexture.type=FloatType,this._renderTargetMaskBuffer=new RenderTarget,this._renderTargetMaskDownSampleBuffer=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTargetEdgeBuffer1=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTargetEdgeBuffer2=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTargetBlurBuffer1=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTargetBlurBuffer2=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTargetComposite=new RenderTarget(1,1,{depthBuffer:!1}),this._cameraNear=reference("near","float",t),this._cameraFar=reference("far","float",t),this._blurDirection=uniform(new Vector2),this._depthTextureUniform=texture(this._renderTargetDepthBuffer.depthTexture),this._maskTextureUniform=texture(this._renderTargetMaskBuffer.texture),this._maskTextureDownsSampleUniform=texture(this._renderTargetMaskDownSampleBuffer.texture),this._edge1TextureUniform=texture(this._renderTargetEdgeBuffer1.texture),this._edge2TextureUniform=texture(this._renderTargetEdgeBuffer2.texture),this._blurColorTextureUniform=texture(this._renderTargetEdgeBuffer1.texture),this._visibleEdgeColor=vec3(1,0,0),this._hiddenEdgeColor=vec3(0,1,0),this._depthMaterial=new NodeMaterial,this._depthMaterial.fragmentNode=vec4(0,0,0,1),this._depthMaterial.name="OutlineNode.depth",this._prepareMaskMaterial=new NodeMaterial,this._prepareMaskMaterial.name="OutlineNode.prepareMask",this._materialCopy=new NodeMaterial,this._materialCopy.name="OutlineNode.copy",this._edgeDetectionMaterial=new NodeMaterial,this._edgeDetectionMaterial.name="OutlineNode.edgeDetection",this._separableBlurMaterial=new NodeMaterial,this._separableBlurMaterial.name="OutlineNode.separableBlur",this._separableBlurMaterial2=new NodeMaterial,this._separableBlurMaterial2.name="OutlineNode.separableBlur2",this._compositeMaterial=new NodeMaterial,this._compositeMaterial.name="OutlineNode.composite",this._selectionCache=new Set,this._textureNode=passTexture(this,this._renderTargetComposite.texture)}get visibleEdge(){return this.r}get hiddenEdge(){return this.g}getTextureNode(){return this._textureNode}setSize(e,t){this._renderTargetDepthBuffer.setSize(e,t),this._renderTargetMaskBuffer.setSize(e,t),this._renderTargetComposite.setSize(e,t);let r=Math.round(e/this.downSampleRatio),a=Math.round(t/this.downSampleRatio);this._renderTargetMaskDownSampleBuffer.setSize(r,a),this._renderTargetEdgeBuffer1.setSize(r,a),this._renderTargetBlurBuffer1.setSize(r,a),r=Math.round(r/2),a=Math.round(a/2),this._renderTargetEdgeBuffer2.setSize(r,a),this._renderTargetBlurBuffer2.setSize(r,a)}updateBefore(e){const{renderer:t}=e,{camera:r,scene:a}=this;_rendererState=RendererUtils.resetRendererAndSceneState(t,a,_rendererState);const i=t.getDrawingBufferSize(_size);this.setSize(i.width,i.height),t.setClearColor(16777215,1),this._updateSelectionCache(),a.overrideMaterial=this._depthMaterial,t.setRenderTarget(this._renderTargetDepthBuffer),t.setRenderObjectFunction(((e,...r)=>{!1===this._selectionCache.has(e)&&t.renderObject(e,...r)})),t.render(a,r),a.overrideMaterial=this._prepareMaskMaterial,t.setRenderTarget(this._renderTargetMaskBuffer),t.setRenderObjectFunction(((e,...r)=>{!0===this._selectionCache.has(e)&&t.renderObject(e,...r)})),t.render(a,r),t.setRenderObjectFunction(_rendererState.renderObjectFunction),this._selectionCache.clear(),_quadMesh.material=this._materialCopy,t.setRenderTarget(this._renderTargetMaskDownSampleBuffer),_quadMesh.render(t),_quadMesh.material=this._edgeDetectionMaterial,t.setRenderTarget(this._renderTargetEdgeBuffer1),_quadMesh.render(t),this._blurColorTextureUniform.value=this._renderTargetEdgeBuffer1.texture,this._blurDirection.value.copy(_BLUR_DIRECTION_X),_quadMesh.material=this._separableBlurMaterial,t.setRenderTarget(this._renderTargetBlurBuffer1),_quadMesh.render(t),this._blurColorTextureUniform.value=this._renderTargetBlurBuffer1.texture,this._blurDirection.value.copy(_BLUR_DIRECTION_Y),t.setRenderTarget(this._renderTargetEdgeBuffer1),_quadMesh.render(t),this._blurColorTextureUniform.value=this._renderTargetEdgeBuffer1.texture,this._blurDirection.value.copy(_BLUR_DIRECTION_X),_quadMesh.material=this._separableBlurMaterial2,t.setRenderTarget(this._renderTargetBlurBuffer2),_quadMesh.render(t),this._blurColorTextureUniform.value=this._renderTargetBlurBuffer2.texture,this._blurDirection.value.copy(_BLUR_DIRECTION_Y),t.setRenderTarget(this._renderTargetEdgeBuffer2),_quadMesh.render(t),_quadMesh.material=this._compositeMaterial,t.setRenderTarget(this._renderTargetComposite),_quadMesh.render(t),RendererUtils.restoreRendererAndSceneState(t,a,_rendererState)}setup(){this._prepareMaskMaterial.fragmentNode=(()=>{const e=this._depthTextureUniform.sample(screenUV);let t;t=this.camera.isPerspectiveCamera?perspectiveDepthToViewZ(e,this._cameraNear,this._cameraFar):orthographicDepthToViewZ(e,this._cameraNear,this._cameraFar);const r=positionView.z.lessThanEqual(t).select(1,0);return vec4(0,r,1,1)})(),this._prepareMaskMaterial.needsUpdate=!0,this._materialCopy.fragmentNode=this._maskTextureUniform,this._materialCopy.needsUpdate=!0;const e=Fn((()=>{const e=textureSize(this._maskTextureDownsSampleUniform),t=vec2(1).div(e).toVar(),r=vec4(1,0,0,1).mul(vec4(t,t)),a=uv(),i=this._maskTextureDownsSampleUniform.sample(a.add(r.xy)).toVar(),s=this._maskTextureDownsSampleUniform.sample(a.sub(r.xy)).toVar(),n=this._maskTextureDownsSampleUniform.sample(a.add(r.yw)).toVar(),d=this._maskTextureDownsSampleUniform.sample(a.sub(r.yw)).toVar(),o=mul(i.r.sub(s.r),.5),h=mul(n.r.sub(d.r),.5),u=vec2(o,h).length(),l=min(i.g,s.g),_=min(n.g,d.g),p=min(l,_).oneMinus().greaterThan(.001).select(this._visibleEdgeColor,this._hiddenEdgeColor);return vec4(p,1).mul(u)}));this._edgeDetectionMaterial.fragmentNode=e(),this._edgeDetectionMaterial.needsUpdate=!0;const t=Fn((([e,t])=>float(.39894).mul(exp(float(-.5).mul(e).mul(e).div(t.mul(t))).div(t)))),r=Fn((([e])=>{const r=textureSize(this._maskTextureDownsSampleUniform),a=vec2(1).div(r).toVar(),i=uv(),s=e.div(2).toVar(),n=t(0,s).toVar(),d=this._blurColorTextureUniform.sample(i).mul(n).toVar(),o=this._blurDirection.mul(a).mul(e).div(4).toVar(),h=o.toVar();return Loop({start:int(1),end:int(4),type:"int",condition:"<="},(({i:r})=>{const a=e.mul(float(r)).div(4),u=t(a,s),l=this._blurColorTextureUniform.sample(i.add(h)),_=this._blurColorTextureUniform.sample(i.sub(h));d.addAssign(l.add(_).mul(u)),n.addAssign(u.mul(2)),h.addAssign(o)})),d.div(n)}));this._separableBlurMaterial.fragmentNode=r(this.edgeThicknessNode),this._separableBlurMaterial.needsUpdate=!0,this._separableBlurMaterial2.fragmentNode=r(4),this._separableBlurMaterial2.needsUpdate=!0;const a=Fn((()=>{const e=this._edge1TextureUniform,t=this._edge2TextureUniform,r=this._maskTextureUniform,a=e.add(t.mul(this.edgeGlowNode));return r.r.mul(a)}));return this._compositeMaterial.fragmentNode=a(),this._compositeMaterial.needsUpdate=!0,this._textureNode}dispose(){this.selectedObjects.length=0,this._renderTargetDepthBuffer.dispose(),this._renderTargetMaskBuffer.dispose(),this._renderTargetMaskDownSampleBuffer.dispose(),this._renderTargetEdgeBuffer1.dispose(),this._renderTargetEdgeBuffer2.dispose(),this._renderTargetBlurBuffer1.dispose(),this._renderTargetBlurBuffer2.dispose(),this._renderTargetComposite.dispose(),this._depthMaterial.dispose(),this._prepareMaskMaterial.dispose(),this._materialCopy.dispose(),this._edgeDetectionMaterial.dispose(),this._separableBlurMaterial.dispose(),this._separableBlurMaterial2.dispose(),this._compositeMaterial.dispose()}_updateSelectionCache(){for(let e=0;e<this.selectedObjects.length;e++){this.selectedObjects[e].traverse((e=>{e.isMesh&&this._selectionCache.add(e)}))}}}export default OutlineNode;export const outline=(e,t,r)=>nodeObject(new OutlineNode(e,t,r));
//# sourceMappingURL=OutlineNode.js.map