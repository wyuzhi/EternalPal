{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/OutlineNode.js","names":["DepthTexture","FloatType","RenderTarget","Vector2","TempNode","QuadMesh","NodeMaterial","RendererUtils","NodeUpdateType","Loop","int","exp","min","float","mul","uv","vec2","vec3","Fn","textureSize","orthographicDepthToViewZ","screenUV","nodeObject","uniform","vec4","passTexture","texture","perspectiveDepthToViewZ","positionView","reference","_quadMesh","_size","_BLUR_DIRECTION_X","_BLUR_DIRECTION_Y","_rendererState","OutlineNode","type","constructor","scene","camera","params","super","selectedObjects","edgeThickness","edgeGlow","downSampleRatio","this","edgeThicknessNode","edgeGlowNode","updateBeforeType","FRAME","_renderTargetDepthBuffer","depthTexture","_renderTargetMaskBuffer","_renderTargetMaskDownSampleBuffer","depthBuffer","_renderTargetEdgeBuffer1","_renderTargetEdgeBuffer2","_renderTargetBlurBuffer1","_renderTargetBlurBuffer2","_renderTargetComposite","_cameraNear","_cameraFar","_blurDirection","_depthTextureUniform","_maskTextureUniform","_maskTextureDownsSampleUniform","_edge1TextureUniform","_edge2TextureUniform","_blurColorTextureUniform","_visibleEdgeColor","_hiddenEdgeColor","_depthMaterial","fragmentNode","name","_prepareMaskMaterial","_materialCopy","_edgeDetectionMaterial","_separableBlurMaterial","_separableBlurMaterial2","_compositeMaterial","_selectionCache","Set","_textureNode","visibleEdge","r","hiddenEdge","g","getTextureNode","setSize","width","height","resx","Math","round","resy","updateBefore","frame","renderer","resetRendererAndSceneState","size","getDrawingBufferSize","setClearColor","_updateSelectionCache","overrideMaterial","setRenderTarget","setRenderObjectFunction","object","has","renderObject","render","renderObjectFunction","clear","material","value","copy","restoreRendererAndSceneState","setup","depth","sample","viewZNode","isPerspectiveCamera","depthTest","z","lessThanEqual","select","prepareMask","needsUpdate","edgeDetection","resolution","invSize","div","toVar","uvOffset","uvNode","c1","add","xy","c2","sub","c3","yw","c4","diff1","diff2","d","length","a1","a2","edgeColor","oneMinus","greaterThan","gaussianPdf","x","sigma","separableBlur","kernelRadius","weightSum","diffuseSum","delta","start","end","condition","i","w","sample1","sample2","addAssign","composite","edgeValue1","edgeValue2","maskColor","edgeValue","dispose","traverse","isMesh","outline"],"sources":["node_modules/three/examples/jsm/tsl/display/OutlineNode.js"],"sourcesContent":["import { DepthTexture, FloatType, RenderTarget, Vector2, TempNode, QuadMesh, NodeMaterial, RendererUtils, NodeUpdateType } from 'three/webgpu';\nimport { Loop, int, exp, min, float, mul, uv, vec2, vec3, Fn, textureSize, orthographicDepthToViewZ, screenUV, nodeObject, uniform, vec4, passTexture, texture, perspectiveDepthToViewZ, positionView, reference } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\nconst _BLUR_DIRECTION_X = /*@__PURE__*/ new Vector2( 1.0, 0.0 );\nconst _BLUR_DIRECTION_Y = /*@__PURE__*/ new Vector2( 0.0, 1.0 );\n\nlet _rendererState;\n\n/**\n * Post processing node for rendering outlines around selected objects. The node\n * gives you great flexibility in composing the final outline look depending on\n * your requirements.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * // outline parameter\n *\n * const edgeStrength = uniform( 3.0 );\n * const edgeGlow = uniform( 0.0 );\n * const edgeThickness = uniform( 1.0 );\n * const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );\n * const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );\n *\n * outlinePass = outline( scene, camera, {\n * \tselectedObjects,\n * \tedgeGlow,\n * \tedgeThickness\n * } );\n *\n * // compose custom outline\n *\n * const { visibleEdge, hiddenEdge } = outlinePass;\n * const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );\n *\n * postProcessing.outputNode = outlineColor.add( scenePass );\n * ```\n *\n * @augments TempNode\n * @three_import import { outline } from 'three/addons/tsl/display/OutlineNode.js';\n */\nclass OutlineNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OutlineNode';\n\n\t}\n\n\t/**\n\t * Constructs a new outline node.\n\t *\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t * @param {Object} params - The configuration parameters.\n\t * @param {Array<Object3D>} params.selectedObjects - An array of selected objects.\n\t * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\n\t * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for an animated glow/pulse effects.\n\t * @param {number} [params.downSampleRatio=2] - The downsample ratio.\n\t */\n\tconstructor( scene, camera, params = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tconst {\n\t\t\tselectedObjects = [],\n\t\t\tedgeThickness = float( 1 ),\n\t\t\tedgeGlow = float( 0 ),\n\t\t\tdownSampleRatio = 2\n\t\t} = params;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * An array of selected objects.\n\t\t *\n\t\t * @type {Array<Object3D>}\n\t\t */\n\t\tthis.selectedObjects = selectedObjects;\n\n\t\t/**\n\t\t * The thickness of the edges.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.edgeThicknessNode = nodeObject( edgeThickness );\n\n\t\t/**\n\t\t * Can be used for an animated glow/pulse effect.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.edgeGlowNode = nodeObject( edgeGlow );\n\n\t\t/**\n\t\t * The downsample ratio.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.downSampleRatio = downSampleRatio;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t// render targets\n\n\t\t/**\n\t\t * The render target for the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetDepthBuffer = new RenderTarget();\n\t\tthis._renderTargetDepthBuffer.depthTexture = new DepthTexture();\n\t\tthis._renderTargetDepthBuffer.depthTexture.type = FloatType;\n\n\t\t/**\n\t\t * The render target for the mask pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetMaskBuffer = new RenderTarget();\n\n\t\t/**\n\t\t * The render target for the mask downsample.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetMaskDownSampleBuffer = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The first render target for the edge detection.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetEdgeBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The second render target for the edge detection.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetEdgeBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The first render target for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBlurBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The second render target for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBlurBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t/**\n\t\t * The render target for the final composite.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetComposite = new RenderTarget( 1, 1, { depthBuffer: false } );\n\n\t\t// uniforms\n\n\t\t/**\n\t\t * Represents the near value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\n\n\t\t/**\n\t\t * Represents the far value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\n\n\t\t/**\n\t\t * Uniform that represents the blur direction of the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._blurDirection = uniform( new Vector2() );\n\n\t\t/**\n\t\t * Texture node that holds the data from the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._depthTextureUniform = texture( this._renderTargetDepthBuffer.depthTexture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the mask pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._maskTextureUniform = texture( this._renderTargetMaskBuffer.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the mask downsample pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._maskTextureDownsSampleUniform = texture( this._renderTargetMaskDownSampleBuffer.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the first edge detection pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._edge1TextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\n\n\t\t/**\n\t\t * Texture node that holds the data from the second edge detection pass.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._edge2TextureUniform = texture( this._renderTargetEdgeBuffer2.texture );\n\n\t\t/**\n\t\t * Texture node that holds the current blurred color data.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._blurColorTextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\n\n\t\t// constants\n\n\t\t/**\n\t\t * Visible edge color.\n\t\t *\n\t\t * @private\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis._visibleEdgeColor = vec3( 1, 0, 0 );\n\n\t\t/**\n\t\t * Hidden edge color.\n\t\t *\n\t\t * @private\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis._hiddenEdgeColor = vec3( 0, 1, 0 );\n\n\t\t// materials\n\n\t\t/**\n\t\t * The material for the depth pre-pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._depthMaterial = new NodeMaterial();\n\t\tthis._depthMaterial.fragmentNode = vec4( 0, 0, 0, 1 );\n\t\tthis._depthMaterial.name = 'OutlineNode.depth';\n\n\t\t/**\n\t\t * The material for preparing the mask.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._prepareMaskMaterial = new NodeMaterial();\n\t\tthis._prepareMaskMaterial.name = 'OutlineNode.prepareMask';\n\n\t\t/**\n\t\t * The copy material\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._materialCopy = new NodeMaterial();\n\t\tthis._materialCopy.name = 'OutlineNode.copy';\n\n\t\t/**\n\t\t * The edge detection material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._edgeDetectionMaterial = new NodeMaterial();\n\t\tthis._edgeDetectionMaterial.name = 'OutlineNode.edgeDetection';\n\n\t\t/**\n\t\t * The material that is used to render in the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._separableBlurMaterial = new NodeMaterial();\n\t\tthis._separableBlurMaterial.name = 'OutlineNode.separableBlur';\n\n\t\t/**\n\t\t * The material that is used to render in the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._separableBlurMaterial2 = new NodeMaterial();\n\t\tthis._separableBlurMaterial2.name = 'OutlineNode.separableBlur2';\n\n\t\t/**\n\t\t * The final composite material.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._compositeMaterial = new NodeMaterial();\n\t\tthis._compositeMaterial.name = 'OutlineNode.composite';\n\n\t\t/**\n\t\t * A set to cache selected objects in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Set<Object3D>}\n\t\t */\n\t\tthis._selectionCache = new Set();\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._renderTargetComposite.texture );\n\n\t}\n\n\t/**\n\t * A mask value that represents the visible edge.\n\t *\n\t * @return {Node<float>} The visible edge.\n\t */\n\tget visibleEdge() {\n\n\t\treturn this.r;\n\n\t}\n\n\t/**\n\t * A mask value that represents the hidden edge.\n\t *\n\t * @return {Node<float>} The hidden edge.\n\t */\n\tget hiddenEdge() {\n\n\t\treturn this.g;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._renderTargetDepthBuffer.setSize( width, height );\n\t\tthis._renderTargetMaskBuffer.setSize( width, height );\n\t\tthis._renderTargetComposite.setSize( width, height );\n\n\t\t// downsample 1\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\n\t\tthis._renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis._renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis._renderTargetBlurBuffer1.setSize( resx, resy );\n\n\t\t// downsample 2\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis._renderTargetEdgeBuffer2.setSize( resx, resy );\n\t\tthis._renderTargetBlurBuffer2.setSize( resx, resy );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { camera, scene } = this;\n\n\t\t_rendererState = RendererUtils.resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\t//\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t//\n\n\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\tthis._updateSelectionCache();\n\n\t\t// 1. Draw non-selected objects in the depth buffer\n\n\t\tscene.overrideMaterial = this._depthMaterial;\n\n\t\trenderer.setRenderTarget( this._renderTargetDepthBuffer );\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( this._selectionCache.has( object ) === false ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.render( scene, camera );\n\n\t\t// 2. Draw only the selected objects by comparing the depth buffer of non-selected objects\n\n\t\tscene.overrideMaterial = this._prepareMaskMaterial;\n\n\t\trenderer.setRenderTarget( this._renderTargetMaskBuffer );\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( this._selectionCache.has( object ) === true ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.render( scene, camera );\n\n\t\t//\n\n\t\trenderer.setRenderObjectFunction( _rendererState.renderObjectFunction );\n\n\t\tthis._selectionCache.clear();\n\n\t\t// 3. Downsample to (at least) half resolution\n\n\t\t_quadMesh.material = this._materialCopy;\n\t\trenderer.setRenderTarget( this._renderTargetMaskDownSampleBuffer );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 4. Perform edge detection (half resolution)\n\n\t\t_quadMesh.material = this._edgeDetectionMaterial;\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 5. Apply blur (half resolution)\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\n\n\t\t_quadMesh.material = this._separableBlurMaterial;\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\n\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 6. Apply blur (quarter resolution)\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\n\n\t\t_quadMesh.material = this._separableBlurMaterial2;\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer2 );\n\t\t_quadMesh.render( renderer );\n\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer2.texture;\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\n\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer2 );\n\t\t_quadMesh.render( renderer );\n\n\t\t// 7. Composite\n\n\t\t_quadMesh.material = this._compositeMaterial;\n\t\trenderer.setRenderTarget( this._renderTargetComposite );\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup() {\n\n\t\t// prepare mask material\n\n\t\tconst prepareMask = () => {\n\n\t\t\tconst depth = this._depthTextureUniform.sample( screenUV );\n\n\t\t\tlet viewZNode;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tviewZNode = perspectiveDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tviewZNode = orthographicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\tconst depthTest = positionView.z.lessThanEqual( viewZNode ).select( 1, 0 );\n\t\t\treturn vec4( 0.0, depthTest, 1.0, 1.0 );\n\n\t\t};\n\n\t\tthis._prepareMaskMaterial.fragmentNode = prepareMask();\n\t\tthis._prepareMaskMaterial.needsUpdate = true;\n\n\t\t// copy material\n\n\t\tthis._materialCopy.fragmentNode = this._maskTextureUniform;\n\t\tthis._materialCopy.needsUpdate = true;\n\n\t\t// edge detection material\n\n\t\tconst edgeDetection = Fn( () => {\n\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\n\t\t\tconst uvOffset = vec4( 1.0, 0.0, 0.0, 1.0 ).mul( vec4( invSize, invSize ) );\n\n\t\t\tconst uvNode = uv();\n\t\t\tconst c1 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.xy ) ).toVar();\n\t\t\tconst c2 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.xy ) ).toVar();\n\t\t\tconst c3 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.yw ) ).toVar();\n\t\t\tconst c4 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.yw ) ).toVar();\n\n\t\t\tconst diff1 = mul( c1.r.sub( c2.r ), 0.5 );\n\t\t\tconst diff2 = mul( c3.r.sub( c4.r ), 0.5 );\n\t\t\tconst d = vec2( diff1, diff2 ).length();\n\t\t\tconst a1 = min( c1.g, c2.g );\n\t\t\tconst a2 = min( c3.g, c4.g );\n\t\t\tconst visibilityFactor = min( a1, a2 );\n\t\t\tconst edgeColor = visibilityFactor.oneMinus().greaterThan( 0.001 ).select( this._visibleEdgeColor, this._hiddenEdgeColor );\n\t\t\treturn vec4( edgeColor, 1 ).mul( d );\n\n\t\t} );\n\n\t\tthis._edgeDetectionMaterial.fragmentNode = edgeDetection();\n\t\tthis._edgeDetectionMaterial.needsUpdate = true;\n\n\t\t// separable blur material\n\n\t\tconst MAX_RADIUS = 4;\n\n\t\tconst gaussianPdf = Fn( ( [ x, sigma ] ) => {\n\n\t\t\treturn float( 0.39894 ).mul( exp( float( - 0.5 ).mul( x ).mul( x ).div( sigma.mul( sigma ) ) ).div( sigma ) );\n\n\t\t} );\n\n\t\tconst separableBlur = Fn( ( [ kernelRadius ] ) => {\n\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst sigma = kernelRadius.div( 2 ).toVar();\n\t\t\tconst weightSum = gaussianPdf( 0, sigma ).toVar();\n\t\t\tconst diffuseSum = this._blurColorTextureUniform.sample( uvNode ).mul( weightSum ).toVar();\n\t\t\tconst delta = this._blurDirection.mul( invSize ).mul( kernelRadius ).div( MAX_RADIUS ).toVar();\n\n\t\t\tconst uvOffset = delta.toVar();\n\n\t\t\tLoop( { start: int( 1 ), end: int( MAX_RADIUS ), type: 'int', condition: '<=' }, ( { i } ) => {\n\n\t\t\t\tconst x = kernelRadius.mul( float( i ) ).div( MAX_RADIUS );\n\t\t\t\tconst w = gaussianPdf( x, sigma );\n\t\t\t\tconst sample1 = this._blurColorTextureUniform.sample( uvNode.add( uvOffset ) );\n\t\t\t\tconst sample2 = this._blurColorTextureUniform.sample( uvNode.sub( uvOffset ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\t\t\t\tweightSum.addAssign( w.mul( 2 ) );\n\t\t\t\tuvOffset.addAssign( delta );\n\n\t\t\t} );\n\n\t\t\treturn diffuseSum.div( weightSum );\n\n\t\t} );\n\n\t\tthis._separableBlurMaterial.fragmentNode = separableBlur( this.edgeThicknessNode );\n\t\tthis._separableBlurMaterial.needsUpdate = true;\n\n\t\tthis._separableBlurMaterial2.fragmentNode = separableBlur( MAX_RADIUS );\n\t\tthis._separableBlurMaterial2.needsUpdate = true;\n\n\t\t// composite material\n\n\t\tconst composite = Fn( () => {\n\n\t\t\tconst edgeValue1 = this._edge1TextureUniform;\n\t\t\tconst edgeValue2 = this._edge2TextureUniform;\n\t\t\tconst maskColor = this._maskTextureUniform;\n\n\t\t\tconst edgeValue = edgeValue1.add( edgeValue2.mul( this.edgeGlowNode ) );\n\n\t\t\treturn maskColor.r.mul( edgeValue );\n\n\t\t} );\n\n\t\tthis._compositeMaterial.fragmentNode = composite();\n\t\tthis._compositeMaterial.needsUpdate = true;\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis.selectedObjects.length = 0;\n\n\t\tthis._renderTargetDepthBuffer.dispose();\n\t\tthis._renderTargetMaskBuffer.dispose();\n\t\tthis._renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis._renderTargetEdgeBuffer1.dispose();\n\t\tthis._renderTargetEdgeBuffer2.dispose();\n\t\tthis._renderTargetBlurBuffer1.dispose();\n\t\tthis._renderTargetBlurBuffer2.dispose();\n\t\tthis._renderTargetComposite.dispose();\n\n\t\tthis._depthMaterial.dispose();\n\t\tthis._prepareMaskMaterial.dispose();\n\t\tthis._materialCopy.dispose();\n\t\tthis._edgeDetectionMaterial.dispose();\n\t\tthis._separableBlurMaterial.dispose();\n\t\tthis._separableBlurMaterial2.dispose();\n\t\tthis._compositeMaterial.dispose();\n\n\t}\n\n\t/**\n\t * Updates the selection cache based on the selected objects.\n\t *\n\t * @private\n\t */\n\t_updateSelectionCache() {\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( ( object ) => {\n\n\t\t\t\tif ( object.isMesh ) this._selectionCache.add( object );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport default OutlineNode;\n\n/**\n * TSL function for creating an outline effect around selected objects.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @param {Object} params - The configuration parameters.\n * @param {Array<Object3D>} params.selectedObjects - An array of selected objects.\n * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\n * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for animated glow/pulse effects.\n * @param {number} [params.downSampleRatio=2] - The downsample ratio.\n * @returns {OutlineNode}\n */\nexport const outline = ( scene, camera, params ) => nodeObject( new OutlineNode( scene, camera, params ) );\n"],"mappings":"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","ignoreList":[]}