{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/ParallaxBarrierPassNode.js","names":["NodeMaterial","nodeObject","Fn","vec4","uv","If","mod","screenCoordinate","StereoCompositePassNode","ParallaxBarrierPassNode","type","constructor","scene","camera","super","this","isParallaxBarrierPassNode","setup","builder","uvNode","parallaxBarrier","color","toVar","y","greaterThan","assign","_mapLeft","sample","Else","_mapRight","material","_material","fragmentNode","context","getSharedContext","needsUpdate","parallaxBarrierPass"],"sources":["node_modules/three/examples/jsm/tsl/display/ParallaxBarrierPassNode.js"],"sourcesContent":["import { NodeMaterial } from 'three/webgpu';\nimport { nodeObject, Fn, vec4, uv, If, mod, screenCoordinate } from 'three/tsl';\nimport StereoCompositePassNode from './StereoCompositePassNode.js';\n\n/**\n * A render pass node that creates a parallax barrier effect.\n *\n * @augments StereoCompositePassNode\n * @three_import import { parallaxBarrierPass } from 'three/addons/tsl/display/ParallaxBarrierPassNode.js';\n */\nclass ParallaxBarrierPassNode extends StereoCompositePassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParallaxBarrierPassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new parallax barrier pass node.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper( scene, camera );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isParallaxBarrierPassNode = true;\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst uvNode = uv();\n\n\t\tconst parallaxBarrier = Fn( () => {\n\n\t\t\tconst color = vec4().toVar();\n\n\t\t\tIf( mod( screenCoordinate.y, 2 ).greaterThan( 1 ), () => {\n\n\t\t\t\tcolor.assign( this._mapLeft.sample( uvNode ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tcolor.assign( this._mapRight.sample( uvNode ) );\n\n\t\t\t} );\n\n\t\t\treturn color;\n\n\t\t} );\n\n\t\tconst material = this._material || ( this._material = new NodeMaterial() );\n\t\tmaterial.fragmentNode = parallaxBarrier().context( builder.getSharedContext() );\n\t\tmaterial.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nexport default ParallaxBarrierPassNode;\n\n/**\n * TSL function for creating an parallax barrier pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - The scene to render.\n * @param {Camera} camera - The camera to render the scene with.\n * @returns {ParallaxBarrierPassNode}\n */\nexport const parallaxBarrierPass = ( scene, camera ) => nodeObject( new ParallaxBarrierPassNode( scene, camera ) );\n"],"mappings":"OAASA,iBAAoB,sBACpBC,WAAYC,GAAIC,KAAMC,GAAIC,GAAIC,IAAKC,qBAAwB,mBAC7DC,4BAA6B,+BAQpC,MAAMC,gCAAgCD,wBAErC,eAAWE,GAEV,MAAO,yBAER,CAQA,WAAAC,CAAaC,EAAOC,GAEnBC,MAAOF,EAAOC,GASdE,KAAKC,2BAA4B,CAElC,CAQA,KAAAC,CAAOC,GAEN,MAAMC,EAASf,KAETgB,EAAkBlB,IAAI,KAE3B,MAAMmB,EAAQlB,OAAOmB,QAYrB,OAVAjB,GAAIC,IAAKC,iBAAiBgB,EAAG,GAAIC,YAAa,IAAK,KAElDH,EAAMI,OAAQV,KAAKW,SAASC,OAAQR,GAAU,IAE3CS,MAAM,KAETP,EAAMI,OAAQV,KAAKc,UAAUF,OAAQR,GAAU,IAIzCE,CAAK,IAIPS,EAAWf,KAAKgB,YAAehB,KAAKgB,UAAY,IAAI/B,cAI1D,OAHA8B,EAASE,aAAeZ,IAAkBa,QAASf,EAAQgB,oBAC3DJ,EAASK,aAAc,EAEhBrB,MAAMG,MAAOC,EAErB,iBAIcT,+BAWR,MAAM2B,oBAAsB,CAAExB,EAAOC,IAAYZ,WAAY,IAAIQ,wBAAyBG,EAAOC","ignoreList":[]}