import{NearestFilter,Vector4,TempNode,NodeUpdateType,PassNode}from"three/webgpu";import{nodeObject,Fn,float,uv,uniform,convertToTexture,vec2,vec3,clamp,floor,dot,smoothstep,If,sign,step,mrt,output,normalView,property}from"three/tsl";class PixelationNode extends TempNode{static get type(){return"PixelationNode"}constructor(e,t,o,s,r,i){super("vec4"),this.textureNode=e,this.depthNode=t,this.normalNode=o,this.pixelSize=s,this.normalEdgeStrength=r,this.depthEdgeStrength=i,this._resolution=uniform(new Vector4),this.updateBeforeType=NodeUpdateType.FRAME}updateBefore(){const e=this.textureNode.value,t=e.image.width,o=e.image.height;this._resolution.value.set(t,o,1/t,1/o)}setup(){const{textureNode:e,depthNode:t,normalNode:o}=this,s=e.uvNode||uv(),r=t.uvNode||uv(),i=o.uvNode||uv(),n=(e,o)=>t.sample(r.add(vec2(e,o).mul(this._resolution.zw))).r,a=(e,t)=>o.sample(i.add(vec2(e,t).mul(this._resolution.zw))).rgb.normalize(),d=(e,t,o,s)=>{const r=n(e,t).sub(o),i=a(e,t),d=vec3(1,1,1),l=dot(s.sub(i),d),p=clamp(smoothstep(-.01,.01,l),0,1),u=clamp(sign(r.mul(.25).add(.0025)),0,1);return float(1).sub(dot(s,i)).mul(u).mul(p)};return Fn((()=>{const t=e.sample(s),o=property("float","depth"),r=property("vec3","normal");If(this.depthEdgeStrength.greaterThan(0).or(this.normalEdgeStrength.greaterThan(0)),(()=>{o.assign(n(0,0)),r.assign(a(0,0))}));const i=property("float","dei");If(this.depthEdgeStrength.greaterThan(0),(()=>{i.assign((e=>{const t=property("float","diff");return t.addAssign(clamp(n(1,0).sub(e))),t.addAssign(clamp(n(-1,0).sub(e))),t.addAssign(clamp(n(0,1).sub(e))),t.addAssign(clamp(n(0,-1).sub(e))),floor(smoothstep(.01,.02,t).mul(2)).div(2)})(o))}));const l=property("float","nei");If(this.normalEdgeStrength.greaterThan(0),(()=>{l.assign(((e,t)=>{const o=property("float","indicator");return o.addAssign(d(0,-1,e,t)),o.addAssign(d(0,1,e,t)),o.addAssign(d(-1,0,e,t)),o.addAssign(d(1,0,e,t)),step(.1,o)})(o,r))}));const p=i.greaterThan(0).select(float(1).sub(i.mul(this.depthEdgeStrength)),l.mul(this.normalEdgeStrength).add(1));return t.mul(p)}))()}}const pixelation=(e,t,o,s=6,r=.3,i=.4)=>nodeObject(new PixelationNode(convertToTexture(e),convertToTexture(t),convertToTexture(o),nodeObject(s),nodeObject(r),nodeObject(i)));class PixelationPassNode extends PassNode{static get type(){return"PixelationPassNode"}constructor(e,t,o=6,s=.3,r=.4){super(PassNode.COLOR,e,t,{minFilter:NearestFilter,magFilter:NearestFilter}),this.pixelSize=o,this.normalEdgeStrength=s,this.depthEdgeStrength=r,this.isPixelationPassNode=!0,this._mrt=mrt({output:output,normal:normalView})}setSize(e,t){const o=this.pixelSize.value?this.pixelSize.value:this.pixelSize,s=Math.floor(e/o),r=Math.floor(t/o);super.setSize(s,r)}setup(){const e=super.getTextureNode("output"),t=super.getTextureNode("depth"),o=super.getTextureNode("normal");return pixelation(e,t,o,this.pixelSize,this.normalEdgeStrength,this.depthEdgeStrength)}}export const pixelationPass=(e,t,o,s,r)=>nodeObject(new PixelationPassNode(e,t,o,s,r));export default PixelationPassNode;
//# sourceMappingURL=PixelationPassNode.js.map