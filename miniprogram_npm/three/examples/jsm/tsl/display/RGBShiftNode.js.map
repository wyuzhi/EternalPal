{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/RGBShiftNode.js","names":["TempNode","nodeObject","Fn","uv","uniform","vec2","sin","cos","vec4","convertToTexture","RGBShiftNode","type","constructor","textureNode","amount","angle","super","this","setup","uvNode","sampleTexture","sample","offset","mul","cr","add","cga","cb","sub","r","g","b","a","rgbShift","node"],"sources":["node_modules/three/examples/jsm/tsl/display/RGBShiftNode.js"],"sourcesContent":["import { TempNode } from 'three/webgpu';\nimport { nodeObject, Fn, uv, uniform, vec2, sin, cos, vec4, convertToTexture } from 'three/tsl';\n\n/**\n * Post processing node for shifting/splitting RGB color channels. The effect\n * separates color channels and offsets them from each other.\n *\n * @augments TempNode\n * @three_import import { rgbShift } from 'three/addons/tsl/display/RGBShiftNode.js';\n */\nclass RGBShiftNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RGBShiftNode';\n\n\t}\n\n\t/**\n\t * Constructs a new RGB shift node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t * @param {number} [amount=0.005] - The amount of the RGB shift.\n\t * @param {number} [angle=0] - Defines the orientation in which colors are shifted.\n\t */\n\tconstructor( textureNode, amount = 0.005, angle = 0 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The amount of the RGB shift.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.amount = uniform( amount );\n\n\t\t/**\n\t\t * Defines in which direction colors are shifted.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.angle = uniform( angle );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst { textureNode } = this;\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.sample( uv );\n\n\t\tconst rgbShift = Fn( () => {\n\n\t\t\tconst offset = vec2( cos( this.angle ), sin( this.angle ) ).mul( this.amount );\n\t\t\tconst cr = sampleTexture( uvNode.add( offset ) );\n\t\t\tconst cga = sampleTexture( uvNode );\n\t\t\tconst cb = sampleTexture( uvNode.sub( offset ) );\n\n\t\t\treturn vec4( cr.r, cga.g, cb.b, cga.a );\n\n\t\t} );\n\n\t\treturn rgbShift();\n\n\t}\n\n}\n\nexport default RGBShiftNode;\n\n/**\n * TSL function for creating a RGB shift or split effect for post processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {number} [amount=0.005] - The amount of the RGB shift.\n * @param {number} [angle=0] - Defines in which direction colors are shifted.\n * @returns {RGBShiftNode}\n */\nexport const rgbShift = ( node, amount, angle ) => nodeObject( new RGBShiftNode( convertToTexture( node ), amount, angle ) );\n"],"mappings":"OAASA,aAAgB,sBAChBC,WAAYC,GAAIC,GAAIC,QAASC,KAAMC,IAAKC,IAAKC,KAAMC,qBAAwB,YASpF,MAAMC,qBAAqBV,SAE1B,eAAWW,GAEV,MAAO,cAER,CASA,WAAAC,CAAaC,EAAaC,EAAS,KAAOC,EAAQ,GAEjDC,MAAO,QAOPC,KAAKJ,YAAcA,EAOnBI,KAAKH,OAASV,QAASU,GAOvBG,KAAKF,MAAQX,QAASW,EAEvB,CAQA,KAAAG,GAEC,MAAML,YAAEA,GAAgBI,KAElBE,EAASN,EAAYM,QAAUhB,KAE/BiB,EAAkBjB,GAAQU,EAAYQ,OAAQlB,GAapD,OAXiBD,IAAI,KAEpB,MAAMoB,EAASjB,KAAME,IAAKU,KAAKF,OAAST,IAAKW,KAAKF,QAAUQ,IAAKN,KAAKH,QAChEU,EAAKJ,EAAeD,EAAOM,IAAKH,IAChCI,EAAMN,EAAeD,GACrBQ,EAAKP,EAAeD,EAAOS,IAAKN,IAEtC,OAAOd,KAAMgB,EAAGK,EAAGH,EAAII,EAAGH,EAAGI,EAAGL,EAAIM,EAAG,GAIjCC,EAER,iBAIcvB,oBAYR,MAAMuB,SAAW,CAAEC,EAAMpB,EAAQC,IAAWd,WAAY,IAAIS,aAAcD,iBAAkByB,GAAQpB,EAAQC","ignoreList":[]}