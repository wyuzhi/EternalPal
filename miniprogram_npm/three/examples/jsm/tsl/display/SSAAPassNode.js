import{AdditiveBlending,Color,Vector2,RendererUtils,PassNode,QuadMesh,NodeMaterial}from"three/webgpu";import{nodeObject,uniform,mrt,texture,getTextureIndex,unpremultiplyAlpha}from"three/tsl";const _size=new Vector2;let _rendererState;class SSAAPassNode extends PassNode{static get type(){return"SSAAPassNode"}constructor(e,t){super(PassNode.COLOR,e,t),this.isSSAAPassNode=!0,this.sampleLevel=4,this.unbiased=!0,this.clearColor=new Color(0),this.clearAlpha=0,this.sampleWeight=uniform(1),this._sampleRenderTarget=null,this._quadMesh=new QuadMesh}updateBefore(e){const{renderer:t}=e,{scene:s,camera:r}=this;_rendererState=RendererUtils.resetRendererState(t,_rendererState),this._pixelRatio=t.getPixelRatio();const a=t.getSize(_size);this.setSize(a.width,a.height),this._sampleRenderTarget.setSize(this.renderTarget.width,this.renderTarget.height),this._cameraNear.value=r.near,this._cameraFar.value=r.far,t.setMRT(this.getMRT()),t.autoClear=!1;const i=_JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],h=1/i.length,l={fullWidth:this.renderTarget.width,fullHeight:this.renderTarget.height,offsetX:0,offsetY:0,width:this.renderTarget.width,height:this.renderTarget.height},d=Object.assign({},r.view);d.enabled&&Object.assign(l,d);for(let e=0;e<i.length;e++){const a=i[e];if(r.setViewOffset&&r.setViewOffset(l.fullWidth,l.fullHeight,l.offsetX+.0625*a[0],l.offsetY+.0625*a[1],l.width,l.height),this.sampleWeight.value=h,this.unbiased){const t=(e+.5)/i.length-.5;this.sampleWeight.value+=.03125*t}t.setClearColor(this.clearColor,this.clearAlpha),t.setRenderTarget(this._sampleRenderTarget),t.clear(),t.render(s,r),t.setRenderTarget(this.renderTarget),0===e&&(t.setClearColor(0,0),t.clear()),this._quadMesh.render(t)}t.copyTextureToTexture(this._sampleRenderTarget.depthTexture,this.renderTarget.depthTexture),r.setViewOffset&&d.enabled?r.setViewOffset(d.fullWidth,d.fullHeight,d.offsetX,d.offsetY,d.width,d.height):r.clearViewOffset&&r.clearViewOffset(),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){let t;null===this._sampleRenderTarget&&(this._sampleRenderTarget=this.renderTarget.clone());const s=this.getMRT();if(null!==s){const e={};for(const t in s.outputNodes){const s=getTextureIndex(this._sampleRenderTarget.textures,t);s>=0&&(e[t]=texture(this._sampleRenderTarget.textures[s]).mul(this.sampleWeight))}t=mrt(e)}else t=texture(this._sampleRenderTarget.texture).mul(this.sampleWeight);return this._quadMesh.material=new NodeMaterial,this._quadMesh.material.fragmentNode=unpremultiplyAlpha(t),this._quadMesh.material.transparent=!0,this._quadMesh.material.depthTest=!1,this._quadMesh.material.depthWrite=!1,this._quadMesh.material.premultipliedAlpha=!0,this._quadMesh.material.blending=AdditiveBlending,this._quadMesh.material.name="SSAA",super.setup(e)}dispose(){super.dispose(),null!==this._sampleRenderTarget&&this._sampleRenderTarget.dispose()}}export default SSAAPassNode;const _JitterVectors=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];export const ssaaPass=(e,t)=>nodeObject(new SSAAPassNode(e,t));
//# sourceMappingURL=SSAAPassNode.js.map