{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/SSAAPassNode.js","names":["AdditiveBlending","Color","Vector2","RendererUtils","PassNode","QuadMesh","NodeMaterial","nodeObject","uniform","mrt","texture","getTextureIndex","unpremultiplyAlpha","_size","_rendererState","SSAAPassNode","type","constructor","scene","camera","super","COLOR","this","isSSAAPassNode","sampleLevel","unbiased","clearColor","clearAlpha","sampleWeight","_sampleRenderTarget","_quadMesh","updateBefore","frame","renderer","resetRendererState","_pixelRatio","getPixelRatio","size","getSize","setSize","width","height","renderTarget","_cameraNear","value","near","_cameraFar","far","setMRT","getMRT","autoClear","jitterOffsets","_JitterVectors","Math","max","min","baseSampleWeight","length","viewOffset","fullWidth","fullHeight","offsetX","offsetY","originalViewOffset","Object","assign","view","enabled","i","jitterOffset","setViewOffset","uniformCenteredDistribution","setClearColor","setRenderTarget","clear","render","copyTextureToTexture","depthTexture","clearViewOffset","restoreRendererState","setup","builder","sampleTexture","clone","passMRT","outputs","name","outputNodes","index","textures","mul","material","fragmentNode","transparent","depthTest","depthWrite","premultipliedAlpha","blending","dispose","ssaaPass"],"sources":["node_modules/three/examples/jsm/tsl/display/SSAAPassNode.js"],"sourcesContent":["import { AdditiveBlending, Color, Vector2, RendererUtils, PassNode, QuadMesh, NodeMaterial } from 'three/webgpu';\nimport { nodeObject, uniform, mrt, texture, getTextureIndex, unpremultiplyAlpha } from 'three/tsl';\n\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n/**\n * A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).\n * This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * This node produces a high-quality anti-aliased output but is also extremely expensive because of\n * its brute-force approach of re-rendering the entire scene multiple times.\n *\n * Reference: {@link https://en.wikipedia.org/wiki/Supersampling}\n *\n * @augments PassNode\n * @three_import import { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';\n */\nclass SSAAPassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'SSAAPassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new SSAA pass node.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSSAAPassNode = true;\n\n\t\t/**\n\t\t * The sample level specified  as n, where the number of samples is 2^n,\n\t\t * so sampleLevel = 4, is 2^4 samples, 16.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 4\n\t\t */\n\t\tthis.sampleLevel = 4;\n\n\t\t/**\n\t\t * Whether rounding errors should be mitigated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.unbiased = true;\n\n\t\t/**\n\t\t * The clear color of the pass.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default 0x000000\n\t\t */\n\t\tthis.clearColor = new Color( 0x000000 );\n\n\t\t/**\n\t\t * The clear alpha of the pass.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.clearAlpha = 0;\n\n\t\t/**\n\t\t * A uniform node representing the sample weight.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t * @default 1\n\t\t */\n\t\tthis.sampleWeight = uniform( 1 );\n\n\t\t/**\n\t\t * Reference to the internal render target that holds the current sample.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._sampleRenderTarget = null;\n\n\t\t/**\n\t\t * Reference to the internal quad mesh.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh();\n\n\t}\n\n\t/**\n\t * This method is used to render the SSAA effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\t\tthis._sampleRenderTarget.setSize( this.renderTarget.width, this.renderTarget.height );\n\n\t\t//\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\trenderer.setMRT( this.getMRT() );\n\t\trenderer.autoClear = false;\n\n\t\tconst jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\tconst baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tconst roundingRange = 1 / 32;\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: this.renderTarget.width,\n\t\t\tfullHeight: this.renderTarget.height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: this.renderTarget.width,\n\t\t\theight: this.renderTarget.height\n\n\t\t};\n\n\t\tconst originalViewOffset = Object.assign( {}, camera.view );\n\n\t\tif ( originalViewOffset.enabled ) Object.assign( viewOffset, originalViewOffset );\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n\t\tfor ( let i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\tconst jitterOffset = jitterOffsets[ i ];\n\n\t\t\tif ( camera.setViewOffset ) {\n\n\t\t\t\tcamera.setViewOffset(\n\n\t\t\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\t\t\tviewOffset.width, viewOffset.height\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tthis.sampleWeight.value = baseSampleWeight;\n\n\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tconst uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\tthis.sampleWeight.value += roundingRange * uniformCenteredDistribution;\n\n\t\t\t}\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\trenderer.setRenderTarget( this._sampleRenderTarget );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( scene, camera );\n\n\t\t\t// accumulation\n\n\t\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tthis._quadMesh.render( renderer );\n\n\t\t}\n\n\t\trenderer.copyTextureToTexture( this._sampleRenderTarget.depthTexture, this.renderTarget.depthTexture );\n\n\t\t// restore\n\n\t\tif ( camera.setViewOffset && originalViewOffset.enabled ) {\n\n\t\t\tcamera.setViewOffset(\n\n\t\t\t\toriginalViewOffset.fullWidth, originalViewOffset.fullHeight,\n\n\t\t\t\toriginalViewOffset.offsetX, originalViewOffset.offsetY,\n\n\t\t\t\toriginalViewOffset.width, originalViewOffset.height\n\n\t\t\t);\n\n\t\t} else if ( camera.clearViewOffset ) {\n\n\t\t\tcamera.clearViewOffset();\n\n\t\t}\n\n\t\t//\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's MRT configuration and quad mesh.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this._sampleRenderTarget === null ) {\n\n\t\t\tthis._sampleRenderTarget = this.renderTarget.clone();\n\n\t\t}\n\n\t\tlet sampleTexture;\n\n\t\tconst passMRT = this.getMRT();\n\n\t\tif ( passMRT !== null ) {\n\n\t\t\tconst outputs = {};\n\n\t\t\tfor ( const name in passMRT.outputNodes ) {\n\n\t\t\t\tconst index = getTextureIndex( this._sampleRenderTarget.textures, name );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\toutputs[ name ] = texture( this._sampleRenderTarget.textures[ index ] ).mul( this.sampleWeight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsampleTexture = mrt( outputs );\n\n\t\t} else {\n\n\t\t\tsampleTexture = texture( this._sampleRenderTarget.texture ).mul( this.sampleWeight );\n\n\t\t}\n\n\t\tthis._quadMesh.material = new NodeMaterial();\n\t\tthis._quadMesh.material.fragmentNode = unpremultiplyAlpha( sampleTexture );\n\t\tthis._quadMesh.material.transparent = true;\n\t\tthis._quadMesh.material.depthTest = false;\n\t\tthis._quadMesh.material.depthWrite = false;\n\t\tthis._quadMesh.material.premultipliedAlpha = true;\n\t\tthis._quadMesh.material.blending = AdditiveBlending;\n\t\tthis._quadMesh.material.name = 'SSAA';\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the pass is no longer required.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._sampleRenderTarget !== null ) {\n\n\t\t\tthis._sampleRenderTarget.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport default SSAAPassNode;\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\n/**\n * TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.\n *\n * @tsl\n * @function\n * @param {Scene} scene - The scene to render.\n * @param {Camera} camera - The camera to render the scene with.\n * @returns {SSAAPassNode}\n */\nexport const ssaaPass = ( scene, camera ) => nodeObject( new SSAAPassNode( scene, camera ) );\n"],"mappings":"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","ignoreList":[]}