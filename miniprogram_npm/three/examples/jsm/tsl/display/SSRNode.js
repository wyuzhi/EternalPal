import{NearestFilter,RenderTarget,Vector2,RendererUtils,QuadMesh,TempNode,NodeMaterial,NodeUpdateType}from"three/webgpu";import{reference,viewZToPerspectiveDepth,logarithmicDepthToViewZ,getScreenPosition,getViewPosition,sqrt,mul,div,cross,float,Continue,Break,Loop,int,max,abs,sub,If,dot,reflect,normalize,screenCoordinate,nodeObject,Fn,passTexture,uv,uniform,perspectiveDepthToViewZ,orthographicDepthToViewZ,vec2,vec3,vec4}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class SSRNode extends TempNode{static get type(){return"SSRNode"}constructor(e,t,r,a,s){super("vec4"),this.colorNode=e,this.depthNode=t,this.normalNode=r,this.metalnessNode=a,this.camera=s,this.resolutionScale=.5,this.updateBeforeType=NodeUpdateType.FRAME,this._ssrRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,minFilter:NearestFilter,magFilter:NearestFilter}),this._ssrRenderTarget.texture.name="SSRNode.SSR",this.maxDistance=uniform(1),this.thickness=uniform(.1),this.opacity=uniform(1),this._cameraProjectionMatrix=uniform(s.projectionMatrix),this._cameraProjectionMatrixInverse=uniform(s.projectionMatrixInverse),this._cameraNear=reference("near","float",s),this._cameraFar=reference("far","float",s),this._isPerspectiveCamera=uniform(s.isPerspectiveCamera?1:0),this._resolution=uniform(new Vector2),this._maxStep=uniform(0),this._material=new NodeMaterial,this._material.name="SSRNode.SSR",this._textureNode=passTexture(this,this._ssrRenderTarget.texture)}getTextureNode(){return this._textureNode}setSize(e,t){e=Math.round(this.resolutionScale*e),t=Math.round(this.resolutionScale*t),this._resolution.value.set(e,t),this._maxStep.value=Math.round(Math.sqrt(e*e+t*t)),this._ssrRenderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=t.getDrawingBufferSize(_size);_quadMesh.material=this._material,this.setSize(r.width,r.height),t.setMRT(null),t.setClearColor(0,0),t.setRenderTarget(this._ssrRenderTarget),_quadMesh.render(t),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=uv(),r=Fn((([e,t,r])=>cross(e.sub(t),e.sub(r)).length().div(r.sub(t).length()))),a=Fn((([e,t,r])=>{const a=mul(r.x,t.x).add(mul(r.y,t.y)).add(mul(r.z,t.z)).negate().toVar(),s=sqrt(mul(r.x,r.x).add(mul(r.y,r.y)).add(mul(r.z,r.z))).toVar();return div(mul(r.x,e.x).add(mul(r.y,e.y)).add(mul(r.z,e.z)).add(a),s)})),s=Fn((([e])=>{let t;return t=this.camera.isPerspectiveCamera?perspectiveDepthToViewZ(e,this._cameraNear,this._cameraFar):orthographicDepthToViewZ(e,this._cameraNear,this._cameraFar),t})),i=t=>{const r=this.depthNode.sample(t).r;if(!0===e.renderer.logarithmicDepthBuffer){const e=logarithmicDepthToViewZ(r,this._cameraNear,this._cameraFar);return viewZToPerspectiveDepth(e,this._cameraNear,this._cameraFar)}return r},o=Fn((()=>{const e=this.metalnessNode.sample(t).r;e.equal(0).discard();const o=i(t).toVar(),n=getViewPosition(t,o,this._cameraProjectionMatrixInverse).toVar(),d=this.normalNode.rgb.normalize().toVar(),h=(this.camera.isPerspectiveCamera?normalize(n):vec3(0,0,-1)).toVar(),c=reflect(h,d).toVar(),l=this.maxDistance.div(dot(h.negate(),d)).toVar(),u=n.add(c.mul(l)).toVar();If(this._isPerspectiveCamera.equal(float(1)).and(u.z.greaterThan(this._cameraNear.negate())),(()=>{const e=sub(this._cameraNear.negate(),n.z).div(c.z);u.assign(n.add(c.mul(e)))}));const m=screenCoordinate.xy.toVar(),p=getScreenPosition(u,this._cameraProjectionMatrix).mul(this._resolution).toVar(),_=p.sub(m).length().toVar(),g=p.x.sub(m.x).toVar(),f=p.y.sub(m.y).toVar(),x=max(abs(g),abs(f)).toVar(),V=g.div(x).toVar(),v=f.div(x).toVar(),N=vec4(0).toVar();return Loop({start:int(0),end:int(this._maxStep),type:"int",condition:"<"},(({i:t})=>{If(e.equal(0),(()=>{Break()})),If(float(t).greaterThanEqual(x),(()=>{Break()}));const o=vec2(m.x.add(V.mul(float(t))),m.y.add(v.mul(float(t)))).toVar();If(o.x.lessThan(0).or(o.x.greaterThan(this._resolution.x)).or(o.y.lessThan(0)).or(o.y.greaterThan(this._resolution.y)),(()=>{Break()}));const l=o.div(this._resolution),p=i(l).toVar(),g=s(p).toVar(),f=getViewPosition(l,p,this._cameraProjectionMatrixInverse).toVar(),T=float(0).toVar(),S=o.sub(m).length().div(_);If(this._isPerspectiveCamera.equal(float(1)),(()=>{const e=float(1).div(n.z).toVar();T.assign(float(1).div(e.add(S.mul(float(1).div(u.z).sub(e)))))})).Else((()=>{T.assign(n.z.add(S.mul(u.z.sub(n.z))))})),If(T.lessThanEqual(g),(()=>{const t=r(f,n,u).toVar(),s=vec2(o.x.add(1),o.y).toVar().div(this._resolution),i=getViewPosition(s,p,this._cameraProjectionMatrixInverse).toVar().x.sub(f.x).toVar();i.mulAssign(3);const m=max(i,this.thickness).toVar();If(t.lessThanEqual(m),(()=>{const t=this.normalNode.sample(l).rgb.normalize().toVar();If(dot(c,t).greaterThanEqual(0),(()=>{Continue()}));const r=a(f,n,d).toVar();If(r.greaterThan(this.maxDistance),(()=>{Break()}));const s=this.opacity.mul(e).toVar(),i=float(1).sub(r.div(this.maxDistance)).toVar(),o=i.mul(i);s.mulAssign(o);const u=div(dot(h,c).add(1),2);s.mulAssign(u);const m=this.colorNode.sample(l);N.assign(vec4(m.rgb,s)),Break()}))}))})),N}));return this._material.fragmentNode=o().context(e.getSharedContext()),this._material.needsUpdate=!0,this._textureNode}dispose(){this._ssrRenderTarget.dispose(),this._material.dispose()}}export default SSRNode;export const ssr=(e,t,r,a,s)=>nodeObject(new SSRNode(nodeObject(e),nodeObject(t),nodeObject(r),nodeObject(a),s));
//# sourceMappingURL=SSRNode.js.map