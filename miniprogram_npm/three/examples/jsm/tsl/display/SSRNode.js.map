{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/SSRNode.js","names":["NearestFilter","RenderTarget","Vector2","RendererUtils","QuadMesh","TempNode","NodeMaterial","NodeUpdateType","reference","viewZToPerspectiveDepth","logarithmicDepthToViewZ","getScreenPosition","getViewPosition","sqrt","mul","div","cross","float","Continue","Break","Loop","int","max","abs","sub","If","dot","reflect","normalize","screenCoordinate","nodeObject","Fn","passTexture","uv","uniform","perspectiveDepthToViewZ","orthographicDepthToViewZ","vec2","vec3","vec4","_quadMesh","_size","_rendererState","SSRNode","type","constructor","colorNode","depthNode","normalNode","metalnessNode","camera","super","this","resolutionScale","updateBeforeType","FRAME","_ssrRenderTarget","depthBuffer","minFilter","magFilter","texture","name","maxDistance","thickness","opacity","_cameraProjectionMatrix","projectionMatrix","_cameraProjectionMatrixInverse","projectionMatrixInverse","_cameraNear","_cameraFar","_isPerspectiveCamera","isPerspectiveCamera","_resolution","_maxStep","_material","_textureNode","getTextureNode","setSize","width","height","Math","round","value","set","updateBefore","frame","renderer","resetRendererState","size","getDrawingBufferSize","material","setMRT","setClearColor","setRenderTarget","render","restoreRendererState","setup","builder","uvNode","pointToLineDistance","point","linePointA","linePointB","length","pointPlaneDistance","planePoint","planeNormal","d","x","add","y","z","negate","toVar","denominator","getViewZ","depth","viewZNode","sampleDepth","sample","r","logarithmicDepthBuffer","viewZ","ssr","metalness","equal","discard","viewPosition","viewNormal","rgb","viewIncidentDir","viewReflectDir","maxReflectRayLen","d1viewPosition","and","greaterThan","t","assign","d0","xy","d1","totalLen","xLen","yLen","totalStep","xSpan","ySpan","output","start","end","condition","i","greaterThanEqual","lessThan","or","vZ","vP","viewReflectRayZ","s","recipVPZ","Else","lessThanEqual","away","uvNeighbor","minThickness","mulAssign","tk","vN","distance","op","ratio","attenuation","fresnelCoe","reflectColor","fragmentNode","context","getSharedContext","needsUpdate","dispose"],"sources":["node_modules/three/examples/jsm/tsl/display/SSRNode.js"],"sourcesContent":["import { NearestFilter, RenderTarget, Vector2, RendererUtils, QuadMesh, TempNode, NodeMaterial, NodeUpdateType } from 'three/webgpu';\nimport { reference, viewZToPerspectiveDepth, logarithmicDepthToViewZ, getScreenPosition, getViewPosition, sqrt, mul, div, cross, float, Continue, Break, Loop, int, max, abs, sub, If, dot, reflect, normalize, screenCoordinate, nodeObject, Fn, passTexture, uv, uniform, perspectiveDepthToViewZ, orthographicDepthToViewZ, vec2, vec3, vec4 } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\nlet _rendererState;\n\n/**\n * Post processing node for computing screen space reflections (SSR).\n *\n * Reference: {@link https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html}\n *\n * @augments TempNode\n * @three_import import { ssr } from 'three/addons/tsl/display/SSRNode.js';\n */\nclass SSRNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SSRNode';\n\n\t}\n\n\t/**\n\t * Constructs a new SSR node.\n\t *\n\t * @param {Node<vec4>} colorNode - The node that represents the beauty pass.\n\t * @param {Node<float>} depthNode - A node that represents the beauty pass's depth.\n\t * @param {Node<vec3>} normalNode - A node that represents the beauty pass's normals.\n\t * @param {Node<float>} metalnessNode - A node that represents the beauty pass's metalness.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( colorNode, depthNode, normalNode, metalnessNode, camera ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The node that represents the beauty pass.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's depth.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's normals.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t\t/**\n\t\t * A node that represents the beauty pass's metalness.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.metalnessNode = metalnessNode;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The resolution scale. By default SSR reflections\n\t\t * are computed in half resolutions. Setting the value\n\t\t * to `1` improves quality but also results in more\n\t\t * computational overhead.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.5\n\t\t */\n\t\tthis.resolutionScale = 0.5;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The render target the SSR is rendered into.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._ssrRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, minFilter: NearestFilter, magFilter: NearestFilter } );\n\t\tthis._ssrRenderTarget.texture.name = 'SSRNode.SSR';\n\n\t\t/**\n\t\t * Controls how far a fragment can reflect.\n\t\t *\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.maxDistance = uniform( 1 );\n\n\t\t/**\n\t\t * Controls the cutoff between what counts as a possible reflection hit and what does not.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.thickness = uniform( 0.1 );\n\n\t\t/**\n\t\t * Controls the transparency of the reflected colors.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.opacity = uniform( 1 );\n\n\t\t/**\n\t\t * Represents the projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrix = uniform( camera.projectionMatrix );\n\n\t\t/**\n\t\t * Represents the inverse projection matrix of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat4>}\n\t\t */\n\t\tthis._cameraProjectionMatrixInverse = uniform( camera.projectionMatrixInverse );\n\n\t\t/**\n\t\t * Represents the near value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\n\n\t\t/**\n\t\t * Represents the far value of the scene's camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ReferenceNode<float>}\n\t\t */\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\n\n\t\t/**\n\t\t * Whether the scene's camera is perspective or orthographic.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<bool>}\n\t\t */\n\t\tthis._isPerspectiveCamera = uniform( camera.isPerspectiveCamera ? 1 : 0 );\n\n\t\t/**\n\t\t * The resolution of the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._resolution = uniform( new Vector2() );\n\n\t\t/**\n\t\t * This value is derived from the resolution and restricts\n\t\t * the maximum raymarching steps in the fragment shader.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._maxStep = uniform( 0 );\n\n\t\t/**\n\t\t * The material that is used to render the effect.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._material = new NodeMaterial();\n\t\tthis._material.name = 'SSRNode.SSR';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._ssrRenderTarget.texture );\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\twidth = Math.round( this.resolutionScale * width );\n\t\theight = Math.round( this.resolutionScale * height );\n\n\t\tthis._resolution.value.set( width, height );\n\t\tthis._maxStep.value = Math.round( Math.sqrt( width * width + height * height ) );\n\n\t\tthis._ssrRenderTarget.setSize( width, height );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\n\t\t_quadMesh.material = this._material;\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\t// clear\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\t// ssr\n\n\t\trenderer.setRenderTarget( this._ssrRenderTarget );\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst uvNode = uv();\n\n\t\tconst pointToLineDistance = Fn( ( [ point, linePointA, linePointB ] )=> {\n\n\t\t\t// https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\n\t\t\treturn cross( point.sub( linePointA ), point.sub( linePointB ) ).length().div( linePointB.sub( linePointA ).length() );\n\n\t\t} );\n\n\t\tconst pointPlaneDistance = Fn( ( [ point, planePoint, planeNormal ] )=> {\n\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t// http://paulbourke.net/geometry/pointlineplane/\n\n\t\t\tconst d = mul( planeNormal.x, planePoint.x ).add( mul( planeNormal.y, planePoint.y ) ).add( mul( planeNormal.z, planePoint.z ) ).negate().toVar();\n\n\t\t\tconst denominator = sqrt( mul( planeNormal.x, planeNormal.x, ).add( mul( planeNormal.y, planeNormal.y ) ).add( mul( planeNormal.z, planeNormal.z ) ) ).toVar();\n\t\t\tconst distance = div( mul( planeNormal.x, point.x ).add( mul( planeNormal.y, point.y ) ).add( mul( planeNormal.z, point.z ) ).add( d ), denominator );\n\t\t\treturn distance;\n\n\t\t} );\n\n\t\tconst getViewZ = Fn( ( [ depth ] ) => {\n\n\t\t\tlet viewZNode;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tviewZNode = perspectiveDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tviewZNode = orthographicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\treturn viewZNode;\n\n\t\t} );\n\n\t\tconst sampleDepth = ( uv ) => {\n\n\t\t\tconst depth = this.depthNode.sample( uv ).r;\n\n\t\t\tif ( builder.renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tconst viewZ = logarithmicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\n\n\t\t\t\treturn viewZToPerspectiveDepth( viewZ, this._cameraNear, this._cameraFar );\n\n\t\t\t}\n\n\t\t\treturn depth;\n\n\t\t};\n\n\t\tconst ssr = Fn( () => {\n\n\t\t\tconst metalness = this.metalnessNode.sample( uvNode ).r;\n\n\t\t\t// fragments with no metalness do not reflect their environment\n\t\t\tmetalness.equal( 0.0 ).discard();\n\n\t\t\t// compute some standard FX entities\n\t\t\tconst depth = sampleDepth( uvNode ).toVar();\n\t\t\tconst viewPosition = getViewPosition( uvNode, depth, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\tconst viewNormal = this.normalNode.rgb.normalize().toVar();\n\n\t\t\t// compute the direction from the position in view space to the camera\n\t\t\tconst viewIncidentDir = ( ( this.camera.isPerspectiveCamera ) ? normalize( viewPosition ) : vec3( 0, 0, - 1 ) ).toVar();\n\n\t\t\t// compute the direction in which the light is reflected on the surface\n\t\t\tconst viewReflectDir = reflect( viewIncidentDir, viewNormal ).toVar();\n\n\t\t\t// adapt maximum distance to the local geometry (see https://www.mathsisfun.com/algebra/vectors-dot-product.html)\n\t\t\tconst maxReflectRayLen = this.maxDistance.div( dot( viewIncidentDir.negate(), viewNormal ) ).toVar();\n\n\t\t\t// compute the maximum point of the reflection ray in view space\n\t\t\tconst d1viewPosition = viewPosition.add( viewReflectDir.mul( maxReflectRayLen ) ).toVar();\n\n\t\t\t// check if d1viewPosition lies behind the camera near plane\n\t\t\tIf( this._isPerspectiveCamera.equal( float( 1 ) ).and( d1viewPosition.z.greaterThan( this._cameraNear.negate() ) ), () => {\n\n\t\t\t\t// if so, ensure d1viewPosition is clamped on the near plane.\n\t\t\t\t// this prevents artifacts during the ray marching process\n\t\t\t\tconst t = sub( this._cameraNear.negate(), viewPosition.z ).div( viewReflectDir.z );\n\t\t\t\td1viewPosition.assign( viewPosition.add( viewReflectDir.mul( t ) ) );\n\n\t\t\t} );\n\n\t\t\t// d0 and d1 are the start and maximum points of the reflection ray in screen space\n\t\t\tconst d0 = screenCoordinate.xy.toVar();\n\t\t\tconst d1 = getScreenPosition( d1viewPosition, this._cameraProjectionMatrix ).mul( this._resolution ).toVar();\n\n\t\t\t// below variables are used to control the raymarching process\n\n\t\t\t// total length of the ray\n\t\t\tconst totalLen = d1.sub( d0 ).length().toVar();\n\n\t\t\t// offset in x and y direction\n\t\t\tconst xLen = d1.x.sub( d0.x ).toVar();\n\t\t\tconst yLen = d1.y.sub( d0.y ).toVar();\n\n\t\t\t// determine the larger delta\n\t\t\t// The larger difference will help to determine how much to travel in the X and Y direction each iteration and\n\t\t\t// how many iterations are needed to travel the entire ray\n\t\t\tconst totalStep = max( abs( xLen ), abs( yLen ) ).toVar();\n\n\t\t\t// step sizes in the x and y directions\n\t\t\tconst xSpan = xLen.div( totalStep ).toVar();\n\t\t\tconst ySpan = yLen.div( totalStep ).toVar();\n\n\t\t\tconst output = vec4( 0 ).toVar();\n\n\t\t\t// the actual ray marching loop\n\t\t\t// starting from d0, the code gradually travels along the ray and looks for an intersection with the geometry.\n\t\t\t// it does not exceed d1 (the maximum ray extend)\n\t\t\tLoop( { start: int( 0 ), end: int( this._maxStep ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\t// TODO: Remove this when Chrome is fixed, see https://issues.chromium.org/issues/372714384#comment14\n\t\t\t\tIf( metalness.equal( 0 ), () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\t// stop if the maximum number of steps is reached for this specific ray\n\t\t\t\tIf( float( i ).greaterThanEqual( totalStep ), () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\t// advance on the ray by computing a new position in screen space\n\t\t\t\tconst xy = vec2( d0.x.add( xSpan.mul( float( i ) ) ), d0.y.add( ySpan.mul( float( i ) ) ) ).toVar();\n\n\t\t\t\t// stop processing if the new position lies outside of the screen\n\t\t\t\tIf( xy.x.lessThan( 0 ).or( xy.x.greaterThan( this._resolution.x ) ).or( xy.y.lessThan( 0 ) ).or( xy.y.greaterThan( this._resolution.y ) ), () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\t// compute new uv, depth, viewZ and viewPosition for the new location on the ray\n\t\t\t\tconst uvNode = xy.div( this._resolution );\n\t\t\t\tconst d = sampleDepth( uvNode ).toVar();\n\t\t\t\tconst vZ = getViewZ( d ).toVar();\n\t\t\t\tconst vP = getViewPosition( uvNode, d, this._cameraProjectionMatrixInverse ).toVar();\n\n\t\t\t\tconst viewReflectRayZ = float( 0 ).toVar();\n\n\t\t\t\t// normalized distance between the current position xy and the starting point d0\n\t\t\t\tconst s = xy.sub( d0 ).length().div( totalLen );\n\n\t\t\t\t// depending on the camera type, we now compute the z-coordinate of the reflected ray at the current step in view space\n\t\t\t\tIf( this._isPerspectiveCamera.equal( float( 1 ) ), () => {\n\n\t\t\t\t\tconst recipVPZ = float( 1 ).div( viewPosition.z ).toVar();\n\t\t\t\t\tviewReflectRayZ.assign( float( 1 ).div( recipVPZ.add( s.mul( float( 1 ).div( d1viewPosition.z ).sub( recipVPZ ) ) ) ) );\n\n\t\t\t\t} ).Else( () => {\n\n\t\t\t\t\tviewReflectRayZ.assign( viewPosition.z.add( s.mul( d1viewPosition.z.sub( viewPosition.z ) ) ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// if viewReflectRayZ is less or equal than the real z-coordinate at this place, it potentially intersects the geometry\n\t\t\t\tIf( viewReflectRayZ.lessThanEqual( vZ ), () => {\n\n\t\t\t\t\t// compute the distance of the new location to the ray in view space\n\t\t\t\t\t// to clarify vP is the fragment's view position which is not an exact point on the ray\n\t\t\t\t\tconst away = pointToLineDistance( vP, viewPosition, d1viewPosition ).toVar();\n\n\t\t\t\t\t// compute the minimum thickness between the current fragment and its neighbor in the x-direction.\n\t\t\t\t\tconst xyNeighbor = vec2( xy.x.add( 1 ), xy.y ).toVar(); // move one pixel\n\t\t\t\t\tconst uvNeighbor = xyNeighbor.div( this._resolution );\n\t\t\t\t\tconst vPNeighbor = getViewPosition( uvNeighbor, d, this._cameraProjectionMatrixInverse ).toVar();\n\t\t\t\t\tconst minThickness = vPNeighbor.x.sub( vP.x ).toVar();\n\t\t\t\t\tminThickness.mulAssign( 3 ); // expand a bit to avoid errors\n\n\t\t\t\t\tconst tk = max( minThickness, this.thickness ).toVar();\n\n\t\t\t\t\tIf( away.lessThanEqual( tk ), () => { // hit\n\n\t\t\t\t\t\tconst vN = this.normalNode.sample( uvNode ).rgb.normalize().toVar();\n\n\t\t\t\t\t\tIf( dot( viewReflectDir, vN ).greaterThanEqual( 0 ), () => {\n\n\t\t\t\t\t\t\t// the reflected ray is pointing towards the same side as the fragment's normal (current ray position),\n\t\t\t\t\t\t\t// which means it wouldn't reflect off the surface. The loop continues to the next step for the next ray sample.\n\t\t\t\t\t\t\tContinue();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// this distance represents the depth of the intersection point between the reflected ray and the scene.\n\t\t\t\t\t\tconst distance = pointPlaneDistance( vP, viewPosition, viewNormal ).toVar();\n\n\t\t\t\t\t\tIf( distance.greaterThan( this.maxDistance ), () => {\n\n\t\t\t\t\t\t\t// Distance exceeding limit: The reflection is potentially too far away and\n\t\t\t\t\t\t\t// might not contribute significantly to the final color\n\t\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst op = this.opacity.mul( metalness ).toVar();\n\n\t\t\t\t\t\t// distance attenuation (the reflection should fade out the farther it is away from the surface)\n\t\t\t\t\t\tconst ratio = float( 1 ).sub( distance.div( this.maxDistance ) ).toVar();\n\t\t\t\t\t\tconst attenuation = ratio.mul( ratio );\n\t\t\t\t\t\top.mulAssign( attenuation );\n\n\t\t\t\t\t\t// fresnel (reflect more light on surfaces that are viewed at grazing angles)\n\t\t\t\t\t\tconst fresnelCoe = div( dot( viewIncidentDir, viewReflectDir ).add( 1 ), 2 );\n\t\t\t\t\t\top.mulAssign( fresnelCoe );\n\n\t\t\t\t\t\t// output\n\t\t\t\t\t\tconst reflectColor = this.colorNode.sample( uvNode );\n\t\t\t\t\t\toutput.assign( vec4( reflectColor.rgb, op ) );\n\t\t\t\t\t\tBreak();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\treturn output;\n\n\t\t} );\n\n\t\tthis._material.fragmentNode = ssr().context( builder.getSharedContext() );\n\t\tthis._material.needsUpdate = true;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._ssrRenderTarget.dispose();\n\n\t\tthis._material.dispose();\n\n\t}\n\n}\n\nexport default SSRNode;\n\n/**\n * TSL function for creating screen space reflections (SSR).\n *\n * @tsl\n * @function\n * @param {Node<vec4>} colorNode - The node that represents the beauty pass.\n * @param {Node<float>} depthNode - A node that represents the beauty pass's depth.\n * @param {Node<vec3>} normalNode - A node that represents the beauty pass's normals.\n * @param {Node<float>} metalnessNode - A node that represents the beauty pass's metalness.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @returns {SSRNode}\n */\nexport const ssr = ( colorNode, depthNode, normalNode, metalnessNode, camera ) => nodeObject( new SSRNode( nodeObject( colorNode ), nodeObject( depthNode ), nodeObject( normalNode ), nodeObject( metalnessNode ), camera ) );\n"],"mappings":"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","ignoreList":[]}