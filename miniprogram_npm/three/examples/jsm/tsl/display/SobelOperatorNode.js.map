{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/SobelOperatorNode.js","names":["Vector2","TempNode","NodeUpdateType","nodeObject","Fn","uv","uniform","convertToTexture","vec2","vec3","vec4","mat3","luminance","add","SobelOperatorNode","type","constructor","textureNode","super","this","updateBeforeType","FRAME","_invSize","updateBefore","map","value","set","image","width","height","setup","uvNode","sampleTexture","sample","texel","Gx","Gy","tx0y0","mul","xyz","tx0y1","tx0y2","tx1y0","tx1y1","tx1y2","tx2y0","tx2y1","tx2y2","valueGx","valueGy","G","sqrt","sobel","node"],"sources":["node_modules/three/examples/jsm/tsl/display/SobelOperatorNode.js"],"sourcesContent":["import { Vector2, TempNode, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, uv, uniform, convertToTexture, vec2, vec3, vec4, mat3, luminance, add } from 'three/tsl';\n\n/**\n * Post processing node for detecting edges with a sobel filter.\n * A sobel filter should be applied after tone mapping and output color\n * space conversion.\n *\n * @augments TempNode\n * @three_import import { sobel } from 'three/addons/tsl/display/SobelOperatorNode.js';\n */\nclass SobelOperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SobelOperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new sobel operator node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node that represents the input of the effect.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * its internal uniforms once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t}\n\n\t/**\n\t * This method is used to update the effect's uniforms once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( /* frame */ ) {\n\n\t\tconst map = this.textureNode.value;\n\n\t\tthis._invSize.value.set( 1 / map.image.width, 1 / map.image.height );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ShaderCallNodeInternal}\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tconst { textureNode } = this;\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.sample( uv );\n\n\t\tconst sobel = Fn( () => {\n\n\t\t\t// Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n\n\t\t\tconst texel = this._invSize;\n\n\t\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\tconst Gx = mat3( - 1, - 2, - 1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\n\t\t\tconst Gy = mat3( - 1, 0, 1, - 2, 0, 2, - 1, 0, 1 ); // y direction kernel\n\n\t\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t\t// first column\n\n\t\t\tconst tx0y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, - 1 ) ) ) ).xyz );\n\t\t\tconst tx0y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, 0 ) ) ) ).xyz );\n\t\t\tconst tx0y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( - 1, 1 ) ) ) ).xyz );\n\n\t\t\t// second column\n\n\t\t\tconst tx1y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, - 1 ) ) ) ).xyz );\n\t\t\tconst tx1y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, 0 ) ) ) ).xyz );\n\t\t\tconst tx1y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 0, 1 ) ) ) ).xyz );\n\n\t\t\t// third column\n\n\t\t\tconst tx2y0 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, - 1 ) ) ) ).xyz );\n\t\t\tconst tx2y1 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, 0 ) ) ) ).xyz );\n\t\t\tconst tx2y2 = luminance( sampleTexture( uvNode.add( texel.mul( vec2( 1, 1 ) ) ) ).xyz );\n\n\t\t\t// gradient value in x direction\n\n\t\t\tconst valueGx = add(\n\t\t\t\tGx[ 0 ][ 0 ].mul( tx0y0 ),\n\t\t\t\tGx[ 1 ][ 0 ].mul( tx1y0 ),\n\t\t\t\tGx[ 2 ][ 0 ].mul( tx2y0 ),\n\t\t\t\tGx[ 0 ][ 1 ].mul( tx0y1 ),\n\t\t\t\tGx[ 1 ][ 1 ].mul( tx1y1 ),\n\t\t\t\tGx[ 2 ][ 1 ].mul( tx2y1 ),\n\t\t\t\tGx[ 0 ][ 2 ].mul( tx0y2 ),\n\t\t\t\tGx[ 1 ][ 2 ].mul( tx1y2 ),\n\t\t\t\tGx[ 2 ][ 2 ].mul( tx2y2 )\n\t\t\t);\n\n\n\t\t\t// gradient value in y direction\n\n\t\t\tconst valueGy = add(\n\t\t\t\tGy[ 0 ][ 0 ].mul( tx0y0 ),\n\t\t\t\tGy[ 1 ][ 0 ].mul( tx1y0 ),\n\t\t\t\tGy[ 2 ][ 0 ].mul( tx2y0 ),\n\t\t\t\tGy[ 0 ][ 1 ].mul( tx0y1 ),\n\t\t\t\tGy[ 1 ][ 1 ].mul( tx1y1 ),\n\t\t\t\tGy[ 2 ][ 1 ].mul( tx2y1 ),\n\t\t\t\tGy[ 0 ][ 2 ].mul( tx0y2 ),\n\t\t\t\tGy[ 1 ][ 2 ].mul( tx1y2 ),\n\t\t\t\tGy[ 2 ][ 2 ].mul( tx2y2 )\n\t\t\t);\n\n\t\t\t// magnitude of the total gradient\n\n\t\t\tconst G = valueGx.mul( valueGx ).add( valueGy.mul( valueGy ) ).sqrt();\n\n\t\t\treturn vec4( vec3( G ), 1 );\n\n\t\t} );\n\n\t\tconst outputNode = sobel();\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default SobelOperatorNode;\n\n/**\n * TSL function for creating a sobel operator node which performs edge detection with a sobel filter.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @returns {SobelOperatorNode}\n */\nexport const sobel = ( node ) => nodeObject( new SobelOperatorNode( convertToTexture( node ) ) );\n"],"mappings":"OAASA,QAASC,SAAUC,mBAAsB,sBACzCC,WAAYC,GAAIC,GAAIC,QAASC,iBAAkBC,KAAMC,KAAMC,KAAMC,KAAMC,UAAWC,QAAW,YAUtG,MAAMC,0BAA0Bb,SAE/B,eAAWc,GAEV,MAAO,mBAER,CAOA,WAAAC,CAAaC,GAEZC,MAAO,QAOPC,KAAKF,YAAcA,EASnBE,KAAKC,iBAAmBlB,eAAemB,MAQvCF,KAAKG,SAAWhB,QAAS,IAAIN,QAE9B,CAOA,YAAAuB,GAEC,MAAMC,EAAML,KAAKF,YAAYQ,MAE7BN,KAAKG,SAASG,MAAMC,IAAK,EAAIF,EAAIG,MAAMC,MAAO,EAAIJ,EAAIG,MAAME,OAE7D,CAQA,KAAAC,GAEC,MAAMb,YAAEA,GAAgBE,KAElBY,EAASd,EAAYc,QAAU1B,KAE/B2B,EAAkB3B,GAAQY,EAAYgB,OAAQ5B,GAwEpD,OAtEcD,IAAI,KAIjB,MAAM8B,EAAQf,KAAKG,SAIba,EAAKxB,MAAQ,GAAK,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzCyB,EAAKzB,MAAQ,EAAG,EAAG,GAAK,EAAG,EAAG,GAAK,EAAG,EAAG,GAMzC0B,EAAQzB,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,MAAQ,GAAK,MAAU+B,KAChFC,EAAQ5B,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,MAAQ,EAAG,MAAU+B,KAC9EE,EAAQ7B,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,MAAQ,EAAG,MAAU+B,KAI9EG,EAAQ9B,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,GAAK,MAAU+B,KAC9EI,EAAQ/B,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,EAAG,MAAU+B,KAC5EK,EAAQhC,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,EAAG,MAAU+B,KAI5EM,EAAQjC,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,GAAK,MAAU+B,KAC9EO,EAAQlC,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,EAAG,MAAU+B,KAC5EQ,EAAQnC,UAAWoB,EAAeD,EAAOlB,IAAKqB,EAAMI,IAAK9B,KAAM,EAAG,MAAU+B,KAI5ES,EAAUnC,IACfsB,EAAI,GAAK,GAAIG,IAAKD,GAClBF,EAAI,GAAK,GAAIG,IAAKI,GAClBP,EAAI,GAAK,GAAIG,IAAKO,GAClBV,EAAI,GAAK,GAAIG,IAAKE,GAClBL,EAAI,GAAK,GAAIG,IAAKK,GAClBR,EAAI,GAAK,GAAIG,IAAKQ,GAClBX,EAAI,GAAK,GAAIG,IAAKG,GAClBN,EAAI,GAAK,GAAIG,IAAKM,GAClBT,EAAI,GAAK,GAAIG,IAAKS,IAMbE,EAAUpC,IACfuB,EAAI,GAAK,GAAIE,IAAKD,GAClBD,EAAI,GAAK,GAAIE,IAAKI,GAClBN,EAAI,GAAK,GAAIE,IAAKO,GAClBT,EAAI,GAAK,GAAIE,IAAKE,GAClBJ,EAAI,GAAK,GAAIE,IAAKK,GAClBP,EAAI,GAAK,GAAIE,IAAKQ,GAClBV,EAAI,GAAK,GAAIE,IAAKG,GAClBL,EAAI,GAAK,GAAIE,IAAKM,GAClBR,EAAI,GAAK,GAAIE,IAAKS,IAKbG,EAAIF,EAAQV,IAAKU,GAAUnC,IAAKoC,EAAQX,IAAKW,IAAYE,OAE/D,OAAOzC,KAAMD,KAAMyC,GAAK,EAAG,GAITE,EAIpB,iBAIctC,yBAUR,MAAMsC,MAAUC,GAAUlD,WAAY,IAAIW,kBAAmBP,iBAAkB8C","ignoreList":[]}