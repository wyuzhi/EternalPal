{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/StereoPassNode.js","names":["StereoCamera","Vector2","PassNode","RendererUtils","nodeObject","_size","_rendererState","StereoPassNode","type","constructor","scene","camera","super","COLOR","this","isStereoPassNode","stereo","aspect","updateBefore","frame","renderer","renderTarget","resetRendererState","_pixelRatio","getPixelRatio","cameraL","coordinateSystem","cameraR","update","size","getSize","setSize","width","height","autoClear","_cameraNear","value","near","_cameraFar","far","name","_previousTextures","toggleTexture","setRenderTarget","setMRT","_mrt","clear","scissorTest","scissor","set","viewport","render","restoreRendererState","stereoPass"],"sources":["node_modules/three/examples/jsm/tsl/display/StereoPassNode.js"],"sourcesContent":["import { StereoCamera, Vector2, PassNode, RendererUtils } from 'three/webgpu';\nimport { nodeObject } from 'three/tsl';\n\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n/**\n * A special render pass node that renders the scene as a stereoscopic image.\n *\n * @augments PassNode\n * @three_import import { stereoPass } from 'three/addons/tsl/display/StereoPassNode.js';\n */\nclass StereoPassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'StereoPassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new stereo pass node.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStereoPassNode = true;\n\n\t\t/**\n\t\t * The internal stereo camera that is used to render the scene.\n\t\t *\n\t\t * @type {StereoCamera}\n\t\t */\n\t\tthis.stereo = new StereoCamera();\n\t\tthis.stereo.aspect = 0.5;\n\n\t}\n\n\t/**\n\t * This method is used to render the stereo effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera, stereo, renderTarget } = this;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tstereo.cameraL.coordinateSystem = renderer.coordinateSystem;\n\t\tstereo.cameraR.coordinateSystem = renderer.coordinateSystem;\n\t\tstereo.update( camera );\n\n\t\tconst size = renderer.getSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\trenderer.autoClear = false;\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\t\trenderer.clear();\n\n\t\trenderTarget.scissorTest = true;\n\n\t\trenderTarget.scissor.set( 0, 0, renderTarget.width / 2, renderTarget.height );\n\t\trenderTarget.viewport.set( 0, 0, renderTarget.width / 2, renderTarget.height );\n\t\trenderer.render( scene, stereo.cameraL );\n\n\t\trenderTarget.scissor.set( renderTarget.width / 2, 0, renderTarget.width / 2, renderTarget.height );\n\t\trenderTarget.viewport.set( renderTarget.width / 2, 0, renderTarget.width / 2, renderTarget.height );\n\t\trenderer.render( scene, stereo.cameraR );\n\n\t\trenderTarget.scissorTest = false;\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n}\n\nexport default StereoPassNode;\n\n/**\n * TSL function for creating a stereo pass node for stereoscopic rendering.\n *\n * @tsl\n * @function\n * @param {Scene} scene - The scene to render.\n * @param {Camera} camera - The camera to render the scene with.\n * @returns {StereoPassNode}\n */\nexport const stereoPass = ( scene, camera ) => nodeObject( new StereoPassNode( scene, camera ) );\n"],"mappings":"OAASA,aAAcC,QAASC,SAAUC,kBAAqB,sBACtDC,eAAkB,YAE3B,MAAMC,MAAsB,IAAIJ,QAEhC,IAAIK,eAQJ,MAAMC,uBAAuBL,SAE5B,eAAWM,GAEV,MAAO,gBAER,CAQA,WAAAC,CAAaC,EAAOC,GAEnBC,MAAOV,SAASW,MAAOH,EAAOC,GAS9BG,KAAKC,kBAAmB,EAOxBD,KAAKE,OAAS,IAAIhB,aAClBc,KAAKE,OAAOC,OAAS,EAEtB,CAOA,YAAAC,CAAcC,GAEb,MAAMC,SAAEA,GAAaD,GACfT,MAAEA,EAAKC,OAAEA,EAAMK,OAAEA,EAAMK,aAAEA,GAAiBP,KAEhDR,eAAiBH,cAAcmB,mBAAoBF,EAAUd,gBAI7DQ,KAAKS,YAAcH,EAASI,gBAE5BR,EAAOS,QAAQC,iBAAmBN,EAASM,iBAC3CV,EAAOW,QAAQD,iBAAmBN,EAASM,iBAC3CV,EAAOY,OAAQjB,GAEf,MAAMkB,EAAOT,EAASU,QAASzB,OAC/BS,KAAKiB,QAASF,EAAKG,MAAOH,EAAKI,QAE/Bb,EAASc,WAAY,EAErBpB,KAAKqB,YAAYC,MAAQzB,EAAO0B,KAChCvB,KAAKwB,WAAWF,MAAQzB,EAAO4B,IAE/B,IAAM,MAAMC,KAAQ1B,KAAK2B,kBAExB3B,KAAK4B,cAAeF,GAIrBpB,EAASuB,gBAAiBtB,GAC1BD,EAASwB,OAAQ9B,KAAK+B,MACtBzB,EAAS0B,QAETzB,EAAa0B,aAAc,EAE3B1B,EAAa2B,QAAQC,IAAK,EAAG,EAAG5B,EAAaW,MAAQ,EAAGX,EAAaY,QACrEZ,EAAa6B,SAASD,IAAK,EAAG,EAAG5B,EAAaW,MAAQ,EAAGX,EAAaY,QACtEb,EAAS+B,OAAQzC,EAAOM,EAAOS,SAE/BJ,EAAa2B,QAAQC,IAAK5B,EAAaW,MAAQ,EAAG,EAAGX,EAAaW,MAAQ,EAAGX,EAAaY,QAC1FZ,EAAa6B,SAASD,IAAK5B,EAAaW,MAAQ,EAAG,EAAGX,EAAaW,MAAQ,EAAGX,EAAaY,QAC3Fb,EAAS+B,OAAQzC,EAAOM,EAAOW,SAE/BN,EAAa0B,aAAc,EAI3B5C,cAAciD,qBAAsBhC,EAAUd,eAE/C,iBAIcC,sBAWR,MAAM8C,WAAa,CAAE3C,EAAOC,IAAYP,WAAY,IAAIG,eAAgBG,EAAOC","ignoreList":[]}