import{HalfFloatType,Vector2,RenderTarget,RendererUtils,QuadMesh,NodeMaterial,TempNode,NodeUpdateType,Matrix4}from"three/webgpu";import{add,float,If,Loop,int,Fn,min,max,clamp,nodeObject,texture,uniform,uv,vec2,vec4,luminance,convertToTexture,passTexture,velocity}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class TRAANode extends TempNode{static get type(){return"TRAANode"}constructor(e,t,r,s){super("vec4"),this.isTRAANode=!0,this.updateBeforeType=NodeUpdateType.FRAME,this.beautyNode=e,this.depthNode=t,this.velocityNode=r,this.camera=s,this._jitterIndex=0,this._invSize=uniform(new Vector2),this._historyRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._historyRenderTarget.texture.name="TRAANode.history",this._resolveRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._resolveRenderTarget.texture.name="TRAANode.resolve",this._resolveMaterial=new NodeMaterial,this._resolveMaterial.name="TRAA.resolve",this._textureNode=passTexture(this,this._resolveRenderTarget.texture),this._originalProjectionMatrix=new Matrix4,this._needsPostProcessingSync=!1}getTextureNode(){return this._textureNode}setSize(e,t){this._historyRenderTarget.setSize(e,t),this._resolveRenderTarget.setSize(e,t),this._invSize.value.set(1/e,1/t)}setViewOffset(e,t){this.camera.updateProjectionMatrix(),this._originalProjectionMatrix.copy(this.camera.projectionMatrix),velocity.setProjectionMatrix(this._originalProjectionMatrix);const r={fullWidth:e,fullHeight:t,offsetX:0,offsetY:0,width:e,height:t},s=_JitterVectors[this._jitterIndex];this.camera.setViewOffset(r.fullWidth,r.fullHeight,r.offsetX+.0625*s[0],r.offsetY+.0625*s[1],r.width,r.height)}clearViewOffset(){this.camera.clearViewOffset(),velocity.setProjectionMatrix(null),this._jitterIndex++,this._jitterIndex=this._jitterIndex%(_JitterVectors.length-1)}updateBefore(e){const{renderer:t}=e,r=this.beautyNode.isRTTNode?this.beautyNode.renderTarget:this.beautyNode.passNode.renderTarget,s=r.texture.width,i=r.texture.height;!0===this._needsPostProcessingSync&&(this.setViewOffset(s,i),this._needsPostProcessingSync=!1),_rendererState=RendererUtils.resetRendererState(t,_rendererState);const o=this._historyRenderTarget.width!==s||this._historyRenderTarget.height!==i;this.setSize(s,i),!0===o&&(t.setRenderTarget(this._historyRenderTarget),t.clear(),t.setRenderTarget(this._resolveRenderTarget),t.clear(),t.copyTextureToTexture(r.texture,this._historyRenderTarget.texture)),t.setRenderTarget(this._resolveRenderTarget),_quadMesh.material=this._resolveMaterial,_quadMesh.render(t),t.setRenderTarget(null),t.copyTextureToTexture(this._resolveRenderTarget.texture,this._historyRenderTarget.texture),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=e.context.postProcessing;t&&(this._needsPostProcessingSync=!0,t.context.onBeforePostProcessing=()=>{const t=e.renderer.getDrawingBufferSize(_size);this.setViewOffset(t.width,t.height)},t.context.onAfterPostProcessing=()=>{this.clearViewOffset()});const r=texture(this._historyRenderTarget.texture),s=this.beautyNode,i=this.depthNode,o=this.velocityNode,a=Fn((()=>{const e=uv(),t=vec4(1e4).toVar(),a=vec4(-1e4).toVar(),n=float(1).toVar(),d=vec2(0).toVar();Loop({start:int(-1),end:int(1),type:"int",condition:"<=",name:"x"},(({x:r})=>{Loop({start:int(-1),end:int(1),type:"int",condition:"<=",name:"y"},(({y:o})=>{const h=e.add(vec2(float(r),float(o)).mul(this._invSize)).toVar(),l=max(vec4(0),s.sample(h)).toVar();t.assign(min(t,l)),a.assign(max(a,l));const c=i.sample(h).r.toVar();If(c.lessThan(n),(()=>{n.assign(c),d.assign(h)}))}))}));const h=o.sample(d).xy.mul(vec2(.5,-.5)),l=s.sample(e),c=r.sample(e.sub(h)),u=clamp(c,t,a),g=float(.05).toVar(),T=g.oneMinus().toVar(),f=l.mul(float(1).div(max(l.r,l.g,l.b).add(1))),x=u.mul(float(1).div(max(u.r,u.g,u.b).add(1))),_=luminance(f.rgb),p=luminance(x.rgb);return g.mulAssign(float(1).div(_.add(1))),T.mulAssign(float(1).div(p.add(1))),add(l.mul(g),u.mul(T)).div(max(g.add(T),1e-5))}));return this._resolveMaterial.colorNode=a(),this._textureNode}dispose(){this._historyRenderTarget.dispose(),this._resolveRenderTarget.dispose(),this._resolveMaterial.dispose()}}export default TRAANode;const _JitterVectors=[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]];export const traa=(e,t,r,s)=>nodeObject(new TRAANode(convertToTexture(e),t,r,s));
//# sourceMappingURL=TRAANode.js.map