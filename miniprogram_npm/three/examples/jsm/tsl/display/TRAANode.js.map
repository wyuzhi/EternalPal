{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/TRAANode.js","names":["HalfFloatType","Vector2","RenderTarget","RendererUtils","QuadMesh","NodeMaterial","TempNode","NodeUpdateType","Matrix4","add","float","If","Loop","int","Fn","min","max","clamp","nodeObject","texture","uniform","uv","vec2","vec4","luminance","convertToTexture","passTexture","velocity","_quadMesh","_size","_rendererState","TRAANode","type","constructor","beautyNode","depthNode","velocityNode","camera","super","this","isTRAANode","updateBeforeType","FRAME","_jitterIndex","_invSize","_historyRenderTarget","depthBuffer","name","_resolveRenderTarget","_resolveMaterial","_textureNode","_originalProjectionMatrix","_needsPostProcessingSync","getTextureNode","setSize","width","height","value","set","setViewOffset","updateProjectionMatrix","copy","projectionMatrix","setProjectionMatrix","viewOffset","fullWidth","fullHeight","offsetX","offsetY","jitterOffset","_JitterVectors","clearViewOffset","length","updateBefore","frame","renderer","beautyRenderTarget","renderTarget","passNode","resetRendererState","needsRestart","setRenderTarget","clear","copyTextureToTexture","material","render","restoreRendererState","setup","builder","postProcessing","context","onBeforePostProcessing","size","getDrawingBufferSize","onAfterPostProcessing","historyTexture","sampleTexture","depthTexture","velocityTexture","resolve","uvNode","minColor","toVar","maxColor","closestDepth","closestDepthPixelPosition","start","end","condition","x","y","uvNeighbor","mul","colorNeighbor","sample","assign","currentDepth","r","lessThan","offset","xy","currentColor","historyColor","sub","clampedHistoryColor","currentWeight","historyWeight","oneMinus","compressedCurrent","div","g","b","compressedHistory","luminanceCurrent","rgb","luminanceHistory","mulAssign","colorNode","dispose","traa"],"sources":["node_modules/three/examples/jsm/tsl/display/TRAANode.js"],"sourcesContent":["import { HalfFloatType, Vector2, RenderTarget, RendererUtils, QuadMesh, NodeMaterial, TempNode, NodeUpdateType, Matrix4 } from 'three/webgpu';\nimport { add, float, If, Loop, int, Fn, min, max, clamp, nodeObject, texture, uniform, uv, vec2, vec4, luminance, convertToTexture, passTexture, velocity } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n\n/**\n * A special node that applies TRAA (Temporal Reprojection Anti-Aliasing).\n *\n * References:\n * - {@link https://alextardif.com/TAA.html}\n * - {@link https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/}\n *\n * @augments TempNode\n * @three_import import { traa } from 'three/addons/tsl/display/TRAANode.js';\n */\nclass TRAANode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'TRAANode';\n\n\t}\n\n\t/**\n\t * Constructs a new TRAA node.\n\t *\n\t * @param {TextureNode} beautyNode - The texture node that represents the input of the effect.\n\t * @param {TextureNode} depthNode - A node that represents the scene's depth.\n\t * @param {TextureNode} velocityNode - A node that represents the scene's velocity.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( beautyNode, depthNode, velocityNode, camera ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTRAANode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The texture node that represents the input of the effect.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.beautyNode = beautyNode;\n\n\t\t/**\n\t\t * A node that represents the scene's velocity.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.depthNode = depthNode;\n\n\t\t/**\n\t\t * A node that represents the scene's velocity.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.velocityNode = velocityNode;\n\n\t\t/**\n\t\t *  The camera the scene is rendered with.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The jitter index selects the current camera offset value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._jitterIndex = 0;\n\n\t\t/**\n\t\t * A uniform node holding the inverse resolution value.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<vec2>}\n\t\t */\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\t/**\n\t\t * The render target that represents the history of frame data.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t */\n\t\tthis._historyRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._historyRenderTarget.texture.name = 'TRAANode.history';\n\n\t\t/**\n\t\t * The render target for the resolve.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t */\n\t\tthis._resolveRenderTarget = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._resolveRenderTarget.texture.name = 'TRAANode.resolve';\n\n\t\t/**\n\t\t * Material used for the resolve step.\n\t\t *\n\t\t * @private\n\t\t * @type {NodeMaterial}\n\t\t */\n\t\tthis._resolveMaterial = new NodeMaterial();\n\t\tthis._resolveMaterial.name = 'TRAA.resolve';\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureNode = passTexture( this, this._resolveRenderTarget.texture );\n\n\t\t/**\n\t\t * Used to save the original/unjittered projection matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis._originalProjectionMatrix = new Matrix4();\n\n\t\t/**\n\t\t * Sync the post processing stack with the TRAA node.\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._needsPostProcessingSync = false;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._historyRenderTarget.setSize( width, height );\n\t\tthis._resolveRenderTarget.setSize( width, height );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\n\t}\n\n\t/**\n\t * Defines the TRAA's current jitter as a view offset\n\t * to the scene's camera.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetViewOffset( width, height ) {\n\n\t\t// save original/unjittered projection matrix for velocity pass\n\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis._originalProjectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\tvelocity.setProjectionMatrix( this._originalProjectionMatrix );\n\n\t\t//\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: width,\n\t\t\tfullHeight: height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: width,\n\t\t\theight: height\n\n\t\t};\n\n\t\tconst jitterOffset = _JitterVectors[ this._jitterIndex ];\n\n\t\tthis.camera.setViewOffset(\n\n\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\tviewOffset.width, viewOffset.height\n\n\t\t);\n\n\t}\n\n\t/**\n\t * Clears the view offset from the scene's camera.\n\t */\n\tclearViewOffset() {\n\n\t\tthis.camera.clearViewOffset();\n\n\t\tvelocity.setProjectionMatrix( null );\n\n\t\t// update jitter index\n\n\t\tthis._jitterIndex ++;\n\t\tthis._jitterIndex = this._jitterIndex % ( _JitterVectors.length - 1 );\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t// keep the TRAA in sync with the dimensions of the beauty node\n\n\t\tconst beautyRenderTarget = ( this.beautyNode.isRTTNode ) ? this.beautyNode.renderTarget : this.beautyNode.passNode.renderTarget;\n\n\t\tconst width = beautyRenderTarget.texture.width;\n\t\tconst height = beautyRenderTarget.texture.height;\n\n\t\t//\n\n\t\tif ( this._needsPostProcessingSync === true ) {\n\n\t\t\tthis.setViewOffset( width, height );\n\n\t\t\tthis._needsPostProcessingSync = false;\n\n\t\t}\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst needsRestart = this._historyRenderTarget.width !== width || this._historyRenderTarget.height !== height;\n\t\tthis.setSize( width, height );\n\n\t\t// every time when the dimensions change we need fresh history data\n\n\t\tif ( needsRestart === true ) {\n\n\t\t\t// bind and clear render target to make sure they are initialized after the resize which triggers a dispose()\n\n\t\t\trenderer.setRenderTarget( this._historyRenderTarget );\n\t\t\trenderer.clear();\n\n\t\t\trenderer.setRenderTarget( this._resolveRenderTarget );\n\t\t\trenderer.clear();\n\n\t\t\t// make sure to reset the history with the contents of the beauty buffer otherwise subsequent frames after the\n\t\t\t// resize will fade from a darker color to the correct one because the history was cleared with black.\n\n\t\t\trenderer.copyTextureToTexture( beautyRenderTarget.texture, this._historyRenderTarget.texture );\n\n\t\t}\n\n\t\t// resolve\n\n\t\trenderer.setRenderTarget( this._resolveRenderTarget );\n\t\t_quadMesh.material = this._resolveMaterial;\n\t\t_quadMesh.render( renderer );\n\t\trenderer.setRenderTarget( null );\n\n\t\t// update history\n\n\t\trenderer.copyTextureToTexture( this._resolveRenderTarget.texture, this._historyRenderTarget.texture );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's render targets and TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tconst postProcessing = builder.context.postProcessing;\n\n\t\tif ( postProcessing ) {\n\n\t\t\tthis._needsPostProcessingSync = true;\n\n\t\t\tpostProcessing.context.onBeforePostProcessing = () => {\n\n\t\t\t\tconst size = builder.renderer.getDrawingBufferSize( _size );\n\t\t\t\tthis.setViewOffset( size.width, size.height );\n\n\t\t\t};\n\n\t\t\tpostProcessing.context.onAfterPostProcessing = () => {\n\n\t\t\t\tthis.clearViewOffset();\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst historyTexture = texture( this._historyRenderTarget.texture );\n\t\tconst sampleTexture = this.beautyNode;\n\t\tconst depthTexture = this.depthNode;\n\t\tconst velocityTexture = this.velocityNode;\n\n\t\tconst resolve = Fn( () => {\n\n\t\t\tconst uvNode = uv();\n\n\t\t\tconst minColor = vec4( 10000 ).toVar();\n\t\t\tconst maxColor = vec4( - 10000 ).toVar();\n\t\t\tconst closestDepth = float( 1 ).toVar();\n\t\t\tconst closestDepthPixelPosition = vec2( 0 ).toVar();\n\n\t\t\t// sample a 3x3 neighborhood to create a box in color space\n\t\t\t// clamping the history color with the resulting min/max colors mitigates ghosting\n\n\t\t\tLoop( { start: int( - 1 ), end: int( 1 ), type: 'int', condition: '<=', name: 'x' }, ( { x } ) => {\n\n\t\t\t\tLoop( { start: int( - 1 ), end: int( 1 ), type: 'int', condition: '<=', name: 'y' }, ( { y } ) => {\n\n\t\t\t\t\tconst uvNeighbor = uvNode.add( vec2( float( x ), float( y ) ).mul( this._invSize ) ).toVar();\n\t\t\t\t\tconst colorNeighbor = max( vec4( 0 ), sampleTexture.sample( uvNeighbor ) ).toVar(); // use max() to avoid propagate garbage values\n\n\t\t\t\t\tminColor.assign( min( minColor, colorNeighbor ) );\n\t\t\t\t\tmaxColor.assign( max( maxColor, colorNeighbor ) );\n\n\t\t\t\t\tconst currentDepth = depthTexture.sample( uvNeighbor ).r.toVar();\n\n\t\t\t\t\t// find the sample position of the closest depth in the neighborhood (used for velocity)\n\n\t\t\t\t\tIf( currentDepth.lessThan( closestDepth ), () => {\n\n\t\t\t\t\t\tclosestDepth.assign( currentDepth );\n\t\t\t\t\t\tclosestDepthPixelPosition.assign( uvNeighbor );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\t// sampling/reprojection\n\n\t\t\tconst offset = velocityTexture.sample( closestDepthPixelPosition ).xy.mul( vec2( 0.5, - 0.5 ) ); // NDC to uv offset\n\n\t\t\tconst currentColor = sampleTexture.sample( uvNode );\n\t\t\tconst historyColor = historyTexture.sample( uvNode.sub( offset ) );\n\n\t\t\t// clamping\n\n\t\t\tconst clampedHistoryColor = clamp( historyColor, minColor, maxColor );\n\n\t\t\t// flicker reduction based on luminance weighing\n\n\t\t\tconst currentWeight = float( 0.05 ).toVar();\n\t\t\tconst historyWeight = currentWeight.oneMinus().toVar();\n\n\t\t\tconst compressedCurrent = currentColor.mul( float( 1 ).div( ( max( currentColor.r, currentColor.g, currentColor.b ).add( 1.0 ) ) ) );\n\t\t\tconst compressedHistory = clampedHistoryColor.mul( float( 1 ).div( ( max( clampedHistoryColor.r, clampedHistoryColor.g, clampedHistoryColor.b ).add( 1.0 ) ) ) );\n\n\t\t\tconst luminanceCurrent = luminance( compressedCurrent.rgb );\n\t\t\tconst luminanceHistory = luminance( compressedHistory.rgb );\n\n\t\t\tcurrentWeight.mulAssign( float( 1.0 ).div( luminanceCurrent.add( 1 ) ) );\n\t\t\thistoryWeight.mulAssign( float( 1.0 ).div( luminanceHistory.add( 1 ) ) );\n\n\t\t\treturn add( currentColor.mul( currentWeight ), clampedHistoryColor.mul( historyWeight ) ).div( max( currentWeight.add( historyWeight ), 0.00001 ) );\n\n\t\t} );\n\n\t\t// materials\n\n\t\tthis._resolveMaterial.colorNode = resolve();\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tthis._historyRenderTarget.dispose();\n\t\tthis._resolveRenderTarget.dispose();\n\n\t\tthis._resolveMaterial.dispose();\n\n\t}\n\n}\n\nexport default TRAANode;\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n];\n\n/**\n * TSL function for creating a TRAA node for Temporal Reprojection Anti-Aliasing.\n *\n * @tsl\n * @function\n * @param {TextureNode} beautyNode - The texture node that represents the input of the effect.\n * @param {TextureNode} depthNode - A node that represents the scene's depth.\n * @param {TextureNode} velocityNode - A node that represents the scene's velocity.\n * @param {Camera} camera - The camera the scene is rendered with.\n * @returns {TRAANode}\n */\nexport const traa = ( beautyNode, depthNode, velocityNode, camera ) => nodeObject( new TRAANode( convertToTexture( beautyNode ), depthNode, velocityNode, camera ) );\n"],"mappings":"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","ignoreList":[]}