{"version":3,"file":"node_modules/three/examples/jsm/tsl/display/hashBlur.js","names":["float","Fn","vec2","uv","sin","rand","degrees","cos","Loop","vec4","premultiplyAlpha","unpremultiplyAlpha","hashBlur","textureNode","bluramount","options","repeats","mask","premultipliedAlpha","targetUV","uvNode","blurred_image","toVar","start","end","type","i","q","div","mul","x","add","y","uv2","addAssign","sample","alpha","rgb","a","draw","divAssign"],"sources":["node_modules/three/examples/jsm/tsl/display/hashBlur.js"],"sourcesContent":["import { float, Fn, vec2, uv, sin, rand, degrees, cos, Loop, vec4, premultiplyAlpha, unpremultiplyAlpha } from 'three/tsl';\n\n/**\n * Applies a hash blur effect to the given texture node.\n *\n * Reference: {@link https://www.shadertoy.com/view/4lXXWn}.\n *\n * @function\n * @param {Node<vec4>} textureNode - The texture node that should be blurred.\n * @param {Node<float>} [bluramount=float(0.1)] - This node determines the amount of blur.\n * @param {Object} [options={}] - Additional options for the hash blur effect.\n * @param {Node<float>} [options.repeats=float(45)] - The number of iterations for the blur effect.\n * @param {Node<vec4>} [options.mask=null] - A mask node to control the alpha blending of the blur.\n * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.\n * @return {Node<vec4>} The blurred texture node.\n */\nexport const hashBlur = /*#__PURE__*/ Fn( ( [ textureNode, bluramount = float( 0.1 ), options = {} ] ) => {\n\n\tconst {\n\t\trepeats = float( 45 ),\n\t\tmask = null,\n\t\tpremultipliedAlpha = false\n\t} = options;\n\n\tconst draw = ( uv ) => {\n\n\t\tlet sample = textureNode.sample( uv );\n\n\t\tif ( mask !== null ) {\n\n\t\t\tconst alpha = mask.sample( uv ).x;\n\n\t\t\tsample = vec4( sample.rgb, sample.a.mul( alpha ) );\n\n\t\t}\n\n\t\treturn premultipliedAlpha ? premultiplyAlpha( sample ) : sample;\n\n\t};\n\n\tconst targetUV = textureNode.uvNode || uv();\n\tconst blurred_image = vec4( 0. ).toVar();\n\n\tLoop( { start: 0., end: repeats, type: 'float' }, ( { i } ) => {\n\n\t\tconst q = vec2( vec2( cos( degrees( i.div( repeats ).mul( 360. ) ) ), sin( degrees( i.div( repeats ).mul( 360. ) ) ) ).mul( rand( vec2( i, targetUV.x.add( targetUV.y ) ) ).add( bluramount ) ) );\n\t\tconst uv2 = vec2( targetUV.add( q.mul( bluramount ) ) );\n\t\tblurred_image.addAssign( draw( uv2 ) );\n\n\t} );\n\n\tblurred_image.divAssign( repeats );\n\n\treturn premultipliedAlpha ? unpremultiplyAlpha( blurred_image ) : blurred_image;\n\n} );\n"],"mappings":"OAASA,MAAOC,GAAIC,KAAMC,GAAIC,IAAKC,KAAMC,QAASC,IAAKC,KAAMC,KAAMC,iBAAkBC,uBAA0B,mBAgBxG,MAAMC,SAAyBX,IAAI,EAAIY,EAAaC,EAAad,MAAO,IAAOe,EAAU,CAAC,MAEhG,MAAMC,QACLA,EAAUhB,MAAO,IAAIiB,KACrBA,EAAO,KAAIC,mBACXA,GAAqB,GAClBH,EAkBEI,EAAWN,EAAYO,QAAUjB,KACjCkB,EAAgBZ,KAAM,GAAKa,QAYjC,OAVAd,KAAM,CAAEe,MAAO,EAAIC,IAAKR,EAASS,KAAM,UAAW,EAAIC,QAErD,MAAMC,EAAIzB,KAAMA,KAAMK,IAAKD,QAASoB,EAAEE,IAAKZ,GAAUa,IAAK,OAAYzB,IAAKE,QAASoB,EAAEE,IAAKZ,GAAUa,IAAK,QAAaA,IAAKxB,KAAMH,KAAMwB,EAAGP,EAASW,EAAEC,IAAKZ,EAASa,KAAQD,IAAKjB,KAC3KmB,EAAM/B,KAAMiB,EAASY,IAAKJ,EAAEE,IAAKf,KACvCO,EAAca,UAvBF,CAAE/B,IAEd,IAAIgC,EAAStB,EAAYsB,OAAQhC,GAEjC,GAAc,OAATc,EAAgB,CAEpB,MAAMmB,EAAQnB,EAAKkB,OAAQhC,GAAK2B,EAEhCK,EAAS1B,KAAM0B,EAAOE,IAAKF,EAAOG,EAAET,IAAKO,GAE1C,CAEA,OAAOlB,EAAqBR,iBAAkByB,GAAWA,CAAM,EAWtCI,CAAMN,GAAO,IAIvCZ,EAAcmB,UAAWxB,GAElBE,EAAqBP,mBAAoBU,GAAkBA,CAAa","ignoreList":[]}