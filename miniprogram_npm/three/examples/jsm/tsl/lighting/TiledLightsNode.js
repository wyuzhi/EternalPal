import{DataTexture,FloatType,RGBAFormat,Vector2,Vector3,LightsNode,NodeUpdateType}from"three/webgpu";import{attributeArray,nodeProxy,int,float,vec2,ivec2,ivec4,uniform,Break,Loop,positionView,Fn,If,Return,textureLoad,instanceIndex,screenCoordinate,directPointLight}from"three/tsl";export const circleIntersectsAABB=Fn((([t,e,i,s])=>{const r=i.x.max(t.x.min(s.x)),n=i.y.max(t.y.min(s.y)),o=t.x.sub(r),a=t.y.sub(n);return o.mul(o).add(a.mul(a)).lessThanEqual(e.mul(e))})).setLayout({name:"circleIntersectsAABB",type:"bool",inputs:[{name:"circleCenter",type:"vec2"},{name:"radius",type:"float"},{name:"minBounds",type:"vec2"},{name:"maxBounds",type:"vec2"}]});const _vector3=new Vector3,_size=new Vector2;class TiledLightsNode extends LightsNode{static get type(){return"TiledLightsNode"}constructor(t=1024,e=32){super(),this.materialLights=[],this.tiledLights=[],this.maxLights=t,this.tileSize=e,this._bufferSize=null,this._lightIndexes=null,this._screenTileIndex=null,this._compute=null,this._lightsTexture=null,this._lightsCount=uniform(0,"int"),this._tileLightCount=8,this._screenSize=uniform(new Vector2),this._cameraProjectionMatrix=uniform("mat4"),this._cameraViewMatrix=uniform("mat4"),this.updateBeforeType=NodeUpdateType.RENDER}customCacheKey(){return this._compute.getCacheKey()+super.customCacheKey()}updateLightsTexture(){const{_lightsTexture:t,tiledLights:e}=this,i=t.image.data,s=4*t.image.width;this._lightsCount.value=e.length;for(let t=0;t<e.length;t++){const r=e[t];_vector3.setFromMatrixPosition(r.matrixWorld);const n=4*t;i[n+0]=_vector3.x,i[n+1]=_vector3.y,i[n+2]=_vector3.z,i[n+3]=r.distance,i[s+n+0]=r.color.r*r.intensity,i[s+n+1]=r.color.g*r.intensity,i[s+n+2]=r.color.b*r.intensity,i[s+n+3]=r.decay}t.needsUpdate=!0}updateBefore(t){const{renderer:e,camera:i}=t;this.updateProgram(e),this.updateLightsTexture(i),this._cameraProjectionMatrix.value=i.projectionMatrix,this._cameraViewMatrix.value=i.matrixWorldInverse,e.getDrawingBufferSize(_size),this._screenSize.value.copy(_size),e.compute(this._compute)}setLights(t){const{tiledLights:e,materialLights:i}=this;let s=0,r=0;for(const n of t)!0===n.isPointLight?e[r++]=n:i[s++]=n;return i.length=s,e.length=r,super.setLights(i)}getBlock(t=0){return this._lightIndexes.element(this._screenTileIndex.mul(int(2).add(int(t))))}getTile(t){t=int(t);const e=int(4),i=t.div(e),s=this._screenTileIndex.mul(int(2)).add(i);return this._lightIndexes.element(s).element(t.mod(e))}getLightData(t){t=int(t);const e=textureLoad(this._lightsTexture,ivec2(t,0)),i=textureLoad(this._lightsTexture,ivec2(t,1)),s=e.xyz;return{position:s,viewPosition:this._cameraViewMatrix.mul(s),distance:e.w,color:i.rgb,decay:i.w}}setupLights(t,e){this.updateProgram(t.renderer);const i=t.context.reflectedLight;i.directDiffuse.toStack(),i.directSpecular.toStack(),super.setupLights(t,e),Fn((()=>{Loop(this._tileLightCount,(({i:e})=>{const i=this.getTile(e);If(i.equal(int(0)),(()=>{Break()}));const{color:s,decay:r,viewPosition:n,distance:o}=this.getLightData(i.sub(1));t.lightsNode.setupDirectLight(t,this,directPointLight({color:s,lightVector:n.sub(positionView),cutoffDistance:o,decayExponent:r}))}))}),"void")()}getBufferFitSize(t){const e=this.tileSize;return Math.ceil(t/e)*e}setSize(t,e){return t=this.getBufferFitSize(t),e=this.getBufferFitSize(e),this._bufferSize&&this._bufferSize.width===t&&this._bufferSize.height===e||this.create(t,e),this}updateProgram(t){t.getDrawingBufferSize(_size);const e=this.getBufferFitSize(_size.width),i=this.getBufferFitSize(_size.height);null===this._bufferSize?this.create(e,i):this._bufferSize.width===e&&this._bufferSize.height===i||this.create(e,i)}create(t,e){const{tileSize:i,maxLights:s}=this,r=new Vector2(t,e),n=Math.floor(r.width/i),o=Math.floor(r.width*r.height/i),a=new Float32Array(4*s*2),h=new DataTexture(a,a.length/8,2,RGBAFormat,FloatType),c=new Int32Array(4*o*2),u=attributeArray(c,"ivec4").setName("lightIndexes"),l=t=>{const e=instanceIndex.mul(int(2)).add(int(t));return u.element(e)},d=Fn((()=>{const{_cameraProjectionMatrix:t,_bufferSize:e,_screenSize:s}=this,r=e.clone().divideScalar(i).floor(),n=vec2(instanceIndex.mod(r.width),instanceIndex.div(r.width)).mul(i).div(s),o=float(i).div(s),a=n,h=a.add(o),c=int(0).toVar();l(0).assign(ivec4(0)),l(1).assign(ivec4(0)),Loop(this.maxLights,(({i:e})=>{If(c.greaterThanEqual(this._tileLightCount).or(int(e).greaterThanEqual(int(this._lightsCount))),(()=>{Return()}));const{viewPosition:i,distance:s}=this.getLightData(e),r=t.mul(i),n=r.div(r.w).xy.mul(.5).add(.5).flipY(),o=i.z,l=s.div(o);If(circleIntersectsAABB(n,l,a,h),(()=>{(t=>{t=int(t);const e=int(4),i=t.div(e),s=instanceIndex.mul(int(2)).add(i);return u.element(s).element(t.mod(e))})(c).assign(e.add(int(1))),c.addAssign(int(1))}))}))}))().compute(o),g=screenCoordinate.div(i).floor().toVar(),m=g.x.add(g.y.mul(n));this._bufferSize=r,this._lightIndexes=u,this._screenTileIndex=m,this._compute=d,this._lightsTexture=h}get hasLights(){return super.hasLights||this.tiledLights.length>0}}export default TiledLightsNode;export const tiledLights=nodeProxy(TiledLightsNode);
//# sourceMappingURL=TiledLightsNode.js.map