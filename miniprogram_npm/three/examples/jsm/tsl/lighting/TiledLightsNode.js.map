{"version":3,"file":"node_modules/three/examples/jsm/tsl/lighting/TiledLightsNode.js","names":["DataTexture","FloatType","RGBAFormat","Vector2","Vector3","LightsNode","NodeUpdateType","attributeArray","nodeProxy","int","float","vec2","ivec2","ivec4","uniform","Break","Loop","positionView","Fn","If","Return","textureLoad","instanceIndex","screenCoordinate","directPointLight","circleIntersectsAABB","circleCenter","radius","minBounds","maxBounds","closestX","x","max","min","closestY","y","distX","sub","distY","mul","add","lessThanEqual","setLayout","name","type","inputs","_vector3","_size","TiledLightsNode","constructor","maxLights","tileSize","super","this","materialLights","tiledLights","_bufferSize","_lightIndexes","_screenTileIndex","_compute","_lightsTexture","_lightsCount","_tileLightCount","_screenSize","_cameraProjectionMatrix","_cameraViewMatrix","updateBeforeType","RENDER","customCacheKey","getCacheKey","updateLightsTexture","lightsTexture","data","image","lineSize","width","value","length","i","light","setFromMatrixPosition","matrixWorld","offset","z","distance","color","r","intensity","g","b","decay","needsUpdate","updateBefore","frame","renderer","camera","updateProgram","projectionMatrix","matrixWorldInverse","getDrawingBufferSize","copy","compute","setLights","lights","materialindex","tiledIndex","isPointLight","getBlock","block","element","getTile","stride","tileOffset","div","tileIndex","mod","getLightData","index","dataA","dataB","position","xyz","viewPosition","w","rgb","setupLights","builder","lightNodes","lightingModel","context","reflectedLight","directDiffuse","toStack","directSpecular","lightIndex","equal","lightsNode","setupDirectLight","lightVector","cutoffDistance","decayExponent","getBufferFitSize","multiple","Math","ceil","setSize","height","create","bufferSize","floor","count","lightsData","Float32Array","lightIndexesArray","Int32Array","lightIndexes","setName","cameraProjectionMatrix","screenSize","tiledBufferSize","clone","divideScalar","tileScreen","blockSize","toVar","assign","greaterThanEqual","or","projectedPosition","screenPosition","xy","flipY","distanceFromCamera","pointRadius","elementIndex","addAssign","screenTile","screenTileIndex","hasLights"],"sources":["node_modules/three/examples/jsm/tsl/lighting/TiledLightsNode.js"],"sourcesContent":["import { DataTexture, FloatType, RGBAFormat, Vector2, Vector3, LightsNode, NodeUpdateType } from 'three/webgpu';\n\nimport {\n\tattributeArray, nodeProxy, int, float, vec2, ivec2, ivec4, uniform, Break, Loop, positionView,\n\tFn, If, Return, textureLoad, instanceIndex, screenCoordinate, directPointLight\n} from 'three/tsl';\n\nexport const circleIntersectsAABB = /*@__PURE__*/ Fn( ( [ circleCenter, radius, minBounds, maxBounds ] ) => {\n\n\t// Find the closest point on the AABB to the circle's center using method chaining\n\tconst closestX = minBounds.x.max( circleCenter.x.min( maxBounds.x ) );\n\tconst closestY = minBounds.y.max( circleCenter.y.min( maxBounds.y ) );\n\n\t// Compute the distance between the circle's center and the closest point\n\tconst distX = circleCenter.x.sub( closestX );\n\tconst distY = circleCenter.y.sub( closestY );\n\n\t// Calculate the squared distance\n\tconst distSquared = distX.mul( distX ).add( distY.mul( distY ) );\n\n\treturn distSquared.lessThanEqual( radius.mul( radius ) );\n\n} ).setLayout( {\n\tname: 'circleIntersectsAABB',\n\ttype: 'bool',\n\tinputs: [\n\t\t{ name: 'circleCenter', type: 'vec2' },\n\t\t{ name: 'radius', type: 'float' },\n\t\t{ name: 'minBounds', type: 'vec2' },\n\t\t{ name: 'maxBounds', type: 'vec2' }\n\t]\n} );\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * A custom version of `LightsNode` implementing tiled lighting. This node is used in\n * {@link TiledLighting} to overwrite the renderer's default lighting with\n * a custom implementation.\n *\n * @augments LightsNode\n * @three_import import { tiledLights } from 'three/addons/tsl/lighting/TiledLightsNode.js';\n */\nclass TiledLightsNode extends LightsNode {\n\n\tstatic get type() {\n\n\t\treturn 'TiledLightsNode';\n\n\t}\n\n\t/**\n\t * Constructs a new tiled lights node.\n\t *\n\t * @param {number} [maxLights=1024] - The maximum number of lights.\n\t * @param {number} [tileSize=32] - The tile size.\n\t */\n\tconstructor( maxLights = 1024, tileSize = 32 ) {\n\n\t\tsuper();\n\n\t\tthis.materialLights = [];\n\t\tthis.tiledLights = [];\n\n\t\t/**\n\t\t * The maximum number of lights.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1024\n\t\t */\n\t\tthis.maxLights = maxLights;\n\n\t\t/**\n\t\t * The tile size.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 32\n\t\t */\n\t\tthis.tileSize = tileSize;\n\n\t\tthis._bufferSize = null;\n\t\tthis._lightIndexes = null;\n\t\tthis._screenTileIndex = null;\n\t\tthis._compute = null;\n\t\tthis._lightsTexture = null;\n\n\t\tthis._lightsCount = uniform( 0, 'int' );\n\t\tthis._tileLightCount = 8;\n\t\tthis._screenSize = uniform( new Vector2() );\n\t\tthis._cameraProjectionMatrix = uniform( 'mat4' );\n\t\tthis._cameraViewMatrix = uniform( 'mat4' );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tcustomCacheKey() {\n\n\t\treturn this._compute.getCacheKey() + super.customCacheKey();\n\n\t}\n\n\tupdateLightsTexture() {\n\n\t\tconst { _lightsTexture: lightsTexture, tiledLights } = this;\n\n\t\tconst data = lightsTexture.image.data;\n\t\tconst lineSize = lightsTexture.image.width * 4;\n\n\t\tthis._lightsCount.value = tiledLights.length;\n\n\t\tfor ( let i = 0; i < tiledLights.length; i ++ ) {\n\n\t\t\tconst light = tiledLights[ i ];\n\n\t\t\t// world position\n\n\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t// store data\n\n\t\t\tconst offset = i * 4;\n\n\t\t\tdata[ offset + 0 ] = _vector3.x;\n\t\t\tdata[ offset + 1 ] = _vector3.y;\n\t\t\tdata[ offset + 2 ] = _vector3.z;\n\t\t\tdata[ offset + 3 ] = light.distance;\n\n\t\t\tdata[ lineSize + offset + 0 ] = light.color.r * light.intensity;\n\t\t\tdata[ lineSize + offset + 1 ] = light.color.g * light.intensity;\n\t\t\tdata[ lineSize + offset + 2 ] = light.color.b * light.intensity;\n\t\t\tdata[ lineSize + offset + 3 ] = light.decay;\n\n\t\t}\n\n\t\tlightsTexture.needsUpdate = true;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, camera } = frame;\n\n\t\tthis.updateProgram( renderer );\n\n\t\tthis.updateLightsTexture( camera );\n\n\t\tthis._cameraProjectionMatrix.value = camera.projectionMatrix;\n\t\tthis._cameraViewMatrix.value = camera.matrixWorldInverse;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\t\tthis._screenSize.value.copy( _size );\n\n\t\trenderer.compute( this._compute );\n\n\t}\n\n\tsetLights( lights ) {\n\n\t\tconst { tiledLights, materialLights } = this;\n\n\t\tlet materialindex = 0;\n\t\tlet tiledIndex = 0;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isPointLight === true ) {\n\n\t\t\t\ttiledLights[ tiledIndex ++ ] = light;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialLights[ materialindex ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterialLights.length = materialindex;\n\t\ttiledLights.length = tiledIndex;\n\n\t\treturn super.setLights( materialLights );\n\n\t}\n\n\tgetBlock( block = 0 ) {\n\n\t\treturn this._lightIndexes.element( this._screenTileIndex.mul( int( 2 ).add( int( block ) ) ) );\n\n\t}\n\n\tgetTile( element ) {\n\n\t\telement = int( element );\n\n\t\tconst stride = int( 4 );\n\t\tconst tileOffset = element.div( stride );\n\t\tconst tileIndex = this._screenTileIndex.mul( int( 2 ) ).add( tileOffset );\n\n\t\treturn this._lightIndexes.element( tileIndex ).element( element.mod( stride ) );\n\n\t}\n\n\tgetLightData( index ) {\n\n\t\tindex = int( index );\n\n\t\tconst dataA = textureLoad( this._lightsTexture, ivec2( index, 0 ) );\n\t\tconst dataB = textureLoad( this._lightsTexture, ivec2( index, 1 ) );\n\n\t\tconst position = dataA.xyz;\n\t\tconst viewPosition = this._cameraViewMatrix.mul( position );\n\t\tconst distance = dataA.w;\n\t\tconst color = dataB.rgb;\n\t\tconst decay = dataB.w;\n\n\t\treturn {\n\t\t\tposition,\n\t\t\tviewPosition,\n\t\t\tdistance,\n\t\t\tcolor,\n\t\t\tdecay\n\t\t};\n\n\t}\n\n\tsetupLights( builder, lightNodes ) {\n\n\t\tthis.updateProgram( builder.renderer );\n\n\t\t//\n\n\t\tconst lightingModel = builder.context.reflectedLight;\n\n\t\t// force declaration order, before of the loop\n\t\tlightingModel.directDiffuse.toStack();\n\t\tlightingModel.directSpecular.toStack();\n\n\t\tsuper.setupLights( builder, lightNodes );\n\n\t\tFn( () => {\n\n\t\t\tLoop( this._tileLightCount, ( { i } ) => {\n\n\t\t\t\tconst lightIndex = this.getTile( i );\n\n\t\t\t\tIf( lightIndex.equal( int( 0 ) ), () => {\n\n\t\t\t\t\tBreak();\n\n\t\t\t\t} );\n\n\t\t\t\tconst { color, decay, viewPosition, distance } = this.getLightData( lightIndex.sub( 1 ) );\n\n\t\t\t\tbuilder.lightsNode.setupDirectLight( builder, this, directPointLight( {\n\t\t\t\t\tcolor,\n\t\t\t\t\tlightVector: viewPosition.sub( positionView ),\n\t\t\t\t\tcutoffDistance: distance,\n\t\t\t\t\tdecayExponent: decay\n\t\t\t\t} ) );\n\n\t\t\t} );\n\n\t\t}, 'void' )();\n\n\t}\n\n\tgetBufferFitSize( value ) {\n\n\t\tconst multiple = this.tileSize;\n\n\t\treturn Math.ceil( value / multiple ) * multiple;\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\twidth = this.getBufferFitSize( width );\n\t\theight = this.getBufferFitSize( height );\n\n\t\tif ( ! this._bufferSize || this._bufferSize.width !== width || this._bufferSize.height !== height ) {\n\n\t\t\tthis.create( width, height );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdateProgram( renderer ) {\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tconst width = this.getBufferFitSize( _size.width );\n\t\tconst height = this.getBufferFitSize( _size.height );\n\n\t\tif ( this._bufferSize === null ) {\n\n\t\t\tthis.create( width, height );\n\n\t\t} else if ( this._bufferSize.width !== width || this._bufferSize.height !== height ) {\n\n\t\t\tthis.create( width, height );\n\n\t\t}\n\n\t}\n\n\tcreate( width, height ) {\n\n\t\tconst { tileSize, maxLights } = this;\n\n\t\tconst bufferSize = new Vector2( width, height );\n\t\tconst lineSize = Math.floor( bufferSize.width / tileSize );\n\t\tconst count = Math.floor( ( bufferSize.width * bufferSize.height ) / tileSize );\n\n\t\t// buffers\n\n\t\tconst lightsData = new Float32Array( maxLights * 4 * 2 ); // 2048 lights, 4 elements(rgba), 2 components, 1 component per line (position, distance, color, decay)\n\t\tconst lightsTexture = new DataTexture( lightsData, lightsData.length / 8, 2, RGBAFormat, FloatType );\n\n\t\tconst lightIndexesArray = new Int32Array( count * 4 * 2 );\n\t\tconst lightIndexes = attributeArray( lightIndexesArray, 'ivec4' ).setName( 'lightIndexes' );\n\n\t\t// compute\n\n\t\tconst getBlock = ( index ) => {\n\n\t\t\tconst tileIndex = instanceIndex.mul( int( 2 ) ).add( int( index ) );\n\n\t\t\treturn lightIndexes.element( tileIndex );\n\n\t\t};\n\n\t\tconst getTile = ( elementIndex ) => {\n\n\t\t\telementIndex = int( elementIndex );\n\n\t\t\tconst stride = int( 4 );\n\t\t\tconst tileOffset = elementIndex.div( stride );\n\t\t\tconst tileIndex = instanceIndex.mul( int( 2 ) ).add( tileOffset );\n\n\t\t\treturn lightIndexes.element( tileIndex ).element( elementIndex.mod( stride ) );\n\n\t\t};\n\n\t\tconst compute = Fn( () => {\n\n\t\t\tconst { _cameraProjectionMatrix: cameraProjectionMatrix, _bufferSize: bufferSize, _screenSize: screenSize } = this;\n\n\t\t\tconst tiledBufferSize = bufferSize.clone().divideScalar( tileSize ).floor();\n\n\t\t\tconst tileScreen = vec2(\n\t\t\t\tinstanceIndex.mod( tiledBufferSize.width ),\n\t\t\t\tinstanceIndex.div( tiledBufferSize.width )\n\t\t\t).mul( tileSize ).div( screenSize );\n\n\t\t\tconst blockSize = float( tileSize ).div( screenSize );\n\t\t\tconst minBounds = tileScreen;\n\t\t\tconst maxBounds = minBounds.add( blockSize );\n\n\t\t\tconst index = int( 0 ).toVar();\n\n\t\t\tgetBlock( 0 ).assign( ivec4( 0 ) );\n\t\t\tgetBlock( 1 ).assign( ivec4( 0 ) );\n\n\t\t\tLoop( this.maxLights, ( { i } ) => {\n\n\t\t\t\tIf( index.greaterThanEqual( this._tileLightCount ).or( int( i ).greaterThanEqual( int( this._lightsCount ) ) ), () => {\n\n\t\t\t\t\tReturn();\n\n\t\t\t\t} );\n\n\t\t\t\tconst { viewPosition, distance } = this.getLightData( i );\n\n\t\t\t\tconst projectedPosition = cameraProjectionMatrix.mul( viewPosition );\n\t\t\t\tconst ndc = projectedPosition.div( projectedPosition.w );\n\t\t\t\tconst screenPosition = ndc.xy.mul( 0.5 ).add( 0.5 ).flipY();\n\n\t\t\t\tconst distanceFromCamera = viewPosition.z;\n\t\t\t\tconst pointRadius = distance.div( distanceFromCamera );\n\n\t\t\t\tIf( circleIntersectsAABB( screenPosition, pointRadius, minBounds, maxBounds ), () => {\n\n\t\t\t\t\tgetTile( index ).assign( i.add( int( 1 ) ) );\n\t\t\t\t\tindex.addAssign( int( 1 ) );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} )().compute( count );\n\n\t\t// screen coordinate lighting indexes\n\n\t\tconst screenTile = screenCoordinate.div( tileSize ).floor().toVar();\n\t\tconst screenTileIndex = screenTile.x.add( screenTile.y.mul( lineSize ) );\n\n\t\t// assigns\n\n\t\tthis._bufferSize = bufferSize;\n\t\tthis._lightIndexes = lightIndexes;\n\t\tthis._screenTileIndex = screenTileIndex;\n\t\tthis._compute = compute;\n\t\tthis._lightsTexture = lightsTexture;\n\n\t}\n\n\tget hasLights() {\n\n\t\treturn super.hasLights || this.tiledLights.length > 0;\n\n\t}\n\n}\n\nexport default TiledLightsNode;\n\nexport const tiledLights = /*@__PURE__*/ nodeProxy( TiledLightsNode );\n"],"mappings":"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","ignoreList":[]}