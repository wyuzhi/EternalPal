import{Vector3,Object3D,ShadowBaseNode,Plane,Line3,DepthTexture,LessCompare,Vector2,RedFormat,ArrayCamera,VSMShadowMap,RendererUtils,Quaternion}from"three/webgpu";import{min,Fn,shadow,NodeUpdateType,getShadowMaterial,getShadowRenderObjectFunction}from"three/tsl";const{resetRendererAndSceneState:resetRendererAndSceneState,restoreRendererAndSceneState:restoreRendererAndSceneState}=RendererUtils;let _rendererState;const _cameraLayers=[],_vec3Temp1=new Vector3,_vec3Temp2=new Vector3,_vec3Temp3=new Vector3,_quatTemp1=new Quaternion;class LwLight extends Object3D{constructor(){super(),this.target=new Object3D}}class TileShadowNode extends ShadowBaseNode{constructor(e,t={}){super(e),this.config={tilesX:t.tilesX||2,tilesY:t.tilesY||2,resolution:t.resolution||e.shadow.mapSize,debug:void 0!==t.debug&&t.debug},this.debug=this.config.debug,this.originalLight=e,this.lightPlane=new Plane(new Vector3(0,1,0),0),this.line=new Line3,this.initialLightDirection=new Vector3,this.updateLightDirection(),this._cameraFrameId=new WeakMap,this.shadowSize={top:e.shadow.camera.top,bottom:e.shadow.camera.bottom,left:e.shadow.camera.left,right:e.shadow.camera.right},this.lights=[],this._shadowNodes=[],this.tiles=this.generateTiles(this.config.tilesX,this.config.tilesY)}generateTiles(e,t){const a=[],s=1/e,o=1/t;for(let r=0;r<t;r++)for(let i=0;i<e;i++)a.push({x:[i*s,(i+1)*s],y:[(t-1-r)*o,(t-r)*o],index:r*e+i});return a}updateLightDirection(){this.initialLightDirection.subVectors(this.originalLight.target.getWorldPosition(new Vector3),this.originalLight.getWorldPosition(new Vector3)).normalize()}init(e){const t=this.originalLight,a=t.parent,s=this.shadowSize.right-this.shadowSize.left,o=this.shadowSize.top-this.shadowSize.bottom,r=this.tiles.length,i=this.config.resolution.width,h=this.config.resolution.height;this.disposeLightsAndNodes();const d=new DepthTexture(i,h,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,r);d.compareFunction=LessCompare,d.name="ShadowDepthArrayTexture";const n=e.createRenderTarget(i,h,{format:RedFormat,depth:r});n.depthTexture=d,n.texture.name="ShadowTexture",this.shadowMap=n;const c=[];for(let e=0;e<r;e++){const r=new LwLight;r.castShadow=!0;const i=t.shadow.clone();i.filterNode=t.shadow.filterNode;const h=this.tiles[e];i.camera.left=this.shadowSize.left+s*h.x[0],i.camera.right=this.shadowSize.left+s*h.x[1],i.camera.top=this.shadowSize.bottom+o*h.y[1],i.camera.bottom=this.shadowSize.bottom+o*h.y[0],i.bias=t.shadow.bias,i.camera.near=t.shadow.camera.near,i.camera.far=t.shadow.camera.far,i.camera.userData.tileIndex=e,r.shadow=i,a?(a.add(r),a.add(r.target)):console.warn("TileShadowNode: Original light has no parent during init. Tile lights not added to scene graph directly."),this.syncLightTransformation(r,t),this.lights.push(r),i.camera.updateMatrixWorld(),c.push(i.camera);const l=shadow(r,i);l.depthLayer=e,l.updateBeforeType=NodeUpdateType.NONE,l.setupRenderTarget=()=>({shadowMap:n,depthTexture:d}),this._shadowNodes.push(l)}const l=new ArrayCamera(c);this.cameraArray=l}update(){const e=this.originalLight,t=e.shadow.camera,a=new Vector2(t.left,t.bottom),s=new Vector2(t.right,t.top),o=s.x-a.x,r=s.y-a.y;for(let t=0;t<this.lights.length;t++){const s=this.lights[t],i=this.tiles[t];this.syncLightTransformation(s,e);const h=s.shadow,d=a.x+i.x[0]*o,n=a.x+i.x[1]*o,c=a.y+i.y[0]*r,l=a.y+i.y[1]*r;h.camera.left=d,h.camera.right=n,h.camera.bottom=c,h.camera.top=l,h.camera.near=e.shadow.camera.near,h.camera.far=e.shadow.camera.far,h.camera.updateProjectionMatrix(),h.camera.updateWorldMatrix(!0,!1),h.camera.updateMatrixWorld(!0),this._shadowNodes[t].shadow.needsUpdate=!0}}updateShadow(e){const{shadowMap:t,light:a}=this,{renderer:s,scene:o,camera:r}=e,i=s.shadowMap.type,h=t.depthTexture.version;this._depthVersionCached=h;const d=s.getRenderObjectFunction(),n=s.getMRT(),c=!!n&&n.has("velocity");_rendererState=resetRendererAndSceneState(s,o,_rendererState),o.overrideMaterial=getShadowMaterial(a),s.setRenderTarget(this.shadowMap);for(let e=0;e<this.lights.length;e++){const a=this.lights[e],o=a.shadow,h=o.camera.layers.mask;_cameraLayers.push(h),0==(4294967294&o.camera.layers.mask)&&(o.camera.layers.mask=r.layers.mask),o.updateMatrices(a),s.setRenderObjectFunction(getShadowRenderObjectFunction(s,o,i,c)),this.shadowMap.setSize(o.mapSize.width,o.mapSize.height,t.depth)}s.render(o,this.cameraArray),s.setRenderObjectFunction(d),!0!==a.isPointLight&&i===VSMShadowMap&&console.warn("THREE.TileShadowNode: VSM shadow map is not supported yet."),restoreRendererAndSceneState(s,o,_rendererState);for(let e=0;e<this.lights.length;e++){this.lights[e].shadow.camera.layers.mask=_cameraLayers[e]}_cameraLayers.length=0}updateBefore(e){const t=this.originalLight.shadow;let a=t.needsUpdate||t.autoUpdate;a&&(this._cameraFrameId[e.camera]===e.frameId&&(a=!1),this._cameraFrameId[e.camera]=e.frameId),a&&(this.update(),this.updateShadow(e),this.shadowMap.depthTexture.version===this._depthVersionCached&&(t.needsUpdate=!1))}syncLightTransformation(e,t){const a=t.getWorldPosition(_vec3Temp1),s=t.target.getWorldPosition(_vec3Temp2),o=_vec3Temp3.subVectors(s,a),r=o.length();o.normalize(),e.position.copy(a),e.target.position.copy(a).add(o.multiplyScalar(r)),e.quaternion.copy(t.getWorldQuaternion(_quatTemp1)),e.scale.copy(t.scale),e.updateMatrix(),e.updateMatrixWorld(!0),e.target.updateMatrix(),e.target.updateMatrixWorld(!0)}setup(e){return 0===this.lights.length&&this.init(e),Fn((e=>(this.setupShadowPosition(e),min(...this._shadowNodes).toVar("shadowValue"))))()}disposeLightsAndNodes(){for(const e of this.lights){const t=e.parent;t&&(t.remove(e.target),t.remove(e))}this.lights=[],this._shadowNodes=[],this.shadowMap&&(this.shadowMap.dispose(),this.shadowMap=null)}dispose(){this.disposeLightsAndNodes(),super.dispose()}}export{TileShadowNode};
//# sourceMappingURL=TileShadowNode.js.map