{"version":3,"file":"node_modules/three/examples/jsm/tsl/shadows/TileShadowNode.js","names":["Vector3","Object3D","ShadowBaseNode","Plane","Line3","DepthTexture","LessCompare","Vector2","RedFormat","ArrayCamera","VSMShadowMap","RendererUtils","Quaternion","min","Fn","shadow","NodeUpdateType","getShadowMaterial","getShadowRenderObjectFunction","resetRendererAndSceneState","restoreRendererAndSceneState","_rendererState","_cameraLayers","_vec3Temp1","_vec3Temp2","_vec3Temp3","_quatTemp1","LwLight","constructor","super","this","target","TileShadowNode","light","options","config","tilesX","tilesY","resolution","mapSize","debug","undefined","originalLight","lightPlane","line","initialLightDirection","updateLightDirection","_cameraFrameId","WeakMap","shadowSize","top","camera","bottom","left","right","lights","_shadowNodes","tiles","generateTiles","tileWidth","tileHeight","y","x","push","index","subVectors","getWorldPosition","normalize","init","builder","parent","width","height","tileCount","length","shadowWidth","shadowHeight","disposeLightsAndNodes","depthTexture","compareFunction","name","shadowMap","createRenderTarget","format","depth","texture","cameras","i","lwLight","castShadow","lShadow","clone","filterNode","tile","bias","near","far","userData","tileIndex","add","console","warn","syncLightTransformation","updateMatrixWorld","shadowNode","depthLayer","updateBeforeType","NONE","setupRenderTarget","cameraArray","update","shadowCam","lsMin","lsMax","fullWidth","fullHeight","tileLeft","tileRight","tileBottom","tileTop","updateProjectionMatrix","updateWorldMatrix","needsUpdate","updateShadow","frame","renderer","scene","shadowType","type","depthVersion","version","_depthVersionCached","currentRenderObjectFunction","getRenderObjectFunction","currentMRT","getMRT","useVelocity","has","overrideMaterial","setRenderTarget","_shadowCameraLayer","layers","mask","updateMatrices","setRenderObjectFunction","setSize","render","isPointLight","updateBefore","autoUpdate","frameId","sourceLight","sourceWorldPos","targetWorldPos","forward","targetDistance","position","copy","multiplyScalar","quaternion","getWorldQuaternion","scale","updateMatrix","setup","setupShadowPosition","toVar","remove","dispose"],"sources":["node_modules/three/examples/jsm/tsl/shadows/TileShadowNode.js"],"sourcesContent":["import {\n\tVector3,\n\tObject3D,\n\tShadowBaseNode,\n\tPlane,\n\tLine3,\n\tDepthTexture,\n\tLessCompare,\n\tVector2,\n\tRedFormat,\n\tArrayCamera,\n\tVSMShadowMap,\n\tRendererUtils,\n\tQuaternion\n} from 'three/webgpu';\n\nimport { min, Fn, shadow, NodeUpdateType, getShadowMaterial, getShadowRenderObjectFunction } from 'three/tsl';\n\nconst { resetRendererAndSceneState, restoreRendererAndSceneState } = RendererUtils;\nlet _rendererState;\n\nconst _cameraLayers = [];\nconst _vec3Temp1 = /*@__PURE__*/ new Vector3();\nconst _vec3Temp2 = /*@__PURE__*/ new Vector3();\nconst _vec3Temp3 = /*@__PURE__*/ new Vector3();\nconst _quatTemp1 = /*@__PURE__*/ new Quaternion();\n\nclass LwLight extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.target = new Object3D();\n\n\t}\n\n}\n\n/**\n * A class that extends `ShadowBaseNode` to implement tiled shadow mapping.\n * This allows splitting a shadow map into multiple tiles, each with its own light and camera,\n * to improve shadow quality and performance for large scenes.\n *\n * **Note:** This class does not support `VSMShadowMap` at the moment.\n *\n * @class\n * @augments ShadowBaseNode\n * @three_import import { TileShadowNode } from 'three/addons/tsl/shadows/TileShadowNode.js';\n */\nclass TileShadowNode extends ShadowBaseNode {\n\n\t/**\n\t * Creates an instance of `TileShadowNode`.\n\t *\n\t * @param {Light} light - The original light source used for shadow mapping.\n\t * @param {Object} [options={}] - Configuration options for the tiled shadow node.\n\t * @param {number} [options.tilesX=2] - The number of tiles along the X-axis.\n\t * @param {number} [options.tilesY=2] - The number of tiles along the Y-axis.\n\t * @param {Object} [options.resolution] - The resolution of the shadow map.\n\t * @param {boolean} [options.debug=false] - Whether to enable debug mode.\n\t */\n\tconstructor( light, options = {} ) {\n\n\t\tsuper( light );\n\n\t\t// Default configuration with sensible defaults\n\t\tthis.config = {\n\t\t\ttilesX: options.tilesX || 2,\n\t\t\ttilesY: options.tilesY || 2,\n\t\t\tresolution: options.resolution || light.shadow.mapSize,\n\t\t\tdebug: options.debug !== undefined ? options.debug : false\n\t\t};\n\n\t\tthis.debug = this.config.debug;\n\n\t\tthis.originalLight = light;\n\t\tthis.lightPlane = new Plane( new Vector3( 0, 1, 0 ), 0 );\n\t\tthis.line = new Line3();\n\n\t\tthis.initialLightDirection = new Vector3();\n\t\tthis.updateLightDirection();\n\n\t\tthis._cameraFrameId = new WeakMap();\n\n\t\tthis.shadowSize = {\n\t\t\ttop: light.shadow.camera.top,\n\t\t\tbottom: light.shadow.camera.bottom,\n\t\t\tleft: light.shadow.camera.left,\n\t\t\tright: light.shadow.camera.right,\n\t\t};\n\n\t\tthis.lights = [];\n\t\tthis._shadowNodes = [];\n\n\t\tthis.tiles = this.generateTiles( this.config.tilesX, this.config.tilesY );\n\n\t}\n\n\t/**\n\t * Generates the tiles for the shadow map based on the specified number of tiles along the X and Y axes.\n\t *\n\t * @param {number} tilesX - The number of tiles along the X-axis.\n\t * @param {number} tilesY - The number of tiles along the Y-axis.\n\t * @returns {Array<Object>} An array of tile objects, each containing the tile's bounds and index.\n\t */\n\tgenerateTiles( tilesX, tilesY ) {\n\n\t\tconst tiles = [];\n\t\tconst tileWidth = 1 / tilesX;\n\t\tconst tileHeight = 1 / tilesY;\n\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\n\n\t\t\t\ttiles.push( {\n\t\t\t\t\tx: [ x * tileWidth, ( x + 1 ) * tileWidth ],\n\t\t\t\t\ty: [ ( tilesY - 1 - y ) * tileHeight, ( tilesY - y ) * tileHeight ], // Start from top row\n\t\t\t\t\tindex: y * tilesX + x\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn tiles;\n\n\t}\n\n\t/**\n\t * Updates the initial light direction based on the light's target position.\n\t */\n\tupdateLightDirection() {\n\n\t\tthis.initialLightDirection.subVectors(\n\t\t\tthis.originalLight.target.getWorldPosition( new Vector3() ),\n\t\t\tthis.originalLight.getWorldPosition( new Vector3() )\n\t\t).normalize();\n\n\t}\n\n\t/**\n\t * Initializes the tiled shadow node by creating lights, cameras, and shadow maps for each tile.\n\t *\n\t * @param {Builder} builder - The builder used to create render targets and other resources.\n\t */\n\tinit( builder ) {\n\n\t\tconst light = this.originalLight;\n\t\tconst parent = light.parent;\n\n\t\tconst width = this.shadowSize.right - this.shadowSize.left;\n\t\tconst height = this.shadowSize.top - this.shadowSize.bottom;\n\n\t\tconst tileCount = this.tiles.length;\n\t\tconst shadowWidth = this.config.resolution.width;\n\t\tconst shadowHeight = this.config.resolution.height;\n\n\t\t// Clear existing lights/nodes if re-initializing\n\t\tthis.disposeLightsAndNodes();\n\n\t\tconst depthTexture = new DepthTexture( shadowWidth, shadowHeight, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, tileCount );\n\t\tdepthTexture.compareFunction = LessCompare;\n\t\tdepthTexture.name = 'ShadowDepthArrayTexture';\n\t\tconst shadowMap = builder.createRenderTarget( shadowWidth, shadowHeight, { format: RedFormat, depth: tileCount } );\n\t\tshadowMap.depthTexture = depthTexture;\n\t\tshadowMap.texture.name = 'ShadowTexture';\n\t\tthis.shadowMap = shadowMap;\n\t\tconst cameras = [];\n\n\n\t\t// Create lights, one for each tile\n\t\tfor ( let i = 0; i < tileCount; i ++ ) {\n\n\t\t\tconst lwLight = new LwLight();\n\t\t\tlwLight.castShadow = true;\n\t\t\tconst lShadow = light.shadow.clone();\n\t\t\tlShadow.filterNode = light.shadow.filterNode;\n\t\t\tconst tile = this.tiles[ i ];\n\t\t\tlShadow.camera.left = this.shadowSize.left + width * tile.x[ 0 ];\n\t\t\tlShadow.camera.right = this.shadowSize.left + width * tile.x[ 1 ];\n\t\t\tlShadow.camera.top = this.shadowSize.bottom + height * tile.y[ 1 ];\n\t\t\tlShadow.camera.bottom = this.shadowSize.bottom + height * tile.y[ 0 ];\n\t\t\tlShadow.bias = light.shadow.bias;\n\t\t\tlShadow.camera.near = light.shadow.camera.near;\n\t\t\tlShadow.camera.far = light.shadow.camera.far;\n\t\t\tlShadow.camera.userData.tileIndex = i;\n\t\t\tlwLight.shadow = lShadow;\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.add( lwLight );\n\t\t\t\tparent.add( lwLight.target );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'TileShadowNode: Original light has no parent during init. Tile lights not added to scene graph directly.' );\n\n\t\t\t}\n\n\t\t\tthis.syncLightTransformation( lwLight, light );\n\n\t\t\tthis.lights.push( lwLight );\n\t\t\tlShadow.camera.updateMatrixWorld();\n\n\t\t\tcameras.push( lShadow.camera );\n\t\t\tconst shadowNode = shadow( lwLight, lShadow );\n\t\t\tshadowNode.depthLayer = i;\n\t\t\tshadowNode.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t\tshadowNode.setupRenderTarget = () => {\n\n\t\t\t\treturn { shadowMap, depthTexture };\n\n\t\t\t};\n\n\t\t\tthis._shadowNodes.push( shadowNode );\n\n\t\t}\n\n\t\tconst cameraArray = new ArrayCamera( cameras );\n\t\tthis.cameraArray = cameraArray;\n\n\t}\n\n\t/**\n\t * Updates the light transformations and shadow cameras for each tile.\n\t */\n\tupdate() {\n\n\t\tconst light = this.originalLight;\n\n\t\tconst shadowCam = light.shadow.camera;\n\t\tconst lsMin = new Vector2( shadowCam.left, shadowCam.bottom );\n\t\tconst lsMax = new Vector2( shadowCam.right, shadowCam.top );\n\t\tconst fullWidth = lsMax.x - lsMin.x;\n\t\tconst fullHeight = lsMax.y - lsMin.y;\n\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\n\n\t\t\tconst lwLight = this.lights[ i ];\n\t\t\tconst tile = this.tiles[ i ];\n\t\t\tthis.syncLightTransformation( lwLight, light );\n\t\t\tconst lShadow = lwLight.shadow;\n\t\t\tconst tileLeft = lsMin.x + tile.x[ 0 ] * fullWidth;\n\t\t\tconst tileRight = lsMin.x + tile.x[ 1 ] * fullWidth;\n\t\t\tconst tileBottom = lsMin.y + tile.y[ 0 ] * fullHeight;\n\t\t\tconst tileTop = lsMin.y + tile.y[ 1 ] * fullHeight;\n\t\t\tlShadow.camera.left = tileLeft;\n\t\t\tlShadow.camera.right = tileRight;\n\t\t\tlShadow.camera.bottom = tileBottom;\n\t\t\tlShadow.camera.top = tileTop;\n\t\t\tlShadow.camera.near = light.shadow.camera.near;\n\t\t\tlShadow.camera.far = light.shadow.camera.far;\n\t\t\tlShadow.camera.updateProjectionMatrix();\n\t\t\tlShadow.camera.updateWorldMatrix( true, false );\n\t\t\tlShadow.camera.updateMatrixWorld( true );\n\t\t\tthis._shadowNodes[ i ].shadow.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n     * Updates the shadow map rendering.\n     * @param {NodeFrame} frame - A reference to the current node frame.\n     */\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\t\tconst shadowType = renderer.shadowMap.type;\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;\n\n\t\t_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\t\trenderer.setRenderTarget( this.shadowMap );\n\n\n\t\tfor ( let index = 0; index < this.lights.length; index ++ ) {\n\n\t\t\tconst light = this.lights[ index ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tconst _shadowCameraLayer = shadow.camera.layers.mask;\n\t\t\t_cameraLayers.push( _shadowCameraLayer );\n\n\t\t\tif ( ( shadow.camera.layers.mask & 0xFFFFFFFE ) === 0 ) {\n\n\t\t\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\t\t}\n\n\t\t\tshadow.updateMatrices( light );\n\n\t\t\trenderer.setRenderObjectFunction( getShadowRenderObjectFunction( renderer, shadow, shadowType, useVelocity ) );\n\t\t\tthis.shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height, shadowMap.depth );\n\n\t\t}\n\n\t\trenderer.render( scene, this.cameraArray );\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\tif ( light.isPointLight !== true && shadowType === VSMShadowMap ) {\n\n\t\t\tconsole.warn( 'THREE.TileShadowNode: VSM shadow map is not supported yet.' );\n\t\t\t// this.vsmPass( renderer );\n\n\t\t}\n\n\t\trestoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\tfor ( let index = 0; index < this.lights.length; index ++ ) {\n\n\t\t\tconst light = this.lights[ index ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tshadow.camera.layers.mask = _cameraLayers[ index ];\n\n\t\t}\n\n\t\t_cameraLayers.length = 0;\n\n\t}\n\n\t/**\n\t * The implementation performs the update of the shadow map if necessary.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst shadow = this.originalLight.shadow;\n\n\t\tlet needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tif ( this._cameraFrameId[ frame.camera ] === frame.frameId ) {\n\n\t\t\t\tneedsUpdate = false;\n\n\t\t\t}\n\n\t\t\tthis._cameraFrameId[ frame.camera ] = frame.frameId;\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.update();\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Synchronizes the transformation of a tile light with the source light.\n\t *\n\t * @param {LwLight} lwLight - The tile light to synchronize.\n\t * @param {Light} sourceLight - The source light to copy transformations from.\n\t */\n\tsyncLightTransformation( lwLight, sourceLight ) {\n\n\t\tconst sourceWorldPos = sourceLight.getWorldPosition( _vec3Temp1 );\n\t\tconst targetWorldPos = sourceLight.target.getWorldPosition( _vec3Temp2 );\n\t\tconst forward = _vec3Temp3.subVectors( targetWorldPos, sourceWorldPos );\n\t\tconst targetDistance = forward.length();\n\t\tforward.normalize();\n\t\tlwLight.position.copy( sourceWorldPos );\n\t\tlwLight.target.position.copy( sourceWorldPos ).add( forward.multiplyScalar( targetDistance ) );\n\t\tlwLight.quaternion.copy( sourceLight.getWorldQuaternion( _quatTemp1 ) );\n\t\tlwLight.scale.copy( sourceLight.scale );\n\t\tlwLight.updateMatrix();\n\t\tlwLight.updateMatrixWorld( true );\n\t\tlwLight.target.updateMatrix();\n\t\tlwLight.target.updateMatrixWorld( true );\n\n\t}\n\n\t/**\n\t * Sets up the shadow node for rendering.\n\t *\n\t * @param {Builder} builder - The builder used to set up the shadow node.\n\t * @returns {Node} A node representing the shadow value.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.lights.length === 0 ) {\n\n\t\t\tthis.init( builder );\n\n\t\t}\n\n\t\treturn Fn( ( builder ) => {\n\n\t\t\tthis.setupShadowPosition( builder );\n\t\t\treturn min( ...this._shadowNodes ).toVar( 'shadowValue' );\n\n\t\t} )();\n\n\t}\n\n\t/**\n     * Helper method to remove lights and associated nodes/targets.\n     * Used internally during dispose and potential re-initialization.\n     */\n\tdisposeLightsAndNodes() {\n\n\t\tfor ( const light of this.lights ) {\n\n\t\t\tconst parent = light.parent;\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( light.target );\n\t\t\t\tparent.remove( light );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.lights = [];\n\t\tthis._shadowNodes = [];\n\n\t\tif ( this.shadowMap ) {\n\n\t\t\tthis.shadowMap.dispose(); // Disposes render target and textures\n\t\t\tthis.shadowMap = null;\n\n\t\t}\n\n\t}\n\n\n\tdispose() {\n\n\t\t// Dispose lights, nodes, and shadow map\n\t\tthis.disposeLightsAndNodes();\n\t\tsuper.dispose();\n\n\t}\n\n}\n\nexport { TileShadowNode };\n"],"mappings":"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","ignoreList":[]}