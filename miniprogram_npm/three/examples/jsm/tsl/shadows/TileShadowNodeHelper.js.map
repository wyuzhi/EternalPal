{"version":3,"file":"node_modules/three/examples/jsm/tsl/shadows/TileShadowNodeHelper.js","names":["Group","NodeMaterial","Mesh","PlaneGeometry","DoubleSide","CameraHelper","Fn","vec4","vec3","texture","uv","positionLocal","vec2","float","screenSize","TileShadowNodeHelper","constructor","tileShadowNode","super","Error","this","config","tiles","_debugMeshes","_shadowCamHelpers","initialized","init","_shadowNodes","length","console","error","tilesX","tilesY","dispose","i","display","renderOrder","material","transparent","frustumCulled","side","depthTest","depthWrite","col","row","Math","floor","vertexNode","aspectRatio","x","div","y","maxTiles","max","displaySize","margin","cornerOffset","xBase","add","mul","yBase","sub","scaledPos","finalPos","outputNode","shadowMap","depthTexture","sampledDepth","sample","flipY","depth","compare","r","g","b","saturate","rgb","push","shadow","camHelper","camera","fog","warn","update","helper","updateMatrixWorld","scene","mesh","geometry","remove"],"sources":["node_modules/three/examples/jsm/tsl/shadows/TileShadowNodeHelper.js"],"sourcesContent":["import { Group, NodeMaterial, Mesh, PlaneGeometry, DoubleSide, CameraHelper } from 'three/webgpu';\nimport { Fn, vec4, vec3, texture, uv, positionLocal, vec2, float, screenSize } from 'three/tsl';\n\n/**\n * Helper class to manage and display debug visuals for TileShadowNode.\n *\n * @augments Group\n * @three_import import { TileShadowNodeHelper } from 'three/addons/tsl/shadows/TileShadowNodeHelper.js';\n */\nclass TileShadowNodeHelper extends Group {\n\n\t/**\n\t * @param {TileShadowNode} tileShadowNode The TileShadowNode instance to debug.\n\t */\n\tconstructor( tileShadowNode ) {\n\n\t\tsuper();\n\n\t\tif ( ! tileShadowNode ) {\n\n\t\t\tthrow new Error( 'TileShadowNode instance is required for TileShadowNodeHelper.' );\n\n\t\t}\n\n\t\tthis.tileShadowNode = tileShadowNode;\n\t\tthis.config = tileShadowNode.config;\n\t\tthis.tiles = tileShadowNode.tiles;\n\t\tthis._debugMeshes = [];\n\t\tthis._shadowCamHelpers = [];\n\n\t\tthis.initialized = false;\n\n\t}\n\n\t/**\n\t * Initializes the debug displays (planes and camera helpers).\n\t * Should be called after TileShadowNode has initialized its lights and shadow nodes.\n\t */\n\tinit() {\n\n\t\tif ( this.tileShadowNode._shadowNodes.length !== this.tiles.length ) {\n\n\t\t\tconsole.error( 'Cannot initialize TileShadowNodeHelper: Shadow nodes not ready or mismatch count.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst tilesX = this.config.tilesX;\n\t\tconst tilesY = this.config.tilesY;\n\n\t\t// Clear previous helpers if any (e.g., during a re-init)\n\t\tthis.dispose();\n\n\t\t// Create a display for each shadow map tile\n\t\tfor ( let i = 0; i < this.tiles.length; i ++ ) {\n\n\t\t\t// Create display plane\n\t\t\tconst display = new Mesh( new PlaneGeometry( 1, 1 ), new NodeMaterial() );\n\t\t\tdisplay.renderOrder = 9999999; // Ensure they appear on top\n\t\t\tdisplay.material.transparent = true;\n\t\t\tdisplay.frustumCulled = false;\n\t\t\tdisplay.side = DoubleSide;\n\t\t\tdisplay.material.depthTest = false; // Disable depth testing\n\t\t\tdisplay.material.depthWrite = false; // Disable depth writing\n\n\t\t\tconst col = i % tilesX;\n\t\t\tconst row = Math.floor( i / tilesX );\n\n\t\t\t// Vertex shader logic for positioning the debug quad\n\t\t\tdisplay.material.vertexNode = Fn( () => {\n\n\t\t\t\tconst aspectRatio = screenSize.x.div( screenSize.y );\n\t\t\t\tconst maxTiles = Math.max( tilesX, tilesY );\n\t\t\t\tconst displaySize = float( 0.8 / maxTiles ); // Size adapts to number of tiles\n\t\t\t\tconst margin = float( 0.01 );\n\t\t\t\tconst cornerOffset = float( 0.05 );\n\n\t\t\t\t// Position tiles left-to-right, top-to-bottom\n\t\t\t\tconst xBase = float( - 1.0 ).add( cornerOffset ).add(\n\t\t\t\t\tdisplaySize.div( 2 ).div( aspectRatio )\n\t\t\t\t).add( float( col ).mul( displaySize.div( aspectRatio ).add( margin ) ) );\n\n\t\t\t\tconst yBase = float( 1.0 ).sub( cornerOffset ).sub(\n\t\t\t\t\tdisplaySize.div( 2 )\n\t\t\t\t).sub( float( row ).mul( displaySize.add( margin ) ) );\n\n\t\t\t\tconst scaledPos = vec2(\n\t\t\t\t\tpositionLocal.x.mul( displaySize.div( aspectRatio ) ),\n\t\t\t\t\tpositionLocal.y.mul( displaySize )\n\t\t\t\t);\n\n\t\t\t\tconst finalPos = vec2(\n\t\t\t\t\tscaledPos.x.add( xBase ),\n\t\t\t\t\tscaledPos.y.add( yBase )\n\t\t\t\t);\n\n\t\t\t\treturn vec4( finalPos.x, finalPos.y, 0.0, 1.0 );\n\n\t\t\t} )();\n\n\t\t\tdisplay.material.outputNode = Fn( () => {\n\n\t\t\t\t// Ensure shadowMap and depthTexture are available\n\t\t\t\tif ( ! this.tileShadowNode.shadowMap || ! this.tileShadowNode.shadowMap.depthTexture ) {\n\n\t\t\t\t\treturn vec4( 1, 0, 1, 1 ); // Magenta error color\n\n\t\t\t\t}\n\n\t\t\t\tconst sampledDepth = texture( this.tileShadowNode.shadowMap.depthTexture )\n\t\t\t\t\t.sample( uv().flipY() )\n\t\t\t\t\t.depth( float( i ) ) // Sample correct layer\n\t\t\t\t\t.compare( 0.9 ); // Example comparison value\n\n\t\t\t\t// Simple tint based on index for visual distinction\n\t\t\t\tconst r = float( 0.5 + ( i % 3 ) * 0.16 );\n\t\t\t\tconst g = float( 0.5 + ( i % 2 ) * 0.25 );\n\t\t\t\tconst b = float( 0.7 + ( i % 4 ) * 0.075 );\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tvec3( r, g, b )\n\t\t\t\t\t\t.mul( sampledDepth )\n\t\t\t\t\t\t.saturate()\n\t\t\t\t\t\t.rgb,\n\t\t\t\t\t1.0\n\t\t\t\t);\n\n\t\t\t} )();\n\n\t\t\tthis.add( display );\n\t\t\tthis._debugMeshes.push( display );\n\n\t\t\tif ( this.tileShadowNode._shadowNodes[ i ] && this.tileShadowNode._shadowNodes[ i ].shadow ) {\n\n\t\t\t\tconst camHelper = new CameraHelper( this.tileShadowNode._shadowNodes[ i ].shadow.camera );\n\t\t\t\tcamHelper.fog = false;\n\t\t\t\tthis.add( camHelper );\n\t\t\t\tthis._shadowCamHelpers.push( camHelper );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `TileShadowNodeHelper: Could not create CameraHelper for tile index ${i}. Shadow node or camera missing.` );\n\t\t\t\tthis._shadowCamHelpers.push( null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.initialized = true;\n\n\t}\n\n\t/**\n\t * Updates the debug visuals (specifically camera helpers).\n\t * Should be called within TileShadowNode's update method.\n\t */\n\tupdate() {\n\n\t\tif ( this.initialized === false ) {\n\n\t\t\tthis.init();\n\n\t\t}\n\n\t\tfor ( const helper of this._shadowCamHelpers ) {\n\n\t\t\tif ( helper ) {\n\n\t\t\t\thelper.update(); // Update CameraHelper matrices\n\t\t\t\thelper.updateMatrixWorld( true ); // Ensure world matrix is current\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes all debug objects (planes and helpers) from the scene.\n\t */\n\tdispose() {\n\n\t\tif ( this.scene ) {\n\n\t\t\tfor ( const mesh of this._debugMeshes ) {\n\n\t\t\t\tmesh.geometry.dispose();\n\t\t\t\tmesh.material.dispose();\n\t\t\t\tthis.scene.remove( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( const helper of this._shadowCamHelpers ) {\n\n\t\t\t\tif ( helper ) {\n\n\t\t\t\t\tthis.scene.remove( helper );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._debugMeshes = [];\n\t\tthis._shadowCamHelpers = [];\n\n\t}\n\n}\n\nexport { TileShadowNodeHelper };\n"],"mappings":"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","ignoreList":[]}