{"version":3,"file":"node_modules/three/examples/jsm/tsl/utils/Raymarching.js","names":["varying","vec4","modelWorldMatrixInverse","cameraPosition","positionGeometry","float","Fn","Loop","max","min","vec2","vec3","hitBox","orig","dir","box_min","box_max","inv_dir","reciprocal","tmin_tmp","sub","mul","tmax_tmp","tmin","tmax","t0","x","y","z","t1","RaymarchingBox","steps","callback","vOrigin","rayDir","normalize","bounds","toVar","greaterThan","discard","assign","inc","abs","delta","divAssign","positionRay","add","type","start","end","update","addAssign"],"sources":["node_modules/three/examples/jsm/tsl/utils/Raymarching.js"],"sourcesContent":["import { varying, vec4, modelWorldMatrixInverse, cameraPosition, positionGeometry, float, Fn, Loop, max, min, vec2, vec3 } from 'three/tsl';\n\n/**\n * @module Raymarching\n * @three_import import { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';\n */\n\nconst hitBox = /*@__PURE__*/ Fn( ( { orig, dir } ) => {\n\n\tconst box_min = vec3( - 0.5 );\n\tconst box_max = vec3( 0.5 );\n\n\tconst inv_dir = dir.reciprocal();\n\n\tconst tmin_tmp = box_min.sub( orig ).mul( inv_dir );\n\tconst tmax_tmp = box_max.sub( orig ).mul( inv_dir );\n\n\tconst tmin = min( tmin_tmp, tmax_tmp );\n\tconst tmax = max( tmin_tmp, tmax_tmp );\n\n\tconst t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\tconst t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\treturn vec2( t0, t1 );\n\n} );\n\n/**\n * TSL function for performing raymarching in a box-area using the specified number of steps\n * and a callback function.\n *\n * ```js\n * RaymarchingBox( count, ( { positionRay } ) => {\n *\n * } );\n * ```\n *\n * @tsl\n * @function\n * @param {number|Node} steps - The number of steps for raymarching.\n * @param {Function|FunctionNode} callback - The callback function to execute at each step.\n */\nexport const RaymarchingBox = ( steps, callback ) => {\n\n\tconst vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );\n\tconst vDirection = varying( positionGeometry.sub( vOrigin ) );\n\n\tconst rayDir = vDirection.normalize();\n\tconst bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();\n\n\tbounds.x.greaterThan( bounds.y ).discard();\n\n\tbounds.assign( vec2( max( bounds.x, 0.0 ), bounds.y ) );\n\n\tconst inc = vec3( rayDir.abs().reciprocal() ).toVar();\n\tconst delta = float( min( inc.x, min( inc.y, inc.z ) ) ).toVar();\n\n\tdelta.divAssign( float( steps ) );\n\n\tconst positionRay = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();\n\n\tLoop( { type: 'float', start: bounds.x, end: bounds.y, update: delta }, () => {\n\n\t\tcallback( { positionRay } );\n\n\t\tpositionRay.addAssign( rayDir.mul( delta ) );\n\n\t} );\n\n};\n"],"mappings":"OAASA,QAASC,KAAMC,wBAAyBC,eAAgBC,iBAAkBC,MAAOC,GAAIC,KAAMC,IAAKC,IAAKC,KAAMC,SAAY,YAOhI,MAAMC,OAAuBN,IAAI,EAAIO,OAAMC,UAE1C,MAAMC,EAAUJ,MAAQ,IAClBK,EAAUL,KAAM,IAEhBM,EAAUH,EAAII,aAEdC,EAAWJ,EAAQK,IAAKP,GAAOQ,IAAKJ,GACpCK,EAAWN,EAAQI,IAAKP,GAAOQ,IAAKJ,GAEpCM,EAAOd,IAAKU,EAAUG,GACtBE,EAAOhB,IAAKW,EAAUG,GAEtBG,EAAKjB,IAAKe,EAAKG,EAAGlB,IAAKe,EAAKI,EAAGJ,EAAKK,IACpCC,EAAKpB,IAAKe,EAAKE,EAAGjB,IAAKe,EAAKG,EAAGH,EAAKI,IAE1C,OAAOlB,KAAMe,EAAII,EAAI,WAmBf,MAAMC,eAAiB,CAAEC,EAAOC,KAEtC,MAAMC,EAAUjC,QAASW,KAAMT,wBAAwBmB,IAAKpB,KAAME,eAAgB,MAG5E+B,EAFalC,QAASI,iBAAiBgB,IAAKa,IAExBE,YACpBC,EAAS1B,KAAME,OAAQ,CAAEC,KAAMoB,EAASnB,IAAKoB,KAAaG,QAEhED,EAAOV,EAAEY,YAAaF,EAAOT,GAAIY,UAEjCH,EAAOI,OAAQ9B,KAAMF,IAAK4B,EAAOV,EAAG,GAAOU,EAAOT,IAElD,MAAMc,EAAM9B,KAAMuB,EAAOQ,MAAMxB,cAAemB,QACxCM,EAAQtC,MAAOI,IAAKgC,EAAIf,EAAGjB,IAAKgC,EAAId,EAAGc,EAAIb,KAAQS,QAEzDM,EAAMC,UAAWvC,MAAO0B,IAExB,MAAMc,EAAclC,KAAMsB,EAAQa,IAAKV,EAAOV,EAAEL,IAAKa,KAAaG,QAElE9B,KAAM,CAAEwC,KAAM,QAASC,MAAOZ,EAAOV,EAAGuB,IAAKb,EAAOT,EAAGuB,OAAQP,IAAS,KAEvEX,EAAU,CAAEa,gBAEZA,EAAYM,UAAWjB,EAAOb,IAAKsB,GAAS,GAE1C","ignoreList":[]}