import{BufferAttribute,BufferGeometry,Float32BufferAttribute,InstancedBufferAttribute,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector3}from"three";function computeMikkTSpaceTangents(e,t,r=!0){if(!t||!t.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){const t=new Float32Array(e.count*e.itemSize);for(let r=0,o=0;r<e.count;r++)t[o++]=e.getX(r),t[o++]=e.getY(r),e.itemSize>2&&(t[o++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}const n=e.index?e.toNonIndexed():e,i=t.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(r)for(let e=3;e<i.length;e+=4)i[e]*=-1;return n.setAttribute("tangent",new BufferAttribute(i,4)),e!==n&&e.copy(n),e}function mergeGeometries(e,t=!1){const r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),i={},s={},u=e[0].morphTargetsRelative,a=new BufferGeometry;let l=0;for(let f=0;f<e.length;++f){const c=e[f];let m=0;if(r!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in c.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===i[e]&&(i[e]=[]),i[e].push(c.attributes[e]),m++}if(m!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(u!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in c.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[e]&&(s[e]=[]),s[e].push(c.morphAttributes[e])}if(t){let e;if(r)e=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;e=c.attributes.position.count}a.addGroup(l,e,f),l+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}a.setIndex(r)}for(const e in i){const t=mergeAttributes(i[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;a.setAttribute(e,t)}for(const e in s){const t=s[e][0].length;if(0===t)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<s[e].length;++o)t.push(s[e][o][r]);const o=mergeAttributes(t);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;a.morphAttributes[e].push(o)}}return a}function mergeAttributes(e){let t,r,o,n=-1,i=0;for(let s=0;s<e.length;++s){const u=e[s];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=u.itemSize),r!==u.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=u.normalized),o!==u.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===n&&(n=u.gpuType),n!==u.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;i+=u.count*r}const s=new t(i),u=new BufferAttribute(s,r,o);let a=0;for(let t=0;t<e.length;++t){const o=e[t];if(o.isInterleavedBufferAttribute){const e=a/r;for(let t=0,n=o.count;t<n;t++)for(let n=0;n<r;n++){const r=o.getComponent(t,n);u.setComponent(t+e,n,r)}}else s.set(o.array,a);a+=o.count*r}return void 0!==n&&(u.gpuType=n),u}function deepCloneAttribute(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?deinterleaveAttribute(e):e.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(e):(new BufferAttribute).copy(e)}function interleaveAttributes(e){let t,r=0,o=0;for(let n=0,i=e.length;n<i;++n){const i=e[n];if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,o+=i.itemSize}const n=new InterleavedBuffer(new t(r),o);let i=0;const s=[],u=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let t=0,r=e.length;t<r;t++){const r=e[t],o=r.itemSize,l=r.count,f=new InterleavedBufferAttribute(n,o,i,r.normalized);s.push(f),i+=o;for(let e=0;e<l;e++)for(let t=0;t<o;t++)f[a[t]](e,r[u[t]](e))}return s}function deinterleaveAttribute(e){const t=e.data.array.constructor,r=e.count,o=e.itemSize,n=e.normalized,i=new t(r*o);let s;s=e.isInstancedInterleavedBufferAttribute?new InstancedBufferAttribute(i,o,n,e.meshPerAttribute):new BufferAttribute(i,o,n);for(let t=0;t<r;t++)s.setX(t,e.getX(t)),o>=2&&s.setY(t,e.getY(t)),o>=3&&s.setZ(t,e.getZ(t)),o>=4&&s.setW(t,e.getW(t));return s}function deinterleaveGeometry(e){const t=e.attributes,r=e.morphTargets,o=new Map;for(const e in t){const r=t[e];r.isInterleavedBufferAttribute&&(o.has(r)||o.set(r,deinterleaveAttribute(r)),t[e]=o.get(r))}for(const e in r){const t=r[e];t.isInterleavedBufferAttribute&&(o.has(t)||o.set(t,deinterleaveAttribute(t)),r[e]=o.get(t))}}function estimateBytesUsed(e){let t=0;for(const r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}function mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},o=e.getIndex(),n=e.getAttribute("position"),i=o?o.count:n.count;let s=0;const u=Object.keys(e.attributes),a={},l={},f=[],c=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"];for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.attributes[r];a[r]=new o.constructor(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const n=e.morphAttributes[r];n&&(l[r]||(l[r]=[]),n.forEach(((e,t)=>{const o=new e.array.constructor(e.count*e.itemSize);l[r][t]=new e.constructor(o,e.itemSize,e.normalized)})))}const g=.5*t,d=Math.log10(1/t),b=Math.pow(10,d),h=g*b;for(let t=0;t<i;t++){const n=o?o.getX(t):t;let i="";for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),s=o.itemSize;for(let e=0;e<s;e++)i+=~~(o[c[e]](n)*b+h)+","}if(i in r)f.push(r[i]);else{for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),i=e.morphAttributes[r],f=o.itemSize,g=a[r],d=l[r];for(let e=0;e<f;e++){const t=c[e],r=m[e];if(g[r](s,o[t](n)),i)for(let e=0,o=i.length;e<o;e++)d[e][r](s,i[e][t](n))}}r[i]=s,f.push(s),s++}}const p=e.clone();for(const t in e.attributes){const e=a[t];if(p.setAttribute(t,new e.constructor(e.array.slice(0,s*e.itemSize),e.itemSize,e.normalized)),t in l)for(let e=0;e<l[t].length;e++){const r=l[t][e];p.morphAttributes[t][e]=new r.constructor(r.array.slice(0,s*r.itemSize),r.itemSize,r.normalized)}}return p.setIndex(f),p}function toTrianglesDrawMode(e,t){if(t===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===TriangleFanDrawMode||t===TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const o=r.count-2,n=[];if(t===TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<o;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}function computeMorphedAttributes(e){const t=new Vector3,r=new Vector3,o=new Vector3,n=new Vector3,i=new Vector3,s=new Vector3,u=new Vector3,a=new Vector3,l=new Vector3;function f(e,f,c,m,g,d,b,h){t.fromBufferAttribute(f,g),r.fromBufferAttribute(f,d),o.fromBufferAttribute(f,b);const p=e.morphTargetInfluences;if(c&&p){u.set(0,0,0),a.set(0,0,0),l.set(0,0,0);for(let e=0,f=c.length;e<f;e++){const f=p[e],h=c[e];0!==f&&(n.fromBufferAttribute(h,g),i.fromBufferAttribute(h,d),s.fromBufferAttribute(h,b),m?(u.addScaledVector(n,f),a.addScaledVector(i,f),l.addScaledVector(s,f)):(u.addScaledVector(n.sub(t),f),a.addScaledVector(i.sub(r),f),l.addScaledVector(s.sub(o),f)))}t.add(u),r.add(a),o.add(l)}e.isSkinnedMesh&&(e.applyBoneTransform(g,t),e.applyBoneTransform(d,r),e.applyBoneTransform(b,o)),h[3*g+0]=t.x,h[3*g+1]=t.y,h[3*g+2]=t.z,h[3*d+0]=r.x,h[3*d+1]=r.y,h[3*d+2]=r.z,h[3*b+0]=o.x,h[3*b+1]=o.y,h[3*b+2]=o.z}const c=e.geometry,m=e.material;let g,d,b;const h=c.index,p=c.attributes.position,A=c.morphAttributes.position,y=c.morphTargetsRelative,w=c.attributes.normal,B=c.morphAttributes.position,T=c.groups,x=c.drawRange;let E,z,v,I,G,S,M;const V=new Float32Array(p.count*p.itemSize),X=new Float32Array(w.count*w.itemSize);if(null!==h)if(Array.isArray(m))for(E=0,v=T.length;E<v;E++)for(G=T[E],S=Math.max(G.start,x.start),M=Math.min(G.start+G.count,x.start+x.count),z=S,I=M;z<I;z+=3)g=h.getX(z),d=h.getX(z+1),b=h.getX(z+2),f(e,p,A,y,g,d,b,V),f(e,w,B,y,g,d,b,X);else for(S=Math.max(0,x.start),M=Math.min(h.count,x.start+x.count),E=S,v=M;E<v;E+=3)g=h.getX(E),d=h.getX(E+1),b=h.getX(E+2),f(e,p,A,y,g,d,b,V),f(e,w,B,y,g,d,b,X);else if(Array.isArray(m))for(E=0,v=T.length;E<v;E++)for(G=T[E],S=Math.max(G.start,x.start),M=Math.min(G.start+G.count,x.start+x.count),z=S,I=M;z<I;z+=3)g=z,d=z+1,b=z+2,f(e,p,A,y,g,d,b,V),f(e,w,B,y,g,d,b,X);else for(S=Math.max(0,x.start),M=Math.min(p.count,x.start+x.count),E=S,v=M;E<v;E+=3)g=E,d=E+1,b=E+2,f(e,p,A,y,g,d,b,V),f(e,w,B,y,g,d,b,X);return{positionAttribute:p,normalAttribute:w,morphedPositionAttribute:new Float32BufferAttribute(V,3),morphedNormalAttribute:new Float32BufferAttribute(X,3)}}function mergeGroups(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort(((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start)),null===e.getIndex()){const t=e.getAttribute("position"),r=[];for(let e=0;e<t.count;e+=3)r.push(e,e+1,e+2);e.setIndex(r)}const r=e.getIndex(),o=[];for(let e=0;e<t.length;e++){const n=t[e],i=n.start,s=i+n.count;for(let e=i;e<s;e++)o.push(r.getX(e))}e.dispose(),e.setIndex(o);let n=0;for(let e=0;e<t.length;e++){const r=t[e];r.start=n,n+=r.count}let i=t[0];e.groups=[i];for(let r=1;r<t.length;r++){const o=t[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,e.groups.push(i))}return e}function toCreasedNormals(e,t=Math.PI/3){const r=Math.cos(t),o=100*(1+1e-10),n=[new Vector3,new Vector3,new Vector3],i=new Vector3,s=new Vector3,u=new Vector3,a=new Vector3;function l(e){return`${~~(e.x*o)},${~~(e.y*o)},${~~(e.z*o)}`}const f=e.index?e.toNonIndexed():e,c=f.attributes.position,m={};for(let e=0,t=c.count/3;e<t;e++){const t=3*e,r=n[0].fromBufferAttribute(c,t+0),o=n[1].fromBufferAttribute(c,t+1),u=n[2].fromBufferAttribute(c,t+2);i.subVectors(u,o),s.subVectors(r,o);const a=(new Vector3).crossVectors(i,s).normalize();for(let e=0;e<3;e++){const t=l(n[e]);t in m||(m[t]=[]),m[t].push(a)}}const g=new Float32Array(3*c.count),d=new BufferAttribute(g,3,!1);for(let e=0,t=c.count/3;e<t;e++){const t=3*e,o=n[0].fromBufferAttribute(c,t+0),f=n[1].fromBufferAttribute(c,t+1),g=n[2].fromBufferAttribute(c,t+2);i.subVectors(g,f),s.subVectors(o,f),u.crossVectors(i,s).normalize();for(let e=0;e<3;e++){const o=m[l(n[e])];a.set(0,0,0);for(let e=0,t=o.length;e<t;e++){const t=o[e];u.dot(t)>r&&a.add(t)}a.normalize(),d.setXYZ(t+e,a.x,a.y,a.z)}}return f.setAttribute("normal",d),f}export{computeMikkTSpaceTangents,mergeGeometries,mergeAttributes,deepCloneAttribute,deinterleaveAttribute,deinterleaveGeometry,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};
//# sourceMappingURL=BufferGeometryUtils.js.map