{"version":3,"file":"node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InstancedBufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","computeMikkTSpaceTangents","geometry","MikkTSpace","negateSign","isReady","Error","hasAttribute","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","dstArray","Float32Array","count","itemSize","i","j","getX","getY","getZ","array","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","length","setAttribute","copy","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","console","error","name","has","undefined","push","size","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","gpuType","arrayLength","constructor","result","tupleOffset","l","c","value","getComponent","setComponent","set","deepCloneAttribute","isInstancedInterleavedBufferAttribute","deinterleaveAttribute","isInstancedBufferAttribute","interleaveAttributes","stride","interleavedBuffer","res","getters","setters","iba","k","cons","data","newAttribute","meshPerAttribute","setX","setY","setZ","setW","getW","deinterleaveGeometry","morphTargets","attrMap","Map","key","attr","get","estimateBytesUsed","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","tmpAttributes","tmpMorphAttributes","newIndices","forEach","morphAttr","halfTolerance","exponent","log10","hashMultiplier","pow","hashAdditive","hash","newArray","newMorphArrays","getterFunc","setterFunc","m","ml","clone","tmpAttribute","slice","tmpMorphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","morphAttribute","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","applyBoneTransform","x","y","z","material","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","group","start","end","modifiedPosition","modifiedNormal","Array","isArray","min","morphedPositionAttribute","morphedNormalAttribute","mergeGroups","sort","materialIndex","groupStart","groupLength","dispose","currentGroup","toCreasedNormals","creaseAngle","PI","creaseDot","cos","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"sources":["node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n/**\n * @module BufferGeometryUtils\n * @three_import import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n */\n\n/**\n * Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,\n * and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,\n * because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored\n * UV seams.\n *\n * In comparison to this method, {@link BufferGeometry#computeTangents} (a custom algorithm) generates tangents that\n * probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a\n * custom material, and may be faster than MikkTSpace.\n *\n * Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.\n *\n * @param {BufferGeometry} geometry - The geometry to compute tangents for.\n * @param {Object} MikkTSpace - Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package.\n * Await `MikkTSpace.ready` before use.\n * @param {boolean} [negateSign=true] - Whether to negate the sign component (.w) of each tangent.\n * Required for normal map conventions in some formats, including glTF.\n * @return {BufferGeometry} The updated geometry.\n */\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Merges a set of geometries into a single instance. All geometries must have compatible attributes.\n *\n * @param {Array<BufferGeometry>} geometries - The geometries to merge.\n * @param {boolean} [useGroups=false] - Whether to use groups or not.\n * @return {?BufferGeometry} The merged geometry. Returns `null` if the merge does not succeed.\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * Merges a set of attributes into a single instance. All attributes must have compatible properties and types.\n * Instances of {@link InterleavedBufferAttribute} are not supported.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to merge.\n * @return {?BufferAttribute} The merged attribute. Returns `null` if the merge does not succeed.\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Performs a deep clone of the given buffer attribute.\n *\n * @param {BufferAttribute} attribute - The attribute to clone.\n * @return {BufferAttribute} The cloned attribute.\n */\nfunction deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * Interleaves a set of attributes and returns a new array of corresponding attributes that share a\n * single {@link InterleavedBuffer} instance. All attributes must have compatible types.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to interleave.\n * @return {Array<InterleavedBufferAttribute>} An array of interleaved attributes. If interleave does not succeed, the method returns `null`.\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * Returns a new, non-interleaved version of the given attribute.\n *\n * @param {InterleavedBufferAttribute} attribute - The interleaved attribute.\n * @return {BufferAttribute} The non-interleaved attribute.\n */\nfunction deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n/**\n * Deinterleaves all attributes on the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to deinterleave.\n */\nfunction deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Returns the amount of bytes used by all attributes to represent the geometry.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The estimate bytes used.\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.\n *\n * @param {BufferGeometry} geometry - The geometry to merge vertices for.\n * @param {number} [tolerance=1e-4] - The tolerance value.\n * @return {BufferGeometry} - The new geometry with merged vertices.\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.\n * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.\n *\n * @param {BufferGeometry} geometry - The geometry to convert.\n * @param {number} drawMode - The current draw mode.\n * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n *\n * Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`\n * will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.\n * Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).\n *\n * @param {Mesh|Line|Points} object - The 3D object to compute morph attributes for.\n * @return {Object} An object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n/**\n * Merges the {@link BufferGeometry#groups} for the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @param {number} [creaseAngle=Math.PI/3] - The crease angle in radians.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tdeepCloneAttribute,\n\tdeinterleaveAttribute,\n\tdeinterleaveGeometry,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n"],"mappings":"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","ignoreList":[]}