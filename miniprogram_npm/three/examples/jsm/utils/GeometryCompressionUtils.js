import{BufferAttribute,Matrix3,Matrix4,Vector3}from"three";function compressNormals(t,e){const n=t.attributes.normal;if(n||console.error("THREE.GeometryCompressionUtils.compressNormals(): Geometry must contain normal attribute."),n.isPacked)return;3!=n.itemSize&&console.error("THREE.GeometryCompressionUtils.compressNormals(): normal.itemSize is not 3, which cannot be encoded.");const r=n.array,o=n.count;let a;if("DEFAULT"==e){a=new Uint8Array(3*o);for(let t=0;t<r.length;t+=3){const e=defaultEncode(r[t],r[t+1],r[t+2],1);a[t+0]=e[0],a[t+1]=e[1],a[t+2]=e[2]}t.setAttribute("normal",new BufferAttribute(a,3,!0)),t.attributes.normal.bytes=1*a.length}else if("OCT1Byte"==e){a=new Int8Array(2*o);for(let t=0;t<r.length;t+=3){const e=octEncodeBest(r[t],r[t+1],r[t+2],1);a[t/3*2+0]=e[0],a[t/3*2+1]=e[1]}t.setAttribute("normal",new BufferAttribute(a,2,!0)),t.attributes.normal.bytes=1*a.length}else if("OCT2Byte"==e){a=new Int16Array(2*o);for(let t=0;t<r.length;t+=3){const e=octEncodeBest(r[t],r[t+1],r[t+2],2);a[t/3*2+0]=e[0],a[t/3*2+1]=e[1]}t.setAttribute("normal",new BufferAttribute(a,2,!0)),t.attributes.normal.bytes=2*a.length}else if("ANGLES"==e){a=new Uint16Array(2*o);for(let t=0;t<r.length;t+=3){const e=anglesEncode(r[t],r[t+1],r[t+2]);a[t/3*2+0]=e[0],a[t/3*2+1]=e[1]}t.setAttribute("normal",new BufferAttribute(a,2,!0)),t.attributes.normal.bytes=2*a.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");t.attributes.normal.needsUpdate=!0,t.attributes.normal.isPacked=!0,t.attributes.normal.packingMethod=e}function compressPositions(t){const e=t.attributes.position;if(e||console.error("THREE.GeometryCompressionUtils.compressPositions(): Geometry must contain position attribute."),e.isPacked)return;3!=e.itemSize&&console.error("THREE.GeometryCompressionUtils.compressPositions(): position.itemSize is not 3, which cannot be packed.");const n=quantizedEncode(e.array,2).quantized;null==t.boundingBox&&t.computeBoundingBox(),null==t.boundingSphere&&t.computeBoundingSphere(),t.setAttribute("position",new BufferAttribute(n,3)),t.attributes.position.isPacked=!0,t.attributes.position.needsUpdate=!0,t.attributes.position.bytes=2*n.length}function compressUvs(t){const e=t.attributes.uv;if(e||console.error("THREE.GeometryCompressionUtils.compressUvs(): Geometry must contain uv attribute."),e.isPacked)return;const n={min:1/0,max:-1/0},r=e.array;for(let t=0;t<r.length;t++)n.min=Math.min(n.min,r[t]),n.max=Math.max(n.max,r[t]);let o;if(n.min>=-1&&n.max<=1){o=new Uint16Array(r.length);for(let t=0;t<r.length;t+=2){const e=defaultEncode(r[t],r[t+1],0,2);o[t]=e[0],o[t+1]=e[1]}t.setAttribute("uv",new BufferAttribute(o,2,!0)),t.attributes.uv.isPacked=!0,t.attributes.uv.needsUpdate=!0,t.attributes.uv.bytes=2*o.length}else o=quantizedEncodeUV(r,2),t.setAttribute("uv",new BufferAttribute(o.quantized,2)),t.attributes.uv.isPacked=!0,t.attributes.uv.needsUpdate=!0,t.attributes.uv.bytes=2*o.quantized.length}function defaultEncode(t,e,n,r){if(1==r){const r=Math.round(.5*(t+1)*255),o=Math.round(.5*(e+1)*255),a=Math.round(.5*(n+1)*255);return new Uint8Array([r,o,a])}if(2==r){const r=Math.round(.5*(t+1)*65535),o=Math.round(.5*(e+1)*65535),a=Math.round(.5*(n+1)*65535);return new Uint16Array([r,o,a])}console.error("number of bytes must be 1 or 2")}function anglesEncode(t,e,n){const r=parseInt(.5*(1+Math.atan2(e,t)/Math.PI)*65535),o=parseInt(.5*(1+n)*65535);return new Uint16Array([r,o])}function octEncodeBest(t,e,n,r){let o,a,s,i,u;return s=o=l(t,e,n,"floor","floor"),a=c(o),u=m(t,e,n,a),o=l(t,e,n,"ceil","floor"),a=c(o),i=m(t,e,n,a),i>u&&(s=o,u=i),o=l(t,e,n,"floor","ceil"),a=c(o),i=m(t,e,n,a),i>u&&(s=o,u=i),o=l(t,e,n,"ceil","ceil"),a=c(o),i=m(t,e,n,a),i>u&&(s=o),s;function l(t,e,o,a,s){let i=t/(Math.abs(t)+Math.abs(e)+Math.abs(o)),u=e/(Math.abs(t)+Math.abs(e)+Math.abs(o));if(n<0){const t=(1-Math.abs(u))*(i>=0?1:-1),e=(1-Math.abs(i))*(u>=0?1:-1);i=t,u=e;let n=1-Math.abs(i)-Math.abs(u);n>0&&(n+=.001,i+=i>0?n/2:-n/2,u+=u>0?n/2:-n/2)}return 1==r?new Int8Array([Math[a](127.5*i+(i<0?1:0)),Math[s](127.5*u+(u<0?1:0))]):2==r?new Int16Array([Math[a](32767.5*i+(i<0?1:0)),Math[s](32767.5*u+(u<0?1:0))]):void 0}function c(t){let e=t[0],n=t[1];1==r?(e/=e<0?127:128,n/=n<0?127:128):2==r&&(e/=e<0?32767:32768,n/=n<0?32767:32768);const o=1-Math.abs(e)-Math.abs(n);if(o<0){const t=e;e=(1-Math.abs(n))*(e>=0?1:-1),n=(1-Math.abs(t))*(n>=0?1:-1)}const a=Math.sqrt(e*e+n*n+o*o);return[e/a,n/a,o/a]}function m(t,e,n,r){return t*r[0]+e*r[1]+n*r[2]}}function quantizedEncode(t,e){let n,r;1==e?(n=new Uint8Array(t.length),r=255):2==e?(n=new Uint16Array(t.length),r=65535):console.error("number of bytes error! ");const o=new Matrix4,a=new Float32Array(3),s=new Float32Array(3);a[0]=a[1]=a[2]=Number.MAX_VALUE,s[0]=s[1]=s[2]=-Number.MAX_VALUE;for(let e=0;e<t.length;e+=3)a[0]=Math.min(a[0],t[e+0]),a[1]=Math.min(a[1],t[e+1]),a[2]=Math.min(a[2],t[e+2]),s[0]=Math.max(s[0],t[e+0]),s[1]=Math.max(s[1],t[e+1]),s[2]=Math.max(s[2],t[e+2]);o.scale(new Vector3((s[0]-a[0])/r,(s[1]-a[1])/r,(s[2]-a[2])/r)),o.elements[12]=a[0],o.elements[13]=a[1],o.elements[14]=a[2],o.transpose();const i=new Float32Array([s[0]!==a[0]?r/(s[0]-a[0]):0,s[1]!==a[1]?r/(s[1]-a[1]):0,s[2]!==a[2]?r/(s[2]-a[2]):0]);for(let e=0;e<t.length;e+=3)n[e+0]=Math.floor((t[e+0]-a[0])*i[0]),n[e+1]=Math.floor((t[e+1]-a[1])*i[1]),n[e+2]=Math.floor((t[e+2]-a[2])*i[2]);return{quantized:n,decodeMat:o}}function quantizedEncodeUV(t,e){let n,r;1==e?(n=new Uint8Array(t.length),r=255):2==e?(n=new Uint16Array(t.length),r=65535):console.error("number of bytes error! ");const o=new Matrix3,a=new Float32Array(2),s=new Float32Array(2);a[0]=a[1]=Number.MAX_VALUE,s[0]=s[1]=-Number.MAX_VALUE;for(let e=0;e<t.length;e+=2)a[0]=Math.min(a[0],t[e+0]),a[1]=Math.min(a[1],t[e+1]),s[0]=Math.max(s[0],t[e+0]),s[1]=Math.max(s[1],t[e+1]);o.scale((s[0]-a[0])/r,(s[1]-a[1])/r),o.elements[6]=a[0],o.elements[7]=a[1],o.transpose();const i=new Float32Array([s[0]!==a[0]?r/(s[0]-a[0]):0,s[1]!==a[1]?r/(s[1]-a[1]):0]);for(let e=0;e<t.length;e+=2)n[e+0]=Math.floor((t[e+0]-a[0])*i[0]),n[e+1]=Math.floor((t[e+1]-a[1])*i[1]);return{quantized:n,decodeMat:o}}export{compressNormals,compressPositions,compressUvs};
//# sourceMappingURL=GeometryCompressionUtils.js.map