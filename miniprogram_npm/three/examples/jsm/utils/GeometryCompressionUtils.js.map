{"version":3,"file":"node_modules/three/examples/jsm/utils/GeometryCompressionUtils.js","names":["BufferAttribute","Matrix3","Matrix4","Vector3","compressNormals","geometry","encodeMethod","normal","attributes","console","error","isPacked","itemSize","array","count","result","Uint8Array","idx","length","encoded","defaultEncode","setAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","compressPositions","position","quantized","quantizedEncode","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","quantizedEncodeUV","x","y","z","tmpx","round","tmpy","tmpz","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","decodeMat","Float32Array","Number","MAX_VALUE","scale","elements","transpose","multiplier","floor"],"sources":["node_modules/three/examples/jsm/utils/GeometryCompressionUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tVector3\n} from 'three';\n\n/**\n * @module GeometryCompressionUtils\n * @three_import import * as GeometryCompressionUtils from 'three/addons/utils/GeometryCompressionUtils.js';\n */\n\n// Octahedron and Quantization encodings based on work by: https://github.com/tsherif/mesh-quantization-example\n\n/**\n * Compressed the given geometry's `normal` attribute by the selected encode method.\n *\n * @param {BufferGeometry} geometry - The geometry whose normals should be compressed.\n * @param {('DEFAULT'|'OCT1Byte'|'OCT2Byte'|'ANGLES')} encodeMethod - The compression method.\n */\nfunction compressNormals( geometry, encodeMethod ) {\n\n\tconst normal = geometry.attributes.normal;\n\n\tif ( ! normal ) {\n\n\t\tconsole.error( 'THREE.GeometryCompressionUtils.compressNormals(): Geometry must contain normal attribute.' );\n\n\t}\n\n\tif ( normal.isPacked ) return;\n\n\tif ( normal.itemSize != 3 ) {\n\n\t\tconsole.error( 'THREE.GeometryCompressionUtils.compressNormals(): normal.itemSize is not 3, which cannot be encoded.' );\n\n\t}\n\n\tconst array = normal.array;\n\tconst count = normal.count;\n\n\tlet result;\n\tif ( encodeMethod == 'DEFAULT' ) {\n\n\t\t// TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n\t\tresult = new Uint8Array( count * 3 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx + 1 ] = encoded[ 1 ];\n\t\t\tresult[ idx + 2 ] = encoded[ 2 ];\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'normal', new BufferAttribute( result, 3, true ) );\n\t\tgeometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT1Byte' ) {\n\n\n\t\t// It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n\t\t// As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n\t\t// Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n\n\t\tresult = new Int8Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tgeometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT2Byte' ) {\n\n\t\tresult = new Int16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 2 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tgeometry.attributes.normal.bytes = result.length * 2;\n\n\t} else if ( encodeMethod == 'ANGLES' ) {\n\n\t\tresult = new Uint16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = anglesEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ] );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tgeometry.attributes.normal.bytes = result.length * 2;\n\n\t} else {\n\n\t\tconsole.error( 'Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ' );\n\n\t}\n\n\tgeometry.attributes.normal.needsUpdate = true;\n\tgeometry.attributes.normal.isPacked = true;\n\tgeometry.attributes.normal.packingMethod = encodeMethod;\n\n}\n\n/**\n * Compressed the given geometry's `position` attribute.\n *\n * @param {BufferGeometry} geometry - The geometry whose position values should be compressed.\n */\nfunction compressPositions( geometry ) {\n\n\tconst position = geometry.attributes.position;\n\n\tif ( ! position ) {\n\n\t\tconsole.error( 'THREE.GeometryCompressionUtils.compressPositions(): Geometry must contain position attribute.' );\n\n\t}\n\n\tif ( position.isPacked ) return;\n\n\tif ( position.itemSize != 3 ) {\n\n\t\tconsole.error( 'THREE.GeometryCompressionUtils.compressPositions(): position.itemSize is not 3, which cannot be packed.' );\n\n\t}\n\n\tconst array = position.array;\n\tconst encodingBytes = 2;\n\n\tconst result = quantizedEncode( array, encodingBytes );\n\n\tconst quantized = result.quantized;\n\n\t// IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\tif ( geometry.boundingBox == null ) geometry.computeBoundingBox();\n\tif ( geometry.boundingSphere == null ) geometry.computeBoundingSphere();\n\n\tgeometry.setAttribute( 'position', new BufferAttribute( quantized, 3 ) );\n\tgeometry.attributes.position.isPacked = true;\n\tgeometry.attributes.position.needsUpdate = true;\n\tgeometry.attributes.position.bytes = quantized.length * encodingBytes;\n\n}\n\n/**\n * Compressed the given geometry's `uv` attribute.\n *\n * @param {BufferGeometry} geometry - The geometry whose texture coordinates should be compressed.\n */\nfunction compressUvs( geometry ) {\n\n\tconst uvs = geometry.attributes.uv;\n\n\tif ( ! uvs ) {\n\n\t\tconsole.error( 'THREE.GeometryCompressionUtils.compressUvs(): Geometry must contain uv attribute.' );\n\n\t}\n\n\tif ( uvs.isPacked ) return;\n\n\tconst range = { min: Infinity, max: - Infinity };\n\n\tconst array = uvs.array;\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\trange.min = Math.min( range.min, array[ i ] );\n\t\trange.max = Math.max( range.max, array[ i ] );\n\n\t}\n\n\tlet result;\n\n\tif ( range.min >= - 1.0 && range.max <= 1.0 ) {\n\n\t\t// use default encoding method\n\t\tresult = new Uint16Array( array.length );\n\n\t\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ i ], array[ i + 1 ], 0, 2 );\n\n\t\t\tresult[ i ] = encoded[ 0 ];\n\t\t\tresult[ i + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( result, 2, true ) );\n\t\tgeometry.attributes.uv.isPacked = true;\n\t\tgeometry.attributes.uv.needsUpdate = true;\n\t\tgeometry.attributes.uv.bytes = result.length * 2;\n\n\t} else {\n\n\t\t// use quantized encoding method\n\t\tresult = quantizedEncodeUV( array, 2 );\n\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( result.quantized, 2 ) );\n\t\tgeometry.attributes.uv.isPacked = true;\n\t\tgeometry.attributes.uv.needsUpdate = true;\n\t\tgeometry.attributes.uv.bytes = result.quantized.length * 2;\n\n\t}\n\n}\n\n\n// Encoding functions\n\nfunction defaultEncode( x, y, z, bytes ) {\n\n\tif ( bytes == 1 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 255 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 255 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 255 );\n\t\treturn new Uint8Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else if ( bytes == 2 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 65535 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 65535 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 65535 );\n\t\treturn new Uint16Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes must be 1 or 2' );\n\n\t}\n\n}\n\n// for `Angles` encoding\nfunction anglesEncode( x, y, z ) {\n\n\tconst normal0 = parseInt( 0.5 * ( 1.0 + Math.atan2( y, x ) / Math.PI ) * 65535 );\n\tconst normal1 = parseInt( 0.5 * ( 1.0 + z ) * 65535 );\n\treturn new Uint16Array( [ normal0, normal1 ] );\n\n}\n\n// for `Octahedron` encoding\nfunction octEncodeBest( x, y, z, bytes ) {\n\n\tlet oct, dec, best, currentCos, bestCos;\n\n\t// Test various combinations of ceil and floor\n\t// to minimize rounding errors\n\tbest = oct = octEncodeVec3( x, y, z, 'floor', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tbestCos = dot( x, y, z, dec );\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'floor', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\n\t}\n\n\treturn best;\n\n\tfunction octEncodeVec3( x0, y0, z0, xfunc, yfunc ) {\n\n\t\tlet x = x0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\t\tlet y = y0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tempx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\tconst tempy = ( 1 - Math.abs( x ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t\tx = tempx;\n\t\t\ty = tempy;\n\n\t\t\tlet diff = 1 - Math.abs( x ) - Math.abs( y );\n\t\t\tif ( diff > 0 ) {\n\n\t\t\t\tdiff += 0.001;\n\t\t\t\tx += x > 0 ? diff / 2 : - diff / 2;\n\t\t\t\ty += y > 0 ? diff / 2 : - diff / 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\treturn new Int8Array( [\n\t\t\t\tMath[ xfunc ]( x * 127.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 127.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\t\tif ( bytes == 2 ) {\n\n\t\t\treturn new Int16Array( [\n\t\t\t\tMath[ xfunc ]( x * 32767.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 32767.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\n\t}\n\n\tfunction octDecodeVec2( oct ) {\n\n\t\tlet x = oct[ 0 ];\n\t\tlet y = oct[ 1 ];\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\tx /= x < 0 ? 127 : 128;\n\t\t\ty /= y < 0 ? 127 : 128;\n\n\t\t} else if ( bytes == 2 ) {\n\n\t\t\tx /= x < 0 ? 32767 : 32768;\n\t\t\ty /= y < 0 ? 32767 : 32768;\n\n\t\t}\n\n\n\t\tconst z = 1 - Math.abs( x ) - Math.abs( y );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tmpx = x;\n\t\t\tx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\ty = ( 1 - Math.abs( tmpx ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t}\n\n\t\tconst length = Math.sqrt( x * x + y * y + z * z );\n\n\t\treturn [\n\t\t\tx / length,\n\t\t\ty / length,\n\t\t\tz / length\n\t\t];\n\n\t}\n\n\tfunction dot( x, y, z, vec3 ) {\n\n\t\treturn x * vec3[ 0 ] + y * vec3[ 1 ] + z * vec3[ 2 ];\n\n\t}\n\n}\n\nfunction quantizedEncode( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix4();\n\n\tconst min = new Float32Array( 3 );\n\tconst max = new Float32Array( 3 );\n\n\tmin[ 0 ] = min[ 1 ] = min[ 2 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = max[ 2 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmin[ 2 ] = Math.min( min[ 2 ], array[ i + 2 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\t\tmax[ 2 ] = Math.max( max[ 2 ], array[ i + 2 ] );\n\n\t}\n\n\tdecodeMat.scale( new Vector3(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments,\n\t\t( max[ 2 ] - min[ 2 ] ) / segments\n\t) );\n\n\tdecodeMat.elements[ 12 ] = min[ 0 ];\n\tdecodeMat.elements[ 13 ] = min[ 1 ];\n\tdecodeMat.elements[ 14 ] = min[ 2 ];\n\n\tdecodeMat.transpose();\n\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0,\n\t\tmax[ 2 ] !== min[ 2 ] ? segments / ( max[ 2 ] - min[ 2 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\t\tquantized[ i + 2 ] = Math.floor( ( array[ i + 2 ] - min[ 2 ] ) * multiplier[ 2 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\nfunction quantizedEncodeUV( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix3();\n\n\tconst min = new Float32Array( 2 );\n\tconst max = new Float32Array( 2 );\n\n\tmin[ 0 ] = min[ 1 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\n\t}\n\n\tdecodeMat.scale(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments\n\t);\n\n\tdecodeMat.elements[ 6 ] = min[ 0 ];\n\tdecodeMat.elements[ 7 ] = min[ 1 ];\n\n\tdecodeMat.transpose();\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\n\n\nexport {\n\tcompressNormals,\n\tcompressPositions,\n\tcompressUvs,\n};\n"],"mappings":"OACCA,gBACAC,QACAC,QACAC,YACM,QAeP,SAASC,gBAAiBC,EAAUC,GAEnC,MAAMC,EAASF,EAASG,WAAWD,OAQnC,GANOA,GAENE,QAAQC,MAAO,6FAIXH,EAAOI,SAAW,OAEC,GAAnBJ,EAAOK,UAEXH,QAAQC,MAAO,wGAIhB,MAAMG,EAAQN,EAAOM,MACfC,EAAQP,EAAOO,MAErB,IAAIC,EACJ,GAAqB,WAAhBT,EAA4B,CAGhCS,EAAS,IAAIC,WAAoB,EAARF,GAEzB,IAAM,IAAIG,EAAM,EAAGA,EAAMJ,EAAMK,OAAQD,GAAO,EAAI,CAEjD,MAAME,EAAUC,cAAeP,EAAOI,GAAOJ,EAAOI,EAAM,GAAKJ,EAAOI,EAAM,GAAK,GAEjFF,EAAQE,EAAM,GAAME,EAAS,GAC7BJ,EAAQE,EAAM,GAAME,EAAS,GAC7BJ,EAAQE,EAAM,GAAME,EAAS,EAE9B,CAEAd,EAASgB,aAAc,SAAU,IAAIrB,gBAAiBe,EAAQ,GAAG,IACjEV,EAASG,WAAWD,OAAOe,MAAwB,EAAhBP,EAAOG,MAE3C,MAAO,GAAqB,YAAhBZ,EAA6B,CAOxCS,EAAS,IAAIQ,UAAmB,EAART,GAExB,IAAM,IAAIG,EAAM,EAAGA,EAAMJ,EAAMK,OAAQD,GAAO,EAAI,CAEjD,MAAME,EAAUK,cAAeX,EAAOI,GAAOJ,EAAOI,EAAM,GAAKJ,EAAOI,EAAM,GAAK,GAEjFF,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,GACrCJ,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,EAEtC,CAEAd,EAASgB,aAAc,SAAU,IAAIrB,gBAAiBe,EAAQ,GAAG,IACjEV,EAASG,WAAWD,OAAOe,MAAwB,EAAhBP,EAAOG,MAE3C,MAAO,GAAqB,YAAhBZ,EAA6B,CAExCS,EAAS,IAAIU,WAAoB,EAARX,GAEzB,IAAM,IAAIG,EAAM,EAAGA,EAAMJ,EAAMK,OAAQD,GAAO,EAAI,CAEjD,MAAME,EAAUK,cAAeX,EAAOI,GAAOJ,EAAOI,EAAM,GAAKJ,EAAOI,EAAM,GAAK,GAEjFF,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,GACrCJ,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,EAEtC,CAEAd,EAASgB,aAAc,SAAU,IAAIrB,gBAAiBe,EAAQ,GAAG,IACjEV,EAASG,WAAWD,OAAOe,MAAwB,EAAhBP,EAAOG,MAE3C,MAAO,GAAqB,UAAhBZ,EAA2B,CAEtCS,EAAS,IAAIW,YAAqB,EAARZ,GAE1B,IAAM,IAAIG,EAAM,EAAGA,EAAMJ,EAAMK,OAAQD,GAAO,EAAI,CAEjD,MAAME,EAAUQ,aAAcd,EAAOI,GAAOJ,EAAOI,EAAM,GAAKJ,EAAOI,EAAM,IAE3EF,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,GACrCJ,EAAQE,EAAM,EAAI,EAAI,GAAME,EAAS,EAEtC,CAEAd,EAASgB,aAAc,SAAU,IAAIrB,gBAAiBe,EAAQ,GAAG,IACjEV,EAASG,WAAWD,OAAOe,MAAwB,EAAhBP,EAAOG,MAE3C,MAECT,QAAQC,MAAO,4EAIhBL,EAASG,WAAWD,OAAOqB,aAAc,EACzCvB,EAASG,WAAWD,OAAOI,UAAW,EACtCN,EAASG,WAAWD,OAAOsB,cAAgBvB,CAE5C,CAOA,SAASwB,kBAAmBzB,GAE3B,MAAM0B,EAAW1B,EAASG,WAAWuB,SAQrC,GANOA,GAENtB,QAAQC,MAAO,iGAIXqB,EAASpB,SAAW,OAEC,GAArBoB,EAASnB,UAEbH,QAAQC,MAAO,2GAIhB,MAKMsB,EAFSC,gBAHDF,EAASlB,MACD,GAIGmB,UAGI,MAAxB3B,EAAS6B,aAAsB7B,EAAS8B,qBACb,MAA3B9B,EAAS+B,gBAAyB/B,EAASgC,wBAEhDhC,EAASgB,aAAc,WAAY,IAAIrB,gBAAiBgC,EAAW,IACnE3B,EAASG,WAAWuB,SAASpB,UAAW,EACxCN,EAASG,WAAWuB,SAASH,aAAc,EAC3CvB,EAASG,WAAWuB,SAAST,MAbP,EAaeU,EAAUd,MAEhD,CAOA,SAASoB,YAAajC,GAErB,MAAMkC,EAAMlC,EAASG,WAAWgC,GAQhC,GANOD,GAEN9B,QAAQC,MAAO,qFAIX6B,EAAI5B,SAAW,OAEpB,MAAM8B,EAAQ,CAAEC,IAAKC,IAAUC,KAAOD,KAEhC9B,EAAQ0B,EAAI1B,MAElB,IAAM,IAAIgC,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,IAElCJ,EAAMC,IAAMI,KAAKJ,IAAKD,EAAMC,IAAK7B,EAAOgC,IACxCJ,EAAMG,IAAME,KAAKF,IAAKH,EAAMG,IAAK/B,EAAOgC,IAIzC,IAAI9B,EAEJ,GAAK0B,EAAMC,MAAS,GAAOD,EAAMG,KAAO,EAAM,CAG7C7B,EAAS,IAAIW,YAAab,EAAMK,QAEhC,IAAM,IAAI2B,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,GAAK,EAAI,CAE3C,MAAM1B,EAAUC,cAAeP,EAAOgC,GAAKhC,EAAOgC,EAAI,GAAK,EAAG,GAE9D9B,EAAQ8B,GAAM1B,EAAS,GACvBJ,EAAQ8B,EAAI,GAAM1B,EAAS,EAE5B,CAEAd,EAASgB,aAAc,KAAM,IAAIrB,gBAAiBe,EAAQ,GAAG,IAC7DV,EAASG,WAAWgC,GAAG7B,UAAW,EAClCN,EAASG,WAAWgC,GAAGZ,aAAc,EACrCvB,EAASG,WAAWgC,GAAGlB,MAAwB,EAAhBP,EAAOG,MAEvC,MAGCH,EAASgC,kBAAmBlC,EAAO,GAEnCR,EAASgB,aAAc,KAAM,IAAIrB,gBAAiBe,EAAOiB,UAAW,IACpE3B,EAASG,WAAWgC,GAAG7B,UAAW,EAClCN,EAASG,WAAWgC,GAAGZ,aAAc,EACrCvB,EAASG,WAAWgC,GAAGlB,MAAkC,EAA1BP,EAAOiB,UAAUd,MAIlD,CAKA,SAASE,cAAe4B,EAAGC,EAAGC,EAAG5B,GAEhC,GAAc,GAATA,EAAa,CAEjB,MAAM6B,EAAOL,KAAKM,MAAmB,IAAVJ,EAAI,GAAY,KACrCK,EAAOP,KAAKM,MAAmB,IAAVH,EAAI,GAAY,KACrCK,EAAOR,KAAKM,MAAmB,IAAVF,EAAI,GAAY,KAC3C,OAAO,IAAIlC,WAAY,CAAEmC,EAAME,EAAMC,GAEtC,CAAO,GAAc,GAAThC,EAAa,CAExB,MAAM6B,EAAOL,KAAKM,MAAmB,IAAVJ,EAAI,GAAY,OACrCK,EAAOP,KAAKM,MAAmB,IAAVH,EAAI,GAAY,OACrCK,EAAOR,KAAKM,MAAmB,IAAVF,EAAI,GAAY,OAC3C,OAAO,IAAIxB,YAAa,CAAEyB,EAAME,EAAMC,GAEvC,CAEC7C,QAAQC,MAAO,iCAIjB,CAGA,SAASiB,aAAcqB,EAAGC,EAAGC,GAE5B,MAAMK,EAAUC,SAAU,IAAQ,EAAMV,KAAKW,MAAOR,EAAGD,GAAMF,KAAKY,IAAO,OACnEC,EAAUH,SAAU,IAAQ,EAAMN,GAAM,OAC9C,OAAO,IAAIxB,YAAa,CAAE6B,EAASI,GAEpC,CAGA,SAASnC,cAAewB,EAAGC,EAAGC,EAAG5B,GAEhC,IAAIsC,EAAKC,EAAKC,EAAMC,EAAYC,EAwChC,OApCAF,EAAOF,EAAMK,EAAejB,EAAGC,EAAGC,EAAG,QAAS,SAC9CW,EAAMK,EAAeN,GACrBI,EAAUG,EAAKnB,EAAGC,EAAGC,EAAGW,GAExBD,EAAMK,EAAejB,EAAGC,EAAGC,EAAG,OAAQ,SACtCW,EAAMK,EAAeN,GACrBG,EAAaI,EAAKnB,EAAGC,EAAGC,EAAGW,GAEtBE,EAAaC,IAEjBF,EAAOF,EACPI,EAAUD,GAIXH,EAAMK,EAAejB,EAAGC,EAAGC,EAAG,QAAS,QACvCW,EAAMK,EAAeN,GACrBG,EAAaI,EAAKnB,EAAGC,EAAGC,EAAGW,GAEtBE,EAAaC,IAEjBF,EAAOF,EACPI,EAAUD,GAIXH,EAAMK,EAAejB,EAAGC,EAAGC,EAAG,OAAQ,QACtCW,EAAMK,EAAeN,GACrBG,EAAaI,EAAKnB,EAAGC,EAAGC,EAAGW,GAEtBE,EAAaC,IAEjBF,EAAOF,GAIDE,EAEP,SAASG,EAAeG,EAAIC,EAAIC,EAAIC,EAAOC,GAE1C,IAAIxB,EAAIoB,GAAOtB,KAAK2B,IAAKL,GAAOtB,KAAK2B,IAAKJ,GAAOvB,KAAK2B,IAAKH,IACvDrB,EAAIoB,GAAOvB,KAAK2B,IAAKL,GAAOtB,KAAK2B,IAAKJ,GAAOvB,KAAK2B,IAAKH,IAE3D,GAAKpB,EAAI,EAAI,CAEZ,MAAMwB,GAAU,EAAI5B,KAAK2B,IAAKxB,KAAUD,GAAK,EAAI,GAAM,GACjD2B,GAAU,EAAI7B,KAAK2B,IAAKzB,KAAUC,GAAK,EAAI,GAAM,GAEvDD,EAAI0B,EACJzB,EAAI0B,EAEJ,IAAIC,EAAO,EAAI9B,KAAK2B,IAAKzB,GAAMF,KAAK2B,IAAKxB,GACpC2B,EAAO,IAEXA,GAAQ,KACR5B,GAAKA,EAAI,EAAI4B,EAAO,GAAMA,EAAO,EACjC3B,GAAKA,EAAI,EAAI2B,EAAO,GAAMA,EAAO,EAInC,CAEA,OAAc,GAATtD,EAEG,IAAIC,UAAW,CACrBuB,KAAMyB,GAAa,MAAJvB,GAAcA,EAAI,EAAI,EAAI,IACzCF,KAAM0B,GAAa,MAAJvB,GAAcA,EAAI,EAAI,EAAI,MAK7B,GAAT3B,EAEG,IAAIG,WAAY,CACtBqB,KAAMyB,GAAa,QAAJvB,GAAgBA,EAAI,EAAI,EAAI,IAC3CF,KAAM0B,GAAa,QAAJvB,GAAgBA,EAAI,EAAI,EAAI,WAJ7C,CAUD,CAEA,SAASiB,EAAeN,GAEvB,IAAIZ,EAAIY,EAAK,GACTX,EAAIW,EAAK,GAEC,GAATtC,GAEJ0B,GAAKA,EAAI,EAAI,IAAM,IACnBC,GAAKA,EAAI,EAAI,IAAM,KAEC,GAAT3B,IAEX0B,GAAKA,EAAI,EAAI,MAAQ,MACrBC,GAAKA,EAAI,EAAI,MAAQ,OAKtB,MAAMC,EAAI,EAAIJ,KAAK2B,IAAKzB,GAAMF,KAAK2B,IAAKxB,GAExC,GAAKC,EAAI,EAAI,CAEZ,MAAMC,EAAOH,EACbA,GAAM,EAAIF,KAAK2B,IAAKxB,KAAUD,GAAK,EAAI,GAAM,GAC7CC,GAAM,EAAIH,KAAK2B,IAAKtB,KAAaF,GAAK,EAAI,GAAM,EAEjD,CAEA,MAAM/B,EAAS4B,KAAK+B,KAAM7B,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAE9C,MAAO,CACNF,EAAI9B,EACJ+B,EAAI/B,EACJgC,EAAIhC,EAGN,CAEA,SAASiD,EAAKnB,EAAGC,EAAGC,EAAG4B,GAEtB,OAAO9B,EAAI8B,EAAM,GAAM7B,EAAI6B,EAAM,GAAM5B,EAAI4B,EAAM,EAElD,CAED,CAEA,SAAS7C,gBAAiBpB,EAAOS,GAEhC,IAAIU,EAAW+C,EAED,GAATzD,GAEJU,EAAY,IAAIhB,WAAYH,EAAMK,QAClC6D,EAAW,KAES,GAATzD,GAEXU,EAAY,IAAIN,YAAab,EAAMK,QACnC6D,EAAW,OAIXtE,QAAQC,MAAO,2BAIhB,MAAMsE,EAAY,IAAI9E,QAEhBwC,EAAM,IAAIuC,aAAc,GACxBrC,EAAM,IAAIqC,aAAc,GAE9BvC,EAAK,GAAMA,EAAK,GAAMA,EAAK,GAAMwC,OAAOC,UACxCvC,EAAK,GAAMA,EAAK,GAAMA,EAAK,IAAQsC,OAAOC,UAE1C,IAAM,IAAItC,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,GAAK,EAEvCH,EAAK,GAAMI,KAAKJ,IAAKA,EAAK,GAAK7B,EAAOgC,EAAI,IAC1CH,EAAK,GAAMI,KAAKJ,IAAKA,EAAK,GAAK7B,EAAOgC,EAAI,IAC1CH,EAAK,GAAMI,KAAKJ,IAAKA,EAAK,GAAK7B,EAAOgC,EAAI,IAC1CD,EAAK,GAAME,KAAKF,IAAKA,EAAK,GAAK/B,EAAOgC,EAAI,IAC1CD,EAAK,GAAME,KAAKF,IAAKA,EAAK,GAAK/B,EAAOgC,EAAI,IAC1CD,EAAK,GAAME,KAAKF,IAAKA,EAAK,GAAK/B,EAAOgC,EAAI,IAI3CmC,EAAUI,MAAO,IAAIjF,SAClByC,EAAK,GAAMF,EAAK,IAAQqC,GACxBnC,EAAK,GAAMF,EAAK,IAAQqC,GACxBnC,EAAK,GAAMF,EAAK,IAAQqC,IAG3BC,EAAUK,SAAU,IAAO3C,EAAK,GAChCsC,EAAUK,SAAU,IAAO3C,EAAK,GAChCsC,EAAUK,SAAU,IAAO3C,EAAK,GAEhCsC,EAAUM,YAGV,MAAMC,EAAa,IAAIN,aAAc,CACpCrC,EAAK,KAAQF,EAAK,GAAMqC,GAAanC,EAAK,GAAMF,EAAK,IAAQ,EAC7DE,EAAK,KAAQF,EAAK,GAAMqC,GAAanC,EAAK,GAAMF,EAAK,IAAQ,EAC7DE,EAAK,KAAQF,EAAK,GAAMqC,GAAanC,EAAK,GAAMF,EAAK,IAAQ,IAG9D,IAAM,IAAIG,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,GAAK,EAEvCb,EAAWa,EAAI,GAAMC,KAAK0C,OAAS3E,EAAOgC,EAAI,GAAMH,EAAK,IAAQ6C,EAAY,IAC7EvD,EAAWa,EAAI,GAAMC,KAAK0C,OAAS3E,EAAOgC,EAAI,GAAMH,EAAK,IAAQ6C,EAAY,IAC7EvD,EAAWa,EAAI,GAAMC,KAAK0C,OAAS3E,EAAOgC,EAAI,GAAMH,EAAK,IAAQ6C,EAAY,IAI9E,MAAO,CACNvD,UAAWA,EACXgD,UAAWA,EAGb,CAEA,SAASjC,kBAAmBlC,EAAOS,GAElC,IAAIU,EAAW+C,EAED,GAATzD,GAEJU,EAAY,IAAIhB,WAAYH,EAAMK,QAClC6D,EAAW,KAES,GAATzD,GAEXU,EAAY,IAAIN,YAAab,EAAMK,QACnC6D,EAAW,OAIXtE,QAAQC,MAAO,2BAIhB,MAAMsE,EAAY,IAAI/E,QAEhByC,EAAM,IAAIuC,aAAc,GACxBrC,EAAM,IAAIqC,aAAc,GAE9BvC,EAAK,GAAMA,EAAK,GAAMwC,OAAOC,UAC7BvC,EAAK,GAAMA,EAAK,IAAQsC,OAAOC,UAE/B,IAAM,IAAItC,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,GAAK,EAEvCH,EAAK,GAAMI,KAAKJ,IAAKA,EAAK,GAAK7B,EAAOgC,EAAI,IAC1CH,EAAK,GAAMI,KAAKJ,IAAKA,EAAK,GAAK7B,EAAOgC,EAAI,IAC1CD,EAAK,GAAME,KAAKF,IAAKA,EAAK,GAAK/B,EAAOgC,EAAI,IAC1CD,EAAK,GAAME,KAAKF,IAAKA,EAAK,GAAK/B,EAAOgC,EAAI,IAI3CmC,EAAUI,OACPxC,EAAK,GAAMF,EAAK,IAAQqC,GACxBnC,EAAK,GAAMF,EAAK,IAAQqC,GAG3BC,EAAUK,SAAU,GAAM3C,EAAK,GAC/BsC,EAAUK,SAAU,GAAM3C,EAAK,GAE/BsC,EAAUM,YAEV,MAAMC,EAAa,IAAIN,aAAc,CACpCrC,EAAK,KAAQF,EAAK,GAAMqC,GAAanC,EAAK,GAAMF,EAAK,IAAQ,EAC7DE,EAAK,KAAQF,EAAK,GAAMqC,GAAanC,EAAK,GAAMF,EAAK,IAAQ,IAG9D,IAAM,IAAIG,EAAI,EAAGA,EAAIhC,EAAMK,OAAQ2B,GAAK,EAEvCb,EAAWa,EAAI,GAAMC,KAAK0C,OAAS3E,EAAOgC,EAAI,GAAMH,EAAK,IAAQ6C,EAAY,IAC7EvD,EAAWa,EAAI,GAAMC,KAAK0C,OAAS3E,EAAOgC,EAAI,GAAMH,EAAK,IAAQ6C,EAAY,IAI9E,MAAO,CACNvD,UAAWA,EACXgD,UAAWA,EAGb,QAKC5E,gBACA0B,kBACAQ","ignoreList":[]}