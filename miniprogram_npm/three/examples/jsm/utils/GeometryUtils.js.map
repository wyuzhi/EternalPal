{"version":3,"file":"node_modules/three/examples/jsm/utils/GeometryUtils.js","names":["Vector3","hilbert2D","center","size","iterations","v0","v1","v2","v3","half","vec_s","x","y","z","vec","hilbert3D","v4","v5","v6","v7","gosper","config","currX","currY","angle","path","fractal","i","l","length","char","Math","cos","sin","push","toPoints","output","input","axiom","il","steps","j","jl","rules","fractalize","A","B","PI"],"sources":["node_modules/three/examples/jsm/utils/GeometryUtils.js"],"sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * @module GeometryUtils\n * @three_import import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';\n */\n\n/**\n * Generates 2D-Coordinates along a Hilbert curve.\n *\n * Based on work by: {@link http://www.openprocessing.org/sketch/15493}\n *\n * @param {Vector3} [center] - Center of Hilbert curve.\n * @param {number} [size=10] - Total width of Hilbert curve.\n * @param {number} [iterations=10] - Number of subdivisions.\n * @param {number} [v0=0] - Corner index -X, -Z.\n * @param {number} [v1=1] - Corner index -X, +Z.\n * @param {number} [v2=2] - Corner index +X, +Z.\n * @param {number} [v3=3] - Corner index +X, -Z.\n * @returns {Array<Vector3>} The Hilbert curve points.\n */\nfunction hilbert2D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3 ) {\n\n\tconst half = size / 2;\n\n\tconst vec_s = [\n\t\tnew Vector3( center.x - half, center.y, center.z - half ),\n\t\tnew Vector3( center.x - half, center.y, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y, center.z - half )\n\t];\n\n\tconst vec = [\n\t\tvec_s[ v0 ],\n\t\tvec_s[ v1 ],\n\t\tvec_s[ v2 ],\n\t\tvec_s[ v3 ]\n\t];\n\n\t// Recurse iterations\n\tif ( 0 <= -- iterations ) {\n\n\t\treturn [\n\t\t\t...hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ),\n\t\t\t...hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ),\n\t\t\t...hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ),\n\t\t\t...hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 )\n\t\t];\n\n\t}\n\n\t// Return complete Hilbert Curve.\n\treturn vec;\n\n}\n\n/**\n * Generates 3D-Coordinates along a Hilbert curve.\n *\n * Based on work by: {@link https://openprocessing.org/user/5654}\n *\n * @param {Vector3} [center] - Center of Hilbert curve.\n * @param {number} [size=10] - Total width of Hilbert curve.\n * @param {number} [iterations=1] - Number of subdivisions.\n * @param {number} [v0=0] - Corner index -X, +Y, -Z.\n * @param {number} [v1=1] - Corner index -X, +Y, +Z.\n * @param {number} [v2=2] - Corner index -X, -Y, +Z.\n * @param {number} [v3=3] - Corner index -X, -Y, -Z.\n * @param {number} [v4=4] - Corner index +X, -Y, -Z.\n * @param {number} [v5=5] - Corner index +X, -Y, +Z.\n * @param {number} [v6=6] - Corner index +X, +Y, +Z.\n * @param {number} [v7=7] - Corner index +X, +Y, -Z.\n * @returns {Array<Vector3>}  - The Hilbert curve points.\n */\nfunction hilbert3D( center = new Vector3( 0, 0, 0 ), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7 ) {\n\n\t// Default Vars\n\tconst half = size / 2;\n\n\tconst vec_s = [\n\t\tnew Vector3( center.x - half, center.y + half, center.z - half ),\n\t\tnew Vector3( center.x - half, center.y + half, center.z + half ),\n\t\tnew Vector3( center.x - half, center.y - half, center.z + half ),\n\t\tnew Vector3( center.x - half, center.y - half, center.z - half ),\n\t\tnew Vector3( center.x + half, center.y - half, center.z - half ),\n\t\tnew Vector3( center.x + half, center.y - half, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y + half, center.z + half ),\n\t\tnew Vector3( center.x + half, center.y + half, center.z - half )\n\t];\n\n\tconst vec = [\n\t\tvec_s[ v0 ],\n\t\tvec_s[ v1 ],\n\t\tvec_s[ v2 ],\n\t\tvec_s[ v3 ],\n\t\tvec_s[ v4 ],\n\t\tvec_s[ v5 ],\n\t\tvec_s[ v6 ],\n\t\tvec_s[ v7 ]\n\t];\n\n\t// Recurse iterations\n\tif ( -- iterations >= 0 ) {\n\n\t\treturn [\n\t\t\t...hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ),\n\t\t\t...hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),\n\t\t\t...hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ),\n\t\t\t...hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),\n\t\t\t...hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ),\n\t\t\t...hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),\n\t\t\t...hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ),\n\t\t\t...hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 )\n\t\t];\n\n\t}\n\n\t// Return complete Hilbert Curve.\n\treturn vec;\n\n}\n\n/**\n * Generates a Gosper curve (lying in the XY plane).\n *\n * Reference: {@link https://gist.github.com/nitaku/6521802}\n *\n * @param {number} [size=1] - The size of a single gosper island.\n * @return {Array<number>} The gosper island points.\n */\nfunction gosper( size = 1 ) {\n\n\tfunction fractalize( config ) {\n\n\t\tlet output;\n\t\tlet input = config.axiom;\n\n\t\tfor ( let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i ++ : i -- ) {\n\n\t\t\toutput = '';\n\n\t\t\tfor ( let j = 0, jl = input.length; j < jl; j ++ ) {\n\n\t\t\t\tconst char = input[ j ];\n\n\t\t\t\tif ( char in config.rules ) {\n\n\t\t\t\t\toutput += config.rules[ char ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\toutput += char;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tinput = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tfunction toPoints( config ) {\n\n\t\tlet currX = 0, currY = 0;\n\t\tlet angle = 0;\n\t\tconst path = [ 0, 0, 0 ];\n\t\tconst fractal = config.fractal;\n\n\t\tfor ( let i = 0, l = fractal.length; i < l; i ++ ) {\n\n\t\t\tconst char = fractal[ i ];\n\n\t\t\tif ( char === '+' ) {\n\n\t\t\t\tangle += config.angle;\n\n\t\t\t} else if ( char === '-' ) {\n\n\t\t\t\tangle -= config.angle;\n\n\t\t\t} else if ( char === 'F' ) {\n\n\t\t\t\tcurrX += config.size * Math.cos( angle );\n\t\t\t\tcurrY += - config.size * Math.sin( angle );\n\t\t\t\tpath.push( currX, currY, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn path;\n\n\t}\n\n\t//\n\n\tconst gosper = fractalize( {\n\t\taxiom: 'A',\n\t\tsteps: 4,\n\t\trules: {\n\t\t\tA: 'A+BF++BF-FA--FAFA-BF+',\n\t\t\tB: '-FA+BFBF++BF+FA--FA-B'\n\t\t}\n\t} );\n\n\tconst points = toPoints( {\n\t\tfractal: gosper,\n\t\tsize: size,\n\t\tangle: Math.PI / 3 // 60 degrees\n\t} );\n\n\treturn points;\n\n}\n\n\n\nexport {\n\thilbert2D,\n\thilbert3D,\n\tgosper,\n};\n"],"mappings":"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","ignoreList":[]}