{"version":3,"file":"node_modules/three/examples/jsm/utils/LDrawUtils.js","names":["BufferAttribute","BufferGeometry","Group","LineSegments","Matrix3","Mesh","mergeGeometries","LDrawUtils","mergeObject","object","extractGroup","geometry","group","elementSize","isConditionalLine","newGeometry","originalPositions","getAttribute","array","originalNormals","numVertsGroup","Math","min","count","floor","length","start","vertStart","vertEnd","positions","subarray","normals","setAttribute","controlArray0","controlArray1","directionArray","addGeometry","mat","geometries","geoms","uuid","arr","push","permuteAttribute","attribute","elemSize","verts","numVerts","offset","i","x","y","z","meshGeometries","linesGeometries","condLinesGeometries","updateMatrixWorld","normalMatrix","traverse","c","isMesh","isLineSegments","clone","matrixWorld","determinant","attributes","position","normal","applyMatrix4","control0","control1","getNormalMatrix","direction","applyNormalMatrix","Array","isArray","material","groupIndex","groups","materialIndex","mergedObject","meshMaterialsIds","Object","keys","meshMaterialsId","meshGeometry","mergedGeometry","add","linesMaterialsIds","linesMaterialsId","lineGeometry","condLinesMaterialsIds","condLinesMaterialsId","condLineGeometry","condLines","userData","constructionStep","numConstructionSteps"],"sources":["node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\n/**\n * Utility class for LDraw models.\n *\n * @three_import import { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n */\nclass LDrawUtils {\n\n\t/**\n\t * Merges geometries in the given object by materials and returns a new group object.\n\t * Use on not indexed geometries. The object buffers reference the old object ones.\n\t * Special treatment is done to the conditional lines generated by LDrawLoader.\n\t *\n\t * @param {Object3D} object - The object to merge.\n\t * @returns {Group} The merged object.\n\t */\n\tstatic mergeObject( object ) {\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const meshMaterialsId of meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const linesMaterialsId of linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const condLinesMaterialsId of condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"mappings":"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","ignoreList":[]}