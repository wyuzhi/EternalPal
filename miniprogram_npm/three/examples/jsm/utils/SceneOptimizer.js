import*as THREE from"three";class SceneOptimizer{constructor(e,t={}){this.scene=e,this.debug=t.debug||!1}_bufferToHash(e){let t=0;if(0!==e.byteLength){let s;s=e.buffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(e);for(let r=0;r<e.byteLength;r++){t=(t<<5)-t+s[r],t|=0}}return t}_getMaterialPropertiesHash(e){const t=["map","alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lightMap","metalnessMap","normalMap","roughnessMap"].map((t=>{const s=e[t];return s?`${s.uuid}_${s.offset.x}_${s.offset.y}_${s.repeat.x}_${s.repeat.y}_${s.rotation}`:0})).join("|"),s=["transparent","opacity","alphaTest","alphaToCoverage","side","vertexColors","visible","blending","wireframe","flatShading","premultipliedAlpha","dithering","toneMapped","depthTest","depthWrite","metalness","roughness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","transmission","thickness","attenuationDistance","ior","iridescence","iridescenceIOR","iridescenceThicknessRange","reflectivity"].map((t=>void 0===e[t]||null===e[t]?0:e[t].toString())).join("|"),r=e.emissive?e.emissive.getHexString():0,o=e.attenuationColor?e.attenuationColor.getHexString():0,a=e.sheenColor?e.sheenColor.getHexString():0;return[e.type,s,t,r,o,a].join("_")}_getAttributesSignature(e){return Object.keys(e.attributes).sort().map((t=>{const s=e.attributes[t];return`${t}_${s.itemSize}_${s.normalized}`})).join("|")}_getGeometryHash(e){return`${e.index?this._bufferToHash(e.index.array):"noIndex"}_${this._bufferToHash(e.attributes.position.array)}_${this._getAttributesSignature(e)}`}_getBatchKey(e,t){return`${e}_${t}`}_analyzeModel(){const e=new Map,t=new Map,s=new Set;this.scene.updateMatrixWorld(!0),this.scene.traverse((t=>{if(!t.isMesh)return;const r=this._getMaterialPropertiesHash(t.material),o=this._getAttributesSignature(t.geometry),a=this._getBatchKey(r,o),n=this._getGeometryHash(t.geometry);s.add(n),e.has(a)||e.set(a,{meshes:[],geometryStats:new Map,totalInstances:0,materialProps:t.material.clone()});const i=e.get(a);i.meshes.push(t),i.totalInstances++,i.geometryStats.has(n)||i.geometryStats.set(n,{count:0,vertices:t.geometry.attributes.position.count,indices:t.geometry.index?t.geometry.index.count:0,geometry:t.geometry}),i.geometryStats.get(n).count++}));for(const[s,r]of e)1===r.totalInstances&&(t.set(s,r),e.delete(s));return{batchGroups:e,singleGroups:t,uniqueGeometries:s.size}}_createBatchedMeshes(e){const t=new Set;for(const[,s]of e){const e=s.totalInstances,r=Array.from(s.geometryStats.values()).reduce(((e,t)=>e+t.vertices),0),o=Array.from(s.geometryStats.values()).reduce(((e,t)=>e+t.indices),0),a=new s.materialProps.constructor(s.materialProps);void 0!==a.color&&a.color.set(1,1,1);const n=new THREE.BatchedMesh(e,r,o,a),i=s.meshes[0];n.name=`${i.name}_batch`;const c=new Map,l=new THREE.Matrix4;i.parent&&(i.parent.updateWorldMatrix(!0,!1),l.copy(i.parent.matrixWorld).invert());for(const e of s.meshes){const s=this._getGeometryHash(e.geometry);c.has(s)||c.set(s,n.addGeometry(e.geometry));const r=c.get(s),o=n.addInstance(r),a=new THREE.Matrix4;e.updateWorldMatrix(!0,!1),a.copy(e.matrixWorld),i.parent&&a.premultiply(l),n.setMatrixAt(o,a),n.setColorAt(o,e.material.color),t.add(e)}i.parent&&i.parent.add(n)}return t}removeEmptyNodes(e){const t=[...e.children];for(const s of t)this.removeEmptyNodes(s),(s instanceof THREE.Group||s.constructor===THREE.Object3D)&&0===s.children.length&&e.remove(s)}disposeMeshes(e){e.forEach((e=>{e.parent&&e.parent.remove(e),e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach((e=>e.dispose())):e.material.dispose())}))}_logDebugInfo(e){console.group("Scene Optimization Results"),console.log(`Original meshes: ${e.originalMeshes}`),console.log(`Batched into: ${e.batchedMeshes} BatchedMesh`),console.log(`Single meshes: ${e.singleMeshes} Mesh`),console.log(`Total draw calls: ${e.drawCalls}`),console.log(`Reduction Ratio: ${e.reductionRatio}% fewer draw calls`),console.groupEnd()}toBatchedMesh(){const{batchGroups:e,singleGroups:t,uniqueGeometries:s}=this._analyzeModel(),r=this._createBatchedMeshes(e);if(this.disposeMeshes(r),this.removeEmptyNodes(this.scene),this.debug){const o=r.size+t.size,a=e.size+t.size,n={originalMeshes:o,batchedMeshes:e.size,singleMeshes:t.size,drawCalls:a,uniqueGeometries:s,reductionRatio:(100*(1-a/o)).toFixed(1)};this._logDebugInfo(n)}return this.scene}toInstancingMesh(){throw new Error("InstancedMesh optimization not implemented yet")}}export{SceneOptimizer};
//# sourceMappingURL=SceneOptimizer.js.map