{"version":3,"file":"node_modules/three/examples/jsm/utils/SceneOptimizer.js","names":["THREE","SceneOptimizer","constructor","scene","options","this","debug","_bufferToHash","buffer","hash","byteLength","uintArray","Uint8Array","byteOffset","i","_getMaterialPropertiesHash","material","mapHash","map","prop","uuid","offset","x","y","repeat","rotation","join","physicalProps","toString","emissiveHash","emissive","getHexString","attenuationHash","attenuationColor","sheenColorHash","sheenColor","type","_getAttributesSignature","geometry","Object","keys","attributes","sort","name","attribute","itemSize","normalized","_getGeometryHash","index","array","position","_getBatchKey","materialProps","attributesSignature","_analyzeModel","batchGroups","Map","singleGroups","uniqueGeometries","Set","updateMatrixWorld","traverse","node","isMesh","batchKey","geometryHash","add","has","set","meshes","geometryStats","totalInstances","clone","group","get","push","count","vertices","indices","delete","size","_createBatchedMeshes","meshesToRemove","maxGeometries","maxVertices","Array","from","values","reduce","sum","stats","maxIndices","batchedMaterial","undefined","color","batchedMesh","BatchedMesh","referenceMesh","geometryIds","inverseParentMatrix","Matrix4","parent","updateWorldMatrix","copy","matrixWorld","invert","mesh","addGeometry","geometryId","instanceId","addInstance","localMatrix","premultiply","setMatrixAt","setColorAt","removeEmptyNodes","object","children","child","Group","Object3D","length","remove","disposeMeshes","forEach","dispose","isArray","m","_logDebugInfo","console","log","originalMeshes","batchedMeshes","singleMeshes","drawCalls","reductionRatio","groupEnd","toBatchedMesh","totalOriginalMeshes","totalFinalMeshes","toFixed","toInstancingMesh","Error"],"sources":["node_modules/three/examples/jsm/utils/SceneOptimizer.js"],"sourcesContent":["import * as THREE from 'three';\n\n/**\n * This class can be used to optimized scenes by converting\n * individual meshes into {@link BatchedMesh}. This component\n * is an experimental attempt to implement auto-batching in three.js.\n *\n * @three_import import { SceneOptimizer } from 'three/addons/utils/SceneOptimizer.js';\n */\nclass SceneOptimizer {\n\n\t/**\n\t * Constructs a new scene optimizer.\n\t *\n\t * @param {Scene} scene - The scene to optimize.\n\t * @param {SceneOptimizer~Options} options - The configuration options.\n\t */\n\tconstructor( scene, options = {} ) {\n\n\t\tthis.scene = scene;\n\t\tthis.debug = options.debug || false;\n\n\t}\n\n\t_bufferToHash( buffer ) {\n\n\t\tlet hash = 0;\n\t\tif ( buffer.byteLength !== 0 ) {\n\n\t\t\tlet uintArray;\n\t\t\tif ( buffer.buffer ) {\n\n\t\t\t\tuintArray = new Uint8Array(\n\t\t\t\t\tbuffer.buffer,\n\t\t\t\t\tbuffer.byteOffset,\n\t\t\t\t\tbuffer.byteLength\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tuintArray = new Uint8Array( buffer );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < buffer.byteLength; i ++ ) {\n\n\t\t\t\tconst byte = uintArray[ i ];\n\t\t\t\thash = ( hash << 5 ) - hash + byte;\n\t\t\t\thash |= 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn hash;\n\n\t}\n\n\t_getMaterialPropertiesHash( material ) {\n\n\t\tconst mapProps = [\n\t\t\t'map',\n\t\t\t'alphaMap',\n\t\t\t'aoMap',\n\t\t\t'bumpMap',\n\t\t\t'displacementMap',\n\t\t\t'emissiveMap',\n\t\t\t'envMap',\n\t\t\t'lightMap',\n\t\t\t'metalnessMap',\n\t\t\t'normalMap',\n\t\t\t'roughnessMap',\n\t\t];\n\n\t\tconst mapHash = mapProps\n\t\t\t.map( ( prop ) => {\n\n\t\t\t\tconst map = material[ prop ];\n\t\t\t\tif ( ! map ) return 0;\n\t\t\t\treturn `${map.uuid}_${map.offset.x}_${map.offset.y}_${map.repeat.x}_${map.repeat.y}_${map.rotation}`;\n\n\t\t\t} )\n\t\t\t.join( '|' );\n\n\t\tconst physicalProps = [\n\t\t\t'transparent',\n\t\t\t'opacity',\n\t\t\t'alphaTest',\n\t\t\t'alphaToCoverage',\n\t\t\t'side',\n\t\t\t'vertexColors',\n\t\t\t'visible',\n\t\t\t'blending',\n\t\t\t'wireframe',\n\t\t\t'flatShading',\n\t\t\t'premultipliedAlpha',\n\t\t\t'dithering',\n\t\t\t'toneMapped',\n\t\t\t'depthTest',\n\t\t\t'depthWrite',\n\t\t\t'metalness',\n\t\t\t'roughness',\n\t\t\t'clearcoat',\n\t\t\t'clearcoatRoughness',\n\t\t\t'sheen',\n\t\t\t'sheenRoughness',\n\t\t\t'transmission',\n\t\t\t'thickness',\n\t\t\t'attenuationDistance',\n\t\t\t'ior',\n\t\t\t'iridescence',\n\t\t\t'iridescenceIOR',\n\t\t\t'iridescenceThicknessRange',\n\t\t\t'reflectivity',\n\t\t]\n\t\t\t.map( ( prop ) => {\n\n\t\t\t\tif ( typeof material[ prop ] === 'undefined' ) return 0;\n\t\t\t\tif ( material[ prop ] === null ) return 0;\n\t\t\t\treturn material[ prop ].toString();\n\n\t\t\t} )\n\t\t\t.join( '|' );\n\n\t\tconst emissiveHash = material.emissive ? material.emissive.getHexString() : 0;\n\t\tconst attenuationHash = material.attenuationColor\n\t\t\t? material.attenuationColor.getHexString()\n\t\t\t: 0;\n\t\tconst sheenColorHash = material.sheenColor\n\t\t\t? material.sheenColor.getHexString()\n\t\t\t: 0;\n\n\t\treturn [\n\t\t\tmaterial.type,\n\t\t\tphysicalProps,\n\t\t\tmapHash,\n\t\t\temissiveHash,\n\t\t\tattenuationHash,\n\t\t\tsheenColorHash,\n\t\t].join( '_' );\n\n\t}\n\n\t_getAttributesSignature( geometry ) {\n\n\t\treturn Object.keys( geometry.attributes )\n\t\t\t.sort()\n\t\t\t.map( ( name ) => {\n\n\t\t\t\tconst attribute = geometry.attributes[ name ];\n\t\t\t\treturn `${name}_${attribute.itemSize}_${attribute.normalized}`;\n\n\t\t\t} )\n\t\t\t.join( '|' );\n\n\t}\n\n\t_getGeometryHash( geometry ) {\n\n\t\tconst indexHash = geometry.index\n\t\t\t? this._bufferToHash( geometry.index.array )\n\t\t\t: 'noIndex';\n\t\tconst positionHash = this._bufferToHash( geometry.attributes.position.array );\n\t\tconst attributesSignature = this._getAttributesSignature( geometry );\n\t\treturn `${indexHash}_${positionHash}_${attributesSignature}`;\n\n\t}\n\n\t_getBatchKey( materialProps, attributesSignature ) {\n\n\t\treturn `${materialProps}_${attributesSignature}`;\n\n\t}\n\n\t_analyzeModel() {\n\n\t\tconst batchGroups = new Map();\n\t\tconst singleGroups = new Map();\n\t\tconst uniqueGeometries = new Set();\n\n\t\tthis.scene.updateMatrixWorld( true );\n\t\tthis.scene.traverse( ( node ) => {\n\n\t\t\tif ( ! node.isMesh ) return;\n\n\t\t\tconst materialProps = this._getMaterialPropertiesHash( node.material );\n\t\t\tconst attributesSignature = this._getAttributesSignature( node.geometry );\n\t\t\tconst batchKey = this._getBatchKey( materialProps, attributesSignature );\n\t\t\tconst geometryHash = this._getGeometryHash( node.geometry );\n\t\t\tuniqueGeometries.add( geometryHash );\n\n\t\t\tif ( ! batchGroups.has( batchKey ) ) {\n\n\t\t\t\tbatchGroups.set( batchKey, {\n\t\t\t\t\tmeshes: [],\n\t\t\t\t\tgeometryStats: new Map(),\n\t\t\t\t\ttotalInstances: 0,\n\t\t\t\t\tmaterialProps: node.material.clone(),\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst group = batchGroups.get( batchKey );\n\t\t\tgroup.meshes.push( node );\n\t\t\tgroup.totalInstances ++;\n\n\t\t\tif ( ! group.geometryStats.has( geometryHash ) ) {\n\n\t\t\t\tgroup.geometryStats.set( geometryHash, {\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tvertices: node.geometry.attributes.position.count,\n\t\t\t\t\tindices: node.geometry.index ? node.geometry.index.count : 0,\n\t\t\t\t\tgeometry: node.geometry,\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tgroup.geometryStats.get( geometryHash ).count ++;\n\n\t\t} );\n\n\t\t// Move single instance groups to singleGroups\n\t\tfor ( const [ batchKey, group ] of batchGroups ) {\n\n\t\t\tif ( group.totalInstances === 1 ) {\n\n\t\t\t\tsingleGroups.set( batchKey, group );\n\t\t\t\tbatchGroups.delete( batchKey );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn { batchGroups, singleGroups, uniqueGeometries: uniqueGeometries.size };\n\n\t}\n\n\t_createBatchedMeshes( batchGroups ) {\n\n\t\tconst meshesToRemove = new Set();\n\n\t\tfor ( const [ , group ] of batchGroups ) {\n\n\t\t\tconst maxGeometries = group.totalInstances;\n\t\t\tconst maxVertices = Array.from( group.geometryStats.values() ).reduce(\n\t\t\t\t( sum, stats ) => sum + stats.vertices,\n\t\t\t\t0\n\t\t\t);\n\t\t\tconst maxIndices = Array.from( group.geometryStats.values() ).reduce(\n\t\t\t\t( sum, stats ) => sum + stats.indices,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\tconst batchedMaterial = new group.materialProps.constructor( group.materialProps );\n\n\t\t\tif ( batchedMaterial.color !== undefined ) {\n\n\t\t\t\t// Reset color to white, color will be set per instance\n\t\t\t\tbatchedMaterial.color.set( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t\tconst batchedMesh = new THREE.BatchedMesh(\n\t\t\t\tmaxGeometries,\n\t\t\t\tmaxVertices,\n\t\t\t\tmaxIndices,\n\t\t\t\tbatchedMaterial\n\t\t\t);\n\n\t\t\tconst referenceMesh = group.meshes[ 0 ];\n\t\t\tbatchedMesh.name = `${referenceMesh.name}_batch`;\n\n\t\t\tconst geometryIds = new Map();\n\t\t\tconst inverseParentMatrix = new THREE.Matrix4();\n\n\t\t\tif ( referenceMesh.parent ) {\n\n\t\t\t\treferenceMesh.parent.updateWorldMatrix( true, false );\n\t\t\t\tinverseParentMatrix.copy( referenceMesh.parent.matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tfor ( const mesh of group.meshes ) {\n\n\t\t\t\tconst geometryHash = this._getGeometryHash( mesh.geometry );\n\n\t\t\t\tif ( ! geometryIds.has( geometryHash ) ) {\n\n\t\t\t\t\tgeometryIds.set( geometryHash, batchedMesh.addGeometry( mesh.geometry ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometryId = geometryIds.get( geometryHash );\n\t\t\t\tconst instanceId = batchedMesh.addInstance( geometryId );\n\n\t\t\t\tconst localMatrix = new THREE.Matrix4();\n\t\t\t\tmesh.updateWorldMatrix( true, false );\n\t\t\t\tlocalMatrix.copy( mesh.matrixWorld );\n\t\t\t\tif ( referenceMesh.parent ) {\n\n\t\t\t\t\tlocalMatrix.premultiply( inverseParentMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tbatchedMesh.setMatrixAt( instanceId, localMatrix );\n\t\t\t\tbatchedMesh.setColorAt( instanceId, mesh.material.color );\n\n\t\t\t\tmeshesToRemove.add( mesh );\n\n\t\t\t}\n\n\t\t\tif ( referenceMesh.parent ) {\n\n\t\t\t\treferenceMesh.parent.add( batchedMesh );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn meshesToRemove;\n\n\t}\n\n\t/**\n\t * Removes empty nodes from all descendants of the given 3D object.\n\t *\n\t * @param {Object3D} object - The 3D object to process.\n\t */\n\tremoveEmptyNodes( object ) {\n\n\t\tconst children = [ ...object.children ];\n\n\t\tfor ( const child of children ) {\n\n\t\t\tthis.removeEmptyNodes( child );\n\n\t\t\tif ( ( child instanceof THREE.Group || child.constructor === THREE.Object3D )\n                && child.children.length === 0 ) {\n\n\t\t\t\tobject.remove( child );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes the given array of meshes from the scene.\n\t *\n\t * @param {Set<Mesh>} meshesToRemove - The meshes to remove.\n\t */\n\tdisposeMeshes( meshesToRemove ) {\n\n\t\tmeshesToRemove.forEach( ( mesh ) => {\n\n\t\t\tif ( mesh.parent ) {\n\n\t\t\t\tmesh.parent.remove( mesh );\n\n\t\t\t}\n\n\t\t\tif ( mesh.geometry ) mesh.geometry.dispose();\n\t\t\tif ( mesh.material ) {\n\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tmesh.material.forEach( ( m ) => m.dispose() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmesh.material.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_logDebugInfo( stats ) {\n\n\t\tconsole.group( 'Scene Optimization Results' );\n\t\tconsole.log( `Original meshes: ${stats.originalMeshes}` );\n\t\tconsole.log( `Batched into: ${stats.batchedMeshes} BatchedMesh` );\n\t\tconsole.log( `Single meshes: ${stats.singleMeshes} Mesh` );\n\t\tconsole.log( `Total draw calls: ${stats.drawCalls}` );\n\t\tconsole.log( `Reduction Ratio: ${stats.reductionRatio}% fewer draw calls` );\n\t\tconsole.groupEnd();\n\n\t}\n\n\t/**\n\t * Performs the auto-baching by identifying groups of meshes in the scene\n\t * that can be represented as a single {@link BatchedMesh}. The method modifies\n\t * the scene by adding instances of `BatchedMesh` and removing the now redundant\n\t * individual meshes.\n\t *\n\t * @return {Scene} The optimized scene.\n\t */\n\ttoBatchedMesh() {\n\n\t\tconst { batchGroups, singleGroups, uniqueGeometries } = this._analyzeModel();\n\t\tconst meshesToRemove = this._createBatchedMeshes( batchGroups );\n\n\t\tthis.disposeMeshes( meshesToRemove );\n\t\tthis.removeEmptyNodes( this.scene );\n\n\t\tif ( this.debug ) {\n\n\t\t\tconst totalOriginalMeshes = meshesToRemove.size + singleGroups.size;\n\t\t\tconst totalFinalMeshes = batchGroups.size + singleGroups.size;\n\n\t\t\tconst stats = {\n\t\t\t\toriginalMeshes: totalOriginalMeshes,\n\t\t\t\tbatchedMeshes: batchGroups.size,\n\t\t\t\tsingleMeshes: singleGroups.size,\n\t\t\t\tdrawCalls: totalFinalMeshes,\n\t\t\t\tuniqueGeometries: uniqueGeometries,\n\t\t\t\treductionRatio: ( ( 1 - totalFinalMeshes / totalOriginalMeshes ) * 100 ).toFixed( 1 ),\n\t\t\t};\n\n\t\t\tthis._logDebugInfo( stats );\n\n\t\t}\n\n\t\treturn this.scene;\n\n\t}\n\n\t/**\n\t * Performs the auto-instancing by identifying groups of meshes in the scene\n\t * that can be represented as a single {@link InstancedMesh}. The method modifies\n\t * the scene by adding instances of `InstancedMesh` and removing the now redundant\n\t * individual meshes.\n\t *\n\t * This method is not yet implemented.\n\t *\n\t * @abstract\n\t * @return {Scene} The optimized scene.\n\t */\n\ttoInstancingMesh() {\n\n\t\tthrow new Error( 'InstancedMesh optimization not implemented yet' );\n\n\t}\n\n}\n\n/**\n * Constructor options of `SceneOptimizer`.\n *\n * @typedef {Object} SceneOptimizer~Options\n * @property {boolean} [debug=false] - Whether to enable debug mode or not.\n **/\n\nexport { SceneOptimizer };\n"],"mappings":"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","ignoreList":[]}