{"version":3,"file":"node_modules/three/examples/jsm/utils/SceneUtils.js","names":["BufferAttribute","BufferGeometry","Color","Group","Matrix4","Mesh","Vector3","mergeGroups","deepCloneAttribute","_color","_matrix","createMeshesFromInstancedMesh","instancedMesh","group","count","geometry","material","i","mesh","getMatrixAt","matrix","decompose","position","quaternion","scale","add","copy","updateMatrixWorld","createMeshesFromMultiMaterialMesh","Array","isArray","console","warn","object","index","groups","attributeNames","Object","keys","attributes","length","start","end","newGeometry","newMaterial","materialIndex","j","name","attribute","itemSize","newLength","newArray","type","array","constructor","newAttribute","k","n","ind","getX","setX","setY","getY","setZ","getZ","setW","getW","setAttribute","newMesh","createMultiMaterialObject","materials","l","reduceVertices","func","initialValue","value","vertex","updateWorldMatrix","traverseVisible","child","undefined","isMesh","getVertexPosition","fromBufferAttribute","isSkinnedMesh","applyMatrix4","matrixWorld","sortInstancedMesh","compareFn","instanceMatrixRef","instanceMatrix","instanceColorRef","instanceColor","attributeRefs","Map","isInstancedBufferAttribute","set","tokens","push","sort","refIndex","fromArray","toArray","attributeRef","get","traverseGenerator","children","traverseVisibleGenerator","visible","traverseAncestorsGenerator","parent"],"sources":["node_modules/three/examples/jsm/utils/SceneUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tGroup,\n\tMatrix4,\n\tMesh,\n\tVector3\n} from 'three';\n\nimport { mergeGroups, deepCloneAttribute } from './BufferGeometryUtils.js';\n\n/**\n * @module SceneUtils\n * @three_import import * as SceneUtils from 'three/addons/utils/SceneUtils.js';\n */\n\nconst _color = /*@__PURE__*/new Color();\nconst _matrix = /*@__PURE__*/new Matrix4();\n\n/**\n * This function creates a mesh for each instance of the given instanced mesh and\n * adds it to a group. Each mesh will honor the current 3D transformation of its\n * corresponding instance.\n *\n * @param {InstancedMesh} instancedMesh - The instanced mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromInstancedMesh( instancedMesh ) {\n\n\tconst group = new Group();\n\n\tconst count = instancedMesh.count;\n\tconst geometry = instancedMesh.geometry;\n\tconst material = instancedMesh.material;\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tinstancedMesh.getMatrixAt( i, mesh.matrix );\n\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\tgroup.add( mesh );\n\n\t}\n\n\tgroup.copy( instancedMesh );\n\tgroup.updateMatrixWorld(); // ensure correct world matrices of meshes\n\n\treturn group;\n\n}\n\n/**\n * This function creates a mesh for each geometry-group of the given multi-material mesh and\n * adds it to a group.\n *\n * @param {Mesh} mesh - The multi-material mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromMultiMaterialMesh( mesh ) {\n\n\tif ( Array.isArray( mesh.material ) === false ) {\n\n\t\tconsole.warn( 'THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.' );\n\t\treturn mesh;\n\n\t}\n\n\tconst object = new Group();\n\tobject.copy( mesh );\n\n\t// merge groups (which automatically sorts them)\n\n\tconst geometry = mergeGroups( mesh.geometry );\n\n\tconst index = geometry.index;\n\tconst groups = geometry.groups;\n\tconst attributeNames = Object.keys( geometry.attributes );\n\n\t// create a mesh for each group by extracting the buffer data into a new geometry\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst start = group.start;\n\t\tconst end = start + group.count;\n\n\t\tconst newGeometry = new BufferGeometry();\n\t\tconst newMaterial = mesh.material[ group.materialIndex ];\n\n\t\t// process all buffer attributes\n\n\t\tfor ( let j = 0; j < attributeNames.length; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.attributes[ name ];\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst newLength = group.count * itemSize;\n\t\t\tconst type = attribute.array.constructor;\n\n\t\t\tconst newArray = new type( newLength );\n\t\t\tconst newAttribute = new BufferAttribute( newArray, itemSize );\n\n\t\t\tfor ( let k = start, n = 0; k < end; k ++, n ++ ) {\n\n\t\t\t\tconst ind = index.getX( k );\n\n\t\t\t\tif ( itemSize >= 1 ) newAttribute.setX( n, attribute.getX( ind ) );\n\t\t\t\tif ( itemSize >= 2 ) newAttribute.setY( n, attribute.getY( ind ) );\n\t\t\t\tif ( itemSize >= 3 ) newAttribute.setZ( n, attribute.getZ( ind ) );\n\t\t\t\tif ( itemSize >= 4 ) newAttribute.setW( n, attribute.getW( ind ) );\n\n\t\t\t}\n\n\n\t\t\tnewGeometry.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\tconst newMesh = new Mesh( newGeometry, newMaterial );\n\t\tobject.add( newMesh );\n\n\t}\n\n\treturn object;\n\n}\n\n/**\n * This function represents an alternative way to create 3D objects with multiple materials.\n * Normally, {@link BufferGeometry#groups} are used which might introduce issues e.g. when\n * exporting the object to a 3D format. This function accepts a geometry and an array of\n * materials and creates for each material a mesh that is added to a group.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @param {Array<Material>} materials - An array of materials.\n * @return {Group} A group representing a multi-material object.\n */\nfunction createMultiMaterialObject( geometry, materials ) {\n\n\tconst group = new Group();\n\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t}\n\n\treturn group;\n\n}\n\n\n/**\n * Executes a reducer function for each vertex of the given 3D object.\n * `reduceVertices()` returns a single value: the function's accumulated result.\n *\n * @param {Object3D} object - The 3D object that should be processed. It must have a\n * geometry with a `position` attribute.\n * @param {function(number,Vector3):number} func - The reducer function. First argument\n * is the current value, second argument the current vertex.\n * @param {any} initialValue - The initial value.\n * @return {any} The result.\n */\nfunction reduceVertices( object, func, initialValue ) {\n\n\tlet value = initialValue;\n\tconst vertex = new Vector3();\n\n\tobject.updateWorldMatrix( true, true );\n\n\tobject.traverseVisible( ( child ) => {\n\n\t\tconst { geometry } = child;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst { position } = geometry.attributes;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.getVertexPosition( i, vertex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! child.isSkinnedMesh ) {\n\n\t\t\t\t\t\tvertex.applyMatrix4( child.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = func( value, vertex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn value;\n\n}\n\n/**\n * Sorts the instances of the given instanced mesh.\n *\n * @param {InstancedMesh} mesh - The instanced mesh to sort.\n * @param {function(number, number):number} compareFn - A custom compare function for the sort.\n */\nfunction sortInstancedMesh( mesh, compareFn ) {\n\n\t// store copy of instanced attributes for lookups\n\n\tconst instanceMatrixRef = deepCloneAttribute( mesh.instanceMatrix );\n\tconst instanceColorRef = mesh.instanceColor ? deepCloneAttribute( mesh.instanceColor ) : null;\n\n\tconst attributeRefs = new Map();\n\n\tfor ( const name in mesh.geometry.attributes ) {\n\n\t\tconst attribute = mesh.geometry.attributes[ name ];\n\n\t\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\t\tattributeRefs.set( attribute, deepCloneAttribute( attribute ) );\n\n\t\t}\n\n\t}\n\n\n\t// compute sort order\n\n\tconst tokens = [];\n\n\tfor ( let i = 0; i < mesh.count; i ++ ) tokens.push( i );\n\n\ttokens.sort( compareFn );\n\n\n\t// apply sort order\n\n\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\tconst refIndex = tokens[ i ];\n\n\t\t_matrix.fromArray( instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize );\n\t\t_matrix.toArray( mesh.instanceMatrix.array, i * mesh.instanceMatrix.itemSize );\n\n\t\tif ( mesh.instanceColor ) {\n\n\t\t\t_color.fromArray( instanceColorRef.array, refIndex * mesh.instanceColor.itemSize );\n\t\t\t_color.toArray( mesh.instanceColor.array, i * mesh.instanceColor.itemSize );\n\n\t\t}\n\n\t\tfor ( const name in mesh.geometry.attributes ) {\n\n\t\t\tconst attribute = mesh.geometry.attributes[ name ];\n\n\t\t\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\t\t\tconst attributeRef = attributeRefs.get( attribute );\n\n\t\t\t\tattribute.setX( i, attributeRef.getX( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 1 ) attribute.setY( i, attributeRef.getY( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 2 ) attribute.setZ( i, attributeRef.getZ( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 3 ) attribute.setW( i, attributeRef.getW( refIndex ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverse}.\n *\n * @param {Object3D} object - Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseGenerator( object ) {\n\n\tyield object;\n\n\tconst children = object.children;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tyield* traverseGenerator( children[ i ] );\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseVisible}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseVisibleGenerator( object ) {\n\n\tif ( object.visible === false ) return;\n\n\tyield object;\n\n\tconst children = object.children;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tyield* traverseVisibleGenerator( children[ i ] );\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseAncestors}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseAncestorsGenerator( object ) {\n\n\tconst parent = object.parent;\n\n\tif ( parent !== null ) {\n\n\t\tyield parent;\n\n\t\tyield* traverseAncestorsGenerator( parent );\n\n\t}\n\n}\n\nexport {\n\tcreateMeshesFromInstancedMesh,\n\tcreateMeshesFromMultiMaterialMesh,\n\tcreateMultiMaterialObject,\n\treduceVertices,\n\tsortInstancedMesh,\n\ttraverseGenerator,\n\ttraverseVisibleGenerator,\n\ttraverseAncestorsGenerator\n};\n"],"mappings":"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","ignoreList":[]}