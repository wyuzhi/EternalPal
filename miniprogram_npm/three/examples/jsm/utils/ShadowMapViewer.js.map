{"version":3,"file":"node_modules/three/examples/jsm/utils/ShadowMapViewer.js","names":["DoubleSide","CanvasTexture","Mesh","MeshBasicMaterial","OrthographicCamera","PlaneGeometry","Scene","ShaderMaterial","UniformsUtils","UnpackDepthRGBAShader","ShadowMapViewer","constructor","light","scope","this","doRenderLabel","undefined","name","userAutoClearSetting","frame","camera","window","innerWidth","innerHeight","position","set","scene","shader","uniforms","clone","material","vertexShader","fragmentShader","plane","mesh","labelCanvas","labelMesh","add","document","createElement","context","getContext","font","labelWidth","measureText","width","height","fillStyle","fillText","labelTexture","labelMaterial","map","side","transparent","labelPlane","enabled","size","scale","x","y","render","renderer","tDiffuse","value","shadow","texture","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update"],"sources":["node_modules/three/examples/jsm/utils/ShadowMapViewer.js"],"sourcesContent":["import {\n\tDoubleSide,\n\tCanvasTexture,\n\tMesh,\n\tMeshBasicMaterial,\n\tOrthographicCamera,\n\tPlaneGeometry,\n\tScene,\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `ShadowMapViewerGPU.js`.\n *\n * ```js\n * const lightShadowMapViewer = new ShadowMapViewer( light );\n * lightShadowMapViewer.position.x = 10;\n * lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;\n * lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;\n * lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;\n * lightShadowMapViewer.update();\n * ```\n *\n * @three_import import { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewer.js';\n */\nclass ShadowMapViewer {\n\n\t/**\n\t * Constructs a new shadow map viewer.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t */\n\tconstructor( light ) {\n\n\t\t//- Internals\n\t\tconst scope = this;\n\t\tconst doRenderLabel = ( light.name !== undefined && light.name !== '' );\n\t\tlet userAutoClearSetting;\n\n\t\t//Holds the initial position and dimension of the HUD\n\t\tconst frame = {\n\t\t\tx: 10,\n\t\t\ty: 10,\n\t\t\twidth: 256,\n\t\t\theight: 256\n\t\t};\n\n\t\tconst camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );\n\t\tcamera.position.set( 0, 0, 2 );\n\t\tconst scene = new Scene();\n\n\t\t//HUD for shadow map\n\t\tconst shader = UnpackDepthRGBAShader;\n\n\t\tconst uniforms = UniformsUtils.clone( shader.uniforms );\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\t\t} );\n\t\tconst plane = new PlaneGeometry( frame.width, frame.height );\n\t\tconst mesh = new Mesh( plane, material );\n\n\t\tscene.add( mesh );\n\n\n\t\t//Label for light's name\n\t\tlet labelCanvas, labelMesh;\n\n\t\tif ( doRenderLabel ) {\n\n\t\t\tlabelCanvas = document.createElement( 'canvas' );\n\n\t\t\tconst context = labelCanvas.getContext( '2d' );\n\t\t\tcontext.font = 'Bold 20px Arial';\n\n\t\t\tconst labelWidth = context.measureText( light.name ).width;\n\t\t\tlabelCanvas.width = labelWidth;\n\t\t\tlabelCanvas.height = 25;\t//25 to account for g, p, etc.\n\n\t\t\tcontext.font = 'Bold 20px Arial';\n\t\t\tcontext.fillStyle = 'rgba( 255, 0, 0, 1 )';\n\t\t\tcontext.fillText( light.name, 0, 20 );\n\n\t\t\tconst labelTexture = new CanvasTexture( labelCanvas );\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide, transparent: true } );\n\n\t\t\tconst labelPlane = new PlaneGeometry( labelCanvas.width, labelCanvas.height );\n\t\t\tlabelMesh = new Mesh( labelPlane, labelMaterial );\n\n\t\t\tscene.add( labelMesh );\n\n\t\t}\n\n\n\t\tfunction resetPosition() {\n\n\t\t\tscope.position.set( scope.position.x, scope.position.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Whether to display the shadow map viewer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * The size of the viewer. When changing this property, make sure\n\t\t * to call {@link ShadowMapViewer#update}.\n\t\t *\n\t\t * @type {{width:number,height:number}}\n\t\t * @default true\n\t\t */\n\t\tthis.size = {\n\t\t\twidth: frame.width,\n\t\t\theight: frame.height,\n\t\t\tset: function ( width, height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tmesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );\n\n\t\t\t\t//Reset the position as it is off when we scale stuff\n\t\t\t\tresetPosition();\n\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * The position of the viewer. When changing this property, make sure\n\t\t * to call {@link ShadowMapViewer#update}.\n\t\t *\n\t\t * @type {{x:number,y:number, set:function(number,number)}}\n\t\t * @default true\n\t\t */\n\t\tthis.position = {\n\t\t\tx: frame.x,\n\t\t\ty: frame.y,\n\t\t\tset: function ( x, y ) {\n\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\n\t\t\t\tconst width = scope.size.width;\n\t\t\t\tconst height = scope.size.height;\n\n\t\t\t\tmesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );\n\n\t\t\t\tif ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );\n\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Renders the viewer. This method must be called in the app's animation loop.\n\t\t *\n\t\t * @param {WebGLRenderer} renderer - The renderer.\n\t\t */\n\t\tthis.render = function ( renderer ) {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t//Because a light's .shadowMap is only initialised after the first render pass\n\t\t\t\t//we have to make sure the correct map is sent into the shader, otherwise we\n\t\t\t\t//always end up with the scene's first added shadow casting light's shadowMap\n\t\t\t\t//in the shader\n\t\t\t\t//See: https://github.com/mrdoob/three.js/issues/5932\n\t\t\t\tuniforms.tDiffuse.value = light.shadow.map.texture;\n\n\t\t\t\tuserAutoClearSetting = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false; // To allow render overlay\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer.autoClear = userAutoClearSetting;\t//Restore user's setting\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Resizes the viewer. This method should be called whenever the app's\n\t\t * window is resized.\n\t\t */\n\t\tthis.updateForWindowResize = function () {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t camera.left = window.innerWidth / - 2;\n\t\t\t\t camera.right = window.innerWidth / 2;\n\t\t\t\t camera.top = window.innerHeight / 2;\n\t\t\t\t camera.bottom = window.innerHeight / - 2;\n\t\t\t\t camera.updateProjectionMatrix();\n\n\t\t\t\t this.update();\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Updates the viewer.\n\t\t */\n\t\tthis.update = function () {\n\n\t\t\tthis.position.set( this.position.x, this.position.y );\n\t\t\tthis.size.set( this.size.width, this.size.height );\n\n\t\t};\n\n\t\t//Force an update to set position/size\n\t\tthis.update();\n\n\t}\n\n}\n\n\nexport { ShadowMapViewer };\n"],"mappings":"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","ignoreList":[]}