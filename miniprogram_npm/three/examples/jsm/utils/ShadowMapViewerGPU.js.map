{"version":3,"file":"node_modules/three/examples/jsm/utils/ShadowMapViewerGPU.js","names":["DoubleSide","CanvasTexture","Mesh","MeshBasicMaterial","NodeMaterial","OrthographicCamera","PlaneGeometry","Scene","Texture","texture","ShadowMapViewer","constructor","light","scope","this","doRenderLabel","undefined","name","currentAutoClear","frame","camera","window","innerWidth","innerHeight","position","set","scene","material","shadowMapUniform","fragmentNode","plane","mesh","labelCanvas","labelMesh","add","document","createElement","context","getContext","font","labelWidth","measureText","width","height","fillStyle","fillText","labelTexture","labelMaterial","map","side","transparent","labelPlane","enabled","size","scale","x","y","render","renderer","value","shadow","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update"],"sources":["node_modules/three/examples/jsm/utils/ShadowMapViewerGPU.js"],"sourcesContent":["import {\n\tDoubleSide,\n\tCanvasTexture,\n\tMesh,\n\tMeshBasicMaterial,\n\tNodeMaterial,\n\tOrthographicCamera,\n\tPlaneGeometry,\n\tScene,\n\tTexture\n} from 'three';\nimport { texture } from 'three/tsl';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * This module can only be used with {@link WebGPURenderer}. When using {@link WebGLRenderer},\n * import the class from `ShadowMapViewer.js`.\n *\n * ```js\n * const lightShadowMapViewer = new ShadowMapViewer( light );\n * lightShadowMapViewer.position.x = 10;\n * lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;\n * lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;\n * lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;\n * lightShadowMapViewer.update();\n * ```\n *\n * @three_import import { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewerGPU.js';\n */\nclass ShadowMapViewer {\n\n\t/**\n\t * Constructs a new shadow map viewer.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t */\n\tconstructor( light ) {\n\n\t\t//- Internals\n\t\tconst scope = this;\n\t\tconst doRenderLabel = ( light.name !== undefined && light.name !== '' );\n\t\tlet currentAutoClear;\n\n\t\t//Holds the initial position and dimension of the HUD\n\t\tconst frame = {\n\t\t\tx: 10,\n\t\t\ty: 10,\n\t\t\twidth: 256,\n\t\t\theight: 256\n\t\t};\n\n\t\tconst camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );\n\t\tcamera.position.set( 0, 0, 2 );\n\t\tconst scene = new Scene();\n\n\t\t//HUD for shadow map\n\n\t\tconst material = new NodeMaterial();\n\n\t\tconst shadowMapUniform = texture( new Texture() );\n\t\tmaterial.fragmentNode = shadowMapUniform;\n\n\t\tconst plane = new PlaneGeometry( frame.width, frame.height );\n\t\tconst mesh = new Mesh( plane, material );\n\n\t\tscene.add( mesh );\n\n\t\t//Label for light's name\n\t\tlet labelCanvas, labelMesh;\n\n\t\tif ( doRenderLabel ) {\n\n\t\t\tlabelCanvas = document.createElement( 'canvas' );\n\n\t\t\tconst context = labelCanvas.getContext( '2d' );\n\t\t\tcontext.font = 'Bold 20px Arial';\n\n\t\t\tconst labelWidth = context.measureText( light.name ).width;\n\t\t\tlabelCanvas.width = labelWidth;\n\t\t\tlabelCanvas.height = 25;\t//25 to account for g, p, etc.\n\n\t\t\tcontext.font = 'Bold 20px Arial';\n\t\t\tcontext.fillStyle = 'rgba( 255, 0, 0, 1 )';\n\t\t\tcontext.fillText( light.name, 0, 20 );\n\n\t\t\tconst labelTexture = new CanvasTexture( labelCanvas );\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide, transparent: true } );\n\n\t\t\tconst labelPlane = new PlaneGeometry( labelCanvas.width, labelCanvas.height );\n\t\t\tlabelMesh = new Mesh( labelPlane, labelMaterial );\n\n\t\t\tscene.add( labelMesh );\n\n\t\t}\n\n\t\tfunction resetPosition() {\n\n\t\t\tscope.position.set( scope.position.x, scope.position.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Whether to display the shadow map viewer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * The size of the viewer. When changing this property, make sure\n\t\t * to call {@link ShadowMapViewer#update}.\n\t\t *\n\t\t * @type {{width:number,height:number}}\n\t\t * @default true\n\t\t */\n\t\tthis.size = {\n\t\t\twidth: frame.width,\n\t\t\theight: frame.height,\n\t\t\tset: function ( width, height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tmesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );\n\n\t\t\t\t//Reset the position as it is off when we scale stuff\n\t\t\t\tresetPosition();\n\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * The position of the viewer. When changing this property, make sure\n\t\t * to call {@link ShadowMapViewer#update}.\n\t\t *\n\t\t * @type {{width:number,height:number}}\n\t\t * @default true\n\t\t */\n\t\tthis.position = {\n\t\t\tx: frame.x,\n\t\t\ty: frame.y,\n\t\t\tset: function ( x, y ) {\n\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\n\t\t\t\tconst width = scope.size.width;\n\t\t\t\tconst height = scope.size.height;\n\n\t\t\t\tmesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );\n\n\t\t\t\tif ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );\n\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Renders the viewer. This method must be called in the app's animation loop.\n\t\t *\n\t\t * @param {WebGPURenderer} renderer - The renderer.\n\t\t */\n\t\tthis.render = function ( renderer ) {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t//Because a light's .shadowMap is only initialised after the first render pass\n\t\t\t\t//we have to make sure the correct map is sent into the shader, otherwise we\n\t\t\t\t//always end up with the scene's first added shadow casting light's shadowMap\n\t\t\t\t//in the shader\n\t\t\t\t//See: https://github.com/mrdoob/three.js/issues/5932\n\t\t\t\tshadowMapUniform.value = light.shadow.map.texture;\n\n\t\t\t\tcurrentAutoClear = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false; // To allow render overlay\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Resizes the viewer. This method should be called whenever the app's\n\t\t * window is resized.\n\t\t */\n\t\tthis.updateForWindowResize = function () {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t camera.left = window.innerWidth / - 2;\n\t\t\t\t camera.right = window.innerWidth / 2;\n\t\t\t\t camera.top = window.innerHeight / 2;\n\t\t\t\t camera.bottom = window.innerHeight / - 2;\n\t\t\t\t camera.updateProjectionMatrix();\n\n\t\t\t\t this.update();\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Updates the viewer.\n\t\t */\n\t\tthis.update = function () {\n\n\t\t\tthis.position.set( this.position.x, this.position.y );\n\t\t\tthis.size.set( this.size.width, this.size.height );\n\n\t\t};\n\n\t\t//Force an update to set position/size\n\t\tthis.update();\n\n\t}\n\n}\n\n\nexport { ShadowMapViewer };\n"],"mappings":"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","ignoreList":[]}