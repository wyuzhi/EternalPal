{"version":3,"file":"node_modules/three/examples/jsm/utils/SkeletonUtils.js","names":["AnimationClip","AnimationMixer","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector3","VectorKeyframeTrack","getBoneName","bone","options","undefined","names","name","retarget","target","source","quat","scale","relativeMatrix","globalMatrix","preserveBoneMatrix","preserveBonePositions","useTargetMatrix","hip","hipInfluence","sourceBones","isObject3D","skeleton","bones","getBones","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","getBoneByName","copy","invert","multiply","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","localOffsets","copyPosition","elements","hipPosition","parent","matrix","decompose","quaternion","retargetClip","clip","useFirstFramePosition","fps","Math","max","tracks","map","track","times","duration","getHelperFromSkeleton","numFrames","round","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","start","end","trim","min","update","frame","time","j","pos","Float32Array","values","sub","toArray","uncacheAction","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","bind","Array","isArray","a","b","callback"],"sources":["node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * @module SkeletonUtils\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n */\n\nfunction getBoneName( bone, options ) {\n\n\tif ( options.getBoneName !== undefined ) {\n\n\t\treturn options.getBoneName( bone );\n\n\t}\n\n\treturn options.names[ bone.name ];\n\n}\n\n/**\n * Retargets the skeleton from the given source 3D object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n */\nfunction retarget( target, source, options = {} ) {\n\n\tconst quat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveBoneMatrix = false;\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = getBoneName( bone, options );\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tif ( options.localOffsets ) {\n\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\n\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( name === options.hip ) {\n\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\n\n\t\t\tif ( options.hipPosition !== undefined ) {\n\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bone.parent ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\n/**\n * Retargets the animation clip of the source object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {AnimationClip} clip - The animation clip.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n * @return {AnimationClip} The retargeted animation clip.\n */\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\n\t// trim\n\n\tlet start = 0, end = numFrames;\n\n\tif ( options.trim !== undefined ) {\n\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\n\n\t\tmixer.update( options.trim[ 0 ] );\n\n\t} else {\n\n\t\tmixer.update( 0 );\n\n\t}\n\n\tsource.updateMatrixWorld();\n\n\t//\n\n\tfor ( let frame = 0; frame < end; ++ frame ) {\n\n\t\tconst time = frame * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tbone = bones[ j ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( frame === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ frame ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( frame === end - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\n/**\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\n *\n * @param {Object3D} source - The 3D object to clone.\n * @return {Object3D} The cloned 3D object.\n */\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\n/**\n * Retarget options of `SkeletonUtils`.\n *\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\n * @property {number} [fps] - The FPS of the clip.\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\n * @property {string} [hip='hip'] - The name of the source's hip bone.\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\n * @property {number} [scale=1] - The scale.\n **/\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n"],"mappings":"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","ignoreList":[]}