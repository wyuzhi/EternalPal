{"version":3,"file":"node_modules/three/examples/jsm/webxr/OculusHandModel.js","names":["Object3D","Sphere","Box3","XRHandMeshModel","TOUCH_RADIUS","POINTING_JOINT","OculusHandModel","constructor","controller","loader","onLoad","super","this","motionController","envMap","path","mesh","addEventListener","event","xrInputSource","data","hand","handedness","clear","updateMatrixWorld","force","updateMesh","getPointerPosition","indexFingerTip","joints","position","intersectBoxObject","boxObject","pointerPosition","indexSphere","box","setFromObject","intersectsBox","checkButton","button","onPress","onClear","isPressed","whilePressed"],"sources":["node_modules/three/examples/jsm/webxr/OculusHandModel.js"],"sourcesContent":["import { Object3D, Sphere, Box3 } from 'three';\nimport { XRHandMeshModel } from './XRHandMeshModel.js';\n\nconst TOUCH_RADIUS = 0.01;\nconst POINTING_JOINT = 'index-finger-tip';\n\n/**\n * Represents an Oculus hand model.\n *\n * @augments Object3D\n * @three_import import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n */\nclass OculusHandModel extends Object3D {\n\n\t/**\n\t * Constructs a new Oculus hand model.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t * @param {?Loader} [loader=null] - A loader that is used to load hand models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n\t */\n\tconstructor( controller, loader = null, onLoad = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The motion controller.\n\t\t *\n\t\t * @type {?MotionController}\n\t\t * @default null\n\t\t */\n\t\tthis.motionController = null;\n\n\t\t/**\n\t\t * The model's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t\t/**\n\t\t * A loader that is used to load hand models.\n\t\t *\n\t\t * @type {?Loader}\n\t\t * @default null\n\t\t */\n\t\tthis.loader = loader;\n\n\t\t/**\n\t\t * A callback that is executed when a hand model has been loaded.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t\t/**\n\t\t * The path to the model repository.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.path = null;\n\n\t\t/**\n\t\t * The model mesh.\n\t\t *\n\t\t * @type {Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.mesh = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.hand && ! this.motionController ) {\n\n\t\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\t\tthis.motionController = new XRHandMeshModel( this, controller, this.path, xrInputSource.handedness, this.loader, this.onLoad );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tthis.clear();\n\t\t\tthis.motionController = null;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.motionController ) {\n\n\t\t\tthis.motionController.updateMesh();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the pointer position which is the position of the index finger tip.\n\t *\n\t * @return {Vector3|null} The pointer position. Returns `null` if not index finger tip joint was found.\n\t */\n\tgetPointerPosition() {\n\n\t\tconst indexFingerTip = this.controller.joints[ POINTING_JOINT ];\n\t\tif ( indexFingerTip ) {\n\n\t\t\treturn indexFingerTip.position;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the current pointer position (the index finger tip) intersections\n\t * with the given box object.\n\t *\n\t *  @param {Mesh} boxObject - The box object.\n\t * @return {boolean} Whether an intersection was found or not.\n\t */\n\tintersectBoxObject( boxObject ) {\n\n\t\tconst pointerPosition = this.getPointerPosition();\n\t\tif ( pointerPosition ) {\n\n\t\t\tconst indexSphere = new Sphere( pointerPosition, TOUCH_RADIUS );\n\t\t\tconst box = new Box3().setFromObject( boxObject );\n\t\t\treturn indexSphere.intersectsBox( box );\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Executed actions depending on the interaction state with\n\t * the given button.\n\t *\n\t *  @param {Object} button - The button.\n\t */\n\tcheckButton( button ) {\n\n\t\tif ( this.intersectBoxObject( button ) ) {\n\n\t\t\tbutton.onPress();\n\n\t\t} else {\n\n\t\t\tbutton.onClear();\n\n\t\t}\n\n\t\tif ( button.isPressed() ) {\n\n\t\t\tbutton.whilePressed();\n\n\t\t}\n\n\t}\n\n}\n\nexport { OculusHandModel };\n"],"mappings":"OAASA,SAAUC,OAAQC,SAAY,eAC9BC,oBAAuB,uBAEhC,MAAMC,aAAe,IACfC,eAAiB,mBAQvB,MAAMC,wBAAwBN,SAS7B,WAAAO,CAAaC,EAAYC,EAAS,KAAMC,EAAS,MAEhDC,QAOAC,KAAKJ,WAAaA,EAQlBI,KAAKC,iBAAmB,KAQxBD,KAAKE,OAAS,KAQdF,KAAKH,OAASA,EAQdG,KAAKF,OAASA,EAQdE,KAAKG,KAAO,KAQZH,KAAKI,KAAO,KAEZR,EAAWS,iBAAkB,aAAeC,IAE3C,MAAMC,EAAgBD,EAAME,KAEvBD,EAAcE,OAAUT,KAAKC,mBAEjCD,KAAKO,cAAgBA,EAErBP,KAAKC,iBAAmB,IAAIV,gBAAiBS,KAAMJ,EAAYI,KAAKG,KAAMI,EAAcG,WAAYV,KAAKH,OAAQG,KAAKF,QAEvH,IAIDF,EAAWS,iBAAkB,gBAAgB,KAE5CL,KAAKW,QACLX,KAAKC,iBAAmB,IAAI,GAI9B,CAQA,iBAAAW,CAAmBC,GAElBd,MAAMa,kBAAmBC,GAEpBb,KAAKC,kBAETD,KAAKC,iBAAiBa,YAIxB,CAOA,kBAAAC,GAEC,MAAMC,EAAiBhB,KAAKJ,WAAWqB,OAAQxB,gBAC/C,OAAKuB,EAEGA,EAAeE,SAIf,IAIT,CASA,kBAAAC,CAAoBC,GAEnB,MAAMC,EAAkBrB,KAAKe,qBAC7B,GAAKM,EAAkB,CAEtB,MAAMC,EAAc,IAAIjC,OAAQgC,EAtJd,KAuJZE,GAAM,IAAIjC,MAAOkC,cAAeJ,GACtC,OAAOE,EAAYG,cAAeF,EAEnC,CAEC,OAAO,CAIT,CAQA,WAAAG,CAAaC,GAEP3B,KAAKmB,mBAAoBQ,GAE7BA,EAAOC,UAIPD,EAAOE,UAIHF,EAAOG,aAEXH,EAAOI,cAIT,SAIQrC","ignoreList":[]}