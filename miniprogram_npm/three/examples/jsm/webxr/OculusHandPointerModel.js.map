{"version":3,"file":"node_modules/three/examples/jsm/webxr/OculusHandPointerModel.js","names":["BufferGeometry","Float32BufferAttribute","Matrix4","Mesh","MeshBasicMaterial","Object3D","Raycaster","SphereGeometry","Vector3","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","constructor","hand","controller","super","this","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_onDisconnected","addEventListener","event","xrInputSource","data","visible","createPointer","dispose","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenter","frontCenterIndex","rearCenter","rearCenterIndex","setAttribute","j","Array","fill","indices","push","transparent","opacity","setIndex","set","add","cursorGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","intersectObjects","objects","checkIntersections","intersections","length","setCursor","removeEventListener"],"sources":["node_modules/three/examples/jsm/webxr/OculusHandPointerModel.js"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Matrix4, Mesh, MeshBasicMaterial, Object3D, Raycaster, SphereGeometry, Vector3 } from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst ZAXIS = /* @__PURE__ */ new Vector3( 0, 0, 1 );\n\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\n/**\n * Represents an Oculus hand pointer model.\n *\n * @augments Object3D\n * @three_import import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';\n */\nclass OculusHandPointerModel extends Object3D {\n\n\t/**\n\t * Constructs a new Oculus hand model.\n\t *\n\t * @param {Group} hand - The hand controller.\n\t * @param {Group} controller - The WebXR controller in target ray space.\n\t */\n\tconstructor( hand, controller ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.hand = hand;\n\n\t\t/**\n\t\t * The WebXR controller in target ray space.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t// Unused\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\t\tthis.mesh = null;\n\n\t\t/**\n\t\t * The pointer geometry.\n\t\t *\n\t\t * @type {?BufferGeometry}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerGeometry = null;\n\n\t\t/**\n\t\t * The pointer mesh.\n\t\t *\n\t\t * @type {?Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerMesh = null;\n\n\t\t/**\n\t\t * The pointer object that holds the pointer mesh.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerObject = null;\n\n\t\t/**\n\t\t * Whether the model is pinched or not.\n\t\t *\n\t\t * @type {?boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.pinched = false;\n\n\t\t/**\n\t\t * Whether the model is attached or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.attached = false;\n\n\t\t/**\n\t\t * The cursor object.\n\t\t *\n\t\t * @type {?Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.cursorObject = null;\n\n\t\t/**\n\t\t * The internal raycaster used for detecting\n\t\t * intersections.\n\t\t *\n\t\t * @type {?Raycaster}\n\t\t * @default null\n\t\t */\n\t\tthis.raycaster = null;\n\n\t\tthis._onConnected = this._onConnected.bind( this );\n\t\tthis._onDisconnected = this._onDisconnected.bind( this );\n\t\tthis.hand.addEventListener( 'connected', this._onConnected );\n\t\tthis.hand.addEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n\t_onConnected( event ) {\n\n\t\tconst xrInputSource = event.data;\n\t\tif ( xrInputSource.hand ) {\n\n\t\t\tthis.visible = true;\n\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\tthis.createPointer();\n\n\t\t}\n\n\t}\n\n\t_onDisconnected() {\n\n\t\tthis.visible = false;\n\t\tthis.xrInputSource = null;\n\n\t\tif ( this.pointerGeometry ) this.pointerGeometry.dispose();\n\t\tif ( this.pointerMesh && this.pointerMesh.material ) this.pointerMesh.material.dispose();\n\n\t\tthis.clear();\n\n\t}\n\n\t_drawVerticesRing( vertices, baseVector, ringIndex ) {\n\n\t\tconst segmentVector = baseVector.clone();\n\t\tfor ( let i = 0; i < POINTER_SEGMENTS; i ++ ) {\n\n\t\t\tsegmentVector.applyAxisAngle( ZAXIS, ( Math.PI * 2 ) / POINTER_SEGMENTS );\n\t\t\tconst vid = ringIndex * POINTER_SEGMENTS + i;\n\t\t\tvertices[ 3 * vid ] = segmentVector.x;\n\t\t\tvertices[ 3 * vid + 1 ] = segmentVector.y;\n\t\t\tvertices[ 3 * vid + 2 ] = segmentVector.z;\n\n\t\t}\n\n\t}\n\n\t_updatePointerVertices( rearRadius ) {\n\n\t\tconst vertices = this.pointerGeometry.attributes.position.array;\n\t\t// first ring for front face\n\t\tconst frontFaceBase = new Vector3(\n\t\t\tPOINTER_FRONT_RADIUS,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tthis._drawVerticesRing( vertices, frontFaceBase, 0 );\n\n\t\t// rings for rear hemisphere\n\t\tconst rearBase = new Vector3(\n\t\t\tMath.sin( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\tMath.cos( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\t0\n\t\t);\n\t\tfor ( let i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tthis._drawVerticesRing( vertices, rearBase, i + 1 );\n\t\t\trearBase.applyAxisAngle(\n\t\t\t\tYAXIS,\n\t\t\t\t( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 / ( POINTER_RINGS * - 2 )\n\t\t\t);\n\n\t\t}\n\n\t\t// front and rear face center vertices\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\t\tconst frontCenter = new Vector3(\n\t\t\t0,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tvertices[ frontCenterIndex * 3 ] = frontCenter.x;\n\t\tvertices[ frontCenterIndex * 3 + 1 ] = frontCenter.y;\n\t\tvertices[ frontCenterIndex * 3 + 2 ] = frontCenter.z;\n\t\tconst rearCenter = new Vector3( 0, 0, rearRadius );\n\t\tvertices[ rearCenterIndex * 3 ] = rearCenter.x;\n\t\tvertices[ rearCenterIndex * 3 + 1 ] = rearCenter.y;\n\t\tvertices[ rearCenterIndex * 3 + 2 ] = rearCenter.z;\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute( vertices, 3 )\n\t\t);\n\t\t// verticesNeedUpdate = true;\n\n\t}\n\n\t/**\n\t * Creates a pointer mesh and adds it to this model.\n\t */\n\tcreatePointer() {\n\n\t\tlet i, j;\n\t\tconst vertices = new Array(\n\t\t\t( ( POINTER_RINGS + 1 ) * POINTER_SEGMENTS + 2 ) * 3\n\t\t).fill( 0 );\n\t\t// const vertices = [];\n\t\tconst indices = [];\n\t\tthis.pointerGeometry = new BufferGeometry();\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute( vertices, 3 )\n\t\t);\n\n\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\n\t\t// construct faces to connect rings\n\t\tfor ( i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tfor ( j = 0; j < POINTER_SEGMENTS - 1; j ++ ) {\n\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j,\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tindices.push(\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS - 1,\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\t\t\tindices.push(\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\n\t\t}\n\n\t\t// construct front and rear face\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\n\t\tfor ( i = 0; i < POINTER_SEGMENTS - 1; i ++ ) {\n\n\t\t\tindices.push( frontCenterIndex, i + 1, i );\n\t\t\tindices.push(\n\t\t\t\trearCenterIndex,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS + 1\n\t\t\t);\n\n\t\t}\n\n\t\tindices.push( frontCenterIndex, 0, POINTER_SEGMENTS - 1 );\n\t\tindices.push(\n\t\t\trearCenterIndex,\n\t\t\tPOINTER_SEGMENTS * ( POINTER_RINGS + 1 ) - 1,\n\t\t\tPOINTER_SEGMENTS * POINTER_RINGS\n\t\t);\n\n\t\tconst material = new MeshBasicMaterial();\n\t\tmaterial.transparent = true;\n\t\tmaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.pointerGeometry.setIndex( indices );\n\n\t\tthis.pointerMesh = new Mesh( this.pointerGeometry, material );\n\n\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\tthis.pointerObject = new Object3D();\n\t\tthis.pointerObject.add( this.pointerMesh );\n\n\t\tthis.raycaster = new Raycaster();\n\n\t\t// create cursor\n\t\tconst cursorGeometry = new SphereGeometry( CURSOR_RADIUS, 10, 10 );\n\t\tconst cursorMaterial = new MeshBasicMaterial();\n\t\tcursorMaterial.transparent = true;\n\t\tcursorMaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.cursorObject = new Mesh( cursorGeometry, cursorMaterial );\n\t\tthis.pointerObject.add( this.cursorObject );\n\n\t\tthis.add( this.pointerObject );\n\n\t}\n\n\t_updateRaycaster() {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\tconst pointerMatrix = this.pointerObject.matrixWorld;\n\t\t\tconst tempMatrix = new Matrix4();\n\t\t\ttempMatrix.identity().extractRotation( pointerMatrix );\n\t\t\tthis.raycaster.ray.origin.setFromMatrixPosition( pointerMatrix );\n\t\t\tthis.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t}\n\n\t}\n\n\t_updatePointer() {\n\n\t\tthis.pointerObject.visible = this.controller.visible;\n\t\tconst indexTip = this.hand.joints[ 'index-finger-tip' ];\n\t\tconst thumbTip = this.hand.joints[ 'thumb-tip' ];\n\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\t\tconst position = indexTip.position\n\t\t\t.clone()\n\t\t\t.add( thumbTip.position )\n\t\t\t.multiplyScalar( 0.5 );\n\t\tthis.pointerObject.position.copy( position );\n\t\tthis.pointerObject.quaternion.copy( this.controller.quaternion );\n\n\t\tthis.pinched = distance <= PINCH_THRESHOLD;\n\n\t\tconst pinchScale = ( distance - PINCH_MIN ) / ( PINCH_MAX - PINCH_MIN );\n\t\tconst focusScale = ( distance - PINCH_MIN ) / ( PINCH_THRESHOLD - PINCH_MIN );\n\t\tif ( pinchScale > 1 ) {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t} else if ( pinchScale > 0 ) {\n\n\t\t\tconst rearRadius =\n        ( POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN ) * pinchScale +\n        POINTER_REAR_RADIUS_MIN;\n\t\t\tthis._updatePointerVertices( rearRadius );\n\t\t\tif ( focusScale < 1 ) {\n\n\t\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t- 1 * rearRadius - ( 1 - focusScale ) * POINTER_ADVANCE_MAX\n\t\t\t\t);\n\t\t\t\tthis.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN +\n          ( 1 - focusScale ) * ( POINTER_OPACITY_MAX - POINTER_OPACITY_MIN );\n\n\t\t\t} else {\n\n\t\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * rearRadius );\n\t\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS_MIN );\n\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t- 1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX\n\t\t\t);\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n\n\t\t}\n\n\t\tthis.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the internal pointer and raycaster are updated.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\t\tif ( this.pointerGeometry ) {\n\n\t\t\tthis._updatePointer();\n\t\t\tthis._updateRaycaster();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` is the model is pinched.\n\t *\n\t * @return {boolean} Whether the model is pinched or not.\n\t */\n\tisPinched() {\n\n\t\treturn this.pinched;\n\n\t}\n\n\t/**\n\t * Sets the attached state.\n\t *\n\t * @param {boolean} attached - Whether the model is attached or not.\n\t */\n\tsetAttached( attached ) {\n\n\t\tthis.attached = attached;\n\n\t}\n\n\t/**\n\t * Returns `true` is the model is attached.\n\t *\n\t * @return {boolean} Whether the model is attached or not.\n\t */\n\tisAttached() {\n\n\t\treturn this.attached;\n\n\t}\n\n\t/**\n\t * Performs an intersection test with the model's raycaster and the given object.\n\t *\n\t * @param {Object3D} object - The 3D object to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObject( object, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObject( object, recursive );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs an intersection test with the model's raycaster and the given objects.\n\t *\n\t * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObjects( objects, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObjects( objects, recursive );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks for intersections between the model's raycaster and the given objects. The method\n\t * updates the cursor object to the intersection point.\n\t *\n\t * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n\t * @param {boolean} [recursive=false] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t */\n\tcheckIntersections( objects, recursive = false ) {\n\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tconst intersections = this.raycaster.intersectObjects( objects, recursive );\n\t\t\tconst direction = new Vector3( 0, 0, - 1 );\n\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\tconst intersection = intersections[ 0 ];\n\t\t\t\tconst distance = intersection.distance;\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t\t} else {\n\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( CURSOR_MAX_DISTANCE ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the cursor to the given distance.\n\t *\n\t * @param {number} distance - The distance to set the cursor to.\n\t */\n\tsetCursor( distance ) {\n\n\t\tconst direction = new Vector3( 0, 0, - 1 );\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._onDisconnected();\n\t\tthis.hand.removeEventListener( 'connected', this._onConnected );\n\t\tthis.hand.removeEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"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","ignoreList":[]}