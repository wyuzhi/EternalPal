{"version":3,"file":"node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js","names":["Mesh","MeshBasicMaterial","Object3D","SphereGeometry","GLTFLoader","MotionControllerConstants","fetchProfile","MotionController","DEFAULT_PROFILES_PATH","DEFAULT_PROFILE","XRControllerModel","constructor","super","this","motionController","envMap","setEnvironmentMap","traverse","child","isMesh","material","needsUpdate","updateMatrixWorld","force","updateFromGamepad","Object","values","components","forEach","component","visualResponses","visualResponse","valueNode","minNode","maxNode","value","valueNodeProperty","VisualResponseProperty","VISIBILITY","visible","TRANSFORM","quaternion","slerpQuaternions","position","lerpVectors","findNodes","scene","type","touchPointNodeName","ComponentType","TOUCHPAD","touchPointNode","getObjectByName","sphereGeometry","color","sphere","add","console","warn","id","valueNodeName","minNodeName","maxNodeName","addAssetSceneToControllerModel","controllerModel","XRControllerModelFactory","gltfLoader","onLoad","path","_assetCache","setPath","createControllerModel","controller","addEventListener","event","xrInputSource","data","targetRayMode","gamepad","hand","then","profile","assetPath","cachedAsset","assetUrl","clone","Error","load","asset","catch","err","remove"],"sources":["node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js"],"sourcesContent":["import {\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tSphereGeometry,\n} from 'three';\n\nimport { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nimport {\n\tConstants as MotionControllerConstants,\n\tfetchProfile,\n\tMotionController\n} from '../libs/motion-controllers.module.js';\n\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\nconst DEFAULT_PROFILE = 'generic-trigger';\n\n/**\n * Represents a XR controller model.\n *\n * @augments Object3D\n */\nclass XRControllerModel extends Object3D {\n\n\t/**\n\t * Constructs a new XR controller model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The motion controller.\n\t\t *\n\t\t * @type {?MotionController}\n\t\t * @default null\n\t\t */\n\t\tthis.motionController = null;\n\n\t\t/**\n\t\t * The controller's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t}\n\n\t/**\n\t * Sets an environment map that is applied to the controller model.\n\t *\n\t * @param {?Texture} envMap - The environment map to apply.\n\t * @return {XRControllerModel} A reference to this instance.\n\t */\n\tsetEnvironmentMap( envMap ) {\n\n\t\tif ( this.envMap == envMap ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.envMap = envMap;\n\t\tthis.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = this.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Polls data from the XRInputSource and updates the\n\t * model's components to match the real world data.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( ! this.motionController ) return;\n\n\t\t// Cause the MotionController to poll the Gamepad for data\n\t\tthis.motionController.updateFromGamepad();\n\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\n\n\t\t\t// Update node data based on the visual responses' current states\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\n\t\t\t\t// because it will have been reported at load time.\n\t\t\t\tif ( ! valueNode ) return;\n\n\t\t\t\t// Calculate the new properties based on the weight supplied\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\n\n\t\t\t\t\tvalueNode.visible = value;\n\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\n\t\t\t\t\t\tminNode.quaternion,\n\t\t\t\t\t\tmaxNode.quaternion,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t\tvalueNode.position.lerpVectors(\n\t\t\t\t\t\tminNode.position,\n\t\t\t\t\t\tmaxNode.position,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Walks the model's tree to find the nodes needed to animate the components and\n * saves them to the motionController components for use in the frame loop. When\n * touchpads are found, attaches a touch dot to them.\n *\n * @private\n * @param {MotionController} motionController\n * @param {Object3D} scene\n */\nfunction findNodes( motionController, scene ) {\n\n\t// Loop through the components and find the nodes needed for each components' visual responses\n\tObject.values( motionController.components ).forEach( ( component ) => {\n\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\n\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\n\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\n\t\t\tif ( component.touchPointNode ) {\n\n\t\t\t\t// Attach a touch dot to the touchpad.\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\n\t\t\t\tcomponent.touchPointNode.add( sphere );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Loop through all the visual responses to be applied to this component\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\n\n\t\t\t\t// If the extents cannot be found, skip this animation\n\t\t\t\tif ( ! visualResponse.minNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! visualResponse.maxNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If the target node cannot be found, skip this animation\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\n\t\t\tif ( ! visualResponse.valueNode ) {\n\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n}\n\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\n\n\t// Find the nodes needed for animation and cache them on the motionController.\n\tfindNodes( controllerModel.motionController, scene );\n\n\t// Apply any environment map that the mesh already has set.\n\tif ( controllerModel.envMap ) {\n\n\t\tscene.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Add the glTF scene to the controllerModel.\n\tcontrollerModel.add( scene );\n\n}\n\n/**\n * Allows to create controller models for WebXR controllers that can be added as a visual\n * representation to your scene. `XRControllerModelFactory` will automatically fetch controller\n * models that match what the user is holding as closely as possible. The models should be\n * attached to the object returned from getControllerGrip in order to match the orientation of\n * the held device.\n *\n * This module depends on the [motion-controllers]{@link https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/motion-controllers/README.md}\n * third-part library.\n *\n * ```js\n * const controllerModelFactory = new XRControllerModelFactory();\n *\n * const controllerGrip = renderer.xr.getControllerGrip( 0 );\n * controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n * scene.add( controllerGrip );\n * ```\n *\n * @three_import import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n */\nclass XRControllerModelFactory {\n\n\t/**\n\t * Constructs a new XR controller model factory.\n\t *\n\t * @param {?GLTFLoader} [gltfLoader=null] - A glTF loader that is used to load controller models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a controller model has been loaded.\n\t */\n\tconstructor( gltfLoader = null, onLoad = null ) {\n\n\t\t/**\n\t\t * A glTF loader that is used to load controller models.\n\t\t *\n\t\t * @type {?GLTFLoader}\n\t\t * @default null\n\t\t */\n\t\tthis.gltfLoader = gltfLoader;\n\n\t\t/**\n\t\t * The path to the model repository.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.path = DEFAULT_PROFILES_PATH;\n\t\tthis._assetCache = {};\n\n\t\t/**\n\t\t * A callback that is executed when a controller model has been loaded.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t\t// If a GLTFLoader wasn't supplied to the constructor create a new one.\n\t\tif ( ! this.gltfLoader ) {\n\n\t\t\tthis.gltfLoader = new GLTFLoader();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the path to the model repository.\n\t *\n\t * @param {string} path - The path to set.\n\t * @return {XRControllerModelFactory} A reference to this instance.\n\t */\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a controller model for the given WebXR controller.\n\t *\n\t * @param {Group} controller - The controller.\n\t * @return {XRControllerModel} The XR controller model.\n\t */\n\tcreateControllerModel( controller ) {\n\n\t\tconst controllerModel = new XRControllerModel();\n\t\tlet scene = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad || xrInputSource.hand ) return;\n\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\n\n\t\t\t\tcontrollerModel.motionController = new MotionController(\n\t\t\t\t\txrInputSource,\n\t\t\t\t\tprofile,\n\t\t\t\t\tassetPath\n\t\t\t\t);\n\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\n\t\t\t\tif ( cachedAsset ) {\n\n\t\t\t\t\tscene = cachedAsset.scene.clone();\n\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\tif ( this.onLoad ) this.onLoad( scene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! this.gltfLoader ) {\n\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\n\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\n\n\t\t\t\t\t\tscene = asset.scene.clone();\n\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\t\tif ( this.onLoad ) this.onLoad( scene );\n\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t() => {\n\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} ).catch( ( err ) => {\n\n\t\t\t\tconsole.warn( err );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontrollerModel.motionController = null;\n\t\t\tcontrollerModel.remove( scene );\n\t\t\tscene = null;\n\n\t\t} );\n\n\t\treturn controllerModel;\n\n\t}\n\n}\n\nexport { XRControllerModelFactory };\n"],"mappings":"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","ignoreList":[]}