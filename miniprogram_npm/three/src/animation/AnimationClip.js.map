{"version":3,"file":"node_modules/three/src/animation/AnimationClip.js","names":["AnimationUtils","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","generateUUID","NormalAnimationBlendMode","AnimationClip","constructor","name","duration","tracks","blendMode","this","uuid","resetDuration","parse","json","jsonTracks","frameTime","fps","i","n","length","push","parseKeyframeTrack","scale","clip","toJSON","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","times","values","order","getKeyframeOrder","sortedArray","findByName","objectOrClipArray","clipArray","Array","isArray","o","geometry","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","bones","console","warn","error","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","h","keys","morphTargetNames","k","m","morphTargetName","animationKey","time","boneName","track","Math","max","trim","validate","valid","optimize","clone","getTrackTypeForValueTypeName","typeName","toLowerCase","Error","undefined","type","interpolation"],"sources":["node_modules/three/src/animation/AnimationClip.js"],"sourcesContent":["import * as AnimationUtils from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { generateUUID } from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\n/**\n * A reusable set of keyframe tracks which represent an animation.\n */\nclass AnimationClip {\n\n\t/**\n\t * Constructs a new animation clip.\n\t *\n\t * Note: Instead of instantiating an AnimationClip directly with the constructor, you can\n\t * use the static interface of this class for creating clips. In most cases though, animation clips\n\t * will automatically be created by loaders when importing animated 3D assets.\n\t *\n\t * @param {string} [name=''] - The clip's name.\n\t * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,\n\t * the duration will be calculated from the passed keyframes.\n\t * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.\n\t * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation\n\t * is blended/combined when two or more animations are simultaneously played.\n\t */\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\t/**\n\t\t * The clip's name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t *  An array of keyframe tracks.\n\t\t *\n\t\t * @type {Array<KeyframeTrack>}\n\t\t */\n\t\tthis.tracks = tracks;\n\n\t\t/**\n\t\t * The clip's duration in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.duration = duration;\n\n\t\t/**\n\t\t * Defines how the animation is blended/combined when two or more animations\n\t\t * are simultaneously played.\n\t\t *\n\t\t * @type {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)}\n\t\t */\n\t\tthis.blendMode = blendMode;\n\n\t\t/**\n\t\t * The UUID of the animation clip.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Factory method for creating an animation clip from the given JSON.\n\t *\n\t * @static\n\t * @param {Object} json - The serialized animation clip.\n\t * @return {AnimationClip} The new animation clip.\n\t */\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\t/**\n\t * Serializes the given animation clip into JSON.\n\t *\n\t * @static\n\t * @param {AnimationClip} clip - The animation clip to serialize.\n\t * @return {Object} The JSON object.\n\t */\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\t/**\n\t * Returns a new animation clip from the passed morph targets array of a\n\t * geometry, taking a name and the number of frames per second.\n\t *\n\t * Note: The fps parameter is required, but the animation speed can be\n\t * overridden via {@link AnimationAction#setDuration}.\n\t *\n\t * @static\n\t * @param {string} name - The name of the animation clip.\n\t * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.\n\t * @param {number} fps - The Frames-Per-Second value.\n\t * @param {boolean} noLoop - Whether the clip should be no loop or not.\n\t * @return {AnimationClip} The new animation clip.\n\t */\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\t/**\n\t * Searches for an animation clip by name, taking as its first parameter\n\t * either an array of clips, or a mesh or geometry that contains an\n\t * array named \"animations\" property.\n\t *\n\t * @static\n\t * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.\n\t * @param {string} name - The name to search for.\n\t * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.\n\t */\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns an array of new AnimationClips created from the morph target\n\t * sequences of a geometry, trying to sort morph target names into\n\t * animation-group-based patterns like \"Walk_001, Walk_002, Run_001, Run_002...\".\n\t *\n\t * See {@link MD2Loader#parse} as an example for how the method should be used.\n\t *\n\t * @static\n\t * @param {Array<Object>} morphTargets - A sequence of morph targets.\n\t * @param {number} fps - The Frames-Per-Second value.\n\t * @param {boolean} noLoop - Whether the clip should be no loop or not.\n\t * @return {Array<AnimationClip>} An array of new animation clips.\n\t */\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t/**\n\t * Parses the `animation.hierarchy` format and returns a new animation clip.\n\t *\n\t * @static\n\t * @deprecated since r175.\n\t * @param {Object} animation - A serialized animation clip as JSON.\n\t * @param {Array<Bones>} bones - An array of bones.\n\t * @return {?AnimationClip} The new animation clip.\n\t */\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tconsole.warn( 'THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185' );\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\t/**\n\t * Sets the duration of this clip to the duration of its longest keyframe track.\n\t *\n\t * @return {AnimationClip} A reference to this animation clip.\n\t */\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Trims all tracks to the clip's duration.\n\t *\n\t * @return {AnimationClip} A reference to this animation clip.\n\t */\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Performs minimal validation on each track in the clip. Returns `true` if all\n\t * tracks are valid.\n\t *\n\t * @return {boolean} Whether the clip's keyframes are valid or not.\n\t */\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t/**\n\t * Optimizes each track by removing equivalent sequential keys (which are\n\t * common in morph target sequences).\n\t *\n\t * @return {AnimationClip} A reference to this animation clip.\n\t */\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new animation clip with copied values from this instance.\n\t *\n\t * @return {AnimationClip} A clone of this instance.\n\t */\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\t/**\n\t * Serializes this animation clip into JSON.\n\t *\n\t * @return {Object} The JSON object.\n\t */\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nexport { AnimationClip };\n"],"mappings":"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","ignoreList":[]}