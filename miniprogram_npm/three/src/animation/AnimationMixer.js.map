{"version":3,"file":"node_modules/three/src/animation/AnimationMixer.js","names":["AnimationAction","EventDispatcher","LinearInterpolant","PropertyBinding","PropertyMixer","AnimationClip","NormalAnimationBlendMode","_controlInterpolantsResultBuffer","Float32Array","AnimationMixer","constructor","root","super","this","_root","_initMemoryManager","_accuIndex","time","timeScale","_bindAction","action","prototypeAction","_localRoot","tracks","_clip","nTracks","length","bindings","_propertyBindings","interpolants","_interpolants","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","i","track","trackName","name","binding","referenceCount","_cacheIndex","_addInactiveBinding","path","parsedPath","create","ValueTypeName","getValueSize","resultBuffer","buffer","_activateAction","_isActiveAction","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","useCount","_lendBinding","saveOriginalState","_lendAction","_deactivateAction","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","_byClipCacheIndex","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","Object","keys","firstInactiveBinding","lastActiveBinding","_lendControlInterpolant","interpolant","__cacheIndex","_takeBackControlInterpolant","lastActiveInterpolant","clipAction","clip","optionalRoot","blendMode","clipObject","findByName","existingAction","newAction","stopAllAction","stop","update","deltaTime","nActions","timeDirection","Math","sign","accuIndex","_update","nBindings","apply","setTime","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"sources":["node_modules/three/src/animation/AnimationMixer.js"],"sourcesContent":["import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n/**\n * `AnimationMixer` is a player for animations on a particular object in\n * the scene. When multiple objects in the scene are animated independently,\n * one `AnimationMixer` may be used for each object.\n */\nclass AnimationMixer extends EventDispatcher {\n\n\t/**\n\t * Constructs a new animation mixer.\n\t *\n\t * @param {Object3D} root - The object whose animations shall be played by this mixer.\n\t */\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\t/**\n\t\t * The global mixer time (in seconds; starting with `0` on the mixer's creation).\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.time = 0;\n\n\t\t/**\n\t\t * A scaling factor for the global time.\n\t\t *\n\t\t * Note: Setting this member to `0` and later back to `1` is a\n\t\t * possibility to pause/unpause all actions that are controlled by this\n\t\t * mixer.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link AnimationAction} for the passed clip.\n\t *\n\t * If an action fitting the clip and root parameters doesn't yet exist, it\n\t * will be created by this method. Calling this method several times with the\n\t * same clip and root parameters always returns the same action.\n\t *\n\t * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.\n\t * @param {Object3D} [optionalRoot] - An alternative root object.\n\t * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.\n\t * @return {?AnimationAction} The animation action.\n\t */\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t/**\n\t * Returns an existing animation action for the passed clip.\n\t *\n\t * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.\n\t * @param {Object3D} [optionalRoot] - An alternative root object.\n\t * @return {?AnimationAction} The animation action. Returns `null` if no action was found.\n\t */\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Deactivates all previously scheduled actions on this mixer.\n\t *\n\t * @return {AnimationMixer} A reference to thi animation mixer.\n\t */\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Advances the global mixer time and updates the animation.\n\t *\n\t * This is usually done in the render loop by passing the delta\n\t * time from {@link Clock} or {@link Timer}.\n\t *\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @return {AnimationMixer} A reference to thi animation mixer.\n\t */\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the global mixer to a specific time and updates the animation accordingly.\n\t *\n\t * This is useful when you need to jump to an exact time in an animation. The\n\t * input parameter will be scaled by {@link AnimationMixer#timeScale}\n\t *\n\t * @param {number} time - The time to set in seconds.\n\t * @return {AnimationMixer} A reference to thi animation mixer.\n\t */\n\tsetTime( time ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( time ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t/**\n\t * Returns this mixer's root object.\n\t *\n\t * @return {Object3D} The mixer's root object.\n\t */\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t/**\n\t * Deallocates all memory resources for a clip. Before using this method make\n\t * sure to call {@link AnimationAction#stop} for all related actions.\n\t *\n\t * @param {AnimationClip} clip - The clip to uncache.\n\t */\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deallocates all memory resources for a root object. Before using this\n\t * method make sure to call {@link AnimationAction#stop} for all related\n\t * actions or alternatively {@link AnimationMixer#stopAllAction} when the\n\t * mixer operates on a single root.\n\t *\n\t * @param {Object3D} root - The root object to uncache.\n\t */\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deallocates all memory resources for an action. The action is identified by the\n\t * given clip and an optional root object. Before using this method make\n\t * sure to call {@link AnimationAction#stop} to deactivate the action.\n\t *\n\t * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.\n\t * @param {Object3D} [optionalRoot] - An alternative root object.\n\t */\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nexport { AnimationMixer };\n"],"mappings":"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","ignoreList":[]}