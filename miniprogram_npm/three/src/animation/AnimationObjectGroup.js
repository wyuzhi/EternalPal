import{PropertyBinding}from"./PropertyBinding.js";import{generateUUID}from"../math/MathUtils.js";class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let s=0,e=arguments.length;s!==e;++s)t[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const s=this;this.stats={objects:{get total(){return s._objects.length},get inUse(){return this.total-s.nCachedObjects_}},get bindingsPerObject(){return s._bindings.length}}}add(){const t=this._objects,s=this._indicesByUUID,e=this._paths,i=this._parsedPaths,n=this._bindings,h=n.length;let o,c=t.length,r=this.nCachedObjects_;for(let d=0,a=arguments.length;d!==a;++d){const a=arguments[d],l=a.uuid;let u=s[l];if(void 0===u){u=c++,s[l]=u,t.push(a);for(let t=0,s=h;t!==s;++t)n[t].push(new PropertyBinding(a,e[t],i[t]))}else if(u<r){o=t[u];const c=--r,d=t[c];s[d.uuid]=u,t[u]=d,s[l]=c,t[c]=a;for(let t=0,s=h;t!==s;++t){const s=n[t],h=s[c];let o=s[u];s[u]=h,void 0===o&&(o=new PropertyBinding(a,e[t],i[t])),s[c]=o}}else t[u]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=r}remove(){const t=this._objects,s=this._indicesByUUID,e=this._bindings,i=e.length;let n=this.nCachedObjects_;for(let h=0,o=arguments.length;h!==o;++h){const o=arguments[h],c=o.uuid,r=s[c];if(void 0!==r&&r>=n){const h=n++,d=t[h];s[d.uuid]=r,t[r]=d,s[c]=h,t[h]=o;for(let t=0,s=i;t!==s;++t){const s=e[t],i=s[h],n=s[r];s[r]=i,s[h]=n}}}this.nCachedObjects_=n}uncache(){const t=this._objects,s=this._indicesByUUID,e=this._bindings,i=e.length;let n=this.nCachedObjects_,h=t.length;for(let o=0,c=arguments.length;o!==c;++o){const c=arguments[o].uuid,r=s[c];if(void 0!==r)if(delete s[c],r<n){const o=--n,c=t[o],d=--h,a=t[d];s[c.uuid]=r,t[r]=c,s[a.uuid]=o,t[o]=a,t.pop();for(let t=0,s=i;t!==s;++t){const s=e[t],i=s[o],n=s[d];s[r]=i,s[o]=n,s.pop()}}else{const n=--h,o=t[n];n>0&&(s[o.uuid]=r),t[r]=o,t.pop();for(let t=0,s=i;t!==s;++t){const s=e[t];s[r]=s[n],s.pop()}}}this.nCachedObjects_=n}subscribe_(t,s){const e=this._bindingsIndicesByPath;let i=e[t];const n=this._bindings;if(void 0!==i)return n[i];const h=this._paths,o=this._parsedPaths,c=this._objects,r=c.length,d=this.nCachedObjects_,a=new Array(r);i=n.length,e[t]=i,h.push(t),o.push(s),n.push(a);for(let e=d,i=c.length;e!==i;++e){const i=c[e];a[e]=new PropertyBinding(i,t,s)}return a}unsubscribe_(t){const s=this._bindingsIndicesByPath,e=s[t];if(void 0!==e){const i=this._paths,n=this._parsedPaths,h=this._bindings,o=h.length-1,c=h[o];s[t[o]]=e,h[e]=c,h.pop(),n[e]=n[o],n.pop(),i[e]=i[o],i.pop()}}}export{AnimationObjectGroup};
//# sourceMappingURL=AnimationObjectGroup.js.map