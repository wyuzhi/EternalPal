{"version":3,"file":"node_modules/three/src/animation/AnimationObjectGroup.js","names":["PropertyBinding","generateUUID","AnimationObjectGroup","constructor","this","isAnimationObjectGroup","uuid","_objects","Array","prototype","slice","call","arguments","nCachedObjects_","indices","_indicesByUUID","i","n","length","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","scope","stats","objects","total","inUse","bindingsPerObject","add","indicesByUUID","paths","parsedPaths","bindings","nBindings","knownObject","nObjects","nCachedObjects","object","index","undefined","push","j","m","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","binding","console","error","remove","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","pop","last","subscribe_","path","parsedPath","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings"],"sources":["node_modules/three/src/animation/AnimationObjectGroup.js"],"sourcesContent":["import { PropertyBinding } from './PropertyBinding.js';\nimport { generateUUID } from '../math/MathUtils.js';\n\n/**\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * - Add objects you would otherwise pass as 'root' to the\n * constructor or the .clipAction method of AnimationMixer.\n * - Instead pass this object as 'root'.\n * - You can also add and remove objects later when the mixer is running.\n *\n * Note:\n *\n * - Objects of this class appear as one object to the mixer,\n * so cache control of the individual objects must be done on the group.\n *\n * Limitation:\n *\n * - The animated properties must be compatible among the all objects in the group.\n * - A single property can either be controlled through a target group or directly, but not both.\n */\nclass AnimationObjectGroup {\n\n\t/**\n\t * Constructs a new animation group.\n\t *\n\t * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\t/**\n\t\t * The UUID of the 3D object.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Adds an arbitrary number of objects to this animation group.\n\t *\n\t * @param {...Object3D} arguments - The 3D objects to add.\n\t */\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t/**\n\t * Removes an arbitrary number of objects to this animation group\n\t *\n\t * @param {...Object3D} arguments - The 3D objects to remove.\n\t */\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t/**\n\t * Deallocates all memory resources for the passed 3D objects of this animation group.\n\t *\n\t * @param {...Object3D} arguments - The 3D objects to uncache.\n\t */\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nexport { AnimationObjectGroup };\n"],"mappings":"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","ignoreList":[]}