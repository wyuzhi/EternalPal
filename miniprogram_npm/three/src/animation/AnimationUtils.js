import{Quaternion}from"../math/Quaternion.js";import{AdditiveAnimationBlendMode}from"../constants.js";function convertArray(t,e){return t&&t.constructor!==e?"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t):t}function isTypedArray(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function getKeyframeOrder(t){const e=t.length,r=new Array(e);for(let t=0;t!==e;++t)r[t]=t;return r.sort((function(e,r){return t[e]-t[r]})),r}function sortedArray(t,e,r){const n=t.length,i=new t.constructor(n);for(let o=0,s=0;s!==n;++o){const n=r[o]*e;for(let r=0;r!==e;++r)i[s++]=t[n+r]}return i}function flattenJSON(t,e,r,n){let i=1,o=t[0];for(;void 0!==o&&void 0===o[n];)o=t[i++];if(void 0===o)return;let s=o[n];if(void 0!==s)if(Array.isArray(s))do{s=o[n],void 0!==s&&(e.push(o.time),r.push(...s)),o=t[i++]}while(void 0!==o);else if(void 0!==s.toArray)do{s=o[n],void 0!==s&&(e.push(o.time),s.toArray(r,r.length)),o=t[i++]}while(void 0!==o);else do{s=o[n],void 0!==s&&(e.push(o.time),r.push(s)),o=t[i++]}while(void 0!==o)}function subclip(t,e,r,n,i=30){const o=t.clone();o.name=e;const s=[];for(let t=0;t<o.tracks.length;++t){const e=o.tracks[t],a=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const o=e.times[t]*i;if(!(o<r||o>=n)){l.push(e.times[t]);for(let r=0;r<a;++r)c.push(e.values[t*a+r])}}0!==l.length&&(e.times=convertArray(l,e.times.constructor),e.values=convertArray(c,e.values.constructor),s.push(e))}o.tracks=s;let a=1/0;for(let t=0;t<o.tracks.length;++t)a>o.tracks[t].times[0]&&(a=o.tracks[t].times[0]);for(let t=0;t<o.tracks.length;++t)o.tracks[t].shift(-1*a);return o.resetDuration(),o}function makeClipAdditive(t,e=0,r=t,n=30){n<=0&&(n=30);const i=r.tracks.length,o=e/n;for(let e=0;e<i;++e){const n=r.tracks[e],i=n.ValueTypeName;if("bool"===i||"string"===i)continue;const s=t.tracks.find((function(t){return t.name===n.name&&t.ValueTypeName===i}));if(void 0===s)continue;let a=0;const l=n.getValueSize();n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const f=n.times.length-1;let d;if(o<=n.times[0]){const t=a,e=l-a;d=n.values.slice(t,e)}else if(o>=n.times[f]){const t=f*l+a,e=t+l-a;d=n.values.slice(t,e)}else{const t=n.createInterpolant(),e=a,r=l-a;t.evaluate(o),d=t.resultBuffer.slice(e,r)}if("quaternion"===i){(new Quaternion).fromArray(d).normalize().conjugate().toArray(d)}const m=s.times.length;for(let t=0;t<m;++t){const e=t*u+c;if("quaternion"===i)Quaternion.multiplyQuaternionsFlat(s.values,e,d,0,s.values,e);else{const t=u-2*c;for(let r=0;r<t;++r)s.values[e+r]-=d[r]}}}return t.blendMode=AdditiveAnimationBlendMode,t}class AnimationUtils{static convertArray(t,e){return convertArray(t,e)}static isTypedArray(t){return isTypedArray(t)}static getKeyframeOrder(t){return getKeyframeOrder(t)}static sortedArray(t,e,r){return sortedArray(t,e,r)}static flattenJSON(t,e,r,n){flattenJSON(t,e,r,n)}static subclip(t,e,r,n,i=30){return subclip(t,e,r,n,i)}static makeClipAdditive(t,e=0,r=t,n=30){return makeClipAdditive(t,e,r,n)}}export{convertArray,isTypedArray,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive,AnimationUtils};
//# sourceMappingURL=AnimationUtils.js.map