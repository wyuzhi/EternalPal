{"version":3,"file":"node_modules/three/src/animation/AnimationUtils.js","names":["Quaternion","AdditiveAnimationBlendMode","convertArray","array","type","constructor","BYTES_PER_ELEMENT","Array","prototype","slice","call","isTypedArray","object","ArrayBuffer","isView","DataView","getKeyframeOrder","times","n","length","result","i","sort","j","sortedArray","values","stride","order","nValues","dstOffset","srcOffset","flattenJSON","jsonKeys","valuePropertyName","key","undefined","value","isArray","push","time","toArray","subclip","sourceClip","name","startFrame","endFrame","fps","clip","clone","tracks","track","valueSize","getValueSize","frame","k","minStartTime","Infinity","shift","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","lastIndex","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","fromArray","normalize","conjugate","numTimes","valueStart","multiplyQuaternionsFlat","valueEnd","blendMode","AnimationUtils"],"sources":["node_modules/three/src/animation/AnimationUtils.js"],"sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\n/**\n * Converts an array to a specific type.\n *\n * @param {TypedArray|Array} array - The array to convert.\n * @param {TypedArray.constructor} type - The constructor of a typed array that defines the new type.\n * @return {TypedArray} The converted array.\n */\nfunction convertArray( array, type ) {\n\n\tif ( ! array || array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\n/**\n * Returns `true` if the given object is a typed array.\n *\n * @param {any} object - The object to check.\n * @return {boolean} Whether the given object is a typed array.\n */\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) && ! ( object instanceof DataView );\n\n}\n\n/**\n * Returns an array by which times and values can be sorted.\n *\n * @param {Array<number>} times - The keyframe time values.\n * @return {Array<number>} The array.\n */\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n/**\n * Sorts the given array by the previously computed order via `getKeyframeOrder()`.\n *\n * @param {Array<number>} values - The values to sort.\n * @param {number} stride - The stride.\n * @param {Array<number>} order - The sort order.\n * @return {Array<number>} The sorted values.\n */\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Used for parsing AOS keyframe formats.\n *\n * @param {Array<number>} jsonKeys - A list of JSON keyframes.\n * @param {Array<number>} times - This array will be filled with keyframe times by this function.\n * @param {Array<number>} values - This array will be filled with keyframe values by this function.\n * @param {string} valuePropertyName - The name of the property to use.\n */\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( ...value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\n/**\n * Creates a new clip, containing only the segment of the original clip between the given frames.\n *\n * @param {AnimationClip} sourceClip - The values to sort.\n * @param {string} name - The name of the clip.\n * @param {number} startFrame - The start frame.\n * @param {number} endFrame - The end frame.\n * @param {number} [fps=30] - The FPS.\n * @return {AnimationClip} The new sub clip.\n */\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\n/**\n * Converts the keyframes of the given animation clip to an additive format.\n *\n * @param {AnimationClip} targetClip - The clip to make additive.\n * @param {number} [referenceFrame=0] - The reference frame.\n * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.\n * @param {number} [fps=30] - The FPS.\n * @return {AnimationClip} The updated clip which is now additive.\n */\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\n/**\n * A class with various methods to assist with animations.\n *\n * @hideconstructor\n */\nclass AnimationUtils {\n\n\t/**\n\t * Converts an array to a specific type\n\t *\n\t * @static\n\t * @param {TypedArray|Array} array - The array to convert.\n\t * @param {TypedArray.constructor} type - The constructor of a type array.\n\t * @return {TypedArray} The converted array\n\t */\n\tstatic convertArray( array, type ) {\n\n\t\treturn convertArray( array, type );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given object is a typed array.\n\t *\n\t * @static\n\t * @param {any} object - The object to check.\n\t * @return {boolean} Whether the given object is a typed array.\n\t */\n\tstatic isTypedArray( object ) {\n\n\t\treturn isTypedArray( object );\n\n\t}\n\n\t/**\n\t * Returns an array by which times and values can be sorted.\n\t *\n\t * @static\n\t * @param {Array<number>} times - The keyframe time values.\n\t * @return {Array<number>} The array.\n\t */\n\tstatic getKeyframeOrder( times ) {\n\n\t\treturn getKeyframeOrder( times );\n\n\t}\n\n\t/**\n\t * Sorts the given array by the previously computed order via `getKeyframeOrder()`.\n\t *\n\t * @static\n\t * @param {Array<number>} values - The values to sort.\n\t * @param {number} stride - The stride.\n\t * @param {Array<number>} order - The sort order.\n\t * @return {Array<number>} The sorted values.\n\t */\n\tstatic sortedArray( values, stride, order ) {\n\n\t\treturn sortedArray( values, stride, order );\n\n\t}\n\n\t/**\n\t * Used for parsing AOS keyframe formats.\n\t *\n\t * @static\n\t * @param {Array<number>} jsonKeys - A list of JSON keyframes.\n\t * @param {Array<number>} times - This array will be filled with keyframe times by this method.\n\t * @param {Array<number>} values - This array will be filled with keyframe values by this method.\n\t * @param {string} valuePropertyName - The name of the property to use.\n\t */\n\tstatic flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tflattenJSON( jsonKeys, times, values, valuePropertyName );\n\n\t}\n\n\t/**\n\t * Creates a new clip, containing only the segment of the original clip between the given frames.\n\t *\n\t * @static\n\t * @param {AnimationClip} sourceClip - The values to sort.\n\t * @param {string} name - The name of the clip.\n\t * @param {number} startFrame - The start frame.\n\t * @param {number} endFrame - The end frame.\n\t * @param {number} [fps=30] - The FPS.\n\t * @return {AnimationClip} The new sub clip.\n\t */\n\tstatic subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\t\treturn subclip( sourceClip, name, startFrame, endFrame, fps );\n\n\t}\n\n\t/**\n\t * Converts the keyframes of the given animation clip to an additive format.\n\t *\n\t * @static\n\t * @param {AnimationClip} targetClip - The clip to make additive.\n\t * @param {number} [referenceFrame=0] - The reference frame.\n\t * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.\n\t * @param {number} [fps=30] - The FPS.\n\t * @return {AnimationClip} The updated clip which is now additive.\n\t */\n\tstatic makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\t\treturn makeClipAdditive( targetClip, referenceFrame, referenceClip, fps );\n\n\t}\n\n}\n\nexport {\n\tconvertArray,\n\tisTypedArray,\n\tgetKeyframeOrder,\n\tsortedArray,\n\tflattenJSON,\n\tsubclip,\n\tmakeClipAdditive,\n\tAnimationUtils\n};\n"],"mappings":"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","ignoreList":[]}