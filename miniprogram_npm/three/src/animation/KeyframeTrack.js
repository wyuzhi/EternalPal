import{InterpolateLinear,InterpolateSmooth,InterpolateDiscrete}from"../constants.js";import{CubicInterpolant}from"../math/interpolants/CubicInterpolant.js";import{LinearInterpolant}from"../math/interpolants/LinearInterpolant.js";import{DiscreteInterpolant}from"../math/interpolants/DiscreteInterpolant.js";import*as AnimationUtils from"./AnimationUtils.js";class KeyframeTrack{constructor(t,e,r,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=AnimationUtils.convertArray(e,this.TimeBufferType),this.values=AnimationUtils.convertArray(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let r;if(e.toJSON!==this.toJSON)r=e.toJSON(t);else{r={name:t.name,times:AnimationUtils.convertArray(t.times,Array),values:AnimationUtils.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(r.interpolation=e)}return r.type=t.ValueTypeName,r}InterpolantFactoryMethodDiscrete(t){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new LinearInterpolant(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new CubicInterpolant(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case InterpolateDiscrete:e=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:e=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let r=0,i=e.length;r!==i;++r)e[r]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let r=0,i=e.length;r!==i;++r)e[r]*=t}return this}trim(t,e){const r=this.times,i=r.length;let o=0,a=i-1;for(;o!==i&&r[o]<t;)++o;for(;-1!==a&&r[a]>e;)--a;if(++a,0!==o||a!==i){o>=a&&(a=Math.max(a,1),o=a-1);const t=this.getValueSize();this.times=r.slice(o,a),this.values=this.values.slice(o*t,a*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const r=this.times,i=this.values,o=r.length;0===o&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let e=0;e!==o;e++){const i=r[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==a&&a>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,a),t=!1;break}a=i}if(void 0!==i&&AnimationUtils.isTypedArray(i))for(let e=0,r=i.length;e!==r;++e){const r=i[e];if(isNaN(r)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,r),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),r=this.getValueSize(),i=this.getInterpolation()===InterpolateSmooth,o=t.length-1;let a=1;for(let n=1;n<o;++n){let o=!1;const s=t[n];if(s!==t[n+1]&&(1!==n||s!==t[0]))if(i)o=!0;else{const t=n*r,i=t-r,a=t+r;for(let n=0;n!==r;++n){const r=e[t+n];if(r!==e[i+n]||r!==e[a+n]){o=!0;break}}}if(o){if(n!==a){t[a]=t[n];const i=n*r,o=a*r;for(let t=0;t!==r;++t)e[o+t]=e[i+t]}++a}}if(o>0){t[a]=t[o];for(let t=o*r,i=a*r,n=0;n!==r;++n)e[i+n]=e[t+n];++a}return a!==t.length?(this.times=t.slice(0,a),this.values=e.slice(0,a*r)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),r=new(0,this.constructor)(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}KeyframeTrack.prototype.ValueTypeName="",KeyframeTrack.prototype.TimeBufferType=Float32Array,KeyframeTrack.prototype.ValueBufferType=Float32Array,KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;export{KeyframeTrack};
//# sourceMappingURL=KeyframeTrack.js.map