{"version":3,"file":"node_modules/three/src/animation/KeyframeTrack.js","names":["InterpolateLinear","InterpolateSmooth","InterpolateDiscrete","CubicInterpolant","LinearInterpolant","DiscreteInterpolant","AnimationUtils","KeyframeTrack","constructor","name","times","values","interpolation","undefined","Error","length","this","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","toJSON","track","trackType","json","Array","getInterpolation","type","ValueTypeName","InterpolantFactoryMethodDiscrete","result","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","createInterpolant","console","warn","shift","timeOffset","i","n","scale","timeScale","trim","startTime","endTime","nKeys","from","to","Math","max","stride","slice","validate","valid","valueSize","floor","error","prevTime","currTime","isNaN","isTypedArray","value","optimize","smoothInterpolation","lastIndex","writeIndex","keep","time","offset","offsetP","offsetN","j","readOffset","writeOffset","clone","TypedKeyframeTrack","prototype","Float32Array"],"sources":["node_modules/three/src/animation/KeyframeTrack.js"],"sourcesContent":["import {\n\tInterpolateLinear,\n\tInterpolateSmooth,\n\tInterpolateDiscrete\n} from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport * as AnimationUtils from './AnimationUtils.js';\n\n/**\n * Represents s a timed sequence of keyframes, which are composed of lists of\n * times and related values, and which are used to animate a specific property\n * of an object.\n */\nclass KeyframeTrack {\n\n\t/**\n\t * Constructs a new keyframe track.\n\t *\n\t * @param {string} name - The keyframe track's name.\n\t * @param {Array<number>} times - A list of keyframe times.\n\t * @param {Array<number|string|boolean>} values - A list of keyframe values.\n\t * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.\n\t */\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\t/**\n\t\t * The track's name can refer to morph targets or bones or\n\t\t * possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}\n\t\t * for the forms of strings that can be parsed for property binding.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The keyframe times.\n\t\t *\n\t\t * @type {Float32Array}\n\t\t */\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\n\t\t/**\n\t\t * The keyframe values.\n\t\t *\n\t\t * @type {Float32Array}\n\t\t */\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t/**\n\t * Converts the keyframe track to JSON.\n\t *\n\t * @static\n\t * @param {KeyframeTrack} track - The keyframe track to serialize.\n\t * @return {Object} The serialized keyframe track as JSON.\n\t */\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\t/**\n\t * Factory method for creating a new discrete interpolant.\n\t *\n\t * @static\n\t * @param {TypedArray} [result] - The result buffer.\n\t * @return {DiscreteInterpolant} The new interpolant.\n\t */\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\t/**\n\t * Factory method for creating a new linear interpolant.\n\t *\n\t * @static\n\t * @param {TypedArray} [result] - The result buffer.\n\t * @return {LinearInterpolant} The new interpolant.\n\t */\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\t/**\n\t * Factory method for creating a new smooth interpolant.\n\t *\n\t * @static\n\t * @param {TypedArray} [result] - The result buffer.\n\t * @return {CubicInterpolant} The new interpolant.\n\t */\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\t/**\n\t * Defines the interpolation factor method for this keyframe track.\n\t *\n\t * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.\n\t * @return {KeyframeTrack} A reference to this keyframe track.\n\t */\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the current interpolation type.\n\t *\n\t * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.\n\t */\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the value size.\n\t *\n\t * @return {number} The value size.\n\t */\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t/**\n\t * Moves all keyframes either forward or backward in time.\n\t *\n\t * @param {number} timeOffset - The offset to move the time values.\n\t * @return {KeyframeTrack} A reference to this keyframe track.\n\t */\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Scale all keyframe times by a factor (useful for frame - seconds conversions).\n\t *\n\t * @param {number} timeScale - The time scale.\n\t * @return {KeyframeTrack} A reference to this keyframe track.\n\t */\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes keyframes before and after animation without changing any values within the defined time range.\n\t *\n\t * Note: The method does not shift around keys to the start of the track time, because for interpolated\n\t * keys this will change their values\n\t *\n\t * @param {number} startTime - The start time.\n\t * @param {number} endTime - The end time.\n\t * @return {KeyframeTrack} A reference to this keyframe track.\n\t */\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Performs minimal validation on the keyframe track. Returns `true` if the values\n\t * are valid.\n\t *\n\t * @return {boolean} Whether the keyframes are valid or not.\n\t */\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t/**\n\t * Optimizes this keyframe track by removing equivalent sequential keys (which are\n\t * common in morph target sequences).\n\t *\n\t * @return {AnimationClip} A reference to this animation clip.\n\t */\n\toptimize() {\n\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new keyframe track with copied values from this instance.\n\t *\n\t * @return {KeyframeTrack} A clone of this instance.\n\t */\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\n/**\n * The value type name.\n *\n * @type {String}\n * @default ''\n */\nKeyframeTrack.prototype.ValueTypeName = '';\n\n/**\n * The time buffer type of this keyframe track.\n *\n * @type {TypedArray|Array}\n * @default Float32Array.constructor\n */\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\n\n/**\n * The value buffer type of this keyframe track.\n *\n * @type {TypedArray|Array}\n * @default Float32Array.constructor\n */\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\n\n/**\n * The default interpolation type of this keyframe track.\n *\n * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}\n * @default InterpolateLinear\n */\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\nexport { KeyframeTrack };\n"],"mappings":"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","ignoreList":[]}