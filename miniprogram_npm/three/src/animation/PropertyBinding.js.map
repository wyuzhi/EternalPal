{"version":3,"file":"node_modules/three/src/animation/PropertyBinding.js","names":["_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","replace","_directoryRe","source","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","Composite","constructor","targetGroup","path","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","this","_targetGroup","_bindings","subscribe_","getValue","array","offset","bind","firstValidIndex","nCachedObjects_","binding","undefined","setValue","bindings","i","n","length","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","root","isAnimationObjectGroup","sanitizeNodeName","name","trackName","matches","exec","Error","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","indexOf","uuid","skeleton","bone","getBoneByName","children","searchNodeSubtree","childNode","result","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","buffer","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","needsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","matrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","console","warn","material","error","materials","bones","map","nodeProperty","versioning","Versioning","None","isMaterial","NeedsUpdate","isObject3D","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","geometry","morphAttributes","morphTargetDictionary","ArrayElement","HasFromToArray","Array","isArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","prototype"],"sources":["node_modules/three/src/animation/PropertyBinding.js"],"sourcesContent":["// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\n\n\n/**\n * This holds a reference to a real property in the scene graph; used internally.\n */\nclass PropertyBinding {\n\n\t/**\n\t * Constructs a new property binding.\n\t *\n\t * @param {Object} rootNode - The root node.\n\t * @param {string} path - The path.\n\t * @param {?Object} [parsedPath] - The parsed path.\n\t */\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\t/**\n\t\t * The object path to the animated property.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * An object holding information about the path.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\t/**\n\t\t * The object owns the animated property.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\t/**\n\t\t * The root node.\n\t\t *\n\t\t * @type {Object3D|Skeleton}\n\t\t */\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\t/**\n\t * Factory method for creating a property binding from the given parameters.\n\t *\n\t * @static\n\t * @param {Object} root - The root node.\n\t * @param {string} path - The path.\n\t * @param {?Object} [parsedPath] - The parsed path.\n\t * @return {PropertyBinding|Composite} The created property binding or composite.\n\t */\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name - Node name to be sanitized.\n\t * @return {string} The sanitized node name.\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\t/**\n\t * Parses the given track name (an object path to an animated property) and\n\t * returns an object with information about the path. Matches strings in the following forms:\n\t *\n\t * - nodeName.property\n\t * - nodeName.property[accessor]\n\t * - nodeName.material.property[accessor]\n\t * - uuid.property[accessor]\n\t * - uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t * - parentName/nodeName.property\n\t * - parentName/parentName/nodeName.property[index]\n\t * - .bone[Armature.DEF_cog].position\n\t * - scene:helium_balloon_model:helium_balloon_model.position\n\t *\n\t * @static\n\t * @param {string} trackName - The track name to parse.\n\t * @return {Object} The parsed track name as an object.\n\t */\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\t/**\n\t * Searches for a node in the hierarchy of the given root object by the given\n\t * node name.\n\t *\n\t * @static\n\t * @param {Object} root - The root object.\n\t * @param {string|number} nodeName - The name of the node.\n\t * @return {?Object} The found node. Returns `null` if no object was found.\n\t */\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t/**\n\t * Creates a getter / setter pair for the property tracked by this binding.\n\t */\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.isMaterial === true ) {\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.isObject3D === true ) {\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\t/**\n\t * Unbinds the property.\n\t */\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n\nexport { PropertyBinding };\n"],"mappings":"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","ignoreList":[]}