{"version":3,"file":"node_modules/three/src/animation/PropertyMixer.js","names":["Quaternion","PropertyMixer","constructor","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","this","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","Array","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","weight","stride","offset","currentWeight","i","mix","accumulateAdditive","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","slerpFlat","workOffset","multiplyQuaternionsFlat","s","j"],"sources":["node_modules/three/src/animation/PropertyMixer.js"],"sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\n\n/**\n * Buffered scene graph property that allows weighted accumulation; used internally.\n */\nclass PropertyMixer {\n\n\t/**\n\t * Constructs a new property mixer.\n\t *\n\t * @param {PropertyBinding} binding - The property binding.\n\t * @param {string} typeName - The keyframe track type name.\n\t * @param {number} valueSize - The keyframe track value size.\n\t */\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\t/**\n\t\t * The property binding.\n\t\t *\n\t\t * @type {PropertyBinding}\n\t\t */\n\t\tthis.binding = binding;\n\n\t\t/**\n\t\t * The keyframe track value size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cumulativeWeight = 0;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.useCount = 0;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t/**\n\t * Accumulates data in the `incoming` region into `accu<i>`.\n\t *\n\t * @param {number} accuIndex - The accumulation index.\n\t * @param {number} weight - The weight.\n\t */\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t/**\n\t * Accumulates data in the `incoming` region into `add`.\n\t *\n\t * @param {number} weight - The weight.\n\t */\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t/**\n\t * Applies the state of `accu<i>` to the binding when accus differ.\n\t *\n\t * @param {number} accuIndex - The accumulation index.\n\t */\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Remembers the state of the bound property and copy it to both accus.\n\t */\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t/**\n\t * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.\n\t */\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t// internals\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { PropertyMixer };\n"],"mappings":"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","ignoreList":[]}