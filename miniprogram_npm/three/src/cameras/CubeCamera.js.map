{"version":3,"file":"node_modules/three/src/cameras/CubeCamera.js","names":["WebGLCoordinateSystem","WebGPUCoordinateSystem","Object3D","PerspectiveCamera","fov","aspect","CubeCamera","constructor","near","far","renderTarget","super","this","type","coordinateSystem","activeMipmapLevel","cameraPX","layers","add","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCoordinateSystem","cameras","children","concat","camera","remove","up","set","lookAt","Error","updateMatrixWorld","update","renderer","scene","parent","currentRenderTarget","getRenderTarget","currentActiveCubeFace","getActiveCubeFace","currentActiveMipmapLevel","getActiveMipmapLevel","currentXrEnabled","xr","enabled","generateMipmaps","texture","setRenderTarget","render","needsPMREMUpdate"],"sources":["node_modules/three/src/cameras/CubeCamera.js"],"sourcesContent":["import { WebGLCoordinateSystem, WebGPUCoordinateSystem } from '../constants.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { PerspectiveCamera } from './PerspectiveCamera.js';\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\n/**\n * A special type of camera that is positioned in 3D space to render its surroundings into a\n * cube render target. The render target can then be used as an environment map for rendering\n * realtime reflections in your scene.\n *\n * ```js\n * // Create cube render target\n * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );\n *\n * // Create cube camera\n * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );\n * scene.add( cubeCamera );\n *\n * // Create car\n * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );\n * const car = new THREE.Mesh( carGeometry, chromeMaterial );\n * scene.add( car );\n *\n * // Update the render target cube\n * car.visible = false;\n * cubeCamera.position.copy( car.position );\n * cubeCamera.update( renderer, scene );\n *\n * // Render the scene\n * car.visible = true;\n * renderer.render( scene, camera );\n * ```\n *\n * @augments Object3D\n */\nclass CubeCamera extends Object3D {\n\n\t/**\n\t * Constructs a new cube camera.\n\t *\n\t * @param {number} near - The camera's near plane.\n\t * @param {number} far - The camera's far plane.\n\t * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.\n\t */\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\t/**\n\t\t * A reference to the cube render target.\n\t\t *\n\t\t * @type {WebGLCubeRenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * The current active coordinate system.\n\t\t *\n\t\t * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}\n\t\t * @default null\n\t\t */\n\t\tthis.coordinateSystem = null;\n\n\t\t/**\n\t\t * The current active mipmap level\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\t/**\n\t * Must be called when the coordinate system of the cube camera is changed.\n\t */\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method will render the given scene with the given renderer\n\t * into the cube render target of the camera.\n\t *\n\t * @param {(Renderer|WebGLRenderer)} renderer - The renderer.\n\t * @param {Scene} scene - The scene to render.\n\t */\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nexport { CubeCamera };\n"],"mappings":"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","ignoreList":[]}