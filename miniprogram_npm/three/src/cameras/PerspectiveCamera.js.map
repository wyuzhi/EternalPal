{"version":3,"file":"node_modules/three/src/cameras/PerspectiveCamera.js","names":["Camera","RAD2DEG","DEG2RAD","Vector2","Vector3","_v3","_minTarget","_maxTarget","PerspectiveCamera","constructor","fov","aspect","near","far","super","this","isPerspectiveCamera","type","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","copy","source","recursive","Object","assign","setFocalLength","focalLength","vExtentSlope","getFilmHeight","Math","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","min","max","getViewBounds","distance","minTarget","maxTarget","set","applyMatrix4","projectionMatrixInverse","x","y","multiplyScalar","z","getViewSize","target","subVectors","setViewOffset","fullWidth","fullHeight","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","projectionMatrix","makePerspective","coordinateSystem","reversedDepth","invert","toJSON","meta","data","object"],"sources":["node_modules/three/src/cameras/PerspectiveCamera.js"],"sourcesContent":["import { Camera } from './Camera.js';\nimport { RAD2DEG, DEG2RAD } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nconst _v3 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n/**\n * Camera that uses [perspective projection]{@link https://en.wikipedia.org/wiki/Perspective_(graphical)}.\n *\n * This projection mode is designed to mimic the way the human eye sees. It\n * is the most common projection mode used for rendering a 3D scene.\n *\n * ```js\n * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );\n * scene.add( camera );\n * ```\n *\n * @augments Camera\n */\nclass PerspectiveCamera extends Camera {\n\n\t/**\n\t * Constructs a new perspective camera.\n\t *\n\t * @param {number} [fov=50] - The vertical field of view.\n\t * @param {number} [aspect=1] - The aspect ratio.\n\t * @param {number} [near=0.1] - The camera's near plane.\n\t * @param {number} [far=2000] - The camera's far plane.\n\t */\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\t/**\n\t\t * The vertical field of view, from bottom to top of view,\n\t\t * in degrees.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 50\n\t\t */\n\t\tthis.fov = fov;\n\n\t\t/**\n\t\t * The zoom factor of the camera.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.zoom = 1;\n\n\t\t/**\n\t\t * The camera's near plane. The valid range is greater than `0`\n\t\t * and less than the current value of {@link PerspectiveCamera#far}.\n\t\t *\n\t\t * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a\n\t\t * valid value for a perspective camera's near plane.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.1\n\t\t */\n\t\tthis.near = near;\n\n\t\t/**\n\t\t * The camera's far plane. Must be greater than the\n\t\t * current value of {@link PerspectiveCamera#near}.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2000\n\t\t */\n\t\tthis.far = far;\n\n\t\t/**\n\t\t * Object distance used for stereoscopy and depth-of-field effects. This\n\t\t * parameter does not influence the projection matrix unless a\n\t\t * {@link StereoCamera} is being used.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 10\n\t\t */\n\t\tthis.focus = 10;\n\n\t\t/**\n\t\t * The aspect ratio, usually the canvas width / canvas height.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.aspect = aspect;\n\n\t\t/**\n\t\t * Represents the frustum window specification. This property should not be edited\n\t\t * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.view = null;\n\n\t\t/**\n\t\t * Film size used for the larger axis. Default is `35` (millimeters). This\n\t\t * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}\n\t\t * is set to a nonzero value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 35\n\t\t */\n\t\tthis.filmGauge = 35;\n\n\t\t/**\n\t\t * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.filmOffset = 0;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * @param {number} focalLength - Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Returns the focal length from the current {@link PerspectiveCamera#fov} and\n\t * {@link PerspectiveCamera#filmGauge}.\n\t *\n\t * @return {number} The computed focal length.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\t/**\n\t * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.\n\t *\n\t * @return {number} The effective FOV.\n\t */\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\t/**\n\t * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or\n\t * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.\n\t *\n\t * @return {number} The film width.\n\t */\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or\n\t * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.\n\t *\n\t * @return {number} The film width.\n\t */\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t *\n\t * @param {number} distance - The viewing distance.\n\t * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.\n\t * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3.x, _v3.y ).multiplyScalar( - distance / _v3.z );\n\n\t\t_v3.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3.x, _v3.y ).multiplyScalar( - distance / _v3.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t *\n\t * @param {number} distance - The viewing distance.\n\t * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.\n\t * @returns {Vector2} The view size.\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *```\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *```\n\t * then for each monitor you would call it like this:\n\t *```js\n\t * const w = 1920;\n\t * const h = 1080;\n\t * const fullWidth = w * 3;\n\t * const fullHeight = h * 2;\n\t *\n\t * // --A--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t * // --B--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t * // --C--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t * // --D--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t * // --E--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t * // --F--\n\t * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t * ```\n\t *\n\t * Note there is no reason monitors have to be the same size or in a grid.\n\t *\n\t * @param {number} fullWidth - The full width of multiview setup.\n\t * @param {number} fullHeight - The full height of multiview setup.\n\t * @param {number} x - The horizontal offset of the subcamera.\n\t * @param {number} y - The vertical offset of the subcamera.\n\t * @param {number} width - The width of subcamera.\n\t * @param {number} height - The height of subcamera.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Removes the view offset from the projection matrix.\n\t */\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Updates the camera's projection matrix. Must be called after any change of\n\t * camera properties.\n\t */\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport { PerspectiveCamera };\n"],"mappings":"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","ignoreList":[]}