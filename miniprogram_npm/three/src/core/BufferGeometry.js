import{Vector3}from"../math/Vector3.js";import{Vector2}from"../math/Vector2.js";import{Box3}from"../math/Box3.js";import{EventDispatcher}from"./EventDispatcher.js";import{BufferAttribute,Float32BufferAttribute,Uint16BufferAttribute,Uint32BufferAttribute}from"./BufferAttribute.js";import{Sphere}from"../math/Sphere.js";import{Object3D}from"./Object3D.js";import{Matrix4}from"../math/Matrix4.js";import{Matrix3}from"../math/Matrix3.js";import{generateUUID}from"../math/MathUtils.js";import{arrayNeedsUint32}from"../utils.js";let _id=0;const _m1=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box=new Box3,_boxMorphTargets=new Box3,_vector=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(arrayNeedsUint32(t)?Uint32BufferAttribute:Uint16BufferAttribute)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,r=0){this.groups.push({start:t,count:e,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const r=this.attributes.normal;if(void 0!==r){const e=(new Matrix3).getNormalMatrix(t);r.applyNormalMatrix(e),r.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(t),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return _m1.makeRotationFromQuaternion(t),this.applyMatrix4(_m1),this}rotateX(t){return _m1.makeRotationX(t),this.applyMatrix4(_m1),this}rotateY(t){return _m1.makeRotationY(t),this.applyMatrix4(_m1),this}rotateZ(t){return _m1.makeRotationZ(t),this.applyMatrix4(_m1),this}translate(t,e,r){return _m1.makeTranslation(t,e,r),this.applyMatrix4(_m1),this}scale(t,e,r){return _m1.makeScale(t,e,r),this.applyMatrix4(_m1),this}lookAt(t){return _obj.lookAt(t),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let r=0,o=t.length;r<o;r++){const o=t[r];e.push(o.x,o.y,o.z||0)}this.setAttribute("position",new Float32BufferAttribute(e,3))}else{const r=Math.min(t.length,e.count);for(let o=0;o<r;o++){const r=t[o];e.setXYZ(o,r.x,r.y,r.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){const r=e[t];_box.setFromBufferAttribute(r),this.morphTargetsRelative?(_vector.addVectors(this.boundingBox.min,_box.min),this.boundingBox.expandByPoint(_vector),_vector.addVectors(this.boundingBox.max,_box.max),this.boundingBox.expandByPoint(_vector)):(this.boundingBox.expandByPoint(_box.min),this.boundingBox.expandByPoint(_box.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new Vector3,1/0);if(t){const r=this.boundingSphere.center;if(_box.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){const r=e[t];_boxMorphTargets.setFromBufferAttribute(r),this.morphTargetsRelative?(_vector.addVectors(_box.min,_boxMorphTargets.min),_box.expandByPoint(_vector),_vector.addVectors(_box.max,_boxMorphTargets.max),_box.expandByPoint(_vector)):(_box.expandByPoint(_boxMorphTargets.min),_box.expandByPoint(_boxMorphTargets.max))}_box.getCenter(r);let o=0;for(let e=0,i=t.count;e<i;e++)_vector.fromBufferAttribute(t,e),o=Math.max(o,r.distanceToSquared(_vector));if(e)for(let i=0,n=e.length;i<n;i++){const n=e[i],s=this.morphTargetsRelative;for(let e=0,i=n.count;e<i;e++)_vector.fromBufferAttribute(n,e),s&&(_offset.fromBufferAttribute(t,e),_vector.add(_offset)),o=Math.max(o,r.distanceToSquared(_vector))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const r=e.position,o=e.normal,i=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*r.count),4));const n=this.getAttribute("tangent"),s=[],a=[];for(let t=0;t<r.count;t++)s[t]=new Vector3,a[t]=new Vector3;const u=new Vector3,h=new Vector3,c=new Vector3,f=new Vector2,d=new Vector2,l=new Vector2,m=new Vector3,p=new Vector3;function b(t,e,o){u.fromBufferAttribute(r,t),h.fromBufferAttribute(r,e),c.fromBufferAttribute(r,o),f.fromBufferAttribute(i,t),d.fromBufferAttribute(i,e),l.fromBufferAttribute(i,o),h.sub(u),c.sub(u),d.sub(f),l.sub(f);const n=1/(d.x*l.y-l.x*d.y);isFinite(n)&&(m.copy(h).multiplyScalar(l.y).addScaledVector(c,-d.y).multiplyScalar(n),p.copy(c).multiplyScalar(d.x).addScaledVector(h,-l.x).multiplyScalar(n),s[t].add(m),s[e].add(m),s[o].add(m),a[t].add(p),a[e].add(p),a[o].add(p))}let g=this.groups;0===g.length&&(g=[{start:0,count:t.count}]);for(let e=0,r=g.length;e<r;++e){const r=g[e],o=r.start;for(let e=o,i=o+r.count;e<i;e+=3)b(t.getX(e+0),t.getX(e+1),t.getX(e+2))}const x=new Vector3,B=new Vector3,y=new Vector3,A=new Vector3;function _(t){y.fromBufferAttribute(o,t),A.copy(y);const e=s[t];x.copy(e),x.sub(y.multiplyScalar(y.dot(e))).normalize(),B.crossVectors(A,e);const r=B.dot(a[t])<0?-1:1;n.setXYZW(t,x.x,x.y,x.z,r)}for(let e=0,r=g.length;e<r;++e){const r=g[e],o=r.start;for(let e=o,i=o+r.count;e<i;e+=3)_(t.getX(e+0)),_(t.getX(e+1)),_(t.getX(e+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let r=this.getAttribute("normal");if(void 0===r)r=new BufferAttribute(new Float32Array(3*e.count),3),this.setAttribute("normal",r);else for(let t=0,e=r.count;t<e;t++)r.setXYZ(t,0,0,0);const o=new Vector3,i=new Vector3,n=new Vector3,s=new Vector3,a=new Vector3,u=new Vector3,h=new Vector3,c=new Vector3;if(t)for(let f=0,d=t.count;f<d;f+=3){const d=t.getX(f+0),l=t.getX(f+1),m=t.getX(f+2);o.fromBufferAttribute(e,d),i.fromBufferAttribute(e,l),n.fromBufferAttribute(e,m),h.subVectors(n,i),c.subVectors(o,i),h.cross(c),s.fromBufferAttribute(r,d),a.fromBufferAttribute(r,l),u.fromBufferAttribute(r,m),s.add(h),a.add(h),u.add(h),r.setXYZ(d,s.x,s.y,s.z),r.setXYZ(l,a.x,a.y,a.z),r.setXYZ(m,u.x,u.y,u.z)}else for(let t=0,s=e.count;t<s;t+=3)o.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),n.fromBufferAttribute(e,t+2),h.subVectors(n,i),c.subVectors(o,i),h.cross(c),r.setXYZ(t+0,h.x,h.y,h.z),r.setXYZ(t+1,h.x,h.y,h.z),r.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,r=t.count;e<r;e++)_vector.fromBufferAttribute(t,e),_vector.normalize(),t.setXYZ(e,_vector.x,_vector.y,_vector.z)}toNonIndexed(){function t(t,e){const r=t.array,o=t.itemSize,i=t.normalized,n=new r.constructor(e.length*o);let s=0,a=0;for(let i=0,u=e.length;i<u;i++){s=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*o;for(let t=0;t<o;t++)n[a++]=r[s++]}return new BufferAttribute(n,o,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new BufferGeometry,r=this.index.array,o=this.attributes;for(const i in o){const n=t(o[i],r);e.setAttribute(i,n)}const i=this.morphAttributes;for(const o in i){const n=[],s=i[o];for(let e=0,o=s.length;e<o;e++){const o=t(s[e],r);n.push(o)}e.morphAttributes[o]=n}e.morphTargetsRelative=this.morphTargetsRelative;const n=this.groups;for(let t=0,r=n.length;t<r;t++){const r=n[t];e.addGroup(r.start,r.count,r.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const r in e)void 0!==e[r]&&(t[r]=e[r]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const r=this.attributes;for(const e in r){const o=r[e];t.data.attributes[e]=o.toJSON(t.data)}const o={};let i=!1;for(const e in this.morphAttributes){const r=this.morphAttributes[e],n=[];for(let e=0,o=r.length;e<o;e++){const o=r[e];n.push(o.toJSON(t.data))}n.length>0&&(o[e]=n,i=!0)}i&&(t.data.morphAttributes=o,t.data.morphTargetsRelative=this.morphTargetsRelative);const n=this.groups;n.length>0&&(t.data.groups=JSON.parse(JSON.stringify(n)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere=s.toJSON()),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const r=t.index;null!==r&&this.setIndex(r.clone());const o=t.attributes;for(const t in o){const r=o[t];this.setAttribute(t,r.clone(e))}const i=t.morphAttributes;for(const t in i){const r=[],o=i[t];for(let t=0,i=o.length;t<i;t++)r.push(o[t].clone(e));this.morphAttributes[t]=r}this.morphTargetsRelative=t.morphTargetsRelative;const n=t.groups;for(let t=0,e=n.length;t<e;t++){const e=n[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}export{BufferGeometry};
//# sourceMappingURL=BufferGeometry.js.map