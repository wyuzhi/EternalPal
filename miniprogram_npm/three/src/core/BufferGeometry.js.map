{"version":3,"file":"node_modules/three/src/core/BufferGeometry.js","names":["Vector3","Vector2","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","Object3D","Matrix4","Matrix3","generateUUID","arrayNeedsUint32","_id","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","constructor","super","this","isBufferGeometry","Object","defineProperty","value","uuid","name","type","index","indirect","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","getIndex","setIndex","Array","isArray","setIndirect","getIndirect","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","applyQuaternion","q","makeRotationFromQuaternion","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","positionAttribute","i","l","length","point","Math","min","setXYZ","console","warn","morphAttributesPosition","isGLBufferAttribute","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","distanceToSquared","j","jl","add","radius","sqrt","computeTangents","uv","normalAttribute","uvAttribute","Float32Array","tangentAttribute","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","getX","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","w","setXYZW","computeVertexNormals","pA","pB","pC","nA","nB","nC","cb","ab","subVectors","cross","normalizeNormals","normals","toNonIndexed","convertBufferAttribute","indices","array","itemSize","normalized","array2","index2","isInterleavedBufferAttribute","data","stride","offset","geometry2","newAttribute","morphArray","toJSON","metadata","version","generator","keys","parameters","key","prototype","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","clone","source","dispose","dispatchEvent"],"sources":["node_modules/three/src/core/BufferGeometry.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { generateUUID } from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector = /*@__PURE__*/ new Vector3();\n\n/**\n * A representation of mesh, line, or point geometry. Includes vertex\n * positions, face indices, normals, colors, UVs, and custom attributes\n * within buffers, reducing the cost of passing all this data to the GPU.\n *\n * ```js\n * const geometry = new THREE.BufferGeometry();\n * // create a simple square shape. We duplicate the top left and bottom right\n * // vertices because each vertex needs to appear once per triangle.\n * const vertices = new Float32Array( [\n * \t-1.0, -1.0,  1.0, // v0\n * \t 1.0, -1.0,  1.0, // v1\n * \t 1.0,  1.0,  1.0, // v2\n *\n * \t 1.0,  1.0,  1.0, // v3\n * \t-1.0,  1.0,  1.0, // v4\n * \t-1.0, -1.0,  1.0  // v5\n * ] );\n * // itemSize = 3 because there are 3 values (components) per vertex\n * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n * const mesh = new THREE.Mesh( geometry, material );\n * ```\n *\n * @augments EventDispatcher\n */\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\n\t * Constructs a new geometry.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\n\t\t * The ID of the geometry.\n\t\t *\n\t\t * @name BufferGeometry#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The UUID of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\n\t\t * Allows for vertices to be re-used across multiple triangles; this is\n\t\t * called using \"indexed triangles\". Each triangle is associated with the\n\t\t * indices of three vertices. This attribute therefore stores the index of\n\t\t * each vertex for each triangular face. If this attribute is not set, the\n\t\t * renderer assumes that each three contiguous positions represent a single triangle.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.index = null;\n\n\t\t/**\n\t\t * A (storage) buffer attribute which was generated with a compute shader and\n\t\t * now defines indirect draw calls.\n\t\t *\n\t\t * Can only be used with {@link WebGPURenderer} and a WebGPU backend.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.indirect = null;\n\n\t\t/**\n\t\t * This dictionary has as id the name of the attribute to be set and as value\n\t\t * the buffer attribute to set it to. Rather than accessing this property directly,\n\t\t * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\t\t *\n\t\t * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n\t\t */\n\t\tthis.attributes = {};\n\n\t\t/**\n\t\t * This dictionary holds the morph targets of the geometry.\n\t\t *\n\t\t * Note: Once the geometry has been rendered, the morph attribute data cannot\n\t\t * be changed. You will have to call `dispose()?, and create a new geometry instance.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.morphAttributes = {};\n\n\t\t/**\n\t\t * Used to control the morph target behavior; when set to `true`, the morph\n\t\t * target data is treated as relative offsets, rather than as absolute\n\t\t * positions/normals.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\n\t\t * Split the geometry into groups, each of which will be rendered in a\n\t\t * separate draw call. This allows an array of materials to be used with the geometry.\n\t\t *\n\t\t * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\t\t *\n\t\t * Every vertex and index must belong to exactly one group â€” groups must not share vertices or\n\t\t * indices, and must not leave vertices or indices unused.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.groups = [];\n\n\t\t/**\n\t\t * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\t\t *\n\t\t * @type {Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\t\t *\n\t\t * @type {Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Determines the part of the geometry to render. This should not be set directly,\n\t\t * instead use `setDrawRange()`.\n\t\t *\n\t\t * @type {{start:number,count:number}}\n\t\t */\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the geometry.\n\t\t * It should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\n\t * Returns the index of this geometry.\n\t *\n\t * @return {?BufferAttribute} The index. Returns `null` if no index is defined.\n\t */\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\n\t * Sets the given index to this geometry.\n\t *\n\t * @param {Array<number>|BufferAttribute} index - The index to set.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given indirect attribute to this geometry.\n\t *\n\t * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the indirect attribute of this geometry.\n\t *\n\t * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n\t */\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\n\t * Returns the buffer attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\n\t * Returns `undefined` if not attribute has been found.\n\t */\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\n\t * Sets the given attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes the attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name to delete.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this geometry has an attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {boolean} Whether this geometry has an attribute for the given name or not.\n\t */\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\n\t * Adds a group to this geometry.\n\t *\n\t * @param {number} start - The first element in this draw call. That is the first\n\t * vertex for non-indexed geometry, otherwise the first triangle index.\n\t * @param {number} count - Specifies how many vertices (or indices) are part of this group.\n\t * @param {number} [materialIndex=0] - The material array index to use.\n\t */\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Clears all groups.\n\t */\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\n\t * Sets the draw range for this geometry.\n\t *\n\t * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n\t * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\n\t * For indexed BufferGeometry, `count` is the number of indices to render.\n\t */\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 transformation matrix to the geometry.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the rotation represented by the Quaternion to the geometry.\n\t *\n\t * @param {Quaternion} q - The Quaternion to apply.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the X axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the Y axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the Z axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates the geometry. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#position} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} x - The x offset.\n\t * @param {number} y - The y offset.\n\t * @param {number} z - The z offset.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Scales the geometry. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#scale} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} x - The x scale.\n\t * @param {number} y - The y scale.\n\t * @param {number} z - The z scale.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry to face a point in 3D space. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#lookAt} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {Vector3} vector - The target point.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Center the geometry based on its bounding box.\n\t *\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines a geometry by creating a `position` attribute based on the given array of points. The array\n\t * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\n\t * set to `0`.\n\t *\n\t * If the method is used with an existing `position` attribute, the vertex data are overwritten with the\n\t * data from the array. The length of the array must match the vertex count.\n\t *\n\t * @param {Array<Vector2>|Array<Vector3>} points - The points.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the bounding box of the geometry, and updates the `boundingBox` member.\n\t * The bounding box is not computed by the engine; it must be computed by your app.\n\t * You may need to recompute the bounding box if the geometry vertices are modified.\n\t */\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.\n\t * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\n\t * You may need to recompute the bounding sphere if the geometry vertices are modified.\n\t */\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculates and adds a tangent attribute to this geometry.\n\t *\n\t * The computation is only supported for indexed geometries and if position, normal, and uv attributes\n\t * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n\t * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n\t */\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes vertex normals for the given vertex data. For indexed geometries, the method sets\n\t * each vertex normal to be the average of the face normals of the faces that share that vertex.\n\t * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal\n\t * to be the same as the face normal.\n\t */\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Ensures every normal vector in a geometry will have a magnitude of `1`. This will\n\t * correct lighting on the geometry surfaces.\n\t */\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Return a new non-index version of this indexed geometry. If the geometry\n\t * is already non-indexed, the method is a NOOP.\n\t *\n\t * @return {BufferGeometry} The non-indexed version of this indexed geometry.\n\t */\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\n\t * Serializes the geometry into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized geometry.\n\t */\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns a new geometry with copied values from this instance.\n\t *\n\t * @return {BufferGeometry} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given geometry to this instance.\n\t *\n\t * @param {BufferGeometry} source - The geometry to copy.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t *\n\t * @fires BufferGeometry#dispose\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nexport { BufferGeometry };\n"],"mappings":"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","ignoreList":[]}