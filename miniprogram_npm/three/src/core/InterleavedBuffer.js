import{generateUUID}from"../math/MathUtils.js";import{StaticDrawUsage}from"../constants.js";class InterleavedBuffer{constructor(r,t){this.isInterleavedBuffer=!0,this.array=r,this.stride=t,this.count=void 0!==r?r.length/t:0,this.usage=StaticDrawUsage,this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(r){!0===r&&this.version++}setUsage(r){return this.usage=r,this}addUpdateRange(r,t){this.updateRanges.push({start:r,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(r){return this.array=new r.array.constructor(r.array),this.count=r.count,this.stride=r.stride,this.usage=r.usage,this}copyAt(r,t,a){r*=this.stride,a*=t.stride;for(let e=0,s=this.stride;e<s;e++)this.array[r+e]=t.array[a+e];return this}set(r,t=0){return this.array.set(r,t),this}clone(r){void 0===r.arrayBuffers&&(r.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===r.arrayBuffers[this.array.buffer._uuid]&&(r.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]),a=new this.constructor(t,this.stride);return a.setUsage(this.usage),a}onUpload(r){return this.onUploadCallback=r,this}toJSON(r){return void 0===r.arrayBuffers&&(r.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===r.arrayBuffers[this.array.buffer._uuid]&&(r.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}export{InterleavedBuffer};
//# sourceMappingURL=InterleavedBuffer.js.map