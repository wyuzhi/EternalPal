{"version":3,"file":"node_modules/three/src/core/Raycaster.js","names":["Matrix4","Ray","Layers","_matrix","Raycaster","constructor","origin","direction","near","far","Infinity","this","ray","camera","layers","params","Mesh","Line","threshold","LOD","Points","Sprite","set","setFromCamera","coords","isPerspectiveCamera","setFromMatrixPosition","matrixWorld","x","y","unproject","sub","normalize","isOrthographicCamera","transformDirection","console","error","type","setFromXRController","controller","identity","extractRotation","applyMatrix4","intersectObject","object","recursive","intersects","intersect","sort","ascSort","intersectObjects","objects","i","l","length","a","b","distance","raycaster","propagate","test","raycast","children"],"sources":["node_modules/three/src/core/Raycaster.js"],"sourcesContent":["import { Matrix4 } from '../math/Matrix4.js';\nimport { Ray } from '../math/Ray.js';\nimport { Layers } from './Layers.js';\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\n/**\n * This class is designed to assist with raycasting. Raycasting is used for\n * mouse picking (working out what objects in the 3d space the mouse is over)\n * amongst other things.\n */\nclass Raycaster {\n\n\t/**\n\t * Constructs a new raycaster.\n\t *\n\t * @param {Vector3} origin - The origin vector where the ray casts from.\n\t * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.\n\t * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.\n\t * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.\n\t */\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\t/**\n\t\t * The ray used for raycasting.\n\t\t *\n\t\t * @type {Ray}\n\t\t */\n\t\tthis.ray = new Ray( origin, direction );\n\n\t\t/**\n\t\t * All results returned are further away than near. Near can't be negative.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.near = near;\n\n\t\t/**\n\t\t * All results returned are further away than near. Near can't be negative.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.far = far;\n\n\t\t/**\n\t\t * The camera to use when raycasting against view-dependent objects such as\n\t\t * billboarded objects like sprites. This field can be set manually or\n\t\t * is set when calling `setFromCamera()`.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * Allows to selectively ignore 3D objects when performing intersection tests.\n\t\t * The following code example ensures that only 3D objects on layer `1` will be\n\t\t * honored by raycaster.\n\t\t * ```js\n\t\t * raycaster.layers.set( 1 );\n\t\t * object.layers.enable( 1 );\n\t\t * ```\n\t\t *\n\t\t * @type {Layers}\n\t\t */\n\t\tthis.layers = new Layers();\n\n\n\t\t/**\n\t\t * A parameter object that configures the raycasting. It has the structure:\n\t\t *\n\t\t * ```\n\t\t * {\n\t\t * \tMesh: {},\n\t\t * \tLine: { threshold: 1 },\n\t\t * \tLOD: {},\n\t\t * \tPoints: { threshold: 1 },\n\t\t * \tSprite: {}\n\t\t * }\n\t\t * ```\n\t\t * Where `threshold` is the precision of the raycaster when intersecting objects, in world units.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\t/**\n\t * Updates the ray with a new origin and direction by copying the values from the arguments.\n\t *\n\t * @param {Vector3} origin - The origin vector where the ray casts from.\n\t * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.\n\t */\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\t/**\n\t * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.\n\t *\n\t * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).\n\t * X and Y components should be between `-1` and `1`.\n\t * @param {Camera} camera - The camera from which the ray should originate.\n\t */\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uses the given WebXR controller to compute a new origin and direction for the internal ray.\n\t *\n\t * @param {WebXRController} controller - The controller to copy the position and direction from.\n\t * @return {Raycaster} A reference to this raycaster.\n\t */\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The intersection point of a raycaster intersection test.\n\t * @typedef {Object} Raycaster~Intersection\n\t * @property {number} distance - The distance from the ray's origin to the intersection point.\n\t * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the\n\t * intersection to the nearest point on the ray. For other objects it will be `undefined`.\n\t * @property {Vector3} point - The intersection point, in world coordinates.\n\t * @property {Object} face - The face that has been intersected.\n\t * @property {number} faceIndex - The face index.\n\t * @property {Object3D} object - The 3D object that has been intersected.\n\t * @property {Vector2} uv - U,V coordinates at point of intersection.\n\t * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.\n\t * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.\n\t * @property {number} instanceId - The index number of the instance where the ray\n\t * intersects the {@link InstancedMesh}.\n\t */\n\n\t/**\n\t * Checks all intersection between the ray and the object with or without the\n\t * descendants. Intersections are returned sorted by distance, closest first.\n\t *\n\t * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when\n\t * evaluating whether the ray intersects the object or not. This allows meshes to respond\n\t * differently to ray casting than lines or points.\n\t *\n\t * Note that for meshes, faces must be pointed towards the origin of the ray in order\n\t * to be detected; intersections of the ray passing through the back of a face will not\n\t * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}\n\t * to `THREE.DoubleSide`.\n\t *\n\t * @param {Object3D} object - The 3D object to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\t/**\n\t * Checks all intersection between the ray and the objects with or without\n\t * the descendants. Intersections are returned sorted by distance, closest first.\n\t *\n\t * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tlet propagate = true;\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tconst result = object.raycast( raycaster, intersects );\n\n\t\tif ( result === false ) propagate = false;\n\n\t}\n\n\tif ( propagate === true && recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nexport { Raycaster };\n"],"mappings":"OAASA,YAAe,4BACfC,QAAW,wBACXC,WAAc,cAEvB,MAAMC,QAAwB,IAAIH,QAOlC,MAAMI,UAUL,WAAAC,CAAaC,EAAQC,EAAWC,EAAO,EAAGC,EAAMC,KAO/CC,KAAKC,IAAM,IAAIX,IAAKK,EAAQC,GAQ5BI,KAAKH,KAAOA,EAQZG,KAAKF,IAAMA,EAUXE,KAAKE,OAAS,KAadF,KAAKG,OAAS,IAAIZ,OAmBlBS,KAAKI,OAAS,CACbC,KAAM,CAAC,EACPC,KAAM,CAAEC,UAAW,GACnBC,IAAK,CAAC,EACNC,OAAQ,CAAEF,UAAW,GACrBG,OAAQ,CAAC,EAGX,CAQA,GAAAC,CAAKhB,EAAQC,GAIZI,KAAKC,IAAIU,IAAKhB,EAAQC,EAEvB,CASA,aAAAgB,CAAeC,EAAQX,GAEjBA,EAAOY,qBAEXd,KAAKC,IAAIN,OAAOoB,sBAAuBb,EAAOc,aAC9ChB,KAAKC,IAAIL,UAAUe,IAAKE,EAAOI,EAAGJ,EAAOK,EAAG,IAAMC,UAAWjB,GAASkB,IAAKpB,KAAKC,IAAIN,QAAS0B,YAC7FrB,KAAKE,OAASA,GAEHA,EAAOoB,sBAElBtB,KAAKC,IAAIN,OAAOgB,IAAKE,EAAOI,EAAGJ,EAAOK,GAAKhB,EAAOL,KAAOK,EAAOJ,MAAUI,EAAOL,KAAOK,EAAOJ,MAAQqB,UAAWjB,GAClHF,KAAKC,IAAIL,UAAUe,IAAK,EAAG,GAAK,GAAIY,mBAAoBrB,EAAOc,aAC/DhB,KAAKE,OAASA,GAIdsB,QAAQC,MAAO,6CAA+CvB,EAAOwB,KAIvE,CAQA,mBAAAC,CAAqBC,GAOpB,OALApC,QAAQqC,WAAWC,gBAAiBF,EAAWZ,aAE/ChB,KAAKC,IAAIN,OAAOoB,sBAAuBa,EAAWZ,aAClDhB,KAAKC,IAAIL,UAAUe,IAAK,EAAG,GAAK,GAAIoB,aAAcvC,SAE3CQ,IAER,CAsCA,eAAAgC,CAAiBC,EAAQC,GAAY,EAAMC,EAAa,IAMvD,OAJAC,UAAWH,EAAQjC,KAAMmC,EAAYD,GAErCC,EAAWE,KAAMC,SAEVH,CAER,CAYA,gBAAAI,CAAkBC,EAASN,GAAY,EAAMC,EAAa,IAEzD,IAAM,IAAIM,EAAI,EAAGC,EAAIF,EAAQG,OAAQF,EAAIC,EAAGD,IAE3CL,UAAWI,EAASC,GAAKzC,KAAMmC,EAAYD,GAM5C,OAFAC,EAAWE,KAAMC,SAEVH,CAER,EAID,SAASG,QAASM,EAAGC,GAEpB,OAAOD,EAAEE,SAAWD,EAAEC,QAEvB,CAEA,SAASV,UAAWH,EAAQc,EAAWZ,EAAYD,GAElD,IAAIc,GAAY,EAEhB,GAAKf,EAAO9B,OAAO8C,KAAMF,EAAU5C,QAAW,EAI7B,IAFD8B,EAAOiB,QAASH,EAAWZ,KAElBa,GAAY,EAErC,CAEA,IAAmB,IAAdA,IAAoC,IAAdd,EAAqB,CAE/C,MAAMiB,EAAWlB,EAAOkB,SAExB,IAAM,IAAIV,EAAI,EAAGC,EAAIS,EAASR,OAAQF,EAAIC,EAAGD,IAE5CL,UAAWe,EAAUV,GAAKM,EAAWZ,GAAY,EAInD,CAED,QAES1C","ignoreList":[]}