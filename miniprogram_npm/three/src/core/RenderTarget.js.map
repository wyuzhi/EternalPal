{"version":3,"file":"node_modules/three/src/core/RenderTarget.js","names":["EventDispatcher","Texture","LinearFilter","Vector4","Source","RenderTarget","constructor","width","height","options","super","Object","assign","generateMipmaps","internalFormat","minFilter","depthBuffer","stencilBuffer","resolveDepthBuffer","resolveStencilBuffer","depthTexture","samples","count","depth","multiview","this","isRenderTarget","scissor","scissorTest","viewport","image","texture","textures","i","clone","isRenderTargetTexture","renderTarget","_setTextureOptions","_depthTexture","values","flipY","undefined","mapping","wrapS","wrapT","wrapR","magFilter","format","type","anisotropy","colorSpace","length","setValues","value","current","setSize","il","isArrayTexture","dispose","set","copy","source","dispatchEvent"],"sources":["node_modules/three/src/core/RenderTarget.js"],"sourcesContent":["import { EventDispatcher } from './EventDispatcher.js';\nimport { Texture } from '../textures/Texture.js';\nimport { LinearFilter } from '../constants.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { Source } from '../textures/Source.js';\n\n/**\n * A render target is a buffer where the video card draws pixels for a scene\n * that is being rendered in the background. It is used in different effects,\n * such as applying postprocessing to a rendered image before displaying it\n * on the screen.\n *\n * @augments EventDispatcher\n */\nclass RenderTarget extends EventDispatcher {\n\n\t/**\n\t * Render target options.\n\t *\n\t * @typedef {Object} RenderTarget~Options\n\t * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.\n\t * @property {number} [magFilter=LinearFilter] - The mag filter.\n\t * @property {number} [minFilter=LinearFilter] - The min filter.\n\t * @property {number} [format=RGBAFormat] - The texture format.\n\t * @property {number} [type=UnsignedByteType] - The texture type.\n\t * @property {?string} [internalFormat=null] - The texture's internal format.\n\t * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.\n\t * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.\n\t * @property {number} [anisotropy=1] - The texture's anisotropy value.\n\t * @property {string} [colorSpace=NoColorSpace] - The texture's color space.\n\t * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.\n\t * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.\n\t * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.\n\t * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.\n\t * @property {?Texture} [depthTexture=null] - Reference to a depth texture.\n\t * @property {number} [samples=0] - The MSAA samples count.\n\t * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.\n\t * @property {number} [depth=1] - The texture depth.\n\t * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.\n\t */\n\n\t/**\n\t * Constructs a new render target.\n\t *\n\t * @param {number} [width=1] - The width of the render target.\n\t * @param {number} [height=1] - The height of the render target.\n\t * @param {RenderTarget~Options} [options] - The configuration object.\n\t */\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1,\n\t\t\tdepth: 1,\n\t\t\tmultiview: false\n\t\t}, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderTarget = true;\n\n\t\t/**\n\t\t * The width of the render target.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.width = width;\n\n\t\t/**\n\t\t * The height of the render target.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.height = height;\n\n\t\t/**\n\t\t * The depth of the render target.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.depth = options.depth;\n\n\t\t/**\n\t\t * A rectangular area inside the render target's viewport. Fragments that are\n\t\t * outside the area will be discarded.\n\t\t *\n\t\t * @type {Vector4}\n\t\t * @default (0,0,width,height)\n\t\t */\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\n\t\t/**\n\t\t * Indicates whether the scissor test should be enabled when rendering into\n\t\t * this render target or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.scissorTest = false;\n\n\t\t/**\n\t\t * A rectangular area representing the render target's viewport.\n\t\t *\n\t\t * @type {Vector4}\n\t\t * @default (0,0,width,height)\n\t\t */\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: options.depth };\n\n\t\tconst texture = new Texture( image );\n\n\t\t/**\n\t\t * An array of textures. Each color attachment is represented as a separate texture.\n\t\t * Has at least a single entry for the default color attachment.\n\t\t *\n\t\t * @type {Array<Texture>}\n\t\t */\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\t\t\tthis.textures[ i ].renderTarget = this;\n\n\t\t}\n\n\t\tthis._setTextureOptions( options );\n\n\t\t/**\n\t\t * Whether to allocate a depth buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depthBuffer = options.depthBuffer;\n\n\t\t/**\n\t\t * Whether to allocate a stencil buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\t/**\n\t\t * Whether to resolve the depth buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\n\t\t/**\n\t\t * Whether to resolve the stencil buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis._depthTexture = null;\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\t/**\n\t\t * The number of MSAA samples.\n\t\t *\n\t\t * A value of `0` disables MSAA.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.samples = options.samples;\n\n\t\t/**\n\t\t * Whether to this target is used in multiview rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.multiview = options.multiview;\n\n\t}\n\n\t_setTextureOptions( options = {} ) {\n\n\t\tconst values = {\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\tflipY: false,\n\t\t\tinternalFormat: null\n\t\t};\n\n\t\tif ( options.mapping !== undefined ) values.mapping = options.mapping;\n\t\tif ( options.wrapS !== undefined ) values.wrapS = options.wrapS;\n\t\tif ( options.wrapT !== undefined ) values.wrapT = options.wrapT;\n\t\tif ( options.wrapR !== undefined ) values.wrapR = options.wrapR;\n\t\tif ( options.magFilter !== undefined ) values.magFilter = options.magFilter;\n\t\tif ( options.minFilter !== undefined ) values.minFilter = options.minFilter;\n\t\tif ( options.format !== undefined ) values.format = options.format;\n\t\tif ( options.type !== undefined ) values.type = options.type;\n\t\tif ( options.anisotropy !== undefined ) values.anisotropy = options.anisotropy;\n\t\tif ( options.colorSpace !== undefined ) values.colorSpace = options.colorSpace;\n\t\tif ( options.flipY !== undefined ) values.flipY = options.flipY;\n\t\tif ( options.generateMipmaps !== undefined ) values.generateMipmaps = options.generateMipmaps;\n\t\tif ( options.internalFormat !== undefined ) values.internalFormat = options.internalFormat;\n\n\t\tfor ( let i = 0; i < this.textures.length; i ++ ) {\n\n\t\t\tconst texture = this.textures[ i ];\n\t\t\ttexture.setValues( values );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The texture representing the default color attachment.\n\t *\n\t * @type {Texture}\n\t */\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tset depthTexture( current ) {\n\n\t\tif ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;\n\t\tif ( current !== null ) current.renderTarget = this;\n\n\t\tthis._depthTexture = current;\n\n\t}\n\n\t/**\n\t * Instead of saving the depth in a renderbuffer, a texture\n\t * can be used instead which is useful for further processing\n\t * e.g. in context of post-processing.\n\t *\n\t * @type {?DepthTexture}\n\t * @default null\n\t */\n\tget depthTexture() {\n\n\t\treturn this._depthTexture;\n\n\t}\n\n\t/**\n\t * Sets the size of this render target.\n\t *\n\t * @param {number} width - The width.\n\t * @param {number} height - The height.\n\t * @param {number} [depth=1] - The depth.\n\t */\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\t\t\t\tthis.textures[ i ].isArrayTexture = this.textures[ i ].image.depth > 1;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\t/**\n\t * Returns a new render target with copied values from this instance.\n\t *\n\t * @return {RenderTarget} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the settings of the given render target. This is a structural copy so\n\t * no resources are shared between render targets after the copy. That includes\n\t * all MRT textures and the depth texture.\n\t *\n\t * @param {RenderTarget} source - The render target to copy.\n\t * @return {RenderTarget} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\t\t\tthis.textures[ i ].renderTarget = this;\n\n\t\t\t// ensure image object is not shared, see #20328\n\n\t\t\tconst image = Object.assign( {}, source.textures[ i ].image );\n\t\t\tthis.textures[ i ].source = new Source( image );\n\n\t\t}\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t *\n\t * @fires RenderTarget#dispose\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nexport { RenderTarget };\n"],"mappings":"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","ignoreList":[]}