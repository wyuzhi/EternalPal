{"version":3,"file":"node_modules/three/src/extras/PMREMGenerator.js","names":["CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","LinearFilter","NoToneMapping","NoBlending","RGBAFormat","HalfFloatType","BackSide","LinearSRGBColorSpace","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","ShaderMaterial","Vector3","Color","WebGLRenderTarget","MeshBasicMaterial","BoxGeometry","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_clearColor","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","_oldXrEnabled","PHI","Math","sqrt","INV_PHI","_axisDirections","_origin","PMREMGenerator","constructor","renderer","this","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_blurMaterial","_cubemapMaterial","_equirectMaterial","_compileMaterial","fromScene","scene","sigma","near","far","options","size","position","getRenderTarget","getActiveCubeFace","getActiveMipmapLevel","xr","enabled","_setSize","cubeUVRenderTarget","_allocateTargets","depthBuffer","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapMaterial","compileEquirectangularShader","_getEquirectMaterial","dispose","_dispose","cubeSize","floor","log2","pow","i","length","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","texture","mapping","image","_textureToCubeUV","max","params","magFilter","minFilter","generateMipmaps","type","format","colorSpace","_createRenderTarget","sizeLods","lodPlanes","sigmas","_createPlanes","_getBlurShader","material","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","toneMapping","getClearColor","state","buffers","depth","getReversed","clearDepth","backgroundMaterial","name","side","depthWrite","depthTest","backgroundBox","useSolidColor","background","isColor","color","copy","col","up","set","x","y","z","lookAt","render","geometry","isCubeTexture","uniforms","flipEnvMap","value","isRenderTargetTexture","mesh","n","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","warn","weights","sum","weight","exp","push","outputSize","lodMax","lod","totalLods","sizeLod","texelSize","min","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","Float32Array","uv","faceIndex","face","coordinates","fill","planes","setAttribute","target","viewport","scissor","defines","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","envMap","latitudinal","dTheta","mipInt","vertexShader","_getCommonVertexShader","fragmentShader","blending"],"sources":["node_modules/three/src/extras/PMREMGenerator.js"],"sourcesContent":["import {\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tCubeUVReflectionMapping,\n\tLinearFilter,\n\tNoToneMapping,\n\tNoBlending,\n\tRGBAFormat,\n\tHalfFloatType,\n\tBackSide,\n\tLinearSRGBColorSpace\n} from '../constants.js';\n\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\nlet _oldXrEnabled = false;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];\n\nconst _origin = /*@__PURE__*/ new Vector3();\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting:\n * {@link https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view}\n*/\nclass PMREMGenerator {\n\n\t/**\n\t * Constructs a new PMREM generator.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety.\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {number} [sigma=0] - The blur radius in radians.\n\t * @param {number} [near=0.1] - The near plane distance.\n\t * @param {number} [far=100] - The far plane distance.\n\t * @param {Object} [options={}] - The configuration options.\n\t * @param {number} [options.size=256] - The texture size of the PMREM.\n\t * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.\n\t * @return {WebGLRenderTarget} The resulting PMREM.\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {\n\n\t\tconst {\n\t\t\tsize = 256,\n\t\t\tposition = _origin,\n\t\t} = options;\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tthis._setSize( size );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {WebGLRenderTarget} The resulting PMREM.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {WebGLRenderTarget} The resulting PMREM.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\tthis._renderer.xr.enabled = _oldXrEnabled;\n\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\t// https://github.com/mrdoob/three.js/issues/31413#issuecomment-3095966812\n\t\tconst reversedDepthBuffer = renderer.state.buffers.depth.getReversed();\n\n\t\tif ( reversedDepthBuffer ) {\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\t\trenderer.clearDepth();\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t}\n\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );\n\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * @private\n\t * @param {WebGLRenderTarget} cubeUVRenderTarget\n\t * @param {number} lodIn\n\t * @param {number} lodOut\n\t * @param {number} sigma\n\t * @param {Vector3} [poleAxis]\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"],"mappings":"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","ignoreList":[]}