import{clamp}from"../../math/MathUtils.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Matrix4}from"../../math/Matrix4.js";class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)}getPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e}getSpacedPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,n=this.getPoint(0),o=0;e.push(0);for(let r=1;r<=t;r++)s=this.getPoint(r/t),o+=s.distanceTo(n),e.push(o),n=s;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const s=this.getLengths();let n=0;const o=s.length;let r;r=e||t*s[o-1];let i,c=0,h=o-1;for(;c<=h;)if(n=Math.floor(c+(h-c)/2),i=s[n]-r,i<0)c=n+1;else{if(!(i>0)){h=n;break}h=n-1}if(n=h,s[n]===r)return n/(o-1);const a=s[n];return(n+(r-a)/(s[n+1]-a))/(o-1)}getTangent(t,e){const s=1e-4;let n=t-s,o=t+s;n<0&&(n=0),o>1&&(o=1);const r=this.getPoint(n),i=this.getPoint(o),c=e||(r.isVector2?new Vector2:new Vector3);return c.copy(i).sub(r).normalize(),c}getTangentAt(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)}computeFrenetFrames(t,e=!1){const s=new Vector3,n=[],o=[],r=[],i=new Vector3,c=new Matrix4;for(let e=0;e<=t;e++){const s=e/t;n[e]=this.getTangentAt(s,new Vector3)}o[0]=new Vector3,r[0]=new Vector3;let h=Number.MAX_VALUE;const a=Math.abs(n[0].x),g=Math.abs(n[0].y),l=Math.abs(n[0].z);a<=h&&(h=a,s.set(1,0,0)),g<=h&&(h=g,s.set(0,1,0)),l<=h&&s.set(0,0,1),i.crossVectors(n[0],s).normalize(),o[0].crossVectors(n[0],i),r[0].crossVectors(n[0],o[0]);for(let e=1;e<=t;e++){if(o[e]=o[e-1].clone(),r[e]=r[e-1].clone(),i.crossVectors(n[e-1],n[e]),i.length()>Number.EPSILON){i.normalize();const t=Math.acos(clamp(n[e-1].dot(n[e]),-1,1));o[e].applyMatrix4(c.makeRotationAxis(i,t))}r[e].crossVectors(n[e],o[e])}if(!0===e){let e=Math.acos(clamp(o[0].dot(o[t]),-1,1));e/=t,n[0].dot(i.crossVectors(o[0],o[t]))>0&&(e=-e);for(let s=1;s<=t;s++)o[s].applyMatrix4(c.makeRotationAxis(n[s],e*s)),r[s].crossVectors(n[s],o[s])}return{tangents:n,normals:o,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}export{Curve};
//# sourceMappingURL=Curve.js.map