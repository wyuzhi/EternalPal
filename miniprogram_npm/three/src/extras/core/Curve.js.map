{"version":3,"file":"node_modules/three/src/extras/core/Curve.js","names":["clamp","Vector2","Vector3","Matrix4","Curve","constructor","this","type","arcLengthDivisions","needsUpdate","cacheArcLengths","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cache","current","last","sum","p","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","comparison","low","high","Math","floor","lengthBefore","getTangent","delta","t1","t2","pt1","pt2","tangent","copy","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","vec","mat","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","clone","EPSILON","theta","acos","dot","applyMatrix4","makeRotationAxis","source","toJSON","data","metadata","version","generator","fromJSON","json"],"sources":["node_modules/three/src/extras/core/Curve.js"],"sourcesContent":["import { clamp } from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * An abstract base class for creating an analytic curve object that contains methods\n * for interpolation.\n *\n * @abstract\n */\nclass Curve {\n\n\t/**\n\t * Constructs a new curve.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The type property is used for detecting the object type\n\t\t * in context of serialization/deserialization.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.type = 'Curve';\n\n\t\t/**\n\t\t * This value determines the amount of divisions when calculating the\n\t\t * cumulative segment lengths of a curve via {@link Curve#getLengths}. To ensure\n\t\t * precision when using methods like {@link Curve#getSpacedPoints}, it is\n\t\t * recommended to increase the value of this property if the curve is very large.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 200\n\t\t */\n\t\tthis.arcLengthDivisions = 200;\n\n\t\t/**\n\t\t * Must be set to `true` if the curve parameters have changed.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsUpdate = false;\n\n\t\t/**\n\t\t * An internal cache that holds precomputed curve length values.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<number>}\n\t\t * @default null\n\t\t */\n\t\tthis.cacheArcLengths = null;\n\n\t}\n\n\t/**\n\t * This method returns a vector in 2D or 3D space (depending on the curve definition)\n\t * for the given interpolation factor.\n\t *\n\t * @abstract\n\t * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.\n\t * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.\n\t */\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\n\t}\n\n\t/**\n\t * This method returns a vector in 2D or 3D space (depending on the curve definition)\n\t * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length\n\t * of the curve which equidistant samples.\n\t *\n\t * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.\n\t * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.\n\t */\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t/**\n\t * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing\n\t * the curve shape.\n\t *\n\t * @param {number} [divisions=5] - The number of divisions.\n\t * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.\n\t */\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\t/**\n\t * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing\n\t * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire\n\t * curve.\n\t *\n\t * @param {number} [divisions=5] - The number of divisions.\n\t * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.\n\t */\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t/**\n\t * Returns the total arc length of the curve.\n\t *\n\t * @return {number} The length of the curve.\n\t */\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t/**\n\t * Returns an array of cumulative segment lengths of the curve.\n\t *\n\t * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.\n\t * @return {Array<number>} An array holding the cumulative segment lengths.\n\t */\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\t/**\n\t * Update the cumulative segment distance cache. The method must be called\n\t * every time curve parameters are changed. If an updated curve is part of a\n\t * composed curve like {@link CurvePath}, this method must be called on the\n\t * composed curve, too.\n\t */\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t/**\n\t * Given an interpolation factor in the range `[0,1]`, this method returns an updated\n\t * interpolation factor in the same range that can be ued to sample equidistant points\n\t * from a curve.\n\t *\n\t * @param {number} u - The interpolation factor.\n\t * @param {?number} distance - An optional distance on the curve.\n\t * @return {number} The updated interpolation factor.\n\t */\n\tgetUtoTmapping( u, distance = null ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t/**\n\t * Returns a unit vector tangent for the given interpolation factor.\n\t * If the derived curve does not implement its tangent derivation,\n\t * two points a small delta apart will be used to find its gradient\n\t * which seems to give a reasonable approximation.\n\t *\n\t * @param {number} t - The interpolation factor.\n\t * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {(Vector2|Vector3)} The tangent vector.\n\t */\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\t/**\n\t * Same as {@link Curve#getTangent} but with equidistant samples.\n\t *\n\t * @param {number} u - The interpolation factor.\n\t * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {(Vector2|Vector3)} The tangent vector.\n\t * @see {@link Curve#getPointAt}\n\t */\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\t/**\n\t * Generates the Frenet Frames. Requires a curve definition in 3D space. Used\n\t * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.\n\t *\n\t * @param {number} segments - The number of segments.\n\t * @param {boolean} [closed=false] - Whether the curve is closed or not.\n\t * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.\n\t */\n\tcomputeFrenetFrames( segments, closed = false ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a new curve with copied values from this instance.\n\t *\n\t * @return {Curve} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given curve to this instance.\n\t *\n\t * @param {Curve} source - The curve to copy.\n\t * @return {Curve} A reference to this curve.\n\t */\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Serializes the curve into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized curve.\n\t * @see {@link ObjectLoader#parse}\n\t */\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Deserializes the curve from the given JSON.\n\t *\n\t * @param {Object} json - The JSON holding the serialized curve.\n\t * @return {Curve} A reference to this curve.\n\t */\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { Curve };\n"],"mappings":"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","ignoreList":[]}