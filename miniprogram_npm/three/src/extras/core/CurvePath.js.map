{"version":3,"file":"node_modules/three/src/extras/core/CurvePath.js","names":["Curve","Curves","CurvePath","constructor","super","this","type","curves","autoClose","add","curve","push","closePath","startPoint","getPoint","endPoint","length","equals","lineType","isVector2","t","optionalTarget","d","getLength","curveLengths","getCurveLengths","i","diff","segmentLength","u","getPointAt","lens","updateArcLengths","needsUpdate","cacheLengths","lengths","sums","l","getSpacedPoints","divisions","points","getPoints","last","resolution","isEllipseCurve","isLineCurve","isLineCurve3","isSplineCurve","pts","j","point","copy","source","clone","toJSON","data","fromJSON","json"],"sources":["node_modules/three/src/extras/core/CurvePath.js"],"sourcesContent":["import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**\n * A base class extending {@link Curve}. `CurvePath` is simply an\n * array of connected curves, but retains the API of a curve.\n *\n * @augments Curve\n */\nclass CurvePath extends Curve {\n\n\t/**\n\t * Constructs a new curve path.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\t/**\n\t\t * An array of curves defining the\n\t\t * path.\n\t\t *\n\t\t * @type {Array<Curve>}\n\t\t */\n\t\tthis.curves = [];\n\n\t\t/**\n\t\t * Whether the path should automatically be closed\n\t\t * by a line curve.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.autoClose = false;\n\n\t}\n\n\t/**\n\t * Adds a curve to this curve path.\n\t *\n\t * @param {Curve} curve - The curve to add.\n\t */\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\t/**\n\t * Adds a line curve to close the path.\n\t *\n\t * @return {CurvePath} A reference to this curve path.\n\t */\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This method returns a vector in 2D or 3D space (depending on the curve definitions)\n\t * for the given interpolation factor.\n\t *\n\t * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.\n\t * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.\n\t */\n\tgetPoint( t, optionalTarget ) {\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\tgetLength() {\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\t// cacheLengths must be recalculated.\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t/**\n\t * Returns list of cumulative curve lengths of the defined curves.\n\t *\n\t * @return {Array<number>} The curve lengths.\n\t */\n\tgetCurveLengths() {\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { CurvePath };\n"],"mappings":"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","ignoreList":[]}