{"version":3,"file":"node_modules/three/src/extras/core/Path.js","names":["Vector2","CurvePath","EllipseCurve","SplineCurve","CubicBezierCurve","QuadraticBezierCurve","LineCurve","Path","constructor","points","super","this","type","currentPoint","setFromPoints","moveTo","x","y","i","l","length","lineTo","set","curve","clone","curves","push","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","npts","concat","copy","arc","aRadius","aStartAngle","aEndAngle","aClockwise","x0","y0","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","firstPoint","getPoint","equals","lastPoint","source","toJSON","data","toArray","fromJSON","json","fromArray"],"sources":["node_modules/three/src/extras/core/Path.js"],"sourcesContent":["import { Vector2 } from '../../math/Vector2.js';\nimport { CurvePath } from './CurvePath.js';\nimport { EllipseCurve } from '../curves/EllipseCurve.js';\nimport { SplineCurve } from '../curves/SplineCurve.js';\nimport { CubicBezierCurve } from '../curves/CubicBezierCurve.js';\nimport { QuadraticBezierCurve } from '../curves/QuadraticBezierCurve.js';\nimport { LineCurve } from '../curves/LineCurve.js';\n\n/**\n * A 2D path representation. The class provides methods for creating paths\n * and contours of 2D shapes similar to the 2D Canvas API.\n *\n * ```js\n * const path = new THREE.Path();\n *\n * path.lineTo( 0, 0.8 );\n * path.quadraticCurveTo( 0, 1, 0.2, 1 );\n * path.lineTo( 1, 1 );\n *\n * const points = path.getPoints();\n *\n * const geometry = new THREE.BufferGeometry().setFromPoints( points );\n * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );\n *\n * const line = new THREE.Line( geometry, material );\n * scene.add( line );\n * ```\n *\n * @augments CurvePath\n */\nclass Path extends CurvePath {\n\n\t/**\n\t * Constructs a new path.\n\t *\n\t * @param {Array<Vector2>} [points] - An array of 2D points defining the path.\n\t */\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\t/**\n\t\t * The current offset of the path. Any new curve added will start here.\n\t\t *\n\t\t * @type {Vector2}\n\t\t */\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a path from the given list of points. The points are added\n\t * to the path as instances of {@link LineCurve}.\n\t *\n\t * @param {Array<Vector2>} points - An array of 2D points.\n\t * @return {Path} A reference to this path.\n\t */\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Moves {@link Path#currentPoint} to the given point.\n\t *\n\t * @param {number} x - The x coordinate.\n\t * @param {number} y - The y coordinate.\n\t * @return {Path} A reference to this path.\n\t */\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link LineCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} x - The x coordinate of the end point.\n\t * @param {number} y - The y coordinate of the end point.\n\t * @return {Path} A reference to this path.\n\t */\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} aCPx - The x coordinate of the control point.\n\t * @param {number} aCPy - The y coordinate of the control point.\n\t * @param {number} aX - The x coordinate of the end point.\n\t * @param {number} aY - The y coordinate of the end point.\n\t * @return {Path} A reference to this path.\n\t */\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link CubicBezierCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} aCP1x - The x coordinate of the first control point.\n\t * @param {number} aCP1y - The y coordinate of the first control point.\n\t * @param {number} aCP2x - The x coordinate of the second control point.\n\t * @param {number} aCP2y - The y coordinate of the second control point.\n\t * @param {number} aX - The x coordinate of the end point.\n\t * @param {number} aY - The y coordinate of the end point.\n\t * @return {Path} A reference to this path.\n\t */\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link SplineCurve} to the path by connecting\n\t * the current point with the given list of points.\n\t *\n\t * @param {Array<Vector2>} pts - An array of points in 2D space.\n\t * @return {Path} A reference to this path.\n\t */\n\tsplineThru( pts ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative\n\t * to the current point.\n\t *\n\t * @param {number} [aX=0] - The x coordinate of the center of the arc offsetted from the previous curve.\n\t * @param {number} [aY=0] - The y coordinate of the center of the arc offsetted from the previous curve.\n\t * @param {number} [aRadius=1] - The radius of the arc.\n\t * @param {number} [aStartAngle=0] - The start angle in radians.\n\t * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.\n\t * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.\n\t * @return {Path} A reference to this path.\n\t */\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.\n\t *\n\t * @param {number} [aX=0] - The x coordinate of the center of the arc.\n\t * @param {number} [aY=0] - The y coordinate of the center of the arc.\n\t * @param {number} [aRadius=1] - The radius of the arc.\n\t * @param {number} [aStartAngle=0] - The start angle in radians.\n\t * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.\n\t * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.\n\t * @return {Path} A reference to this path.\n\t */\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative\n\t * to the current point\n\t *\n\t * @param {number} [aX=0] - The x coordinate of the center of the ellipse offsetted from the previous curve.\n\t * @param {number} [aY=0] - The y coordinate of the center of the ellipse offsetted from the previous curve.\n\t * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.\n\t * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.\n\t * @param {number} [aStartAngle=0] - The start angle in radians.\n\t * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.\n\t * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.\n\t * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.\n\t * @return {Path} A reference to this path.\n\t */\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.\n\t *\n\t * @param {number} [aX=0] - The x coordinate of the absolute center of the ellipse.\n\t * @param {number} [aY=0] - The y coordinate of the absolute center of the ellipse.\n\t * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.\n\t * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.\n\t * @param {number} [aStartAngle=0] - The start angle in radians.\n\t * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.\n\t * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.\n\t * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.\n\t * @return {Path} A reference to this path.\n\t */\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { Path };\n"],"mappings":"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","ignoreList":[]}