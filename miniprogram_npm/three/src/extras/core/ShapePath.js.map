{"version":3,"file":"node_modules/three/src/extras/core/ShapePath.js","names":["Color","Path","Shape","ShapeUtils","ShapePath","constructor","this","type","color","subPaths","currentPath","moveTo","x","y","push","lineTo","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","toShapes","isCCW","isPointInsidePolygon","inPt","inPolygon","polyLen","length","inside","p","q","edgeLowPt","edgeHighPt","edgeDx","edgeDy","Math","abs","Number","EPSILON","perpEdge","isClockWise","solid","tmpPath","tmpShape","shapes","curves","holesFirst","getPoints","betterShapeHoles","newShapes","tmpPoints","tmpHoles","newShapeHoles","mainIdx","undefined","i","l","s","h","inSubpaths","toShapesNoHoles","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","il","j","jl","holes"],"sources":["node_modules/three/src/extras/core/ShapePath.js"],"sourcesContent":["import { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\n\n/**\n * This class is used to convert a series of paths to an array of\n * shapes. It is specifically used in context of fonts and SVG.\n */\nclass ShapePath {\n\n\t/**\n\t * Constructs a new shape path.\n\t */\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\t/**\n\t\t * The color of the shape.\n\t\t *\n\t\t * @type {Color}\n\t\t */\n\t\tthis.color = new Color();\n\n\t\t/**\n\t\t * The paths that have been generated for this shape.\n\t\t *\n\t\t * @type {Array<Path>}\n\t\t * @default null\n\t\t */\n\t\tthis.subPaths = [];\n\n\t\t/**\n\t\t * The current path that is being generated.\n\t\t *\n\t\t * @type {?Path}\n\t\t * @default null\n\t\t */\n\t\tthis.currentPath = null;\n\n\t}\n\n\t/**\n\t * Creates a new path and moves it current point to the given one.\n\t *\n\t * @param {number} x - The x coordinate.\n\t * @param {number} y - The y coordinate.\n\t * @return {ShapePath} A reference to this shape path.\n\t */\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link LineCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} x - The x coordinate of the end point.\n\t * @param {number} y - The y coordinate of the end point.\n\t * @return {ShapePath} A reference to this shape path.\n\t */\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} aCPx - The x coordinate of the control point.\n\t * @param {number} aCPy - The y coordinate of the control point.\n\t * @param {number} aX - The x coordinate of the end point.\n\t * @param {number} aY - The y coordinate of the end point.\n\t * @return {ShapePath} A reference to this shape path.\n\t */\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link CubicBezierCurve} to the path by connecting\n\t * the current point with the given one.\n\t *\n\t * @param {number} aCP1x - The x coordinate of the first control point.\n\t * @param {number} aCP1y - The y coordinate of the first control point.\n\t * @param {number} aCP2x - The x coordinate of the second control point.\n\t * @param {number} aCP2y - The y coordinate of the second control point.\n\t * @param {number} aX - The x coordinate of the end point.\n\t * @param {number} aY - The y coordinate of the end point.\n\t * @return {ShapePath} A reference to this shape path.\n\t */\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds an instance of {@link SplineCurve} to the path by connecting\n\t * the current point with the given list of points.\n\t *\n\t * @param {Array<Vector2>} pts - An array of points in 2D space.\n\t * @return {ShapePath} A reference to this shape path.\n\t */\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Converts the paths into an array of shapes.\n\t *\n\t * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).\n\t * If this flag is set to `true`, then those are flipped.\n\t * @return {Array<Shape>} An array of shapes.\n\t */\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\n\nexport { ShapePath };\n"],"mappings":"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","ignoreList":[]}