import{Vector3}from"../../math/Vector3.js";import{Curve}from"../core/Curve.js";function CubicPoly(){let t=0,o=0,e=0,s=0;function i(i,n,r,c){t=i,o=r,e=-3*i+3*n-2*r-c,s=2*i-2*n+r+c}return{initCatmullRom:function(t,o,e,s,n){i(o,e,n*(e-t),n*(s-o))},initNonuniformCatmullRom:function(t,o,e,s,n,r,c){let l=(o-t)/n-(e-t)/(n+r)+(e-o)/r,u=(e-o)/r-(s-o)/(r+c)+(s-e)/c;l*=r,u*=r,i(o,e,l,u)},calc:function(i){const n=i*i;return t+o*i+e*n+s*(n*i)}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(t=[],o=!1,e="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=o,this.curveType=e,this.tension=s}getPoint(t,o=new Vector3){const e=o,s=this.points,i=s.length,n=(i-(this.closed?0:1))*t;let r,c,l=Math.floor(n),u=n-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===u&&l===i-1&&(l=i-2,u=1),this.closed||l>0?r=s[(l-1)%i]:(tmp.subVectors(s[0],s[1]).add(s[0]),r=tmp);const p=s[l%i],h=s[(l+1)%i];if(this.closed||l+2<i?c=s[(l+2)%i]:(tmp.subVectors(s[i-1],s[i-2]).add(s[i-1]),c=tmp),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let o=Math.pow(r.distanceToSquared(p),t),e=Math.pow(p.distanceToSquared(h),t),s=Math.pow(h.distanceToSquared(c),t);e<1e-4&&(e=1),o<1e-4&&(o=e),s<1e-4&&(s=e),px.initNonuniformCatmullRom(r.x,p.x,h.x,c.x,o,e,s),py.initNonuniformCatmullRom(r.y,p.y,h.y,c.y,o,e,s),pz.initNonuniformCatmullRom(r.z,p.z,h.z,c.z,o,e,s)}else"catmullrom"===this.curveType&&(px.initCatmullRom(r.x,p.x,h.x,c.x,this.tension),py.initCatmullRom(r.y,p.y,h.y,c.y,this.tension),pz.initCatmullRom(r.z,p.z,h.z,c.z,this.tension));return e.set(px.calc(u),py.calc(u),pz.calc(u)),e}copy(t){super.copy(t),this.points=[];for(let o=0,e=t.points.length;o<e;o++){const e=t.points[o];this.points.push(e.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let o=0,e=this.points.length;o<e;o++){const e=this.points[o];t.points.push(e.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let o=0,e=t.points.length;o<e;o++){const e=t.points[o];this.points.push((new Vector3).fromArray(e))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}export{CatmullRomCurve3};
//# sourceMappingURL=CatmullRomCurve3.js.map