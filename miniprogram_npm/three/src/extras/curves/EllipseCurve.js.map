{"version":3,"file":"node_modules/three/src/extras/curves/EllipseCurve.js","names":["Curve","Vector2","EllipseCurve","constructor","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","Math","PI","aClockwise","aRotation","super","this","isEllipseCurve","type","getPoint","t","optionalTarget","point","twoPi","deltaAngle","samePoints","abs","Number","EPSILON","angle","x","cos","y","sin","tx","ty","set","copy","source","toJSON","data","fromJSON","json"],"sources":["node_modules/three/src/extras/curves/EllipseCurve.js"],"sourcesContent":["import { Curve } from '../core/Curve.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\n/**\n * A curve representing an ellipse.\n *\n * ```js\n * const curve = new THREE.EllipseCurve(\n * \t0, 0,\n * \t10, 10,\n * \t0, 2 * Math.PI,\n * \tfalse,\n * \t0\n * );\n *\n * const points = curve.getPoints( 50 );\n * const geometry = new THREE.BufferGeometry().setFromPoints( points );\n *\n * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );\n *\n * // Create the final object to add to the scene\n * const ellipse = new THREE.Line( geometry, material );\n * ```\n *\n * @augments Curve\n */\nclass EllipseCurve extends Curve {\n\n\t/**\n\t * Constructs a new ellipse curve.\n\t *\n\t * @param {number} [aX=0] - The X center of the ellipse.\n\t * @param {number} [aY=0] - The Y center of the ellipse.\n\t * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.\n\t * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.\n\t * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.\n\t * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.\n\t * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.\n\t * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.\n\t */\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\t/**\n\t\t * The X center of the ellipse.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.aX = aX;\n\n\t\t/**\n\t\t * The Y center of the ellipse.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.aY = aY;\n\n\t\t/**\n\t\t * The radius of the ellipse in the x direction.\n\t\t * Setting the this value equal to the {@link EllipseCurve#yRadius} will result in a circle.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.xRadius = xRadius;\n\n\t\t/**\n\t\t * The radius of the ellipse in the y direction.\n\t\t * Setting the this value equal to the {@link EllipseCurve#xRadius} will result in a circle.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.yRadius = yRadius;\n\n\t\t/**\n\t\t * The start angle of the curve in radians starting from the positive X axis.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.aStartAngle = aStartAngle;\n\n\t\t/**\n\t\t * The end angle of the curve in radians starting from the positive X axis.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Math.PI*2\n\t\t */\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\t/**\n\t\t * Whether the ellipse is drawn clockwise or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.aClockwise = aClockwise;\n\n\t\t/**\n\t\t * The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\t/**\n\t * Returns a point on the curve.\n\t *\n\t * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.\n\t * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {Vector2} The position on the curve.\n\t */\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { EllipseCurve };\n"],"mappings":"OAASA,UAAa,0BACbC,YAAe,wBAyBxB,MAAMC,qBAAqBF,MAc1B,WAAAG,CAAaC,EAAK,EAAGC,EAAK,EAAGC,EAAU,EAAGC,EAAU,EAAGC,EAAc,EAAGC,EAAsB,EAAVC,KAAKC,GAAQC,GAAa,EAAOC,EAAY,GAEhIC,QASAC,KAAKC,gBAAiB,EAEtBD,KAAKE,KAAO,eAQZF,KAAKX,GAAKA,EAQVW,KAAKV,GAAKA,EASVU,KAAKT,QAAUA,EASfS,KAAKR,QAAUA,EAQfQ,KAAKP,YAAcA,EAQnBO,KAAKN,UAAYA,EAQjBM,KAAKH,WAAaA,EAQlBG,KAAKF,UAAYA,CAElB,CASA,QAAAK,CAAUC,EAAGC,EAAiB,IAAInB,SAEjC,MAAMoB,EAAQD,EAERE,EAAkB,EAAVZ,KAAKC,GACnB,IAAIY,EAAaR,KAAKN,UAAYM,KAAKP,YACvC,MAAMgB,EAAad,KAAKe,IAAKF,GAAeG,OAAOC,QAGnD,KAAQJ,EAAa,GAAIA,GAAcD,EACvC,KAAQC,EAAaD,GAAQC,GAAcD,EAEtCC,EAAaG,OAAOC,UAIvBJ,EAFIC,EAES,EAIAF,IAMU,IAApBP,KAAKH,YAAyBY,IAE7BD,IAAeD,EAEnBC,GAAeD,EAIfC,GAA0BD,GAM5B,MAAMM,EAAQb,KAAKP,YAAcW,EAAII,EACrC,IAAIM,EAAId,KAAKX,GAAKW,KAAKT,QAAUI,KAAKoB,IAAKF,GACvCG,EAAIhB,KAAKV,GAAKU,KAAKR,QAAUG,KAAKsB,IAAKJ,GAE3C,GAAwB,IAAnBb,KAAKF,UAAkB,CAE3B,MAAMiB,EAAMpB,KAAKoB,IAAKf,KAAKF,WACrBmB,EAAMtB,KAAKsB,IAAKjB,KAAKF,WAErBoB,EAAKJ,EAAId,KAAKX,GACd8B,EAAKH,EAAIhB,KAAKV,GAGpBwB,EAAII,EAAKH,EAAMI,EAAKF,EAAMjB,KAAKX,GAC/B2B,EAAIE,EAAKD,EAAME,EAAKJ,EAAMf,KAAKV,EAEhC,CAEA,OAAOgB,EAAMc,IAAKN,EAAGE,EAEtB,CAEA,IAAAK,CAAMC,GAiBL,OAfAvB,MAAMsB,KAAMC,GAEZtB,KAAKX,GAAKiC,EAAOjC,GACjBW,KAAKV,GAAKgC,EAAOhC,GAEjBU,KAAKT,QAAU+B,EAAO/B,QACtBS,KAAKR,QAAU8B,EAAO9B,QAEtBQ,KAAKP,YAAc6B,EAAO7B,YAC1BO,KAAKN,UAAY4B,EAAO5B,UAExBM,KAAKH,WAAayB,EAAOzB,WAEzBG,KAAKF,UAAYwB,EAAOxB,UAEjBE,IAER,CAEA,MAAAuB,GAEC,MAAMC,EAAOzB,MAAMwB,SAenB,OAbAC,EAAKnC,GAAKW,KAAKX,GACfmC,EAAKlC,GAAKU,KAAKV,GAEfkC,EAAKjC,QAAUS,KAAKT,QACpBiC,EAAKhC,QAAUQ,KAAKR,QAEpBgC,EAAK/B,YAAcO,KAAKP,YACxB+B,EAAK9B,UAAYM,KAAKN,UAEtB8B,EAAK3B,WAAaG,KAAKH,WAEvB2B,EAAK1B,UAAYE,KAAKF,UAEf0B,CAER,CAEA,QAAAC,CAAUC,GAiBT,OAfA3B,MAAM0B,SAAUC,GAEhB1B,KAAKX,GAAKqC,EAAKrC,GACfW,KAAKV,GAAKoC,EAAKpC,GAEfU,KAAKT,QAAUmC,EAAKnC,QACpBS,KAAKR,QAAUkC,EAAKlC,QAEpBQ,KAAKP,YAAciC,EAAKjC,YACxBO,KAAKN,UAAYgC,EAAKhC,UAEtBM,KAAKH,WAAa6B,EAAK7B,WAEvBG,KAAKF,UAAY4B,EAAK5B,UAEfE,IAER,SAIQb","ignoreList":[]}