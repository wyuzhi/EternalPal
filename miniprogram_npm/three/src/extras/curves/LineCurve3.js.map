{"version":3,"file":"node_modules/three/src/extras/curves/LineCurve3.js","names":["Vector3","Curve","LineCurve3","constructor","v1","v2","super","this","isLineCurve3","type","getPoint","t","optionalTarget","point","copy","sub","multiplyScalar","add","getPointAt","u","getTangent","subVectors","normalize","getTangentAt","source","toJSON","data","toArray","fromJSON","json","fromArray"],"sources":["node_modules/three/src/extras/curves/LineCurve3.js"],"sourcesContent":["import { Vector3 } from '../../math/Vector3.js';\nimport { Curve } from '../core/Curve.js';\n\n/**\n * A curve representing a 3D line segment.\n *\n * @augments Curve\n */\nclass LineCurve3 extends Curve {\n\n\t/**\n\t * Constructs a new line curve.\n\t *\n\t * @param {Vector3} [v1] - The start point.\n\t * @param {Vector3} [v2] - The end point.\n\t */\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\t/**\n\t\t * The start point.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.v1 = v1;\n\n\t\t/**\n\t\t * The end point.\n\t\t *\n\t\t * @type {Vector2}\n\t\t */\n\t\tthis.v2 = v2;\n\n\t}\n\n\t/**\n\t * Returns a point on the line.\n\t *\n\t * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.\n\t * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.\n\t * @return {Vector3} The position on the line.\n\t */\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineCurve3 };\n"],"mappings":"OAASA,YAAe,+BACfC,UAAa,mBAOtB,MAAMC,mBAAmBD,MAQxB,WAAAE,CAAaC,EAAK,IAAIJ,QAAWK,EAAK,IAAIL,SAEzCM,QASAC,KAAKC,cAAe,EAEpBD,KAAKE,KAAO,aAOZF,KAAKH,GAAKA,EAOVG,KAAKF,GAAKA,CAEX,CASA,QAAAK,CAAUC,EAAGC,EAAiB,IAAIZ,SAEjC,MAAMa,EAAQD,EAad,OAXW,IAAND,EAEJE,EAAMC,KAAMP,KAAKF,KAIjBQ,EAAMC,KAAMP,KAAKF,IAAKU,IAAKR,KAAKH,IAChCS,EAAMG,eAAgBL,GAAIM,IAAKV,KAAKH,KAI9BS,CAER,CAGA,UAAAK,CAAYC,EAAGP,GAEd,OAAOL,KAAKG,SAAUS,EAAGP,EAE1B,CAEA,UAAAQ,CAAYT,EAAGC,EAAiB,IAAIZ,SAEnC,OAAOY,EAAeS,WAAYd,KAAKF,GAAIE,KAAKH,IAAKkB,WAEtD,CAEA,YAAAC,CAAcJ,EAAGP,GAEhB,OAAOL,KAAKa,WAAYD,EAAGP,EAE5B,CAEA,IAAAE,CAAMU,GAOL,OALAlB,MAAMQ,KAAMU,GAEZjB,KAAKH,GAAGU,KAAMU,EAAOpB,IACrBG,KAAKF,GAAGS,KAAMU,EAAOnB,IAEdE,IAER,CAEA,MAAAkB,GAEC,MAAMC,EAAOpB,MAAMmB,SAKnB,OAHAC,EAAKtB,GAAKG,KAAKH,GAAGuB,UAClBD,EAAKrB,GAAKE,KAAKF,GAAGsB,UAEXD,CAER,CAEA,QAAAE,CAAUC,GAOT,OALAvB,MAAMsB,SAAUC,GAEhBtB,KAAKH,GAAG0B,UAAWD,EAAKzB,IACxBG,KAAKF,GAAGyB,UAAWD,EAAKxB,IAEjBE,IAER,SAIQL","ignoreList":[]}