import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import{Vector3}from"../math/Vector3.js";class BoxGeometry extends BufferGeometry{constructor(t=1,e=1,r=1,o=1,s=1,h=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:r,widthSegments:o,heightSegments:s,depthSegments:h};const i=this;o=Math.floor(o),s=Math.floor(s),h=Math.floor(h);const u=[],f=[],n=[],m=[];let p=0,c=0;function a(t,e,r,o,s,h,a,y,l,x,d){const B=h/l,g=a/x,b=h/2,w=a/2,z=y/2,A=l+1,G=x+1;let S=0,j=0;const F=new Vector3;for(let h=0;h<G;h++){const i=h*g-w;for(let u=0;u<A;u++){const p=u*B-b;F[t]=p*o,F[e]=i*s,F[r]=z,f.push(F.x,F.y,F.z),F[t]=0,F[e]=0,F[r]=y>0?1:-1,n.push(F.x,F.y,F.z),m.push(u/l),m.push(1-h/x),S+=1}}for(let t=0;t<x;t++)for(let e=0;e<l;e++){const r=p+e+A*t,o=p+e+A*(t+1),s=p+(e+1)+A*(t+1),h=p+(e+1)+A*t;u.push(r,o,h),u.push(o,s,h),j+=6}i.addGroup(c,j,d),c+=j,p+=S}a("z","y","x",-1,-1,r,e,t,h,s,0),a("z","y","x",1,-1,r,e,-t,h,s,1),a("x","z","y",1,1,t,r,e,o,h,2),a("x","z","y",1,-1,t,r,-e,o,h,3),a("x","y","z",1,-1,t,e,r,o,s,4),a("x","y","z",-1,-1,t,e,-r,o,s,5),this.setIndex(u),this.setAttribute("position",new Float32BufferAttribute(f,3)),this.setAttribute("normal",new Float32BufferAttribute(n,3)),this.setAttribute("uv",new Float32BufferAttribute(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new BoxGeometry(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}export{BoxGeometry};
//# sourceMappingURL=BoxGeometry.js.map