{"version":3,"file":"node_modules/three/src/geometries/BoxGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","BoxGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","super","this","type","parameters","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","y","ix","x","push","z","a","b","c","d","addGroup","setIndex","setAttribute","copy","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/BoxGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n/**\n * A geometry class for a rectangular cuboid with a given width, height, and depth.\n * On creation, the cuboid is centred on the origin, with each edge parallel to one\n * of the axes.\n *\n * ```js\n * const geometry = new THREE.BoxGeometry( 1, 1, 1 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const cube = new THREE.Mesh( geometry, material );\n * scene.add( cube );\n * ```\n *\n * @augments BufferGeometry\n */\nclass BoxGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new box geometry.\n\t *\n\t * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.\n\t * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.\n\t * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.\n\t * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.\n\t * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.\n\t * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.\n\t */\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {BoxGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\nexport { BoxGeometry };\n"],"mappings":"OAASA,mBAAsB,mCACtBC,2BAA8B,oCAC9BC,YAAe,qBAgBxB,MAAMC,oBAAoBH,eAYzB,WAAAI,CAAaC,EAAQ,EAAGC,EAAS,EAAGC,EAAQ,EAAGC,EAAgB,EAAGC,EAAiB,EAAGC,EAAgB,GAErGC,QAEAC,KAAKC,KAAO,cASZD,KAAKE,WAAa,CACjBT,MAAOA,EACPC,OAAQA,EACRC,MAAOA,EACPC,cAAeA,EACfC,eAAgBA,EAChBC,cAAeA,GAGhB,MAAMK,EAAQH,KAIdJ,EAAgBQ,KAAKC,MAAOT,GAC5BC,EAAiBO,KAAKC,MAAOR,GAC7BC,EAAgBM,KAAKC,MAAOP,GAI5B,MAAMQ,EAAU,GACVC,EAAW,GACXC,EAAU,GACVC,EAAM,GAIZ,IAAIC,EAAmB,EACnBC,EAAa,EAkBjB,SAASC,EAAYC,EAAGC,EAAGC,EAAGC,EAAMC,EAAMxB,EAAOC,EAAQC,EAAOuB,EAAOC,EAAOC,GAE7E,MAAMC,EAAe5B,EAAQyB,EACvBI,EAAgB5B,EAASyB,EAEzBI,EAAY9B,EAAQ,EACpB+B,EAAa9B,EAAS,EACtB+B,EAAY9B,EAAQ,EAEpB+B,EAASR,EAAQ,EACjBS,EAASR,EAAQ,EAEvB,IAAIS,EAAgB,EAChBC,EAAa,EAEjB,MAAMC,EAAS,IAAIxC,QAInB,IAAM,IAAIyC,EAAK,EAAGA,EAAKJ,EAAQI,IAAQ,CAEtC,MAAMC,EAAID,EAAKT,EAAgBE,EAE/B,IAAM,IAAIS,EAAK,EAAGA,EAAKP,EAAQO,IAAQ,CAEtC,MAAMC,EAAID,EAAKZ,EAAeE,EAI9BO,EAAQjB,GAAMqB,EAAIlB,EAClBc,EAAQhB,GAAMkB,EAAIf,EAClBa,EAAQf,GAAMU,EAIdlB,EAAS4B,KAAML,EAAOI,EAAGJ,EAAOE,EAAGF,EAAOM,GAI1CN,EAAQjB,GAAM,EACdiB,EAAQhB,GAAM,EACdgB,EAAQf,GAAMpB,EAAQ,EAAI,GAAM,EAIhCa,EAAQ2B,KAAML,EAAOI,EAAGJ,EAAOE,EAAGF,EAAOM,GAIzC3B,EAAI0B,KAAMF,EAAKf,GACfT,EAAI0B,KAAM,EAAMJ,EAAKZ,GAIrBS,GAAiB,CAElB,CAED,CAQA,IAAM,IAAIG,EAAK,EAAGA,EAAKZ,EAAOY,IAE7B,IAAM,IAAIE,EAAK,EAAGA,EAAKf,EAAOe,IAAQ,CAErC,MAAMI,EAAI3B,EAAmBuB,EAAKP,EAASK,EACrCO,EAAI5B,EAAmBuB,EAAKP,GAAWK,EAAK,GAC5CQ,EAAI7B,GAAqBuB,EAAK,GAAMP,GAAWK,EAAK,GACpDS,EAAI9B,GAAqBuB,EAAK,GAAMP,EAASK,EAInDzB,EAAQ6B,KAAME,EAAGC,EAAGE,GACpBlC,EAAQ6B,KAAMG,EAAGC,EAAGC,GAIpBX,GAAc,CAEf,CAMD1B,EAAMsC,SAAU9B,EAAYkB,EAAYT,GAIxCT,GAAckB,EAIdnB,GAAoBkB,CAErB,CAlHAhB,EAAY,IAAK,IAAK,KAAO,GAAK,EAAGjB,EAAOD,EAAQD,EAAOK,EAAeD,EAAgB,GAC1Fe,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGjB,EAAOD,GAAUD,EAAOK,EAAeD,EAAgB,GAC1Fe,EAAY,IAAK,IAAK,IAAK,EAAG,EAAGnB,EAAOE,EAAOD,EAAQE,EAAeE,EAAe,GACrFc,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGnB,EAAOE,GAASD,EAAQE,EAAeE,EAAe,GACzFc,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGnB,EAAOC,EAAQC,EAAOC,EAAeC,EAAgB,GACxFe,EAAY,IAAK,IAAK,KAAO,GAAK,EAAGnB,EAAOC,GAAUC,EAAOC,EAAeC,EAAgB,GAI5FG,KAAK0C,SAAUpC,GACfN,KAAK2C,aAAc,WAAY,IAAItD,uBAAwBkB,EAAU,IACrEP,KAAK2C,aAAc,SAAU,IAAItD,uBAAwBmB,EAAS,IAClER,KAAK2C,aAAc,KAAM,IAAItD,uBAAwBoB,EAAK,GAwG3D,CAEA,IAAAmC,CAAMC,GAML,OAJA9C,MAAM6C,KAAMC,GAEZ7C,KAAKE,WAAa4C,OAAOC,OAAQ,CAAC,EAAGF,EAAO3C,YAErCF,IAER,CASA,eAAOgD,CAAUC,GAEhB,OAAO,IAAI1D,YAAa0D,EAAKxD,MAAOwD,EAAKvD,OAAQuD,EAAKtD,MAAOsD,EAAKrD,cAAeqD,EAAKpD,eAAgBoD,EAAKnD,cAE5G,SAIQP","ignoreList":[]}