{"version":3,"file":"node_modules/three/src/geometries/CapsuleGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","CapsuleGeometry","constructor","radius","height","capSegments","radialSegments","heightSegments","super","this","type","parameters","Math","max","floor","indices","vertices","normals","uvs","halfHeight","capArcLength","PI","cylinderPartLength","totalArcLength","numVerticalSegments","verticesPerRow","normal","vertex","iy","currentArcLength","profileY","profileRadius","normalYComponent","segmentProgress","angle","cos","sin","v","min","uOffset","ix","u","theta","sinTheta","cosTheta","x","y","z","push","set","normalize","prevIndexRow","i1","i2","i3","i4","setIndex","setAttribute","copy","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/CapsuleGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n/**\n * A geometry class for representing a capsule.\n *\n * ```js\n * const geometry = new THREE.CapsuleGeometry( 1, 1, 4, 8, 1 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const capsule = new THREE.Mesh( geometry, material );\n * scene.add( capsule );\n * ```\n *\n * @augments BufferGeometry\n */\nclass CapsuleGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new capsule geometry.\n\t *\n\t * @param {number} [radius=1] - Radius of the capsule.\n\t * @param {number} [height=1] - Height of the middle section.\n\t * @param {number} [capSegments=4] - Number of curve segments used to build each cap.\n\t * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule. Must be an integer >= 3.\n\t * @param {number} [heightSegments=1] - Number of rows of faces along the height of the middle section. Must be an integer >= 1.\n\t */\n\tconstructor( radius = 1, height = 1, capSegments = 4, radialSegments = 8, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t};\n\n\t\theight = Math.max( 0, height );\n\t\tcapSegments = Math.max( 1, Math.floor( capSegments ) );\n\t\tradialSegments = Math.max( 3, Math.floor( radialSegments ) );\n\t\theightSegments = Math.max( 1, Math.floor( heightSegments ) );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst halfHeight = height / 2;\n\t\tconst capArcLength = ( Math.PI / 2 ) * radius;\n\t\tconst cylinderPartLength = height;\n\t\tconst totalArcLength = 2 * capArcLength + cylinderPartLength;\n\n\t\tconst numVerticalSegments = capSegments * 2 + heightSegments;\n\t\tconst verticesPerRow = radialSegments + 1;\n\n\t\tconst normal = new Vector3();\n\t\tconst vertex = new Vector3();\n\n\t\t// generate vertices, normals, and uvs\n\n\t\tfor ( let iy = 0; iy <= numVerticalSegments; iy ++ ) {\n\n\t\t\tlet currentArcLength = 0;\n\t\t\tlet profileY = 0;\n\t\t\tlet profileRadius = 0;\n\t\t\tlet normalYComponent = 0;\n\n\t\t\tif ( iy <= capSegments ) {\n\n\t\t\t\t// bottom cap\n\t\t\t\tconst segmentProgress = iy / capSegments;\n\t\t\t\tconst angle = ( segmentProgress * Math.PI ) / 2;\n\t\t\t\tprofileY = - halfHeight - radius * Math.cos( angle );\n\t\t\t\tprofileRadius = radius * Math.sin( angle );\n\t\t\t\tnormalYComponent = - radius * Math.cos( angle );\n\t\t\t\tcurrentArcLength = segmentProgress * capArcLength;\n\n\t\t\t} else if ( iy <= capSegments + heightSegments ) {\n\n\t\t\t\t// middle section\n\t\t\t\tconst segmentProgress = ( iy - capSegments ) / heightSegments;\n\t\t\t\tprofileY = - halfHeight + segmentProgress * height;\n\t\t\t\tprofileRadius = radius;\n\t\t\t\tnormalYComponent = 0;\n\t\t\t\tcurrentArcLength = capArcLength + segmentProgress * cylinderPartLength;\n\n\t\t\t} else {\n\n\t\t\t\t// top cap\n\t\t\t\tconst segmentProgress =\n\t\t\t\t\t( iy - capSegments - heightSegments ) / capSegments;\n\t\t\t\tconst angle = ( segmentProgress * Math.PI ) / 2;\n\t\t\t\tprofileY = halfHeight + radius * Math.sin( angle );\n\t\t\t\tprofileRadius = radius * Math.cos( angle );\n\t\t\t\tnormalYComponent = radius * Math.sin( angle );\n\t\t\t\tcurrentArcLength =\n\t\t\t\t\tcapArcLength + cylinderPartLength + segmentProgress * capArcLength;\n\n\t\t\t}\n\n\t\t\tconst v = Math.max( 0, Math.min( 1, currentArcLength / totalArcLength ) );\n\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / radialSegments;\n\n\t\t\t} else if ( iy === numVerticalSegments ) {\n\n\t\t\t\tuOffset = - 0.5 / radialSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= radialSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / radialSegments;\n\t\t\t\tconst theta = u * Math.PI * 2;\n\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - profileRadius * cosTheta;\n\t\t\t\tvertex.y = profileY;\n\t\t\t\tvertex.z = profileRadius * sinTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.set(\n\t\t\t\t\t- profileRadius * cosTheta,\n\t\t\t\t\tnormalYComponent,\n\t\t\t\t\tprofileRadius * sinTheta\n\t\t\t\t);\n\t\t\t\tnormal.normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, v );\n\n\t\t\t}\n\n\t\t\tif ( iy > 0 ) {\n\n\t\t\t\tconst prevIndexRow = ( iy - 1 ) * verticesPerRow;\n\t\t\t\tfor ( let ix = 0; ix < radialSegments; ix ++ ) {\n\n\t\t\t\t\tconst i1 = prevIndexRow + ix;\n\t\t\t\t\tconst i2 = prevIndexRow + ix + 1;\n\t\t\t\t\tconst i3 = iy * verticesPerRow + ix;\n\t\t\t\t\tconst i4 = iy * verticesPerRow + ix + 1;\n\n\t\t\t\t\tindices.push( i1, i2, i3 );\n\t\t\t\t\tindices.push( i2, i4, i3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {CapsuleGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.height, data.capSegments, data.radialSegments, data.heightSegments );\n\n\t}\n\n}\n\nexport { CapsuleGeometry };\n"],"mappings":"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","ignoreList":[]}