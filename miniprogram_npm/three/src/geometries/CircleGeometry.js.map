{"version":3,"file":"node_modules/three/src/geometries/CircleGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CircleGeometry","constructor","radius","segments","thetaStart","thetaLength","Math","PI","super","this","type","parameters","max","indices","vertices","normals","uvs","vertex","uv","push","s","i","segment","x","cos","y","sin","z","setIndex","setAttribute","copy","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/CircleGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\n/**\n * A simple shape of Euclidean geometry. It is constructed from a\n * number of triangular segments that are oriented around a central point and\n * extend as far out as a given radius. It is built counter-clockwise from a\n * start angle and a given central angle. It can also be used to create\n * regular polygons, where the number of segments determines the number of\n * sides.\n *\n * ```js\n * const geometry = new THREE.CircleGeometry( 5, 32 );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const circle = new THREE.Mesh( geometry, material );\n * scene.add( circle )\n * ```\n *\n * @augments BufferGeometry\n */\nclass CircleGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new circle geometry.\n\t *\n\t * @param {number} [radius=1] - Radius of the circle.\n\t * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.\n\t * @param {number} [thetaStart=0] - Start angle for first segment in radians.\n\t * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,\n\t * of the circular sector in radians. The default value results in a complete circle.\n\t */\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {CircleGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\n\nexport { CircleGeometry };\n"],"mappings":"OAASA,mBAAsB,mCACtBC,2BAA8B,oCAC9BC,YAAe,4BACfC,YAAe,qBAmBxB,MAAMC,uBAAuBJ,eAW5B,WAAAK,CAAaC,EAAS,EAAGC,EAAW,GAAIC,EAAa,EAAGC,EAAwB,EAAVC,KAAKC,IAE1EC,QAEAC,KAAKC,KAAO,iBASZD,KAAKE,WAAa,CACjBT,OAAQA,EACRC,SAAUA,EACVC,WAAYA,EACZC,YAAaA,GAGdF,EAAWG,KAAKM,IAAK,EAAGT,GAIxB,MAAMU,EAAU,GACVC,EAAW,GACXC,EAAU,GACVC,EAAM,GAINC,EAAS,IAAInB,QACboB,EAAK,IAAInB,QAIfe,EAASK,KAAM,EAAG,EAAG,GACrBJ,EAAQI,KAAM,EAAG,EAAG,GACpBH,EAAIG,KAAM,GAAK,IAEf,IAAM,IAAIC,EAAI,EAAGC,EAAI,EAAGD,GAAKjB,EAAUiB,IAAMC,GAAK,EAAI,CAErD,MAAMC,EAAUlB,EAAagB,EAAIjB,EAAWE,EAI5CY,EAAOM,EAAIrB,EAASI,KAAKkB,IAAKF,GAC9BL,EAAOQ,EAAIvB,EAASI,KAAKoB,IAAKJ,GAE9BR,EAASK,KAAMF,EAAOM,EAAGN,EAAOQ,EAAGR,EAAOU,GAI1CZ,EAAQI,KAAM,EAAG,EAAG,GAIpBD,EAAGK,GAAMT,EAAUO,GAAMnB,EAAS,GAAM,EACxCgB,EAAGO,GAAMX,EAAUO,EAAI,GAAMnB,EAAS,GAAM,EAE5Cc,EAAIG,KAAMD,EAAGK,EAAGL,EAAGO,EAEpB,CAIA,IAAM,IAAIJ,EAAI,EAAGA,GAAKlB,EAAUkB,IAE/BR,EAAQM,KAAME,EAAGA,EAAI,EAAG,GAMzBZ,KAAKmB,SAAUf,GACfJ,KAAKoB,aAAc,WAAY,IAAIhC,uBAAwBiB,EAAU,IACrEL,KAAKoB,aAAc,SAAU,IAAIhC,uBAAwBkB,EAAS,IAClEN,KAAKoB,aAAc,KAAM,IAAIhC,uBAAwBmB,EAAK,GAE3D,CAEA,IAAAc,CAAMC,GAML,OAJAvB,MAAMsB,KAAMC,GAEZtB,KAAKE,WAAaqB,OAAOC,OAAQ,CAAC,EAAGF,EAAOpB,YAErCF,IAER,CASA,eAAOyB,CAAUC,GAEhB,OAAO,IAAInC,eAAgBmC,EAAKjC,OAAQiC,EAAKhC,SAAUgC,EAAK/B,WAAY+B,EAAK9B,YAE9E,SAKQL","ignoreList":[]}