{"version":3,"file":"node_modules/three/src/geometries/CylinderGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CylinderGeometry","constructor","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","Math","PI","super","this","type","parameters","scope","floor","indices","vertices","normals","uvs","index","indexArray","halfHeight","groupStart","generateCap","top","centerIndexStart","uv","vertex","groupCount","radius","sign","x","push","centerIndexEnd","theta","cosTheta","cos","sinTheta","sin","y","z","c","i","addGroup","normal","slope","indexRow","v","u","set","normalize","a","b","d","generateTorso","setIndex","setAttribute","copy","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/CylinderGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\n/**\n * A geometry class for representing a cylinder.\n *\n * ```js\n * const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const cylinder = new THREE.Mesh( geometry, material );\n * scene.add( cylinder );\n * ```\n *\n * @augments BufferGeometry\n */\nclass CylinderGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new cylinder geometry.\n\t *\n\t * @param {number} [radiusTop=1] - Radius of the cylinder at the top.\n\t * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.\n\t * @param {number} [height=1] - Height of the cylinder.\n\t * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.\n\t * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.\n\t * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.\n\t * @param {number} [thetaStart=0] - Start angle for first segment, in radians.\n\t * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.\n\t * The default value results in a complete cylinder.\n\t */\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( radiusTop > 0 || y !== 0 ) {\n\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( radiusBottom > 0 || y !== heightSegments - 1 ) {\n\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {CylinderGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\n\nexport { CylinderGeometry };\n"],"mappings":"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","ignoreList":[]}