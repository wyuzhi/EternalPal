import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import{DEG2RAD}from"../math/MathUtils.js";import{Triangle}from"../math/Triangle.js";import{Vector3}from"../math/Vector3.js";const _v0=new Vector3,_v1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(t=null,r=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:r},null!==t){const e=4,o=Math.pow(10,e),n=Math.cos(DEG2RAD*r),i=t.getIndex(),a=t.getAttribute("position"),u=i?i.count:a.count,s=[0,0,0],f=["a","b","c"],m=new Array(3),l={},h=[];for(let t=0;t<u;t+=3){i?(s[0]=i.getX(t),s[1]=i.getX(t+1),s[2]=i.getX(t+2)):(s[0]=t,s[1]=t+1,s[2]=t+2);const{a:r,b:e,c:u}=_triangle;if(r.fromBufferAttribute(a,s[0]),e.fromBufferAttribute(a,s[1]),u.fromBufferAttribute(a,s[2]),_triangle.getNormal(_normal),m[0]=`${Math.round(r.x*o)},${Math.round(r.y*o)},${Math.round(r.z*o)}`,m[1]=`${Math.round(e.x*o)},${Math.round(e.y*o)},${Math.round(e.z*o)}`,m[2]=`${Math.round(u.x*o)},${Math.round(u.y*o)},${Math.round(u.z*o)}`,m[0]!==m[1]&&m[1]!==m[2]&&m[2]!==m[0])for(let t=0;t<3;t++){const r=(t+1)%3,e=m[t],o=m[r],i=_triangle[f[t]],a=_triangle[f[r]],u=`${e}_${o}`,c=`${o}_${e}`;c in l&&l[c]?(_normal.dot(l[c].normal)<=n&&(h.push(i.x,i.y,i.z),h.push(a.x,a.y,a.z)),l[c]=null):u in l||(l[u]={index0:s[t],index1:s[r],normal:_normal.clone()})}}for(const t in l)if(l[t]){const{index0:r,index1:e}=l[t];_v0.fromBufferAttribute(a,r),_v1.fromBufferAttribute(a,e),h.push(_v0.x,_v0.y,_v0.z),h.push(_v1.x,_v1.y,_v1.z)}this.setAttribute("position",new Float32BufferAttribute(h,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}export{EdgesGeometry};
//# sourceMappingURL=EdgesGeometry.js.map