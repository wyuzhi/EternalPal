{"version":3,"file":"node_modules/three/src/geometries/EdgesGeometry.js","names":["BufferGeometry","Float32BufferAttribute","DEG2RAD","Triangle","Vector3","_v0","_v1","_normal","_triangle","EdgesGeometry","constructor","geometry","thresholdAngle","super","this","type","parameters","precisionPoints","precision","Math","pow","thresholdDot","cos","indexAttr","getIndex","positionAttr","getAttribute","indexCount","count","indexArr","vertKeys","hashes","Array","edgeData","vertices","i","getX","a","b","c","fromBufferAttribute","getNormal","round","x","y","z","j","jNext","vecHash0","vecHash1","v0","v1","hash","reverseHash","dot","normal","push","index0","index1","clone","key","setAttribute","copy","source","Object","assign"],"sources":["node_modules/three/src/geometries/EdgesGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { DEG2RAD } from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\n/**\n * Can be used as a helper object to view the edges of a geometry.\n *\n * ```js\n * const geometry = new THREE.BoxGeometry();\n * const edges = new THREE.EdgesGeometry( geometry );\n * const line = new THREE.LineSegments( edges );\n * scene.add( line );\n * ```\n *\n * Note: It is not yet possible to serialize/deserialize instances of this class.\n *\n * @augments BufferGeometry\n */\nclass EdgesGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new edges geometry.\n\t *\n\t * @param {?BufferGeometry} [geometry=null] - The geometry.\n\t * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)\n\t * between the face normals of the adjoining faces exceeds this value.\n\t */\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1.x, _v1.y, _v1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { EdgesGeometry };\n"],"mappings":"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","ignoreList":[]}