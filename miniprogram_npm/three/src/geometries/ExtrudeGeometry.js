import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import*as Curves from"../extras/curves/Curves.js";import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";import{Shape}from"../extras/core/Shape.js";import{ShapeUtils}from"../extras/ShapeUtils.js";class ExtrudeGeometry extends BufferGeometry{constructor(t=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const o=this,r=[],s=[];for(let e=0,o=t.length;e<o;e++){n(t[e])}function n(t){const n=[],c=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let h=void 0===e.bevelEnabled||e.bevelEnabled,i=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:i-.1,p=void 0!==e.bevelOffset?e.bevelOffset:0,f=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,d=void 0!==e.UVGenerator?e.UVGenerator:WorldUVGenerator;let y,x,g,S,b,V=!1;m&&(y=m.getSpacedPoints(a),V=!0,h=!1,x=m.computeFrenetFrames(a,!1),g=new Vector3,S=new Vector3,b=new Vector3),h||(f=0,i=0,u=0,p=0);const v=t.extractPoints(c);let w=v.shape;const M=v.holes;if(!ShapeUtils.isClockWise(w)){w=w.reverse();for(let t=0,e=M.length;t<e;t++){const e=M[t];ShapeUtils.isClockWise(e)&&(M[t]=e.reverse())}}function N(t){let e=t[0];for(let o=1;o<=t.length;o++){const r=o%t.length,s=t[r],n=s.x-e.x,c=s.y-e.y,a=n*n+c*c,l=Math.max(Math.abs(s.x),Math.abs(s.y),Math.abs(e.x),Math.abs(e.y));a<=1.0000000000000001e-20*l*l?(t.splice(r,1),o--):e=s}}N(w),M.forEach(N);const P=M.length,O=w;for(let t=0;t<P;t++){const e=M[t];w=w.concat(e)}function E(t,e,o){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,o)}const G=w.length;function U(t,e,o){let r,s,n;const c=t.x-e.x,a=t.y-e.y,l=o.x-t.x,h=o.y-t.y,i=c*c+a*a,u=c*h-a*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(i),p=Math.sqrt(l*l+h*h),f=e.x-a/u,m=e.y+c/u,d=((o.x-h/p-f)*h-(o.y+l/p-m)*l)/(c*h-a*l);r=f+c*d-t.x,s=m+a*d-t.y;const y=r*r+s*s;if(y<=2)return new Vector2(r,s);n=Math.sqrt(y/2)}else{let t=!1;c>Number.EPSILON?l>Number.EPSILON&&(t=!0):c<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(h)&&(t=!0),t?(r=-a,s=c,n=Math.sqrt(i)):(r=c,s=a,n=Math.sqrt(i/2))}return new Vector2(r/n,s/n)}const A=[];for(let t=0,e=O.length,o=e-1,r=t+1;t<e;t++,o++,r++)o===e&&(o=0),r===e&&(r=0),A[t]=U(O[t],O[o],O[r]);const j=[];let I,B,J=A.concat();for(let t=0,e=P;t<e;t++){const e=M[t];I=[];for(let t=0,o=e.length,r=o-1,s=t+1;t<o;t++,r++,s++)r===o&&(r=0),s===o&&(s=0),I[t]=U(e[t],e[r],e[s]);j.push(I),J=J.concat(I)}if(0===f)B=ShapeUtils.triangulateShape(O,M);else{const t=[],e=[];for(let o=0;o<f;o++){const r=o/f,s=i*Math.cos(r*Math.PI/2),n=u*Math.sin(r*Math.PI/2)+p;for(let e=0,o=O.length;e<o;e++){const o=E(O[e],A[e],n);F(o.x,o.y,-s),0===r&&t.push(o)}for(let t=0,o=P;t<o;t++){const o=M[t];I=j[t];const c=[];for(let t=0,e=o.length;t<e;t++){const e=E(o[t],I[t],n);F(e.x,e.y,-s),0===r&&c.push(e)}0===r&&e.push(c)}}B=ShapeUtils.triangulateShape(t,e)}const W=B.length,q=u+p;for(let t=0;t<G;t++){const e=h?E(w[t],J[t],q):w[t];V?(S.copy(x.normals[0]).multiplyScalar(e.x),g.copy(x.binormals[0]).multiplyScalar(e.y),b.copy(y[0]).add(S).add(g),F(b.x,b.y,b.z)):F(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<G;e++){const o=h?E(w[e],J[e],q):w[e];V?(S.copy(x.normals[t]).multiplyScalar(o.x),g.copy(x.binormals[t]).multiplyScalar(o.y),b.copy(y[t]).add(S).add(g),F(b.x,b.y,b.z)):F(o.x,o.y,l/a*t)}for(let t=f-1;t>=0;t--){const e=t/f,o=i*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+p;for(let t=0,e=O.length;t<e;t++){const e=E(O[t],A[t],r);F(e.x,e.y,l+o)}for(let t=0,e=M.length;t<e;t++){const e=M[t];I=j[t];for(let t=0,s=e.length;t<s;t++){const s=E(e[t],I[t],r);V?F(s.x,s.y+y[a-1].y,y[a-1].x+o):F(s.x,s.y,l+o)}}}function C(t,e){let o=t.length;for(;--o>=0;){const r=o;let s=o-1;s<0&&(s=t.length-1);for(let t=0,o=a+2*f;t<o;t++){const o=G*t,n=G*(t+1);T(e+r+o,e+s+o,e+s+n,e+r+n)}}}function F(t,e,o){n.push(t),n.push(e),n.push(o)}function L(t,e,s){k(t),k(e),k(s);const n=r.length/3,c=d.generateTopUV(o,r,n-3,n-2,n-1);z(c[0]),z(c[1]),z(c[2])}function T(t,e,s,n){k(t),k(e),k(n),k(e),k(s),k(n);const c=r.length/3,a=d.generateSideWallUV(o,r,c-6,c-3,c-2,c-1);z(a[0]),z(a[1]),z(a[3]),z(a[1]),z(a[2]),z(a[3])}function k(t){r.push(n[3*t+0]),r.push(n[3*t+1]),r.push(n[3*t+2])}function z(t){s.push(t.x),s.push(t.y)}!function(){const t=r.length/3;if(h){let t=0,e=G*t;for(let t=0;t<W;t++){const o=B[t];L(o[2]+e,o[1]+e,o[0]+e)}t=a+2*f,e=G*t;for(let t=0;t<W;t++){const o=B[t];L(o[0]+e,o[1]+e,o[2]+e)}}else{for(let t=0;t<W;t++){const e=B[t];L(e[2],e[1],e[0])}for(let t=0;t<W;t++){const e=B[t];L(e[0]+G*a,e[1]+G*a,e[2]+G*a)}}o.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;C(O,e),e+=O.length;for(let t=0,o=M.length;t<o;t++){const o=M[t];C(o,e),e+=o.length}o.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new Float32BufferAttribute(r,3)),this.setAttribute("uv",new Float32BufferAttribute(s,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return toJSON(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const o=[];for(let r=0,s=t.shapes.length;r<s;r++){const s=e[t.shapes[r]];o.push(s)}const r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=(new Curves[r.type]).fromJSON(r)),new ExtrudeGeometry(o,t.options)}}const WorldUVGenerator={generateTopUV:function(t,e,o,r,s){const n=e[3*o],c=e[3*o+1],a=e[3*r],l=e[3*r+1],h=e[3*s],i=e[3*s+1];return[new Vector2(n,c),new Vector2(a,l),new Vector2(h,i)]},generateSideWallUV:function(t,e,o,r,s,n){const c=e[3*o],a=e[3*o+1],l=e[3*o+2],h=e[3*r],i=e[3*r+1],u=e[3*r+2],p=e[3*s],f=e[3*s+1],m=e[3*s+2],d=e[3*n],y=e[3*n+1],x=e[3*n+2];return Math.abs(a-i)<Math.abs(c-h)?[new Vector2(c,1-l),new Vector2(h,1-u),new Vector2(p,1-m),new Vector2(d,1-x)]:[new Vector2(a,1-l),new Vector2(i,1-u),new Vector2(f,1-m),new Vector2(y,1-x)]}};function toJSON(t,e,o){if(o.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){const r=t[e];o.shapes.push(r.uuid)}else o.shapes.push(t.uuid);return o.options=Object.assign({},e),void 0!==e.extrudePath&&(o.options.extrudePath=e.extrudePath.toJSON()),o}export{ExtrudeGeometry};
//# sourceMappingURL=ExtrudeGeometry.js.map