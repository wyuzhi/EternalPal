{"version":3,"file":"node_modules/three/src/geometries/ExtrudeGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","Shape","ShapeUtils","ExtrudeGeometry","constructor","shapes","options","super","this","type","parameters","Array","isArray","scope","verticesArray","uvArray","i","l","length","addShape","shape","placeholder","curveSegments","undefined","steps","depth","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","extrudePts","splineTube","binormal","normal","position2","extrudeByPath","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","vertices","holes","isClockWise","reverse","h","hl","ahole","mergeOverlappingPoints","points","prevPos","currentIndex","currentPos","dx","x","dy","y","distSq","scalingFactorSqrt","Math","max","abs","THRESHOLD","splice","forEach","numHoles","contour","concat","scalePt2","pt","vec","size","console","error","clone","addScaledVector","vlen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","Number","EPSILON","v_prev_len","sqrt","v_next_len","ptPrevShift_x","ptPrevShift_y","sf","v_trans_lensq","direction_eq","sign","contourMovements","il","j","k","holesMovements","oneHoleMovements","faces","verticesMovements","push","triangulateShape","contractedContourVertices","expandedHoleVertices","b","t","z","cos","PI","bs","sin","vert","v","oneHoleVertices","flen","copy","normals","multiplyScalar","binormals","add","s","sidewalls","layeroffset","sl","slen1","slen2","f4","f3","a","c","addVertex","nextIndex","uvs","generateTopUV","addUV","d","generateSideWallUV","index","vector2","start","layer","offset","face","addGroup","buildLidFaces","buildSideFaces","setAttribute","computeVertexNormals","source","Object","assign","toJSON","data","fromJSON","geometryShapes","jl","geometry","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","uuid"],"sources":["node_modules/three/src/geometries/ExtrudeGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * ```js\n * const length = 12, width = 8;\n *\n * const shape = new THREE.Shape();\n * shape.moveTo( 0,0 );\n * shape.lineTo( 0, width );\n * shape.lineTo( length, width );\n * shape.lineTo( length, 0 );\n * shape.lineTo( 0, 0 );\n *\n * const geometry = new THREE.ExtrudeGeometry( shape );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const mesh = new THREE.Mesh( geometry, material ) ;\n * scene.add( mesh );\n * ```\n *\n * @augments BufferGeometry\n */\nclass ExtrudeGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new extrude geometry.\n\t *\n\t * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.\n\t * @param {ExtrudeGeometry~Options} [options] - The extrude settings.\n\t */\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**Merges index-adjacent points that are within a threshold distance of each other. Array is modified in-place. Threshold distance is empirical, and scaled based on the magnitude of point coordinates.\n\t\t\t * @param {Array<Vector2>} points\n\t\t\t*/\n\t\t\tfunction mergeOverlappingPoints( points ) {\n\n\t\t\t\tconst THRESHOLD = 1e-10;\n\t\t\t\tconst THRESHOLD_SQ = THRESHOLD * THRESHOLD;\n\t\t\t\tlet prevPos = points[ 0 ];\n\t\t\t\tfor ( let i = 1; i <= points.length; i ++ ) {\n\n\t\t\t\t\tconst currentIndex = i % points.length;\n\t\t\t\t\tconst currentPos = points[ currentIndex ];\n\t\t\t\t\tconst dx = currentPos.x - prevPos.x;\n\t\t\t\t\tconst dy = currentPos.y - prevPos.y;\n\t\t\t\t\tconst distSq = dx * dx + dy * dy;\n\n\t\t\t\t\tconst scalingFactorSqrt = Math.max(\n\t\t\t\t\t\tMath.abs( currentPos.x ),\n\t\t\t\t\t\tMath.abs( currentPos.y ),\n\t\t\t\t\t\tMath.abs( prevPos.x ),\n\t\t\t\t\t\tMath.abs( prevPos.y )\n\t\t\t\t\t);\n\t\t\t\t\tconst thresholdSqScaled = THRESHOLD_SQ * scalingFactorSqrt * scalingFactorSqrt;\n\t\t\t\t\tif ( distSq <= thresholdSqScaled ) {\n\n\t\t\t\t\t\tpoints.splice( currentIndex, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tprevPos = currentPos;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmergeOverlappingPoints( vertices );\n\t\t\tholes.forEach( mergeOverlappingPoints );\n\n\t\t\tconst numHoles = holes.length;\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0; h < numHoles; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = numHoles; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\t\t\tlet faces;\n\n\t\t\tif ( bevelSegments === 0 ) {\n\n\t\t\t\tfaces = ShapeUtils.triangulateShape( contour, holes );\n\n\t\t\t} else {\n\n\t\t\t\tconst contractedContourVertices = [];\n\t\t\t\tconst expandedHoleVertices = [];\n\n\t\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t\t// contract shape\n\n\t\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\t\t\t\t\t\tif ( t === 0 ) contractedContourVertices.push( vert );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// expand holes\n\n\t\t\t\t\tfor ( let h = 0, hl = numHoles; h < hl; h ++ ) {\n\n\t\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\t\t\t\t\tconst oneHoleVertices = [];\n\t\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\t\t\t\t\t\t\tif ( t === 0 ) oneHoleVertices.push( vert );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( t === 0 ) expandedHoleVertices.push( oneHoleVertices );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfaces = ShapeUtils.triangulateShape( contractedContourVertices, expandedHoleVertices );\n\n\t\t\t}\n\n\t\t\tconst flen = faces.length;\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON( shapes, options, data );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @param {Array<Shape>} shapes - An array of shapes.\n\t * @return {ExtrudeGeometry} A new instance.\n\t */\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n/**\n * Represents the `options` type of the geometry's constructor.\n *\n * @typedef {Object} ExtrudeGeometry~Options\n * @property {number} [curveSegments=12] - Number of points on the curves.\n * @property {number} [steps=1] - Number of points used for subdividing segments along the depth of the extruded spline.\n * @property {number} [depth=1] - Depth to extrude the shape.\n * @property {boolean} [bevelEnabled=true] - Whether to beveling to the shape or not.\n * @property {number} [bevelThickness=0.2] - How deep into the original shape the bevel goes.\n * @property {number} [bevelSize=bevelThickness-0.1] - Distance from the shape outline that the bevel extends.\n * @property {number} [bevelOffset=0] - Distance from the shape outline that the bevel starts.\n * @property {number} [bevelSegments=3] - Number of bevel layers.\n * @property {?Curve} [extrudePath=null] - A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion.\n * @property {Object} [UVGenerator] - An object that provides UV generator functions for custom UV generation.\n **/\n\nexport { ExtrudeGeometry };\n"],"mappings":"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","ignoreList":[]}