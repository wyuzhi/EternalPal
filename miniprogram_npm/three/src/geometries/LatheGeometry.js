import{Float32BufferAttribute}from"../core/BufferAttribute.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{Vector3}from"../math/Vector3.js";import{Vector2}from"../math/Vector2.js";import{clamp}from"../math/MathUtils.js";class LatheGeometry extends BufferGeometry{constructor(t=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],e=12,r=0,o=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:r,phiLength:o},e=Math.floor(e),o=clamp(o,0,2*Math.PI);const s=[],h=[],n=[],a=[],i=[],c=1/e,p=new Vector3,m=new Vector2,u=new Vector3,f=new Vector3,y=new Vector3;let l=0,x=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:l=t[e+1].x-t[e].x,x=t[e+1].y-t[e].y,u.x=1*x,u.y=-l,u.z=0*x,y.copy(u),u.normalize(),a.push(u.x,u.y,u.z);break;case t.length-1:a.push(y.x,y.y,y.z);break;default:l=t[e+1].x-t[e].x,x=t[e+1].y-t[e].y,u.x=1*x,u.y=-l,u.z=0*x,f.copy(u),u.x+=y.x,u.y+=y.y,u.z+=y.z,u.normalize(),a.push(u.x,u.y,u.z),y.copy(f)}for(let s=0;s<=e;s++){const u=r+s*c*o,f=Math.sin(u),y=Math.cos(u);for(let r=0;r<=t.length-1;r++){p.x=t[r].x*f,p.y=t[r].y,p.z=t[r].x*y,h.push(p.x,p.y,p.z),m.x=s/e,m.y=r/(t.length-1),n.push(m.x,m.y);const o=a[3*r+0]*f,c=a[3*r+1],u=a[3*r+0]*y;i.push(o,c,u)}}for(let r=0;r<e;r++)for(let e=0;e<t.length-1;e++){const o=e+r*t.length,h=o,n=o+t.length,a=o+t.length+1,i=o+1;s.push(h,n,i),s.push(a,i,n)}this.setIndex(s),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(n,2)),this.setAttribute("normal",new Float32BufferAttribute(i,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new LatheGeometry(t.points,t.segments,t.phiStart,t.phiLength)}}export{LatheGeometry};
//# sourceMappingURL=LatheGeometry.js.map