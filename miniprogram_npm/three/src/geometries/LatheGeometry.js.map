{"version":3,"file":"node_modules/three/src/geometries/LatheGeometry.js","names":["Float32BufferAttribute","BufferGeometry","Vector3","Vector2","clamp","LatheGeometry","constructor","points","segments","phiStart","phiLength","Math","PI","super","this","type","parameters","floor","indices","vertices","uvs","initNormals","normals","inverseSegments","vertex","uv","normal","curNormal","prevNormal","dx","dy","j","length","x","y","z","copy","normalize","push","i","phi","sin","cos","base","a","b","c","d","setIndex","setAttribute","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/LatheGeometry.js"],"sourcesContent":["import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { clamp } from '../math/MathUtils.js';\n\n/**\n * Creates meshes with axial symmetry like vases. The lathe rotates around the Y axis.\n *\n * ```js\n * const points = [];\n * for ( let i = 0; i < 10; i ++ ) {\n * \tpoints.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );\n * }\n * const geometry = new THREE.LatheGeometry( points );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const lathe = new THREE.Mesh( geometry, material );\n * scene.add( lathe );\n * ```\n *\n * @augments BufferGeometry\n */\nclass LatheGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new lathe geometry.\n\t *\n\t * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point\n\t * must be greater than zero.\n\t * @param {number} [segments=12] - The number of circumference segments to generate.\n\t * @param {number} [phiStart=0] - The starting angle in radians.\n\t * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a\n\t * closed lathe, less than 2PI is a portion.\n\t */\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {LatheGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\n\nexport { LatheGeometry };\n"],"mappings":"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","ignoreList":[]}