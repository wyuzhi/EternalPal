{"version":3,"file":"node_modules/three/src/geometries/PolyhedronGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","PolyhedronGeometry","constructor","vertices","indices","radius","detail","super","this","type","parameters","vertexBuffer","uvBuffer","subdivideFace","a","b","c","cols","v","i","aj","clone","lerp","bj","rows","j","k","Math","floor","pushVertex","vertex","push","x","y","z","getVertexByIndex","index","stride","correctUV","uv","vector","azimuth","PI","atan2","length","subdivide","normalize","multiplyScalar","applyRadius","u","sqrt","centroid","uvA","uvB","uvC","set","copy","add","divideScalar","azi","correctUVs","x0","x1","x2","max","min","correctSeam","generateUVs","setAttribute","slice","computeVertexNormals","normalizeNormals","source","Object","assign","fromJSON","data","details"],"sources":["node_modules/three/src/geometries/PolyhedronGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\n/**\n * A polyhedron is a solid in three dimensions with flat faces. This class\n * will take an array of vertices, project them onto a sphere, and then\n * divide them up to the desired level of detail.\n *\n * @augments BufferGeometry\n */\nclass PolyhedronGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new polyhedron geometry.\n\t *\n\t * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.\n\t * @param {Array<number>} [indices] - A flat array of indices describing the base shape.\n\t * @param {number} [radius=1] - The radius of the shape.\n\t * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.\n\t */\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {PolyhedronGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nexport { PolyhedronGeometry };\n"],"mappings":"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","ignoreList":[]}