import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import{Shape}from"../extras/core/Shape.js";import{ShapeUtils}from"../extras/ShapeUtils.js";import{Vector2}from"../math/Vector2.js";class ShapeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],s=[],o=[],a=[];let h=0,n=0;if(!1===Array.isArray(e))i(e);else for(let t=0;t<e.length;t++)i(e[t]),this.addGroup(h,n,t),h+=n,n=0;function i(e){const h=s.length/3,i=e.extractPoints(t);let p=i.shape;const u=i.holes;!1===ShapeUtils.isClockWise(p)&&(p=p.reverse());for(let e=0,t=u.length;e<t;e++){const t=u[e];!0===ShapeUtils.isClockWise(t)&&(u[e]=t.reverse())}const c=ShapeUtils.triangulateShape(p,u);for(let e=0,t=u.length;e<t;e++){const t=u[e];p=p.concat(t)}for(let e=0,t=p.length;e<t;e++){const t=p[e];s.push(t.x,t.y,0),o.push(0,0,1),a.push(t.x,t.y)}for(let e=0,t=c.length;e<t;e++){const t=c[e],s=t[0]+h,o=t[1]+h,a=t[2]+h;r.push(s,o,a),n+=3}}this.setIndex(r),this.setAttribute("position",new Float32BufferAttribute(s,3)),this.setAttribute("normal",new Float32BufferAttribute(o,3)),this.setAttribute("uv",new Float32BufferAttribute(a,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return toJSON(this.parameters.shapes,e)}static fromJSON(e,t){const r=[];for(let s=0,o=e.shapes.length;s<o;s++){const o=t[e.shapes[s]];r.push(o)}return new ShapeGeometry(r,e.curveSegments)}}function toJSON(e,t){if(t.shapes=[],Array.isArray(e))for(let r=0,s=e.length;r<s;r++){const s=e[r];t.shapes.push(s.uuid)}else t.shapes.push(e.uuid);return t}export{ShapeGeometry};
//# sourceMappingURL=ShapeGeometry.js.map