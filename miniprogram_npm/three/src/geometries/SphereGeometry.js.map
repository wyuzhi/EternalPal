{"version":3,"file":"node_modules/three/src/geometries/SphereGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","SphereGeometry","constructor","radius","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","super","this","type","parameters","max","floor","thetaEnd","min","index","grid","vertex","normal","indices","vertices","normals","uvs","iy","verticesRow","v","uOffset","ix","u","x","cos","sin","y","z","push","copy","normalize","a","b","c","d","setIndex","setAttribute","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/SphereGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n/**\n * A class for generating a sphere geometry.\n *\n * ```js\n * const geometry = new THREE.SphereGeometry( 15, 32, 16 );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const sphere = new THREE.Mesh( geometry, material );\n * scene.add( sphere );\n * ```\n *\n * @augments BufferGeometry\n */\nclass SphereGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new sphere geometry.\n\t *\n\t * @param {number} [radius=1] - The sphere radius.\n\t * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.\n\t * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.\n\t * @param {number} [phiStart=0] - The horizontal starting angle in radians.\n\t * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.\n\t * @param {number} [thetaStart=0] - The vertical starting angle in radians.\n\t * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.\n\t */\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {SphereGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nexport { SphereGeometry };\n"],"mappings":"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","ignoreList":[]}