{"version":3,"file":"node_modules/three/src/geometries/TorusKnotGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Vector3","TorusKnotGeometry","constructor","radius","tube","tubularSegments","radialSegments","p","q","super","this","type","parameters","Math","floor","indices","vertices","normals","uvs","vertex","normal","P1","P2","B","T","N","i","u","PI","calculatePositionOnCurve","subVectors","addVectors","crossVectors","normalize","j","v","cx","cos","cy","sin","x","y","z","push","a","b","c","d","position","cu","su","quOverP","cs","setIndex","setAttribute","copy","source","Object","assign","fromJSON","data"],"sources":["node_modules/three/src/geometries/TorusKnotGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n/**\n * Creates a torus knot, the particular shape of which is defined by a pair\n * of coprime integers, p and q. If p and q are not coprime, the result will\n * be a torus link.\n *\n * ```js\n * const geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const torusKnot = new THREE.Mesh( geometry, material );\n * scene.add( torusKnot );\n * ```\n *\n * @augments BufferGeometry\n */\nclass TorusKnotGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new torus knot geometry.\n\t *\n\t * @param {number} [radius=1] - Radius of the torus knot.\n\t * @param {number} [tube=0.4] - Radius of the tube.\n\t * @param {number} [tubularSegments=64] - The number of tubular segments.\n\t * @param {number} [radialSegments=8] - The number of radial segments.\n\t * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.\n\t * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.\n\t */\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {TorusKnotGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nexport { TorusKnotGeometry };\n"],"mappings":"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","ignoreList":[]}