import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import*as Curves from"../extras/curves/Curves.js";import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";class TubeGeometry extends BufferGeometry{constructor(t=new Curves.QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),e=64,r=1,o=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:r,radialSegments:o,closed:s};const n=t.computeFrenetFrames(e,s);this.tangents=n.tangents,this.normals=n.normals,this.binormals=n.binormals;const u=new Vector3,a=new Vector3,i=new Vector2;let m=new Vector3;const c=[],f=[],p=[],h=[];function l(s){m=t.getPointAt(s/e,m);const i=n.normals[s],p=n.binormals[s];for(let t=0;t<=o;t++){const e=t/o*Math.PI*2,s=Math.sin(e),n=-Math.cos(e);a.x=n*i.x+s*p.x,a.y=n*i.y+s*p.y,a.z=n*i.z+s*p.z,a.normalize(),f.push(a.x,a.y,a.z),u.x=m.x+r*a.x,u.y=m.y+r*a.y,u.z=m.z+r*a.z,c.push(u.x,u.y,u.z)}}!function(){for(let t=0;t<e;t++)l(t);l(!1===s?e:0),function(){for(let t=0;t<=e;t++)for(let r=0;r<=o;r++)i.x=t/e,i.y=r/o,p.push(i.x,i.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=o;e++){const r=(o+1)*(t-1)+(e-1),s=(o+1)*t+(e-1),n=(o+1)*t+e,u=(o+1)*(t-1)+e;h.push(r,s,u),h.push(s,n,u)}}()}(),this.setIndex(h),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(f,3)),this.setAttribute("uv",new Float32BufferAttribute(p,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new TubeGeometry((new Curves[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}export{TubeGeometry};
//# sourceMappingURL=TubeGeometry.js.map