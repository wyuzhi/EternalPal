{"version":3,"file":"node_modules/three/src/geometries/TubeGeometry.js","names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","TubeGeometry","constructor","path","tubularSegments","radius","radialSegments","closed","super","this","type","parameters","frames","computeFrenetFrames","tangents","normals","binormals","vertex","normal","uv","P","vertices","uvs","indices","generateSegment","i","getPointAt","N","B","j","v","Math","PI","sin","cos","x","y","z","normalize","push","generateUVs","a","b","c","d","generateIndices","generateBufferData","setIndex","setAttribute","copy","source","Object","assign","toJSON","data","fromJSON"],"sources":["node_modules/three/src/geometries/TubeGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n/**\n * Creates a tube that extrudes along a 3D curve.\n *\n * ```js\n * class CustomSinCurve extends THREE.Curve {\n *\n * \tgetPoint( t, optionalTarget = new THREE.Vector3() ) {\n *\n * \t\tconst tx = t * 3 - 1.5;\n * \t\tconst ty = Math.sin( 2 * Math.PI * t );\n * \t\tconst tz = 0;\n *\n * \t\treturn optionalTarget.set( tx, ty, tz );\n * \t}\n *\n * }\n *\n * const path = new CustomSinCurve( 10 );\n * const geometry = new THREE.TubeGeometry( path, 20, 2, 8, false );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n * ```\n *\n * @augments BufferGeometry\n */\nclass TubeGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new tube geometry.\n\t *\n\t * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.\n\t * @param {number} [tubularSegments=64] - The number of segments that make up the tube.\n\t * @param {number} [radius=1] -The radius of the tube.\n\t * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.\n\t * @param {boolean} [closed=false] - Whether the tube is closed or not.\n\t */\n\tconstructor( path = new Curves[ 'QuadraticBezierCurve3' ]( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of this class from the given\n\t * JSON object.\n\t *\n\t * @param {Object} data - A JSON object representing the serialized geometry.\n\t * @return {TubeGeometry} A new instance.\n\t */\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\n\nexport { TubeGeometry };\n"],"mappings":"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","ignoreList":[]}