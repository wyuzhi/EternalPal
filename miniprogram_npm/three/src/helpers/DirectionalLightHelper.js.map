{"version":3,"file":"node_modules/three/src/helpers/DirectionalLightHelper.js","names":["Vector3","Object3D","Line","Float32BufferAttribute","BufferGeometry","LineBasicMaterial","_v1","_v2","_v3","DirectionalLightHelper","constructor","light","size","color","super","this","matrix","matrixWorld","matrixAutoUpdate","type","undefined","geometry","setAttribute","material","fog","toneMapped","lightPlane","add","targetLine","update","dispose","updateWorldMatrix","target","setFromMatrixPosition","subVectors","lookAt","set","copy","scale","z","length"],"sources":["node_modules/three/src/helpers/DirectionalLightHelper.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Line } from '../objects/Line.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\n/**\n * Helper object to assist with visualizing a {@link DirectionalLight}'s\n * effect on the scene. This consists of plane and a line representing the\n * light's position and direction.\n *\n * ```js\n * const light = new THREE.DirectionalLight( 0xFFFFFF );\n * scene.add( light );\n *\n * const helper = new THREE.DirectionalLightHelper( light, 5 );\n * scene.add( helper );\n * ```\n *\n * @augments Object3D\n */\nclass DirectionalLightHelper extends Object3D {\n\n\t/**\n\t * Constructs a new directional light helper.\n\t *\n\t * @param {DirectionalLight} light - The light to be visualized.\n\t * @param {number} [size=1] - The dimensions of the plane.\n\t * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take\n\t * the color of the light.\n\t */\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light being visualized.\n\t\t *\n\t\t * @type {DirectionalLight}\n\t\t */\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/**\n\t\t * The color parameter passed in the constructor.\n\t\t * If not set, the helper will take the color of the light.\n\t\t *\n\t\t * @type {number|Color|string}\n\t\t */\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\t/**\n\t\t * Contains the line showing the location of the directional light.\n\t\t *\n\t\t * @type {Line}\n\t\t */\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\t/**\n\t\t * Represents the target line of the directional light.\n\t\t *\n\t\t * @type {Line}\n\t\t */\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\t/**\n\t * Updates the helper to match the position and direction of the\n\t * light being visualized.\n\t */\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\n\nexport { DirectionalLightHelper };\n"],"mappings":"OAASA,YAAe,4BACfC,aAAgB,6BAChBC,SAAY,4BACZC,2BAA8B,oCAC9BC,mBAAsB,mCACtBC,sBAAyB,oCAElC,MAAMC,IAAoB,IAAIN,QACxBO,IAAoB,IAAIP,QACxBQ,IAAoB,IAAIR,QAiB9B,MAAMS,+BAA+BR,SAUpC,WAAAS,CAAaC,EAAOC,EAAMC,GAEzBC,QAOAC,KAAKJ,MAAQA,EAEbI,KAAKC,OAASL,EAAMM,YACpBF,KAAKG,kBAAmB,EAQxBH,KAAKF,MAAQA,EAEbE,KAAKI,KAAO,8BAEEC,IAATR,IAAqBA,EAAO,GAEjC,IAAIS,EAAW,IAAIjB,eACnBiB,EAASC,aAAc,WAAY,IAAInB,uBAAwB,EAC5DS,EAAMA,EAAM,EACdA,EAAMA,EAAM,EACZA,GAAQA,EAAM,GACZA,GAAQA,EAAM,GACdA,EAAMA,EAAM,GACZ,IAEH,MAAMW,EAAW,IAAIlB,kBAAmB,CAAEmB,KAAK,EAAOC,YAAY,IAOlEV,KAAKW,WAAa,IAAIxB,KAAMmB,EAAUE,GACtCR,KAAKY,IAAKZ,KAAKW,YAEfL,EAAW,IAAIjB,eACfiB,EAASC,aAAc,WAAY,IAAInB,uBAAwB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,IAOrFY,KAAKa,WAAa,IAAI1B,KAAMmB,EAAUE,GACtCR,KAAKY,IAAKZ,KAAKa,YAEfb,KAAKc,QAEN,CAMA,OAAAC,GAECf,KAAKW,WAAWL,SAASS,UACzBf,KAAKW,WAAWH,SAASO,UACzBf,KAAKa,WAAWP,SAASS,UACzBf,KAAKa,WAAWL,SAASO,SAE1B,CAMA,MAAAD,GAECd,KAAKJ,MAAMoB,mBAAmB,GAAM,GACpChB,KAAKJ,MAAMqB,OAAOD,mBAAmB,GAAM,GAE3CzB,IAAI2B,sBAAuBlB,KAAKJ,MAAMM,aACtCV,IAAI0B,sBAAuBlB,KAAKJ,MAAMqB,OAAOf,aAC7CT,IAAI0B,WAAY3B,IAAKD,KAErBS,KAAKW,WAAWS,OAAQ5B,UAEJa,IAAfL,KAAKF,OAETE,KAAKW,WAAWH,SAASV,MAAMuB,IAAKrB,KAAKF,OACzCE,KAAKa,WAAWL,SAASV,MAAMuB,IAAKrB,KAAKF,SAIzCE,KAAKW,WAAWH,SAASV,MAAMwB,KAAMtB,KAAKJ,MAAME,OAChDE,KAAKa,WAAWL,SAASV,MAAMwB,KAAMtB,KAAKJ,MAAME,QAIjDE,KAAKa,WAAWO,OAAQ5B,KACxBQ,KAAKa,WAAWU,MAAMC,EAAI/B,IAAIgC,QAE/B,SAKQ/B","ignoreList":[]}