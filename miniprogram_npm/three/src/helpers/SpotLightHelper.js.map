{"version":3,"file":"node_modules/three/src/helpers/SpotLightHelper.js","names":["Vector3","Object3D","LineSegments","LineBasicMaterial","Float32BufferAttribute","BufferGeometry","_vector","SpotLightHelper","constructor","light","color","super","this","matrixAutoUpdate","type","geometry","positions","i","j","l","p1","Math","PI","p2","push","cos","sin","setAttribute","material","fog","toneMapped","cone","add","update","dispose","updateWorldMatrix","target","parent","matrix","copy","matrixWorld","invert","multiply","coneLength","distance","coneWidth","tan","angle","scale","set","setFromMatrixPosition","lookAt","undefined"],"sources":["node_modules/three/src/helpers/SpotLightHelper.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { LineSegments } from '../objects/LineSegments.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\n/**\n * This displays a cone shaped helper object for a {@link SpotLight}.\n *\n * ```js\n * const spotLight = new THREE.SpotLight( 0xffffff );\n * spotLight.position.set( 10, 10, 10 );\n * scene.add( spotLight );\n *\n * const spotLightHelper = new THREE.SpotLightHelper( spotLight );\n * scene.add( spotLightHelper );\n * ```\n *\n * @augments Object3D\n */\nclass SpotLightHelper extends Object3D {\n\n\t/**\n\t * Constructs a new spot light helper.\n\t *\n\t * @param {HemisphereLight} light - The light to be visualized.\n\t * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take\n\t * the color of the light.\n\t */\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light being visualized.\n\t\t *\n\t\t * @type {SpotLight}\n\t\t */\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/**\n\t\t * The color parameter passed in the constructor.\n\t\t * If not set, the helper will take the color of the light.\n\t\t *\n\t\t * @type {number|Color|string}\n\t\t */\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\t/**\n\t * Updates the helper to match the position and direction of the\n\t * light being visualized.\n\t */\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { SpotLightHelper };\n"],"mappings":"OAASA,YAAe,4BACfC,aAAgB,6BAChBC,iBAAoB,oCACpBC,sBAAyB,2CACzBC,2BAA8B,oCAC9BC,mBAAsB,4BAE/B,MAAMC,QAAwB,IAAIN,QAgBlC,MAAMO,wBAAwBN,SAS7B,WAAAO,CAAaC,EAAOC,GAEnBC,QAOAC,KAAKH,MAAQA,EAEbG,KAAKC,kBAAmB,EAQxBD,KAAKF,MAAQA,EAEbE,KAAKE,KAAO,kBAEZ,MAAMC,EAAW,IAAIV,eAEfW,EAAY,CACjB,EAAG,EAAG,EAAI,EAAG,EAAG,EAChB,EAAG,EAAG,EAAI,EAAG,EAAG,EAChB,EAAG,EAAG,GAAK,EAAG,EAAG,EACjB,EAAG,EAAG,EAAI,EAAG,EAAG,EAChB,EAAG,EAAG,EAAI,GAAK,EAAG,GAGnB,IAAM,IAAIC,EAAI,EAAGC,EAAI,EAAGC,EAAI,GAAIF,EAAIE,EAAGF,IAAMC,IAAO,CAEnD,MAAME,EAAOH,EAAIE,EAAME,KAAKC,GAAK,EAC3BC,EAAOL,EAAIC,EAAME,KAAKC,GAAK,EAEjCN,EAAUQ,KACTH,KAAKI,IAAKL,GAAMC,KAAKK,IAAKN,GAAM,EAChCC,KAAKI,IAAKF,GAAMF,KAAKK,IAAKH,GAAM,EAGlC,CAEAR,EAASY,aAAc,WAAY,IAAIvB,uBAAwBY,EAAW,IAE1E,MAAMY,EAAW,IAAIzB,kBAAmB,CAAE0B,KAAK,EAAOC,YAAY,IAElElB,KAAKmB,KAAO,IAAI7B,aAAca,EAAUa,GACxChB,KAAKoB,IAAKpB,KAAKmB,MAEfnB,KAAKqB,QAEN,CAMA,OAAAC,GAECtB,KAAKmB,KAAKhB,SAASmB,UACnBtB,KAAKmB,KAAKH,SAASM,SAEpB,CAMA,MAAAD,GAECrB,KAAKH,MAAM0B,mBAAmB,GAAM,GACpCvB,KAAKH,MAAM2B,OAAOD,mBAAmB,GAAM,GAGtCvB,KAAKyB,QAETzB,KAAKyB,OAAOF,mBAAmB,GAE/BvB,KAAK0B,OACHC,KAAM3B,KAAKyB,OAAOG,aAClBC,SACAC,SAAU9B,KAAKH,MAAM+B,cAIvB5B,KAAK0B,OAAOC,KAAM3B,KAAKH,MAAM+B,aAI9B5B,KAAK4B,YAAYD,KAAM3B,KAAKH,MAAM+B,aAElC,MAAMG,EAAa/B,KAAKH,MAAMmC,SAAWhC,KAAKH,MAAMmC,SAAW,IACzDC,EAAYF,EAAatB,KAAKyB,IAAKlC,KAAKH,MAAMsC,OAEpDnC,KAAKmB,KAAKiB,MAAMC,IAAKJ,EAAWA,EAAWF,GAE3CrC,QAAQ4C,sBAAuBtC,KAAKH,MAAM2B,OAAOI,aAEjD5B,KAAKmB,KAAKoB,OAAQ7C,cAEE8C,IAAfxC,KAAKF,MAETE,KAAKmB,KAAKH,SAASlB,MAAMuC,IAAKrC,KAAKF,OAInCE,KAAKmB,KAAKH,SAASlB,MAAM6B,KAAM3B,KAAKH,MAAMC,MAI5C,SAKQH","ignoreList":[]}