{"version":3,"file":"node_modules/three/src/lights/LightShadow.js","names":["Matrix4","Vector2","Vector3","Vector4","Frustum","UnsignedByteType","_projScreenMatrix","_lightPositionWorld","_lookTarget","LightShadow","constructor","camera","this","intensity","bias","normalBias","radius","blurSamples","mapSize","mapType","map","mapPass","matrix","autoUpdate","needsUpdate","_frustum","_frameExtents","_viewportCount","_viewports","getViewportCount","getFrustum","updateMatrices","light","shadowCamera","shadowMatrix","setFromMatrixPosition","matrixWorld","position","copy","target","lookAt","updateMatrixWorld","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","coordinateSystem","reversedDepth","set","multiply","getViewport","viewportIndex","getFrameExtents","dispose","source","clone","toJSON","object","x","y","toArray"],"sources":["node_modules/three/src/lights/LightShadow.js"],"sourcesContent":["import { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { UnsignedByteType } from '../constants.js';\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\n/**\n * Abstract base class for light shadow classes. These classes\n * represent the shadow configuration for different light types.\n *\n * @abstract\n */\nclass LightShadow {\n\n\t/**\n\t * Constructs a new light shadow.\n\t *\n\t * @param {Camera} camera - The light's view of the world.\n\t */\n\tconstructor( camera ) {\n\n\t\t/**\n\t\t * The light's view of the world.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The intensity of the shadow. The default is `1`.\n\t\t * Valid values are in the range `[0, 1]`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.intensity = 1;\n\n\t\t/**\n\t\t * Shadow map bias, how much to add or subtract from the normalized depth\n\t\t * when deciding whether a surface is in shadow.\n\t\t *\n\t\t * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)\n\t\t * may help reduce artifacts in shadows.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bias = 0;\n\n\t\t/**\n\t\t * Defines how much the position used to query the shadow map is offset along\n\t\t * the object normal. The default is `0`. Increasing this value can be used to\n\t\t * reduce shadow acne especially in large scenes where light shines onto\n\t\t * geometry at a shallow angle. The cost is that shadows may appear distorted.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.normalBias = 0;\n\n\t\t/**\n\t\t * Setting this to values greater than 1 will blur the edges of the shadow.\n\t\t * High values will cause unwanted banding effects in the shadows - a greater\n\t\t * map size will allow for a higher value to be used here before these effects\n\t\t * become visible.\n\t\t *\n\t\t * The property has no effect when the shadow map type is `PCFSoftShadowMap` and\n\t\t * and it is recommended to increase softness by decreasing the shadow map size instead.\n\t\t *\n\t\t * The property has no effect when the shadow map type is `BasicShadowMap`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.radius = 1;\n\n\t\t/**\n\t\t * The amount of samples to use when blurring a VSM shadow map.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 8\n\t\t */\n\t\tthis.blurSamples = 8;\n\n\t\t/**\n\t\t * Defines the width and height of the shadow map. Higher values give better quality\n\t\t * shadows at the cost of computation time. Values must be powers of two.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (512,512)\n\t\t */\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\t/**\n\t\t * The type of shadow texture. The default is `UnsignedByteType`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default UnsignedByteType\n\t\t */\n\t\tthis.mapType = UnsignedByteType;\n\n\t\t/**\n\t\t * The depth map generated using the internal camera; a location beyond a\n\t\t * pixel's depth is in shadow. Computed internally during rendering.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.map = null;\n\n\t\t/**\n\t\t * The distribution map generated using the internal camera; an occlusion is\n\t\t * calculated based on the distribution of depths. Computed internally during\n\t\t * rendering.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.mapPass = null;\n\n\t\t/**\n\t\t * Model to shadow camera space, to compute location and depth in shadow map.\n\t\t * This is computed internally during rendering.\n\t\t *\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis.matrix = new Matrix4();\n\n\t\t/**\n\t\t * Enables automatic updates of the light's shadow. If you do not require dynamic\n\t\t * lighting / shadows, you may set this to `false`.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoUpdate = true;\n\n\t\t/**\n\t\t * When set to `true`, shadow maps will be updated in the next `render` call.\n\t\t * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to\n\t\t * set this property to `true` and then make a render call to update the light's shadow.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\t/**\n\t * Used internally by the renderer to get the number of viewports that need\n\t * to be rendered for this shadow.\n\t *\n\t * @return {number} The viewport count.\n\t */\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\t/**\n\t * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.\n\t *\n\t * @return {Frustum} The shadow camera frustum.\n\t */\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\t/**\n\t * Update the matrices for the camera and shadow, used internally by the renderer.\n\t *\n\t * @param {Light} light - The light for which the shadow is being rendered.\n\t */\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix, shadowCamera.coordinateSystem, shadowCamera.reversedDepth );\n\n\t\tif ( shadowCamera.reversedDepth ) {\n\n\t\t\tshadowMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tshadowMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t}\n\n\t\tshadowMatrix.multiply( _projScreenMatrix );\n\n\t}\n\n\t/**\n\t * Returns a viewport definition for the given viewport index.\n\t *\n\t * @param {number} viewportIndex - The viewport index.\n\t * @return {Vector4} The viewport.\n\t */\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\t/**\n\t * Returns the frame extends.\n\t *\n\t * @return {Vector2} The frame extends.\n\t */\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Copies the values of the given light shadow instance to this instance.\n\t *\n\t * @param {LightShadow} source - The light shadow to copy.\n\t * @return {LightShadow} A reference to this light shadow instance.\n\t */\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.intensity = source.intensity;\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.needsUpdate = source.needsUpdate;\n\t\tthis.normalBias = source.normalBias;\n\t\tthis.blurSamples = source.blurSamples;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new light shadow instance with copied values from this instance.\n\t *\n\t * @return {LightShadow} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Serializes the light shadow into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized light shadow.\n\t * @see {@link ObjectLoader#parse}\n\t */\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.intensity !== 1 ) object.intensity = this.intensity;\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nexport { LightShadow };\n"],"mappings":"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","ignoreList":[]}