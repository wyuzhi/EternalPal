{"version":3,"file":"node_modules/three/src/lights/PointLight.js","names":["Light","PointLightShadow","PointLight","constructor","color","intensity","distance","decay","super","this","isPointLight","type","shadow","power","Math","PI","dispose","copy","source","recursive","clone"],"sources":["node_modules/three/src/lights/PointLight.js"],"sourcesContent":["import { Light } from './Light.js';\nimport { PointLightShadow } from './PointLightShadow.js';\n\n/**\n * A light that gets emitted from a single point in all directions. A common\n * use case for this is to replicate the light emitted from a bare\n * lightbulb.\n *\n * This light can cast shadows - see the {@link PointLightShadow} for details.\n *\n * ```js\n * const light = new THREE.PointLight( 0xff0000, 1, 100 );\n * light.position.set( 50, 50, 50 );\n * scene.add( light );\n * ```\n *\n * @augments Light\n */\nclass PointLight extends Light {\n\n\t/**\n\t * Constructs a new point light.\n\t *\n\t * @param {(number|Color|string)} [color=0xffffff] - The light's color.\n\t * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).\n\t * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.\n\t * @param {number} [decay=2] - The amount the light dims along the distance of the light.\n\t */\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\t/**\n\t\t * When distance is zero, light will attenuate according to inverse-square\n\t\t * law to infinite distance. When distance is non-zero, light will attenuate\n\t\t * according to inverse-square law until near the distance cutoff, where it\n\t\t * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not\n\t\t * physically correct.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.distance = distance;\n\n\t\t/**\n\t\t * The amount the light dims along the distance of the light. In context of\n\t\t * physically-correct rendering the default value should not be changed.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.decay = decay;\n\n\t\t/**\n\t\t * This property holds the light's shadow configuration.\n\t\t *\n\t\t * @type {PointLightShadow}\n\t\t */\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\t/**\n\t * The light's power. Power is the luminous power of the light measured in lumens (lm).\n\t * Changing the power will also change the light's intensity.\n\t *\n\t * @type {number}\n\t */\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4 Ï€ luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { PointLight };\n"],"mappings":"OAASA,UAAa,oBACbC,qBAAwB,wBAiBjC,MAAMC,mBAAmBF,MAUxB,WAAAG,CAAaC,EAAOC,EAAWC,EAAW,EAAGC,EAAQ,GAEpDC,MAAOJ,EAAOC,GASdI,KAAKC,cAAe,EAEpBD,KAAKE,KAAO,aAYZF,KAAKH,SAAWA,EAShBG,KAAKF,MAAQA,EAObE,KAAKG,OAAS,IAAIX,gBAEnB,CAQA,SAAIY,GAIH,OAAwB,EAAjBJ,KAAKJ,UAAgBS,KAAKC,EAElC,CAEA,SAAIF,CAAOA,GAGVJ,KAAKJ,UAAYQ,GAAU,EAAIC,KAAKC,GAErC,CAEA,OAAAC,GAECP,KAAKG,OAAOI,SAEb,CAEA,IAAAC,CAAMC,EAAQC,GASb,OAPAX,MAAMS,KAAMC,EAAQC,GAEpBV,KAAKH,SAAWY,EAAOZ,SACvBG,KAAKF,MAAQW,EAAOX,MAEpBE,KAAKG,OAASM,EAAON,OAAOQ,QAErBX,IAER,SAIQP","ignoreList":[]}