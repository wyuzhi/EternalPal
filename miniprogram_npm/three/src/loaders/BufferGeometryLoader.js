import{Sphere}from"../math/Sphere.js";import{BufferAttribute}from"../core/BufferAttribute.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{FileLoader}from"./FileLoader.js";import{Loader}from"./Loader.js";import{InstancedBufferGeometry}from"../core/InstancedBufferGeometry.js";import{InstancedBufferAttribute}from"../core/InstancedBufferAttribute.js";import{InterleavedBufferAttribute}from"../core/InterleavedBufferAttribute.js";import{InterleavedBuffer}from"../core/InterleavedBuffer.js";import{getTypedArray}from"../utils.js";class BufferGeometryLoader extends Loader{constructor(e){super(e)}load(e,t,r,a){const o=this,n=new FileLoader(o.manager);n.setPath(o.path),n.setRequestHeader(o.requestHeader),n.setWithCredentials(o.withCredentials),n.load(e,(function(r){try{t(o.parse(JSON.parse(r)))}catch(t){a?a(t):console.error(t),o.manager.itemError(e)}}),r,a)}parse(e){const t={},r={};function a(e,a){if(void 0!==t[a])return t[a];const o=e.interleavedBuffers[a],n=function(e,t){if(void 0!==r[t])return r[t];const a=e.arrayBuffers,o=a[t],n=new Uint32Array(o).buffer;return r[t]=n,n}(e,o.buffer),f=getTypedArray(o.type,n),s=new InterleavedBuffer(f,o.stride);return s.uuid=o.uuid,t[a]=s,s}const o=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,n=e.data.index;if(void 0!==n){const e=getTypedArray(n.type,n.array);o.setIndex(new BufferAttribute(e,1))}const f=e.data.attributes;for(const t in f){const r=f[t];let n;if(r.isInterleavedBufferAttribute){const t=a(e.data,r.data);n=new InterleavedBufferAttribute(t,r.itemSize,r.offset,r.normalized)}else{const e=getTypedArray(r.type,r.array);n=new(r.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute)(e,r.itemSize,r.normalized)}void 0!==r.name&&(n.name=r.name),void 0!==r.usage&&n.setUsage(r.usage),o.setAttribute(t,n)}const s=e.data.morphAttributes;if(s)for(const t in s){const r=s[t],n=[];for(let t=0,o=r.length;t<o;t++){const o=r[t];let f;if(o.isInterleavedBufferAttribute){const t=a(e.data,o.data);f=new InterleavedBufferAttribute(t,o.itemSize,o.offset,o.normalized)}else{const e=getTypedArray(o.type,o.array);f=new BufferAttribute(e,o.itemSize,o.normalized)}void 0!==o.name&&(f.name=o.name),n.push(f)}o.morphAttributes[t]=n}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const i=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==i)for(let e=0,t=i.length;e!==t;++e){const t=i[e];o.addGroup(t.start,t.count,t.materialIndex)}const u=e.data.boundingSphere;return void 0!==u&&(o.boundingSphere=(new Sphere).fromJSON(u)),e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}export{BufferGeometryLoader};
//# sourceMappingURL=BufferGeometryLoader.js.map