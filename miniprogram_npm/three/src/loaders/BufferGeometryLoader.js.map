{"version":3,"file":"node_modules/three/src/loaders/BufferGeometryLoader.js","names":["Sphere","BufferAttribute","BufferGeometry","FileLoader","Loader","InstancedBufferGeometry","InstancedBufferAttribute","InterleavedBufferAttribute","InterleavedBuffer","getTypedArray","BufferGeometryLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","JSON","e","console","error","itemError","json","interleavedBufferMap","arrayBufferMap","getInterleavedBuffer","uuid","undefined","interleavedBuffer","interleavedBuffers","buffer","arrayBuffers","arrayBuffer","ab","Uint32Array","getArrayBuffer","array","type","ib","stride","geometry","isInstancedBufferGeometry","index","data","typedArray","setIndex","attributes","key","attribute","bufferAttribute","isInterleavedBufferAttribute","itemSize","offset","normalized","isInstancedBufferAttribute","name","usage","setUsage","setAttribute","morphAttributes","attributeArray","i","il","length","push","morphTargetsRelative","groups","drawcalls","offsets","n","group","addGroup","start","count","materialIndex","boundingSphere","fromJSON","userData"],"sources":["node_modules/three/src/loaders/BufferGeometryLoader.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { FileLoader } from './FileLoader.js';\nimport { Loader } from './Loader.js';\nimport { InstancedBufferGeometry } from '../core/InstancedBufferGeometry.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\nimport { getTypedArray } from '../utils.js';\n\n/**\n * Class for loading geometries. The files are internally\n * loaded via {@link FileLoader}.\n *\n * ```js\n * const loader = new THREE.BufferGeometryLoader();\n * const geometry = await loader.loadAsync( 'models/json/pressure.json' );\n *\n * const material = new THREE.MeshBasicMaterial( { color: 0xF5F5F5 } );\n * const object = new THREE.Mesh( geometry, material );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n */\nclass BufferGeometryLoader extends Loader {\n\n\t/**\n\t * Constructs a new geometry loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given JSON object and returns a geometry.\n\t *\n\t * @param {Object} json - The serialized geometry.\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tgeometry.boundingSphere = new Sphere().fromJSON( boundingSphere );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nexport { BufferGeometryLoader };\n"],"mappings":"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","ignoreList":[]}