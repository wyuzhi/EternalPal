import{LinearFilter}from"../constants.js";import{FileLoader}from"./FileLoader.js";import{CompressedTexture}from"../textures/CompressedTexture.js";import{Loader}from"./Loader.js";class CompressedTextureLoader extends Loader{constructor(e){super(e)}load(e,t,r,i){const a=this,s=[],m=new CompressedTexture,o=new FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(a.withCredentials);let p=0;function n(n){o.load(e[n],(function(e){const r=a.parse(e,!0);s[n]={width:r.width,height:r.height,format:r.format,mipmaps:r.mipmaps},p+=1,6===p&&(1===r.mipmapCount&&(m.minFilter=LinearFilter),m.image=s,m.format=r.format,m.needsUpdate=!0,t&&t(m))}),r,i)}if(Array.isArray(e))for(let t=0,r=e.length;t<r;++t)n(t);else o.load(e,(function(e){const r=a.parse(e,!0);if(r.isCubemap){const e=r.mipmaps.length/r.mipmapCount;for(let t=0;t<e;t++){s[t]={mipmaps:[]};for(let e=0;e<r.mipmapCount;e++)s[t].mipmaps.push(r.mipmaps[t*r.mipmapCount+e]),s[t].format=r.format,s[t].width=r.width,s[t].height=r.height}m.image=s}else m.image.width=r.width,m.image.height=r.height,m.mipmaps=r.mipmaps;1===r.mipmapCount&&(m.minFilter=LinearFilter),m.format=r.format,m.needsUpdate=!0,t&&t(m)}),r,i);return m}}export{CompressedTextureLoader};
//# sourceMappingURL=CompressedTextureLoader.js.map