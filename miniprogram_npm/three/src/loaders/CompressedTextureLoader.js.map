{"version":3,"file":"node_modules/three/src/loaders/CompressedTextureLoader.js","names":["LinearFilter","FileLoader","CompressedTexture","Loader","CompressedTextureLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","images","texture","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loaded","loadTexture","i","buffer","texDatas","parse","width","height","format","mipmaps","mipmapCount","minFilter","image","needsUpdate","Array","isArray","il","length","isCubemap","faces","f","push"],"sources":["node_modules/three/src/loaders/CompressedTextureLoader.js"],"sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * Abstract base class for loading compressed texture formats S3TC, ASTC or ETC.\n * Textures are internally loaded via {@link FileLoader}.\n *\n * Derived classes have to implement the `parse()` method which holds the parsing\n * for the respective format.\n *\n * @abstract\n * @augments Loader\n */\nclass CompressedTextureLoader extends Loader {\n\n\t/**\n\t * Constructs a new compressed texture loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded compressed texture\n\t * to the `onLoad()` callback. The method also returns a new texture object which can\n\t * directly be used for material creation. If you do it this way, the texture\n\t * may pop up in your scene once the respective loading process is finished.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(CompressedTexture)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {CompressedTexture} The compressed texture.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Represents the result object type of the `parse()` method.\n *\n * @typedef {Object} CompressedTextureLoader~TexData\n * @property {number} width - The width of the base mip.\n * @property {number} height - The width of the base mip.\n * @property {boolean} isCubemap - Whether the data represent a cubemap or not.\n * @property {number} mipmapCount - The mipmap count.\n * @property {Array<{data:TypedArray,width:number,height:number}>} mipmaps - An array holding the mipmaps.\n * Each entry holds the data and the dimensions for each level.\n * @property {number} format - The texture format.\n **/\n\nexport { CompressedTextureLoader };\n"],"mappings":"OAASA,iBAAoB,yBACpBC,eAAkB,yBAClBC,sBAAyB,0CACzBC,WAAc,cAYvB,MAAMC,gCAAgCD,OAOrC,WAAAE,CAAaC,GAEZC,MAAOD,EAER,CAcA,IAAAE,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQC,KAERC,EAAS,GAETC,EAAU,IAAId,kBAEde,EAAS,IAAIhB,WAAYa,KAAKR,SACpCW,EAAOC,QAASJ,KAAKK,MACrBF,EAAOG,gBAAiB,eACxBH,EAAOI,iBAAkBP,KAAKQ,eAC9BL,EAAOM,mBAAoBV,EAAMW,iBAEjC,IAAIC,EAAS,EAEb,SAASC,EAAaC,GAErBV,EAAOT,KAAMC,EAAKkB,IAAK,SAAWC,GAEjC,MAAMC,EAAWhB,EAAMiB,MAAOF,GAAQ,GAEtCb,EAAQY,GAAM,CACbI,MAAOF,EAASE,MAChBC,OAAQH,EAASG,OACjBC,OAAQJ,EAASI,OACjBC,QAASL,EAASK,SAGnBT,GAAU,EAEM,IAAXA,IAE0B,IAAzBI,EAASM,cAAoBnB,EAAQoB,UAAYpC,cAEtDgB,EAAQqB,MAAQtB,EAChBC,EAAQiB,OAASJ,EAASI,OAC1BjB,EAAQsB,aAAc,EAEjB5B,GAASA,EAAQM,GAIxB,GAAGL,EAAYC,EAEhB,CAEA,GAAK2B,MAAMC,QAAS/B,GAEnB,IAAM,IAAIkB,EAAI,EAAGc,EAAKhC,EAAIiC,OAAQf,EAAIc,IAAOd,EAE5CD,EAAaC,QAQdV,EAAOT,KAAMC,GAAK,SAAWmB,GAE5B,MAAMC,EAAWhB,EAAMiB,MAAOF,GAAQ,GAEtC,GAAKC,EAASc,UAAY,CAEzB,MAAMC,EAAQf,EAASK,QAAQQ,OAASb,EAASM,YAEjD,IAAM,IAAIU,EAAI,EAAGA,EAAID,EAAOC,IAAO,CAElC9B,EAAQ8B,GAAM,CAAEX,QAAS,IAEzB,IAAM,IAAIP,EAAI,EAAGA,EAAIE,EAASM,YAAaR,IAE1CZ,EAAQ8B,GAAIX,QAAQY,KAAMjB,EAASK,QAASW,EAAIhB,EAASM,YAAcR,IACvEZ,EAAQ8B,GAAIZ,OAASJ,EAASI,OAC9BlB,EAAQ8B,GAAId,MAAQF,EAASE,MAC7BhB,EAAQ8B,GAAIb,OAASH,EAASG,MAIhC,CAEAhB,EAAQqB,MAAQtB,CAEjB,MAECC,EAAQqB,MAAMN,MAAQF,EAASE,MAC/Bf,EAAQqB,MAAML,OAASH,EAASG,OAChChB,EAAQkB,QAAUL,EAASK,QAIE,IAAzBL,EAASM,cAEbnB,EAAQoB,UAAYpC,cAIrBgB,EAAQiB,OAASJ,EAASI,OAC1BjB,EAAQsB,aAAc,EAEjB5B,GAASA,EAAQM,EAEvB,GAAGL,EAAYC,GAIhB,OAAOI,CAER,SAiBQZ","ignoreList":[]}