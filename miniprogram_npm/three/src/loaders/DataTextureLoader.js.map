{"version":3,"file":"node_modules/three/src/loaders/DataTextureLoader.js","names":["LinearFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","FileLoader","DataTexture","Loader","DataTextureLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","texture","loader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","buffer","texData","parse","error","undefined","console","image","data","width","height","wrapS","wrapT","magFilter","minFilter","anisotropy","colorSpace","flipY","format","type","mipmaps","mipmapCount","generateMipmaps","needsUpdate"],"sources":["node_modules/three/src/loaders/DataTextureLoader.js"],"sourcesContent":["import { LinearFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * Abstract base class for loading binary texture formats RGBE, EXR or TGA.\n * Textures are internally loaded via {@link FileLoader}.\n *\n * Derived classes have to implement the `parse()` method which holds the parsing\n * for the respective format.\n *\n * @abstract\n * @augments Loader\n */\nclass DataTextureLoader extends Loader {\n\n\t/**\n\t * Constructs a new data texture loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded data texture\n\t * to the `onLoad()` callback. The method also returns a new texture object which can\n\t * directly be used for material creation. If you do it this way, the texture\n\t * may pop up in your scene once the respective loading process is finished.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(DataTexture)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {DataTexture} The data texture.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Represents the result object type of the `parse()` method.\n *\n * @typedef {Object} DataTextureLoader~TexData\n * @property {Object} [image] - An object holding width, height and the texture data.\n * @property {number} [width] - The width of the base mip.\n * @property {number} [height] - The width of the base mip.\n * @property {TypedArray} [data] - The texture data.\n * @property {number} [format] - The texture format.\n * @property {number} [type] - The texture type.\n * @property {boolean} [flipY] - If set to `true`, the texture is flipped along the vertical axis when uploaded to the GPU.\n * @property {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n * @property {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n * @property {number} [anisotropy=1] - The anisotropy value.\n * @property {boolean} [generateMipmaps] - Whether to generate mipmaps or not.\n * @property {string} [colorSpace] - The color space.\n * @property {number} [magFilter] - The mag filter.\n * @property {number} [minFilter] - The min filter.\n * @property {Array<Object>} [mipmaps] - The mipmaps.\n **/\n\nexport { DataTextureLoader };\n"],"mappings":"OAASA,aAAcC,yBAA0BC,wBAA2B,yBACnEC,eAAkB,yBAClBC,gBAAmB,oCACnBC,WAAc,cAYvB,MAAMC,0BAA0BD,OAO/B,WAAAE,CAAaC,GAEZC,MAAOD,EAER,CAcA,IAAAE,CAAMC,EAAKC,EAAQC,EAAYC,GAE9B,MAAMC,EAAQC,KAERC,EAAU,IAAIb,YAEdc,EAAS,IAAIf,WAAYa,KAAKR,SAkGpC,OAjGAU,EAAOC,gBAAiB,eACxBD,EAAOE,iBAAkBJ,KAAKK,eAC9BH,EAAOI,QAASN,KAAKO,MACrBL,EAAOM,mBAAoBT,EAAMU,iBACjCP,EAAOR,KAAMC,GAAK,SAAWe,GAE5B,IAAIC,EAEJ,IAECA,EAAUZ,EAAMa,MAAOF,EAExB,CAAE,MAAQG,GAET,QAAiBC,IAAZhB,EAOJ,YADAiB,QAAQF,MAAOA,GAJff,EAASe,EASX,MAEuBC,IAAlBH,EAAQK,MAEZf,EAAQe,MAAQL,EAAQK,WAEIF,IAAjBH,EAAQM,OAEnBhB,EAAQe,MAAME,MAAQP,EAAQO,MAC9BjB,EAAQe,MAAMG,OAASR,EAAQQ,OAC/BlB,EAAQe,MAAMC,KAAON,EAAQM,MAI9BhB,EAAQmB,WAA0BN,IAAlBH,EAAQS,MAAsBT,EAAQS,MAAQlC,oBAC9De,EAAQoB,WAA0BP,IAAlBH,EAAQU,MAAsBV,EAAQU,MAAQnC,oBAE9De,EAAQqB,eAAkCR,IAAtBH,EAAQW,UAA0BX,EAAQW,UAAYtC,aAC1EiB,EAAQsB,eAAkCT,IAAtBH,EAAQY,UAA0BZ,EAAQY,UAAYvC,aAE1EiB,EAAQuB,gBAAoCV,IAAvBH,EAAQa,WAA2Bb,EAAQa,WAAa,OAEjDV,IAAvBH,EAAQc,aAEZxB,EAAQwB,WAAad,EAAQc,iBAIPX,IAAlBH,EAAQe,QAEZzB,EAAQyB,MAAQf,EAAQe,YAIDZ,IAAnBH,EAAQgB,SAEZ1B,EAAQ0B,OAAShB,EAAQgB,aAIJb,IAAjBH,EAAQiB,OAEZ3B,EAAQ2B,KAAOjB,EAAQiB,WAICd,IAApBH,EAAQkB,UAEZ5B,EAAQ4B,QAAUlB,EAAQkB,QAC1B5B,EAAQsB,UAAYtC,0BAIQ,IAAxB0B,EAAQmB,cAEZ7B,EAAQsB,UAAYvC,mBAIY8B,IAA5BH,EAAQoB,kBAEZ9B,EAAQ8B,gBAAkBpB,EAAQoB,iBAInC9B,EAAQ+B,aAAc,EAEjBpC,GAASA,EAAQK,EAASU,EAEhC,GAAGd,EAAYC,GAGRG,CAER,SAyBQX","ignoreList":[]}