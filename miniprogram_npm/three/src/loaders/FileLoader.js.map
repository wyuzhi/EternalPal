{"version":3,"file":"node_modules/three/src/loaders/FileLoader.js","names":["Cache","Loader","loading","HttpError","Error","constructor","message","response","super","this","FileLoader","manager","mimeType","responseType","_abortController","AbortController","load","url","onLoad","onProgress","onError","undefined","path","resolveURL","cached","get","itemStart","setTimeout","itemEnd","push","req","Request","headers","Headers","requestHeader","credentials","withCredentials","signal","AbortSignal","any","abortController","fetch","then","status","console","warn","ReadableStream","body","getReader","callbacks","reader","contentLength","total","parseInt","lengthComputable","loaded","stream","start","controller","readData","read","done","value","close","byteLength","event","ProgressEvent","i","il","length","callback","enqueue","e","error","Response","statusText","arrayBuffer","blob","text","DOMParser","parseFromString","json","exec","label","toLowerCase","decoder","TextDecoder","ab","decode","data","add","catch","err","itemError","finally","setResponseType","setMimeType","abort"],"sources":["node_modules/three/src/loaders/FileLoader.js"],"sourcesContent":["import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\n/**\n * A low level class for loading resources with the Fetch API, used internally by\n * most loaders. It can also be used directly to load any file type that does\n * not have a loader.\n *\n * This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`\n * once to your application.\n *\n * ```js\n * const loader = new THREE.FileLoader();\n * const data = await loader.loadAsync( 'example.txt' );\n * ```\n *\n * @augments Loader\n */\nclass FileLoader extends Loader {\n\n\t/**\n\t * Constructs a new file loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The expected mime type. Valid values can be found\n\t\t * [here]{@link hhttps://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#mimetype}\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.mimeType = '';\n\n\t\t/**\n\t\t * The expected response type.\n\t\t *\n\t\t * @type {('arraybuffer'|'blob'|'document'|'json'|'')}\n\t\t * @default ''\n\t\t */\n\t\tthis.responseType = '';\n\n\t\t/**\n\t\t * Used for aborting requests.\n\t\t *\n\t\t * @private\n\t\t * @type {AbortController}\n\t\t */\n\t\tthis._abortController = new AbortController();\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(any)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.\n\t * @param {onErrorCallback} [onError] - Executed when errors occur.\n\t * @return {any|undefined} The cached resource if available.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( `file:${url}` );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: ( typeof AbortSignal.any === 'function' ) ? AbortSignal.any( [ this._abortController.signal, this.manager.abortController.signal ] ) : this._abortController.signal\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}, ( e ) => {\n\n\t\t\t\t\t\t\t\t\tcontroller.error( e );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === '' ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( `file:${url}`, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\t/**\n\t * Sets the expected response type.\n\t *\n\t * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.\n\t * @return {FileLoader} A reference to this file loader.\n\t */\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the expected mime type of the loaded file.\n\t *\n\t * @param {string} value - The mime type.\n\t * @return {FileLoader} A reference to this file loader.\n\t */\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Aborts ongoing fetch requests.\n\t *\n\t * @return {FileLoader} A reference to this instance.\n\t */\n\tabort() {\n\n\t\tthis._abortController.abort();\n\t\tthis._abortController = new AbortController();\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { FileLoader };\n"],"mappings":"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","ignoreList":[]}