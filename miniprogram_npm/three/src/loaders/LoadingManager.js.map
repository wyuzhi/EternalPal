{"version":3,"file":"node_modules/three/src/loaders/LoadingManager.js","names":["LoadingManager","constructor","onLoad","onProgress","onError","scope","this","urlModifier","isLoading","itemsLoaded","itemsTotal","handlers","onStart","undefined","abortController","AbortController","itemStart","url","itemEnd","itemError","resolveURL","setURLModifier","transform","addHandler","regex","loader","push","removeHandler","index","indexOf","splice","getHandler","file","i","l","length","global","lastIndex","test","abort","DefaultLoadingManager"],"sources":["node_modules/three/src/loaders/LoadingManager.js"],"sourcesContent":["/**\n * Handles and keeps track of loaded and pending data. A default global\n * instance of this class is created and used by loaders if not supplied\n * manually.\n *\n * In general that should be sufficient, however there are times when it can\n * be useful to have separate loaders - for example if you want to show\n * separate loading bars for objects and textures.\n *\n * ```js\n * const manager = new THREE.LoadingManager();\n * manager.onLoad = () => console.log( 'Loading complete!' );\n *\n * const loader1 = new OBJLoader( manager );\n * const loader2 = new ColladaLoader( manager );\n * ```\n */\nclass LoadingManager {\n\n\t/**\n\t * Constructs a new loading manager.\n\t *\n\t * @param {Function} [onLoad] - Executes when all items have been loaded.\n\t * @param {Function} [onProgress] - Executes when single items have been loaded.\n\t * @param {Function} [onError] - Executes when an error occurs.\n\t */\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\t/**\n\t\t * Executes when an item starts loading.\n\t\t *\n\t\t * @type {Function|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.onStart = undefined;\n\n\t\t/**\n\t\t * Executes when all items have been loaded.\n\t\t *\n\t\t * @type {Function|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t\t/**\n\t\t * Executes when single items have been loaded.\n\t\t *\n\t\t * @type {Function|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.onProgress = onProgress;\n\n\t\t/**\n\t\t * Executes when an error occurs.\n\t\t *\n\t\t * @type {Function|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.onError = onError;\n\n\t\t/**\n\t\t * Used for aborting ongoing requests in loaders using this manager.\n\t\t *\n\t\t * @type {AbortController}\n\t\t */\n\t\tthis.abortController = new AbortController();\n\n\t\t/**\n\t\t * This should be called by any loader using the manager when the loader\n\t\t * starts loading an item.\n\t\t *\n\t\t * @param {string} url - The URL to load.\n\t\t */\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\t/**\n\t\t * This should be called by any loader using the manager when the loader\n\t\t * ended loading an item.\n\t\t *\n\t\t * @param {string} url - The URL of the loaded item.\n\t\t */\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * This should be called by any loader using the manager when the loader\n\t\t * encounters an error when loading an item.\n\t\t *\n\t\t * @param {string} url - The URL of the item that produces an error.\n\t\t */\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Given a URL, uses the URL modifier callback (if any) and returns a\n\t\t * resolved URL. If no URL modifier is set, returns the original URL.\n\t\t *\n\t\t * @param {string} url - The URL to load.\n\t\t * @return {string} The resolved URL.\n\t\t */\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\t/**\n\t\t * If provided, the callback will be passed each resource URL before a\n\t\t * request is sent. The callback may return the original URL, or a new URL to\n\t\t * override loading behavior. This behavior can be used to load assets from\n\t\t * .ZIP files, drag-and-drop APIs, and Data URIs.\n\t\t *\n\t\t * ```js\n\t\t * const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};\n\t\t *\n\t\t * const manager = new THREE.LoadingManager();\n\t\t *\n\t\t * // Initialize loading manager with URL callback.\n\t\t * const objectURLs = [];\n\t\t * manager.setURLModifier( ( url ) => {\n\t\t *\n\t\t * \turl = URL.createObjectURL( blobs[ url ] );\n\t\t * \tobjectURLs.push( url );\n\t\t * \treturn url;\n\t\t *\n\t\t * } );\n\t\t *\n\t\t * // Load as usual, then revoke the blob URLs.\n\t\t * const loader = new GLTFLoader( manager );\n\t\t * loader.load( 'fish.gltf', (gltf) => {\n\t\t *\n\t\t * \tscene.add( gltf.scene );\n\t\t * \tobjectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );\n\t\t *\n\t\t * } );\n\t\t * ```\n\t\t *\n\t\t * @param {function(string):string} transform - URL modifier callback. Called with an URL and must return a resolved URL.\n\t\t * @return {LoadingManager} A reference to this loading manager.\n\t\t */\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Registers a loader with the given regular expression. Can be used to\n\t\t * define what loader should be used in order to load specific files. A\n\t\t * typical use case is to overwrite the default loader for textures.\n\t\t *\n\t\t * ```js\n\t\t * // add handler for TGA textures\n\t\t * manager.addHandler( /\\.tga$/i, new TGALoader() );\n\t\t * ```\n\t\t *\n\t\t * @param {string} regex - A regular expression.\n\t\t * @param {Loader} loader - A loader that should handle matched cases.\n\t\t * @return {LoadingManager} A reference to this loading manager.\n\t\t */\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Removes the loader for the given regular expression.\n\t\t *\n\t\t * @param {string} regex - A regular expression.\n\t\t * @return {LoadingManager} A reference to this loading manager.\n\t\t */\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Can be used to retrieve the registered loader for the given file path.\n\t\t *\n\t\t * @param {string} file - The file path.\n\t\t * @return {?Loader} The registered loader. Returns `null` if no loader was found.\n\t\t */\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\t/**\n\t\t * Can be used to abort ongoing loading requests in loaders using this manager.\n\t\t * The abort only works if the loaders implement {@link Loader#abort} and `AbortSignal.any()`\n\t\t * is supported in the browser.\n\t\t *\n\t\t * @return {LoadingManager} A reference to this loading manager.\n\t\t */\n\t\tthis.abort = function () {\n\n\t\t\tthis.abortController.abort();\n\t\t\tthis.abortController = new AbortController();\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}\n\n}\n\n/**\n * The global default loading manager.\n *\n * @constant\n * @type {LoadingManager}\n */\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nexport { DefaultLoadingManager, LoadingManager };\n"],"mappings":"AAiBA,MAAMA,eASL,WAAAC,CAAaC,EAAQC,EAAYC,GAEhC,MAAMC,EAAQC,KAEd,IAGIC,EAHAC,GAAY,EACZC,EAAc,EACdC,EAAa,EAEjB,MAAMC,EAAW,GAWjBL,KAAKM,aAAUC,EAQfP,KAAKJ,OAASA,EAQdI,KAAKH,WAAaA,EAQlBG,KAAKF,QAAUA,EAOfE,KAAKQ,gBAAkB,IAAIC,gBAQ3BT,KAAKU,UAAY,SAAWC,GAE3BP,KAEmB,IAAdF,QAEmBK,IAAlBR,EAAMO,SAEVP,EAAMO,QAASK,EAAKR,EAAaC,GAMnCF,GAAY,CAEb,EAQAF,KAAKY,QAAU,SAAWD,GAEzBR,SAE0BI,IAArBR,EAAMF,YAEVE,EAAMF,WAAYc,EAAKR,EAAaC,GAIhCD,IAAgBC,IAEpBF,GAAY,OAEUK,IAAjBR,EAAMH,QAEVG,EAAMH,SAMT,EAQAI,KAAKa,UAAY,SAAWF,QAEJJ,IAAlBR,EAAMD,SAEVC,EAAMD,QAASa,EAIjB,EASAX,KAAKc,WAAa,SAAWH,GAE5B,OAAKV,EAEGA,EAAaU,GAIdA,CAER,EAoCAX,KAAKe,eAAiB,SAAWC,GAIhC,OAFAf,EAAce,EAEPhB,IAER,EAgBAA,KAAKiB,WAAa,SAAWC,EAAOC,GAInC,OAFAd,EAASe,KAAMF,EAAOC,GAEfnB,IAER,EAQAA,KAAKqB,cAAgB,SAAWH,GAE/B,MAAMI,EAAQjB,EAASkB,QAASL,GAQhC,OANiB,IAAZI,GAEJjB,EAASmB,OAAQF,EAAO,GAIlBtB,IAER,EAQAA,KAAKyB,WAAa,SAAWC,GAE5B,IAAM,IAAIC,EAAI,EAAGC,EAAIvB,EAASwB,OAAQF,EAAIC,EAAGD,GAAK,EAAI,CAErD,MAAMT,EAAQb,EAAUsB,GAClBR,EAASd,EAAUsB,EAAI,GAI7B,GAFKT,EAAMY,SAASZ,EAAMa,UAAY,GAEjCb,EAAMc,KAAMN,GAEhB,OAAOP,CAIT,CAEA,OAAO,IAER,EASAnB,KAAKiC,MAAQ,WAKZ,OAHAjC,KAAKQ,gBAAgByB,QACrBjC,KAAKQ,gBAAkB,IAAIC,gBAEpBT,IAER,CAED,EAUD,MAAMkC,sBAAsC,IAAIxC,sBAEvCwC,sBAAuBxC","ignoreList":[]}