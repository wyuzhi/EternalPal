import{UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping,RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping,NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter}from"../constants.js";import{InstancedBufferAttribute}from"../core/InstancedBufferAttribute.js";import{Color}from"../math/Color.js";import{Object3D}from"../core/Object3D.js";import{Group}from"../objects/Group.js";import{InstancedMesh}from"../objects/InstancedMesh.js";import{BatchedMesh}from"../objects/BatchedMesh.js";import{Sprite}from"../objects/Sprite.js";import{Points}from"../objects/Points.js";import{Line}from"../objects/Line.js";import{LineLoop}from"../objects/LineLoop.js";import{LineSegments}from"../objects/LineSegments.js";import{LOD}from"../objects/LOD.js";import{Mesh}from"../objects/Mesh.js";import{SkinnedMesh}from"../objects/SkinnedMesh.js";import{Bone}from"../objects/Bone.js";import{Skeleton}from"../objects/Skeleton.js";import{Shape}from"../extras/core/Shape.js";import{Fog}from"../scenes/Fog.js";import{FogExp2}from"../scenes/FogExp2.js";import{HemisphereLight}from"../lights/HemisphereLight.js";import{SpotLight}from"../lights/SpotLight.js";import{PointLight}from"../lights/PointLight.js";import{DirectionalLight}from"../lights/DirectionalLight.js";import{AmbientLight}from"../lights/AmbientLight.js";import{RectAreaLight}from"../lights/RectAreaLight.js";import{LightProbe}from"../lights/LightProbe.js";import{OrthographicCamera}from"../cameras/OrthographicCamera.js";import{PerspectiveCamera}from"../cameras/PerspectiveCamera.js";import{Scene}from"../scenes/Scene.js";import{CubeTexture}from"../textures/CubeTexture.js";import{Texture}from"../textures/Texture.js";import{Source}from"../textures/Source.js";import{DataTexture}from"../textures/DataTexture.js";import{ImageLoader}from"./ImageLoader.js";import{LoadingManager}from"./LoadingManager.js";import{AnimationClip}from"../animation/AnimationClip.js";import{MaterialLoader}from"./MaterialLoader.js";import{LoaderUtils}from"./LoaderUtils.js";import{BufferGeometryLoader}from"./BufferGeometryLoader.js";import{Loader}from"./Loader.js";import{FileLoader}from"./FileLoader.js";import*as Geometries from"../geometries/Geometries.js";import{getTypedArray}from"../utils.js";import{Box3}from"../math/Box3.js";import{Sphere}from"../math/Sphere.js";class ObjectLoader extends Loader{constructor(e){super(e)}load(e,t,r,o){const i=this,a=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const n=new FileLoader(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(e,(function(r){let a=null;try{a=JSON.parse(r)}catch(t){return void 0!==o&&o(t),void console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message)}const n=a.metadata;if(void 0===n||void 0===n.type||"geometry"===n.type.toLowerCase())return void 0!==o&&o(new Error("THREE.ObjectLoader: Can't load "+e)),void console.error("THREE.ObjectLoader: Can't load "+e);i.parse(a,t)}),r,o)}async loadAsync(e,t){const r=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const o=new FileLoader(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials);const i=await o.loadAsync(e,t),a=JSON.parse(i),n=a.metadata;if(void 0===n||void 0===n.type||"geometry"===n.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+e);return await this.parseAsync(a)}parse(e,t){const r=this.parseAnimations(e.animations),o=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,o),a=this.parseImages(e.images,(function(){void 0!==t&&t(d)})),n=this.parseTextures(e.textures,a),s=this.parseMaterials(e.materials,n),d=this.parseObject(e.object,i,s,n,r),m=this.parseSkeletons(e.skeletons,d);if(this.bindSkeletons(d,m),this.bindLightTargets(d),void 0!==t){let e=!1;for(const t in a)if(a[t].data instanceof HTMLImageElement){e=!0;break}!1===e&&t(d)}return d}async parseAsync(e){const t=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),o=this.parseGeometries(e.geometries,r),i=await this.parseImagesAsync(e.images),a=this.parseTextures(e.textures,i),n=this.parseMaterials(e.materials,a),s=this.parseObject(e.object,o,n,a,t),d=this.parseSkeletons(e.skeletons,s);return this.bindSkeletons(s,d),this.bindLightTargets(s),s}parseShapes(e){const t={};if(void 0!==e)for(let r=0,o=e.length;r<o;r++){const o=(new Shape).fromJSON(e[r]);t[o.uuid]=o}return t}parseSkeletons(e,t){const r={},o={};if(t.traverse((function(e){e.isBone&&(o[e.uuid]=e)})),void 0!==e)for(let t=0,i=e.length;t<i;t++){const i=(new Skeleton).fromJSON(e[t],o);r[i.uuid]=i}return r}parseGeometries(e,t){const r={};if(void 0!==e){const o=new BufferGeometryLoader;for(let i=0,a=e.length;i<a;i++){let a;const n=e[i];switch(n.type){case"BufferGeometry":case"InstancedBufferGeometry":a=o.parse(n);break;default:n.type in Geometries?a=Geometries[n.type].fromJSON(n,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${n.type}"`)}a.uuid=n.uuid,void 0!==n.name&&(a.name=n.name),void 0!==n.userData&&(a.userData=n.userData),r[n.uuid]=a}}return r}parseMaterials(e,t){const r={},o={};if(void 0!==e){const i=new MaterialLoader;i.setTextures(t);for(let t=0,a=e.length;t<a;t++){const a=e[t];void 0===r[a.uuid]&&(r[a.uuid]=i.parse(a)),o[a.uuid]=r[a.uuid]}}return o}parseAnimations(e){const t={};if(void 0!==e)for(let r=0;r<e.length;r++){const o=e[r],i=AnimationClip.parse(o);t[i.uuid]=i}return t}parseImages(e,t){const r=this,o={};let i;function a(e){if("string"==typeof e){const t=e;return function(e){return r.manager.itemStart(e),i.load(e,(function(){r.manager.itemEnd(e)}),void 0,(function(){r.manager.itemError(e),r.manager.itemEnd(e)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:r.resourcePath+t)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const r=new LoadingManager(t);i=new ImageLoader(r),i.setCrossOrigin(this.crossOrigin);for(let t=0,r=e.length;t<r;t++){const r=e[t],i=r.url;if(Array.isArray(i)){const e=[];for(let t=0,r=i.length;t<r;t++){const r=a(i[t]);null!==r&&(r instanceof HTMLImageElement?e.push(r):e.push(new DataTexture(r.data,r.width,r.height)))}o[r.uuid]=new Source(e)}else{const e=a(r.url);o[r.uuid]=new Source(e)}}}return o}async parseImagesAsync(e){const t=this,r={};let o;async function i(e){if("string"==typeof e){const r=e,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(r)?r:t.resourcePath+r;return await o.loadAsync(i)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){o=new ImageLoader(this.manager),o.setCrossOrigin(this.crossOrigin);for(let t=0,o=e.length;t<o;t++){const o=e[t],a=o.url;if(Array.isArray(a)){const e=[];for(let t=0,r=a.length;t<r;t++){const r=a[t],o=await i(r);null!==o&&(o instanceof HTMLImageElement?e.push(o):e.push(new DataTexture(o.data,o.width,o.height)))}r[o.uuid]=new Source(e)}else{const e=await i(o.url);r[o.uuid]=new Source(e)}}}return r}parseTextures(e,t){function r(e,t){return"number"==typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const o={};if(void 0!==e)for(let i=0,a=e.length;i<a;i++){const a=e[i];void 0===a.image&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),void 0===t[a.image]&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const n=t[a.image],s=n.data;let d;Array.isArray(s)?(d=new CubeTexture,6===s.length&&(d.needsUpdate=!0)):(d=s&&s.data?new DataTexture:new Texture,s&&(d.needsUpdate=!0)),d.source=n,d.uuid=a.uuid,void 0!==a.name&&(d.name=a.name),void 0!==a.mapping&&(d.mapping=r(a.mapping,TEXTURE_MAPPING)),void 0!==a.channel&&(d.channel=a.channel),void 0!==a.offset&&d.offset.fromArray(a.offset),void 0!==a.repeat&&d.repeat.fromArray(a.repeat),void 0!==a.center&&d.center.fromArray(a.center),void 0!==a.rotation&&(d.rotation=a.rotation),void 0!==a.wrap&&(d.wrapS=r(a.wrap[0],TEXTURE_WRAPPING),d.wrapT=r(a.wrap[1],TEXTURE_WRAPPING)),void 0!==a.format&&(d.format=a.format),void 0!==a.internalFormat&&(d.internalFormat=a.internalFormat),void 0!==a.type&&(d.type=a.type),void 0!==a.colorSpace&&(d.colorSpace=a.colorSpace),void 0!==a.minFilter&&(d.minFilter=r(a.minFilter,TEXTURE_FILTER)),void 0!==a.magFilter&&(d.magFilter=r(a.magFilter,TEXTURE_FILTER)),void 0!==a.anisotropy&&(d.anisotropy=a.anisotropy),void 0!==a.flipY&&(d.flipY=a.flipY),void 0!==a.generateMipmaps&&(d.generateMipmaps=a.generateMipmaps),void 0!==a.premultiplyAlpha&&(d.premultiplyAlpha=a.premultiplyAlpha),void 0!==a.unpackAlignment&&(d.unpackAlignment=a.unpackAlignment),void 0!==a.compareFunction&&(d.compareFunction=a.compareFunction),void 0!==a.userData&&(d.userData=a.userData),o[a.uuid]=d}return o}parseObject(e,t,r,o,i){let a,n,s;function d(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function m(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let o=0,i=e.length;o<i;o++){const i=e[o];void 0===r[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),t.push(r[i])}return t}return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),r[e]}}function c(e){return void 0===o[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),o[e]}switch(e.type){case"Scene":a=new Scene,void 0!==e.background&&(Number.isInteger(e.background)?a.background=new Color(e.background):a.background=c(e.background)),void 0!==e.environment&&(a.environment=c(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?a.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(a.fog=new FogExp2(e.fog.color,e.fog.density)),""!==e.fog.name&&(a.fog.name=e.fog.name)),void 0!==e.backgroundBlurriness&&(a.backgroundBlurriness=e.backgroundBlurriness),void 0!==e.backgroundIntensity&&(a.backgroundIntensity=e.backgroundIntensity),void 0!==e.backgroundRotation&&a.backgroundRotation.fromArray(e.backgroundRotation),void 0!==e.environmentIntensity&&(a.environmentIntensity=e.environmentIntensity),void 0!==e.environmentRotation&&a.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":a=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(a.focus=e.focus),void 0!==e.zoom&&(a.zoom=e.zoom),void 0!==e.filmGauge&&(a.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(a.filmOffset=e.filmOffset),void 0!==e.view&&(a.view=Object.assign({},e.view));break;case"OrthographicCamera":a=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(a.zoom=e.zoom),void 0!==e.view&&(a.view=Object.assign({},e.view));break;case"AmbientLight":a=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":a=new DirectionalLight(e.color,e.intensity),a.target=e.target||"";break;case"PointLight":a=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":a=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":a=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),a.target=e.target||"";break;case"HemisphereLight":a=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":a=(new LightProbe).fromJSON(e);break;case"SkinnedMesh":n=d(e.geometry),s=m(e.material),a=new SkinnedMesh(n,s),void 0!==e.bindMode&&(a.bindMode=e.bindMode),void 0!==e.bindMatrix&&a.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(a.skeleton=e.skeleton);break;case"Mesh":n=d(e.geometry),s=m(e.material),a=new Mesh(n,s);break;case"InstancedMesh":n=d(e.geometry),s=m(e.material);const t=e.count,r=e.instanceMatrix,o=e.instanceColor;a=new InstancedMesh(n,s,t),a.instanceMatrix=new InstancedBufferAttribute(new Float32Array(r.array),16),void 0!==o&&(a.instanceColor=new InstancedBufferAttribute(new Float32Array(o.array),o.itemSize));break;case"BatchedMesh":n=d(e.geometry),s=m(e.material),a=new BatchedMesh(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,s),a.geometry=n,a.perObjectFrustumCulled=e.perObjectFrustumCulled,a.sortObjects=e.sortObjects,a._drawRanges=e.drawRanges,a._reservedRanges=e.reservedRanges,a._geometryInfo=e.geometryInfo.map((e=>{let t=null,r=null;return void 0!==e.boundingBox&&(t=(new Box3).fromJSON(e.boundingBox)),void 0!==e.boundingSphere&&(r=(new Sphere).fromJSON(e.boundingSphere)),{...e,boundingBox:t,boundingSphere:r}})),a._instanceInfo=e.instanceInfo,a._availableInstanceIds=e._availableInstanceIds,a._availableGeometryIds=e._availableGeometryIds,a._nextIndexStart=e.nextIndexStart,a._nextVertexStart=e.nextVertexStart,a._geometryCount=e.geometryCount,a._maxInstanceCount=e.maxInstanceCount,a._maxVertexCount=e.maxVertexCount,a._maxIndexCount=e.maxIndexCount,a._geometryInitialized=e.geometryInitialized,a._matricesTexture=c(e.matricesTexture.uuid),a._indirectTexture=c(e.indirectTexture.uuid),void 0!==e.colorsTexture&&(a._colorsTexture=c(e.colorsTexture.uuid)),void 0!==e.boundingSphere&&(a.boundingSphere=(new Sphere).fromJSON(e.boundingSphere)),void 0!==e.boundingBox&&(a.boundingBox=(new Box3).fromJSON(e.boundingBox));break;case"LOD":a=new LOD;break;case"Line":a=new Line(d(e.geometry),m(e.material));break;case"LineLoop":a=new LineLoop(d(e.geometry),m(e.material));break;case"LineSegments":a=new LineSegments(d(e.geometry),m(e.material));break;case"PointCloud":case"Points":a=new Points(d(e.geometry),m(e.material));break;case"Sprite":a=new Sprite(m(e.material));break;case"Group":a=new Group;break;case"Bone":a=new Bone;break;default:a=new Object3D}if(a.uuid=e.uuid,void 0!==e.name&&(a.name=e.name),void 0!==e.matrix?(a.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(a.matrixAutoUpdate=e.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==e.position&&a.position.fromArray(e.position),void 0!==e.rotation&&a.rotation.fromArray(e.rotation),void 0!==e.quaternion&&a.quaternion.fromArray(e.quaternion),void 0!==e.scale&&a.scale.fromArray(e.scale)),void 0!==e.up&&a.up.fromArray(e.up),void 0!==e.castShadow&&(a.castShadow=e.castShadow),void 0!==e.receiveShadow&&(a.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.intensity&&(a.shadow.intensity=e.shadow.intensity),void 0!==e.shadow.bias&&(a.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(a.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(a.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&a.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(a.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(a.visible=e.visible),void 0!==e.frustumCulled&&(a.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(a.renderOrder=e.renderOrder),void 0!==e.userData&&(a.userData=e.userData),void 0!==e.layers&&(a.layers.mask=e.layers),void 0!==e.children){const n=e.children;for(let e=0;e<n.length;e++)a.add(this.parseObject(n[e],t,r,o,i))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const r=t[e];a.animations.push(i[r])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(a.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const r=t[e],o=a.getObjectByProperty("uuid",r.object);void 0!==o&&a.addLevel(o,r.distance,r.hysteresis)}}return a}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(!0===e.isSkinnedMesh&&void 0!==e.skeleton){const r=t[e.skeleton];void 0===r?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(r,e.bindMatrix)}}))}bindLightTargets(e){e.traverse((function(t){if(t.isDirectionalLight||t.isSpotLight){const r=t.target,o=e.getObjectByProperty("uuid",r);t.target=void 0!==o?o:new Object3D}}))}}const TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipmapNearestFilter:NearestMipmapNearestFilter,NearestMipmapLinearFilter:NearestMipmapLinearFilter,LinearFilter:LinearFilter,LinearMipmapNearestFilter:LinearMipmapNearestFilter,LinearMipmapLinearFilter:LinearMipmapLinearFilter};export{ObjectLoader};
//# sourceMappingURL=ObjectLoader.js.map