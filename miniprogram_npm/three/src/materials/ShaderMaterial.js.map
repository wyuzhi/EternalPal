{"version":3,"file":"node_modules/three/src/materials/ShaderMaterial.js","names":["Material","cloneUniforms","cloneUniformsGroups","default_vertex","default_fragment","ShaderMaterial","constructor","parameters","super","this","isShaderMaterial","type","defines","uniforms","uniformsGroups","vertexShader","fragmentShader","linewidth","wireframe","wireframeLinewidth","fog","lights","clipping","forceSinglePass","extensions","clipCullDistance","multiDraw","defaultAttributeValues","color","uv","uv1","index0AttributeName","undefined","uniformsNeedUpdate","glslVersion","setValues","copy","source","Object","assign","toJSON","meta","data","name","value","isTexture","uuid","isColor","getHex","isVector2","toArray","isVector3","isVector4","isMatrix3","isMatrix4","keys","length","key"],"sources":["node_modules/three/src/materials/ShaderMaterial.js"],"sourcesContent":["import { Material } from './Material.js';\nimport { cloneUniforms, cloneUniformsGroups } from '../renderers/shaders/UniformsUtils.js';\n\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n\n/**\n * A material rendered with custom shaders. A shader is a small program written in GLSL.\n * that runs on the GPU. You may want to use a custom shader if you need to implement an\n * effect not included with any of the built-in materials.\n *\n * There are the following notes to bear in mind when using a `ShaderMaterial`:\n *\n * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.\n * - Built in attributes and uniforms are passed to the shaders along with your code. If\n * you don't want that, use {@link RawShaderMaterial} instead.\n * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`\n * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has\n * to be placed right above the loop. The loop formatting has to correspond to a defined standard.\n *   - The loop has to be [normalized]{@link https://en.wikipedia.org/wiki/Normalized_loop}.\n *   - The loop variable has to be *i*.\n *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly\n * value of *i* for the given iteration and can be used in preprocessor\n * statements.\n *\n * ```js\n * const material = new THREE.ShaderMaterial( {\n * \tuniforms: {\n * \t\ttime: { value: 1.0 },\n * \t\tresolution: { value: new THREE.Vector2() }\n * \t},\n * \tvertexShader: document.getElementById( 'vertexShader' ).textContent,\n * \tfragmentShader: document.getElementById( 'fragmentShader' ).textContent\n * } );\n * ```\n *\n * @augments Material\n */\nclass ShaderMaterial extends Material {\n\n\t/**\n\t * Constructs a new shader material.\n\t *\n\t * @param {Object} [parameters] - An object with one or more properties\n\t * defining the material's appearance. Any property of the material\n\t * (including any property from inherited materials) can be passed\n\t * in here. Color values can be passed any type of value accepted\n\t * by {@link Color#set}.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\t/**\n\t\t * Defines custom constants using `#define` directives within the GLSL code\n\t\t * for both the vertex shader and the fragment shader; each key/value pair\n\t\t * yields another directive.\n\t\t * ```js\n\t\t * defines: {\n\t\t * \tFOO: 15,\n\t\t * \tBAR: true\n\t\t * }\n\t\t * ```\n\t\t * Yields the lines:\n\t\t * ```\n\t\t * #define FOO 15\n\t\t * #define BAR true\n\t\t * ```\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.defines = {};\n\n\t\t/**\n\t\t * An object of the form:\n\t\t * ```js\n\t\t * {\n\t\t * \t\"uniform1\": { value: 1.0 },\n\t\t * \t\"uniform2\": { value: 2 }\n\t\t * }\n\t\t * ```\n\t\t * specifying the uniforms to be passed to the shader code; keys are uniform\n\t\t * names, values are definitions of the form\n\t\t * ```\n\t\t * {\n\t\t * \tvalue: 1.0\n\t\t * }\n\t\t * ```\n\t\t * where `value` is the value of the uniform. Names must match the name of\n\t\t * the uniform, as defined in the GLSL code. Note that uniforms are refreshed\n\t\t * on every frame, so updating the value of the uniform will immediately\n\t\t * update the value available to the GLSL code.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = {};\n\n\t\t/**\n\t\t * An array holding uniforms groups for configuring UBOs.\n\t\t *\n\t\t * @type {Array<UniformsGroup>}\n\t\t */\n\t\tthis.uniformsGroups = [];\n\n\t\t/**\n\t\t * Vertex shader GLSL code. This is the actual code for the shader.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.vertexShader = default_vertex;\n\n\t\t/**\n\t\t * Fragment shader GLSL code. This is the actual code for the shader.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.fragmentShader = default_fragment;\n\n\t\t/**\n\t\t * Controls line thickness or lines.\n\t\t *\n\t\t * WebGL and WebGPU ignore this setting and always render line primitives with a\n\t\t * width of one pixel.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.linewidth = 1;\n\n\t\t/**\n\t\t * Renders the geometry as a wireframe.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.wireframe = false;\n\n\t\t/**\n\t\t * Controls the thickness of the wireframe.\n\t\t *\n\t\t * WebGL and WebGPU ignore this property and always render\n\t\t * 1 pixel wide lines.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.wireframeLinewidth = 1;\n\n\t\t/**\n\t\t * Define whether the material color is affected by global fog settings; `true`\n\t\t * to pass fog uniforms to the shader.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.fog = false;\n\n\t\t/**\n\t\t * Defines whether this material uses lighting; `true` to pass uniform data\n\t\t * related to lighting to this shader.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.lights = false;\n\n\t\t/**\n\t\t * Defines whether this material supports clipping; `true` to let the renderer\n\t\t * pass the clippingPlanes uniform.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipping = false;\n\n\t\t/**\n\t\t * Overwritten and set to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.forceSinglePass = true;\n\n\t\t/**\n\t\t * This object allows to enable certain WebGL 2 extensions.\n\t\t *\n\t\t * - clipCullDistance: set to `true` to use vertex shader clipping\n\t\t * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID\n\t\t *\n\t\t * @type {{clipCullDistance:false,multiDraw:false}}\n\t\t */\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t/**\n\t\t * When the rendered geometry doesn't include these attributes but the\n\t\t * material does, these default values will be passed to the shaders. This\n\t\t * avoids errors when buffer data is missing.\n\t\t *\n\t\t * - color: [ 1, 1, 1 ]\n\t\t * - uv: [ 0, 0 ]\n\t\t * - uv1: [ 0, 0 ]\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\t/**\n\t\t * If set, this calls [gl.bindAttribLocation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation}\n\t\t * to bind a generic vertex index to an attribute variable.\n\t\t *\n\t\t * @type {string|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.index0AttributeName = undefined;\n\n\t\t/**\n\t\t * Can be used to force a uniform update while changing uniforms in\n\t\t * {@link Object3D#onBeforeRender}.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\t/**\n\t\t * Defines the GLSL version of custom shader code.\n\t\t *\n\t\t * @type {?(GLSL1|GLSL3)}\n\t\t * @default null\n\t\t */\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * This type represents the fields required to store and run the shader code.\n *\n * @typedef {Object} ShaderMaterial~Shader\n * @property {string} name - The name of the shader.\n * @property {Object<string, Uniform>} uniforms - The uniforms of the shader.\n * @property {Object<string, any>} defines - The defines of the shader.\n * @property {string} vertexShader - The vertex shader code.\n * @property {string} fragmentShader - The fragment shader code.\n **/\n\nexport { ShaderMaterial };\n"],"mappings":"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","ignoreList":[]}