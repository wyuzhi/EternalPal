import NodeMaterial from"./NodeMaterial.js";import{dashSize,gapSize,varyingProperty}from"../../nodes/core/PropertyNode.js";import{attribute}from"../../nodes/core/AttributeNode.js";import{cameraProjectionMatrix}from"../../nodes/accessors/Camera.js";import{materialColor,materialLineScale,materialLineDashSize,materialLineGapSize,materialLineDashOffset,materialLineWidth,materialOpacity}from"../../nodes/accessors/MaterialNode.js";import{modelViewMatrix}from"../../nodes/accessors/ModelNode.js";import{positionGeometry}from"../../nodes/accessors/Position.js";import{mix,smoothstep}from"../../nodes/math/MathNode.js";import{Fn,float,vec2,vec3,vec4,If}from"../../nodes/tsl/TSLBase.js";import{uv}from"../../nodes/accessors/UV.js";import{viewport}from"../../nodes/display/ScreenNode.js";import{viewportSharedTexture}from"../../nodes/display/ViewportSharedTextureNode.js";import{LineDashedMaterial}from"../LineDashedMaterial.js";import{NoBlending}from"../../constants.js";const _defaultValues=new LineDashedMaterial;class Line2NodeMaterial extends NodeMaterial{static get type(){return"Line2NodeMaterial"}constructor(e={}){super(),this.isLine2NodeMaterial=!0,this.setDefaultValues(_defaultValues),this.useColor=e.vertexColors,this.dashOffset=0,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.blending=NoBlending,this._useDash=e.dashed,this._useAlphaToCoverage=!0,this._useWorldUnits=!1,this.setValues(e)}setup(e){const{renderer:s}=e,t=this._useAlphaToCoverage,a=this.useColor,i=this._useDash,o=this._useWorldUnits,r=Fn((({start:e,end:s})=>{const t=cameraProjectionMatrix.element(2).element(2),a=cameraProjectionMatrix.element(3).element(2).mul(-.5).div(t).sub(e.z).div(s.z.sub(e.z));return vec4(mix(e.xyz,s.xyz,a),s.w)})).setLayout({name:"trimSegment",type:"vec4",inputs:[{name:"start",type:"vec4"},{name:"end",type:"vec4"}]});this.vertexNode=Fn((()=>{const e=attribute("instanceStart"),s=attribute("instanceEnd"),t=vec4(modelViewMatrix.mul(vec4(e,1))).toVar("start"),a=vec4(modelViewMatrix.mul(vec4(s,1))).toVar("end");if(i){const e=this.dashScaleNode?float(this.dashScaleNode):materialLineScale,s=this.offsetNode?float(this.offsetNode):materialLineDashOffset,t=attribute("instanceDistanceStart"),a=attribute("instanceDistanceEnd");let i=positionGeometry.y.lessThan(.5).select(e.mul(t),e.mul(a));i=i.add(s),varyingProperty("float","lineDistance").assign(i)}o&&(varyingProperty("vec3","worldStart").assign(t.xyz),varyingProperty("vec3","worldEnd").assign(a.xyz));const n=viewport.z.div(viewport.w),l=cameraProjectionMatrix.element(2).element(3).equal(-1);If(l,(()=>{If(t.z.lessThan(0).and(a.z.greaterThan(0)),(()=>{a.assign(r({start:t,end:a}))})).ElseIf(a.z.lessThan(0).and(t.z.greaterThanEqual(0)),(()=>{t.assign(r({start:a,end:t}))}))}));const d=cameraProjectionMatrix.mul(t),m=cameraProjectionMatrix.mul(a),c=d.xyz.div(d.w),h=m.xyz.div(m.w),u=h.xy.sub(c.xy).toVar();u.x.assign(u.x.mul(n)),u.assign(u.normalize());const p=vec4().toVar();if(o){const e=a.xyz.sub(t.xyz).normalize(),s=mix(t.xyz,a.xyz,.5).normalize(),o=e.cross(s).normalize(),r=e.cross(o),n=varyingProperty("vec4","worldPos");n.assign(positionGeometry.y.lessThan(.5).select(t,a));const l=materialLineWidth.mul(.5);n.addAssign(vec4(positionGeometry.x.lessThan(0).select(o.mul(l),o.mul(l).negate()),0)),i||(n.addAssign(vec4(positionGeometry.y.lessThan(.5).select(e.mul(l).negate(),e.mul(l)),0)),n.addAssign(vec4(r.mul(l),0)),If(positionGeometry.y.greaterThan(1).or(positionGeometry.y.lessThan(0)),(()=>{n.subAssign(vec4(r.mul(2).mul(l),0))}))),p.assign(cameraProjectionMatrix.mul(n));const d=vec3().toVar();d.assign(positionGeometry.y.lessThan(.5).select(c,h)),p.z.assign(d.z.mul(p.w))}else{const e=vec2(u.y,u.x.negate()).toVar("offset");u.x.assign(u.x.div(n)),e.x.assign(e.x.div(n)),e.assign(positionGeometry.x.lessThan(0).select(e.negate(),e)),If(positionGeometry.y.lessThan(0),(()=>{e.assign(e.sub(u))})).ElseIf(positionGeometry.y.greaterThan(1),(()=>{e.assign(e.add(u))})),e.assign(e.mul(materialLineWidth)),e.assign(e.div(viewport.w)),p.assign(positionGeometry.y.lessThan(.5).select(d,m)),e.assign(e.mul(p.w)),p.assign(p.add(vec4(e,0,0)))}return p}))();const n=Fn((({p1:e,p2:s,p3:t,p4:a})=>{const i=e.sub(t),o=a.sub(t),r=s.sub(e),n=i.dot(o),l=o.dot(r),d=i.dot(r),m=o.dot(o),c=r.dot(r).mul(m).sub(l.mul(l)),h=n.mul(l).sub(d.mul(m)).div(c).clamp(),u=n.add(l.mul(h)).div(m).clamp();return vec2(h,u)}));if(this.colorNode=Fn((()=>{const e=uv();if(i){const s=this.dashSizeNode?float(this.dashSizeNode):materialLineDashSize,t=this.gapSizeNode?float(this.gapSizeNode):materialLineGapSize;dashSize.assign(s),gapSize.assign(t);const a=varyingProperty("float","lineDistance");e.y.lessThan(-1).or(e.y.greaterThan(1)).discard(),a.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard()}const r=float(1).toVar("alpha");if(o){const e=varyingProperty("vec3","worldStart"),a=varyingProperty("vec3","worldEnd"),o=varyingProperty("vec4","worldPos").xyz.normalize().mul(1e5),l=a.sub(e),d=n({p1:e,p2:a,p3:vec3(0,0,0),p4:o}),m=e.add(l.mul(d.x)),c=o.mul(d.y),h=m.sub(c).length().div(materialLineWidth);if(!i)if(t&&s.samples>1){const e=h.fwidth();r.assign(smoothstep(e.negate().add(.5),e.add(.5),h).oneMinus())}else h.greaterThan(.5).discard()}else if(t&&s.samples>1){const s=e.x,t=e.y.greaterThan(0).select(e.y.sub(1),e.y.add(1)),a=s.mul(s).add(t.mul(t)),i=float(a.fwidth()).toVar("dlen");If(e.y.abs().greaterThan(1),(()=>{r.assign(smoothstep(i.oneMinus(),i.add(1),a).oneMinus())}))}else If(e.y.abs().greaterThan(1),(()=>{const s=e.x,t=e.y.greaterThan(0).select(e.y.sub(1),e.y.add(1));s.mul(s).add(t.mul(t)).greaterThan(1).discard()}));let l;if(this.lineColorNode)l=this.lineColorNode;else if(a){const e=attribute("instanceColorStart"),s=attribute("instanceColorEnd");l=positionGeometry.y.lessThan(.5).select(e,s).mul(materialColor)}else l=materialColor;return vec4(l,r)}))(),this.transparent){const e=this.opacityNode?float(this.opacityNode):materialOpacity;this.outputNode=vec4(this.colorNode.rgb.mul(e).add(viewportSharedTexture().rgb.mul(e.oneMinus())),this.colorNode.a)}super.setup(e)}get worldUnits(){return this._useWorldUnits}set worldUnits(e){this._useWorldUnits!==e&&(this._useWorldUnits=e,this.needsUpdate=!0)}get dashed(){return this._useDash}set dashed(e){this._useDash!==e&&(this._useDash=e,this.needsUpdate=!0)}get alphaToCoverage(){return this._useAlphaToCoverage}set alphaToCoverage(e){this._useAlphaToCoverage!==e&&(this._useAlphaToCoverage=e,this.needsUpdate=!0)}}export default Line2NodeMaterial;
//# sourceMappingURL=Line2NodeMaterial.js.map