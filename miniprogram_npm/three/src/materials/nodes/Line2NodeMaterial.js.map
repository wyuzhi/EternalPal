{"version":3,"file":"node_modules/three/src/materials/nodes/Line2NodeMaterial.js","names":["NodeMaterial","dashSize","gapSize","varyingProperty","attribute","cameraProjectionMatrix","materialColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineDashOffset","materialLineWidth","materialOpacity","modelViewMatrix","positionGeometry","mix","smoothstep","Fn","float","vec2","vec3","vec4","If","uv","viewport","viewportSharedTexture","LineDashedMaterial","NoBlending","_defaultValues","Line2NodeMaterial","type","constructor","parameters","super","this","isLine2NodeMaterial","setDefaultValues","useColor","vertexColors","dashOffset","lineColorNode","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","blending","_useDash","dashed","_useAlphaToCoverage","_useWorldUnits","setValues","setup","builder","renderer","useAlphaToCoverage","useDash","useWorldUnits","trimSegment","start","end","a","element","alpha","mul","div","sub","z","xyz","w","setLayout","name","inputs","vertexNode","instanceStart","instanceEnd","toVar","instanceDistanceStart","instanceDistanceEnd","lineDistance","y","lessThan","select","add","assign","aspect","perspective","equal","and","greaterThan","ElseIf","greaterThanEqual","clipStart","clipEnd","ndcStart","ndcEnd","dir","xy","x","normalize","clip","worldDir","tmpFwd","worldUp","cross","worldFwd","worldPos","hw","addAssign","negate","or","subAssign","clipPose","offset","closestLineToLine","p1","p2","p3","p4","p13","p43","p21","d1343","dot","d4321","d1321","d4343","denom","mua","clamp","mub","colorNode","vUv","vLineDistance","discard","mod","worldStart","worldEnd","rayEnd","lineDir","params","norm","length","samples","dnorm","fwidth","oneMinus","b","len2","dlen","abs","instanceColorStart","instanceColorEnd","transparent","opacityNode","outputNode","rgb","worldUnits","value","needsUpdate","alphaToCoverage"],"sources":["node_modules/three/src/materials/nodes/Line2NodeMaterial.js"],"sourcesContent":["import NodeMaterial from './NodeMaterial.js';\nimport { dashSize, gapSize, varyingProperty } from '../../nodes/core/PropertyNode.js';\nimport { attribute } from '../../nodes/core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../../nodes/accessors/Camera.js';\nimport { materialColor, materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth, materialOpacity } from '../../nodes/accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../../nodes/accessors/ModelNode.js';\nimport { positionGeometry } from '../../nodes/accessors/Position.js';\nimport { mix, smoothstep } from '../../nodes/math/MathNode.js';\nimport { Fn, float, vec2, vec3, vec4, If } from '../../nodes/tsl/TSLBase.js';\nimport { uv } from '../../nodes/accessors/UV.js';\nimport { viewport } from '../../nodes/display/ScreenNode.js';\nimport { viewportSharedTexture } from '../../nodes/display/ViewportSharedTextureNode.js';\n\nimport { LineDashedMaterial } from '../LineDashedMaterial.js';\nimport { NoBlending } from '../../constants.js';\n\nconst _defaultValues = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * This node material can be used to render lines with a size larger than one\n * by representing them as instanced meshes.\n *\n * @augments NodeMaterial\n */\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new node material for wide line rendering.\n\t *\n\t * @param {Object} [parameters={}] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLine2NodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\t/**\n\t\t * Whether vertex colors should be used or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useColor = parameters.vertexColors;\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * Defines the lines color.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.lineColorNode = null;\n\n\t\t/**\n\t\t * Defines the offset.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Defines the dash scale.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * Defines the dash size.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * Defines the gap size.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\t/**\n\t\t * Blending is set to `NoBlending` since transparency\n\t\t * is not supported, yet.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.blending = NoBlending;\n\n\t\tthis._useDash = parameters.dashed;\n\t\tthis._useAlphaToCoverage = true;\n\t\tthis._useWorldUnits = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst useAlphaToCoverage = this._useAlphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this._useDash;\n\t\tconst useWorldUnits = this._useWorldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\t/**\n\t * Whether the lines should sized in world units or not.\n\t * When set to `false` the unit is pixel.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t */\n\tget worldUnits() {\n\n\t\treturn this._useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this._useWorldUnits !== value ) {\n\n\t\t\tthis._useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether the lines should be dashed or not.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t */\n\tget dashed() {\n\n\t\treturn this._useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this._useDash !== value ) {\n\n\t\t\tthis._useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport default Line2NodeMaterial;\n"],"mappings":"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","ignoreList":[]}