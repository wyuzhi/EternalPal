{"version":3,"file":"node_modules/three/src/materials/nodes/MeshSSSNodeMaterial.js","names":["MeshPhysicalNodeMaterial","PhysicalLightingModel","normalView","positionViewDirection","float","vec3","SSSLightingModel","constructor","clearcoat","sheen","iridescence","anisotropy","transmission","dispersion","sss","super","this","useSSS","direct","lightDirection","lightColor","reflectedLight","builder","material","thicknessColorNode","thicknessDistortionNode","thicknessAmbientNode","thicknessAttenuationNode","thicknessPowerNode","thicknessScaleNode","scatteringHalf","add","mul","normalize","scatteringDot","dot","negate","saturate","pow","scatteringIllu","directDiffuse","addAssign","MeshSSSNodeMaterial","type","parameters","setupLightingModel","useClearcoat","useSheen","useIridescence","useAnisotropy","useTransmission","useDispersion","copy","source"],"sources":["node_modules/three/src/materials/nodes/MeshSSSNodeMaterial.js"],"sourcesContent":["import MeshPhysicalNodeMaterial from './MeshPhysicalNodeMaterial.js';\nimport PhysicalLightingModel from '../../nodes/functions/PhysicalLightingModel.js';\nimport { normalView } from '../../nodes/accessors/Normal.js';\nimport { positionViewDirection } from '../../nodes/accessors/Position.js';\nimport { float, vec3 } from '../../nodes/tsl/TSLBase.js';\n\n/**\n * Represents the lighting model for {@link MeshSSSNodeMaterial}.\n *\n * @augments PhysicalLightingModel\n */\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t * @param {boolean} [sss=false] - Whether SSS is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false ) {\n\n\t\tsuper( clearcoat, sheen, iridescence, anisotropy, transmission, dispersion );\n\n\t\t/**\n\t\t * Whether the lighting model should use SSS or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useSSS = sss;\n\n\t}\n\n\t/**\n\t * Extends the default implementation with a SSS term.\n\t *\n\t * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look]{@link https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/}\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( normalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, builder );\n\n\t}\n\n}\n\n/**\n * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}\n * that implements a Subsurface scattering (SSS) term.\n *\n * @augments MeshPhysicalNodeMaterial\n */\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh SSS node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * Represents the thickness color.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessColorNode = null;\n\n\t\t/**\n\t\t * Represents the distortion factor.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\n\t\t/**\n\t\t * Represents the thickness ambient factor.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\n\t\t/**\n\t\t * Represents the thickness attenuation.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\n\t\t/**\n\t\t * Represents the thickness power.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\n\t\t/**\n\t\t * Represents the thickness scale.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use SSS or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {SSSLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default MeshSSSNodeMaterial;\n"],"mappings":"OAAOA,6BAA8B,uCAC9BC,0BAA2B,wDACzBC,eAAkB,yCAClBC,0BAA6B,2CAC7BC,MAAOC,SAAY,6BAO5B,MAAMC,yBAAyBL,sBAa9B,WAAAM,CAAaC,GAAY,EAAOC,GAAQ,EAAOC,GAAc,EAAOC,GAAa,EAAOC,GAAe,EAAOC,GAAa,EAAOC,GAAM,GAEvIC,MAAOP,EAAWC,EAAOC,EAAaC,EAAYC,EAAcC,GAQhEG,KAAKC,OAASH,CAEf,CAUA,MAAAI,EAAQC,eAAEA,EAAcC,WAAEA,EAAUC,eAAEA,GAAkBC,GAEvD,IAAqB,IAAhBN,KAAKC,OAAkB,CAE3B,MAAMM,EAAWD,EAAQC,UAEnBC,mBAAEA,EAAkBC,wBAAEA,EAAuBC,qBAAEA,EAAoBC,yBAAEA,EAAwBC,mBAAEA,EAAkBC,mBAAEA,GAAuBN,EAE1IO,EAAiBX,EAAeY,IAAK7B,WAAW8B,IAAKP,IAA4BQ,YACjFC,EAAgB9B,MAAOD,sBAAsBgC,IAAKL,EAAeM,UAAWC,WAAWC,IAAKV,GAAqBI,IAAKH,IACtHU,EAAiBlC,KAAM6B,EAAcH,IAAKL,GAAuBM,IAAKR,IAE5EH,EAAemB,cAAcC,UAAWF,EAAeP,IAAKL,EAAyBK,IAAKZ,IAE3F,CAEAL,MAAMG,OAAQ,CAAEC,iBAAgBC,aAAYC,kBAAkBC,EAE/D,EAUD,MAAMoB,4BAA4B1C,yBAEjC,eAAW2C,GAEV,MAAO,qBAER,CAOA,WAAApC,CAAaqC,GAEZ7B,MAAO6B,GAQP5B,KAAKQ,mBAAqB,KAO1BR,KAAKS,wBAA0BrB,MAAO,IAOtCY,KAAKU,qBAAuBtB,MAAO,GAOnCY,KAAKW,yBAA2BvB,MAAO,IAOvCY,KAAKY,mBAAqBxB,MAAO,GAOjCY,KAAKa,mBAAqBzB,MAAO,GAElC,CAQA,UAAIa,GAEH,OAAmC,OAA5BD,KAAKQ,kBAEb,CAOA,kBAAAqB,GAEC,OAAO,IAAIvC,iBAAkBU,KAAK8B,aAAc9B,KAAK+B,SAAU/B,KAAKgC,eAAgBhC,KAAKiC,cAAejC,KAAKkC,gBAAiBlC,KAAKmC,cAAenC,KAAKC,OAExJ,CAEA,IAAAmC,CAAMC,GASL,OAPArC,KAAKQ,mBAAqB6B,EAAO7B,mBACjCR,KAAKS,wBAA0B4B,EAAO5B,wBACtCT,KAAKU,qBAAuB2B,EAAO3B,qBACnCV,KAAKW,yBAA2B0B,EAAO1B,yBACvCX,KAAKY,mBAAqByB,EAAOzB,mBACjCZ,KAAKa,mBAAqBwB,EAAOxB,mBAE1Bd,MAAMqC,KAAMC,EAEpB,iBAIcX","ignoreList":[]}