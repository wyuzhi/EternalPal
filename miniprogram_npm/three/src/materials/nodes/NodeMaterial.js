import{Material}from"../Material.js";import{NormalBlending}from"../../constants.js";import{getNodeChildren,getCacheKey}from"../../nodes/core/NodeUtils.js";import{output,diffuseColor,emissive,varyingProperty}from"../../nodes/core/PropertyNode.js";import{materialAlphaTest,materialColor,materialOpacity,materialEmissive,materialNormal,materialLightMap,materialAO}from"../../nodes/accessors/MaterialNode.js";import{modelViewProjection}from"../../nodes/accessors/ModelViewProjectionNode.js";import{normalLocal}from"../../nodes/accessors/Normal.js";import{instancedMesh}from"../../nodes/accessors/InstancedMeshNode.js";import{batch}from"../../nodes/accessors/BatchNode.js";import{materialReference}from"../../nodes/accessors/MaterialReferenceNode.js";import{positionLocal,positionView}from"../../nodes/accessors/Position.js";import{skinning}from"../../nodes/accessors/SkinningNode.js";import{morphReference}from"../../nodes/accessors/MorphNode.js";import{mix}from"../../nodes/math/MathNode.js";import{float,vec3,vec4,bool}from"../../nodes/tsl/TSLBase.js";import AONode from"../../nodes/lighting/AONode.js";import{lightingContext}from"../../nodes/lighting/LightingContextNode.js";import IrradianceNode from"../../nodes/lighting/IrradianceNode.js";import{depth,viewZToLogarithmicDepth,viewZToOrthographicDepth}from"../../nodes/display/ViewportDepthNode.js";import{cameraFar,cameraNear,cameraProjectionMatrix}from"../../nodes/accessors/Camera.js";import{clipping,clippingAlpha,hardwareClipping}from"../../nodes/accessors/ClippingNode.js";import NodeMaterialObserver from"./manager/NodeMaterialObserver.js";import getAlphaHashThreshold from"../../nodes/functions/material/getAlphaHashThreshold.js";import{modelViewMatrix}from"../../nodes/accessors/ModelNode.js";import{vertexColor}from"../../nodes/accessors/VertexColorNode.js";import{premultiplyAlpha}from"../../nodes/display/BlendModes.js";import{subBuild}from"../../nodes/core/SubBuildNode.js";class NodeMaterial extends Material{static get type(){return"NodeMaterial"}get type(){return this.constructor.type}set type(e){}constructor(){super(),this.isNodeMaterial=!0,this.fog=!0,this.lights=!1,this.hardwareClipping=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.maskNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.receivedShadowPositionNode=null,this.castShadowPositionNode=null,this.receivedShadowNode=null,this.castShadowNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null,Object.defineProperty(this,"shadowPositionNode",{get:()=>this.receivedShadowPositionNode,set:e=>{console.warn('THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".'),this.receivedShadowPositionNode=e}})}customProgramCacheKey(){return this.type+getCacheKey(this)}build(e){this.setup(e)}setupObserver(e){return new NodeMaterialObserver(e)}setup(e){e.context.setupNormal=()=>subBuild(this.setupNormal(e),"NORMAL","vec3"),e.context.setupPositionView=()=>this.setupPositionView(e),e.context.setupModelViewProjection=()=>this.setupModelViewProjection(e);const t=e.renderer,o=t.getRenderTarget();e.addStack();const i=subBuild(this.setupVertex(e),"VERTEX"),s=this.vertexNode||i;let r;e.stack.outputNode=s,this.setupHardwareClipping(e),null!==this.geometryNode&&(e.stack.outputNode=e.stack.outputNode.bypass(this.geometryNode)),e.addFlow("vertex",e.removeStack()),e.addStack();const a=this.setupClipping(e);if(!0!==this.depthWrite&&!0!==this.depthTest||(null!==o?!0===o.depthBuffer&&this.setupDepth(e):!0===t.depth&&this.setupDepth(e)),null===this.fragmentNode){this.setupDiffuseColor(e),this.setupVariants(e);const i=this.setupLighting(e);null!==a&&e.stack.add(a);const s=vec4(i,diffuseColor.a).max(0);r=this.setupOutput(e,s),output.assign(r);const n=null!==this.outputNode;if(n&&(r=this.outputNode),null!==o){const e=t.getMRT(),o=this.mrtNode;null!==e?(n&&output.assign(r),r=e,null!==o&&(r=e.merge(o))):null!==o&&(r=o)}}else{let t=this.fragmentNode;!0!==t.isOutputStructNode&&(t=vec4(t)),r=this.setupOutput(e,t)}e.stack.outputNode=r,e.addFlow("fragment",e.removeStack()),e.observer=this.setupObserver(e)}setupClipping(e){if(null===e.clippingContext)return null;const{unionPlanes:t,intersectionPlanes:o}=e.clippingContext;let i=null;if(t.length>0||o.length>0){const t=e.renderer.samples;this.alphaToCoverage&&t>1?i=clippingAlpha():e.stack.add(clipping())}return i}setupHardwareClipping(e){if(this.hardwareClipping=!1,null===e.clippingContext)return;const t=e.clippingContext.unionPlanes.length;t>0&&t<=8&&e.isAvailable("clipDistance")&&(e.stack.add(hardwareClipping()),this.hardwareClipping=!0)}setupDepth(e){const{renderer:t,camera:o}=e;let i=this.depthNode;if(null===i){const e=t.getMRT();e&&e.has("depth")?i=e.get("depth"):!0===t.logarithmicDepthBuffer&&(i=o.isPerspectiveCamera?viewZToLogarithmicDepth(positionView.z,cameraNear,cameraFar):viewZToOrthographicDepth(positionView.z,cameraNear,cameraFar))}null!==i&&depth.assign(i).toStack()}setupPositionView(){return modelViewMatrix.mul(positionLocal).xyz}setupModelViewProjection(){return cameraProjectionMatrix.mul(positionView)}setupVertex(e){return e.addStack(),this.setupPosition(e),e.context.vertex=e.removeStack(),modelViewProjection}setupPosition(e){const{object:t,geometry:o}=e;if((o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color)&&morphReference(t).toStack(),!0===t.isSkinnedMesh&&skinning(t).toStack(),this.displacementMap){const e=materialReference("displacementMap","texture"),t=materialReference("displacementScale","float"),o=materialReference("displacementBias","float");positionLocal.addAssign(normalLocal.normalize().mul(e.x.mul(t).add(o)))}return t.isBatchedMesh&&batch(t).toStack(),t.isInstancedMesh&&t.instanceMatrix&&!0===t.instanceMatrix.isInstancedBufferAttribute&&instancedMesh(t).toStack(),null!==this.positionNode&&positionLocal.assign(subBuild(this.positionNode,"POSITION","vec3")),positionLocal}setupDiffuseColor({object:e,geometry:t}){null!==this.maskNode&&bool(this.maskNode).not().discard();let o=this.colorNode?vec4(this.colorNode):materialColor;if(!0===this.vertexColors&&t.hasAttribute("color")&&(o=o.mul(vertexColor())),e.instanceColor){o=varyingProperty("vec3","vInstanceColor").mul(o)}if(e.isBatchedMesh&&e._colorsTexture){o=varyingProperty("vec3","vBatchColor").mul(o)}diffuseColor.assign(o);const i=this.opacityNode?float(this.opacityNode):materialOpacity;diffuseColor.a.assign(diffuseColor.a.mul(i));let s=null;(null!==this.alphaTestNode||this.alphaTest>0)&&(s=null!==this.alphaTestNode?float(this.alphaTestNode):materialAlphaTest,diffuseColor.a.lessThanEqual(s).discard()),!0===this.alphaHash&&diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();!1===this.transparent&&this.blending===NormalBlending&&!1===this.alphaToCoverage?diffuseColor.a.assign(1):null===s&&diffuseColor.a.lessThanEqual(0).discard()}setupVariants(){}setupOutgoingLight(){return!0===this.lights?vec3(0):diffuseColor.rgb}setupNormal(){return this.normalNode?vec3(this.normalNode):materialNormal}setupEnvironment(){let e=null;return this.envNode?e=this.envNode:this.envMap&&(e=this.envMap.isCubeTexture?materialReference("envMap","cubeTexture"):materialReference("envMap","texture")),e}setupLightMap(e){let t=null;return e.material.lightMap&&(t=new IrradianceNode(materialLightMap)),t}setupLights(e){const t=[],o=this.setupEnvironment(e);o&&o.isLightingNode&&t.push(o);const i=this.setupLightMap(e);if(i&&i.isLightingNode&&t.push(i),null!==this.aoNode||e.material.aoMap){const e=null!==this.aoNode?this.aoNode:materialAO;t.push(new AONode(e))}let s=this.lightsNode||e.lightsNode;return t.length>0&&(s=e.renderer.lighting.createNode([...s.getLights(),...t])),s}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:o,backdropAlphaNode:i,emissiveNode:s}=this,r=!0===this.lights||null!==this.lightsNode?this.setupLights(e):null;let a=this.setupOutgoingLight(e);if(r&&r.getScope().hasLights){const t=this.setupLightingModel(e)||null;a=lightingContext(r,t,o,i)}else null!==o&&(a=vec3(null!==i?mix(a,o,i):o));return(s&&!0===s.isNode||t.emissive&&!0===t.emissive.isColor)&&(emissive.assign(vec3(s||materialEmissive)),a=a.add(emissive)),a}setupFog(e,t){const o=e.fogNode;return o&&(output.assign(t),t=vec4(o.toVar())),t}setupPremultipliedAlpha(e,t){return premultiplyAlpha(t)}setupOutput(e,t){return!0===this.fog&&(t=this.setupFog(e,t)),!0===this.premultipliedAlpha&&(t=this.setupPremultipliedAlpha(e,t)),t}setDefaultValues(e){for(const t in e){const o=e[t];void 0===this[t]&&(this[t]=o,o&&o.clone&&(this[t]=o.clone()))}const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const e in t)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,e)&&void 0!==t[e].get&&Object.defineProperty(this.constructor.prototype,e,t[e])}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{},nodes:{}});const o=Material.prototype.toJSON.call(this,e),i=getNodeChildren(this);o.inputNodes={};for(const{property:t,childNode:s}of i)o.inputNodes[t]=s.toJSON(e).uuid;function s(e){const t=[];for(const o in e){const i=e[o];delete i.metadata,t.push(i)}return t}if(t){const t=s(e.textures),i=s(e.images),r=s(e.nodes);t.length>0&&(o.textures=t),i.length>0&&(o.images=i),r.length>0&&(o.nodes=r)}return o}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.maskNode=e.maskNode,this.positionNode=e.positionNode,this.geometryNode=e.geometryNode,this.depthNode=e.depthNode,this.receivedShadowPositionNode=e.receivedShadowPositionNode,this.castShadowPositionNode=e.castShadowPositionNode,this.receivedShadowNode=e.receivedShadowNode,this.castShadowNode=e.castShadowNode,this.outputNode=e.outputNode,this.mrtNode=e.mrtNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}}export default NodeMaterial;
//# sourceMappingURL=NodeMaterial.js.map