{"version":3,"file":"node_modules/three/src/materials/nodes/NodeMaterial.js","names":["Material","NormalBlending","getNodeChildren","getCacheKey","output","diffuseColor","emissive","varyingProperty","materialAlphaTest","materialColor","materialOpacity","materialEmissive","materialNormal","materialLightMap","materialAO","modelViewProjection","normalLocal","instancedMesh","batch","materialReference","positionLocal","positionView","skinning","morphReference","mix","float","vec3","vec4","bool","AONode","lightingContext","IrradianceNode","depth","viewZToLogarithmicDepth","viewZToOrthographicDepth","cameraFar","cameraNear","cameraProjectionMatrix","clipping","clippingAlpha","hardwareClipping","NodeMaterialObserver","getAlphaHashThreshold","modelViewMatrix","vertexColor","premultiplyAlpha","subBuild","NodeMaterial","type","this","constructor","_value","super","isNodeMaterial","fog","lights","lightsNode","envNode","aoNode","colorNode","normalNode","opacityNode","backdropNode","backdropAlphaNode","alphaTestNode","maskNode","positionNode","geometryNode","depthNode","receivedShadowPositionNode","castShadowPositionNode","receivedShadowNode","castShadowNode","outputNode","mrtNode","fragmentNode","vertexNode","Object","defineProperty","get","set","value","console","warn","customProgramCacheKey","build","builder","setup","setupObserver","context","setupNormal","setupPositionView","setupModelViewProjection","renderer","renderTarget","getRenderTarget","addStack","mvp","setupVertex","resultNode","stack","setupHardwareClipping","bypass","addFlow","removeStack","clippingNode","setupClipping","depthWrite","depthTest","depthBuffer","setupDepth","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","add","basicOutput","a","max","setupOutput","assign","isCustomOutput","mrt","getMRT","materialMRT","merge","isOutputStructNode","observer","clippingContext","unionPlanes","intersectionPlanes","result","length","samples","alphaToCoverage","candidateCount","isAvailable","camera","has","logarithmicDepthBuffer","isPerspectiveCamera","z","toStack","mul","xyz","setupPosition","vertex","object","geometry","morphAttributes","position","normal","color","isSkinnedMesh","displacementMap","displacementScale","displacementBias","addAssign","normalize","x","isBatchedMesh","isInstancedMesh","instanceMatrix","isInstancedBufferAttribute","not","discard","vertexColors","hasAttribute","instanceColor","_colorsTexture","alphaTest","lessThanEqual","alphaHash","lessThan","transparent","blending","setupOutgoingLight","rgb","setupEnvironment","node","envMap","isCubeTexture","setupLightMap","material","lightMap","setupLights","materialLightsNode","isLightingNode","push","lightMapNode","aoMap","lightsN","lighting","createNode","getLights","setupLightingModel","emissiveNode","getScope","hasLights","lightingModel","isNode","isColor","setupFog","fogNode","toVar","setupPremultipliedAlpha","premultipliedAlpha","setDefaultValues","property","undefined","clone","descriptors","getOwnPropertyDescriptors","prototype","key","getOwnPropertyDescriptor","toJSON","meta","isRoot","textures","images","nodes","data","call","nodeChildren","inputNodes","childNode","uuid","extractFromCache","cache","values","metadata","copy","source"],"sources":["node_modules/three/src/materials/nodes/NodeMaterial.js"],"sourcesContent":["import { Material } from '../Material.js';\nimport { NormalBlending } from '../../constants.js';\n\nimport { getNodeChildren, getCacheKey } from '../../nodes/core/NodeUtils.js';\nimport { output, diffuseColor, emissive, varyingProperty } from '../../nodes/core/PropertyNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive, materialNormal, materialLightMap, materialAO } from '../../nodes/accessors/MaterialNode.js';\nimport { modelViewProjection } from '../../nodes/accessors/ModelViewProjectionNode.js';\nimport { normalLocal } from '../../nodes/accessors/Normal.js';\nimport { instancedMesh } from '../../nodes/accessors/InstancedMeshNode.js';\nimport { batch } from '../../nodes/accessors/BatchNode.js';\nimport { materialReference } from '../../nodes/accessors/MaterialReferenceNode.js';\nimport { positionLocal, positionView } from '../../nodes/accessors/Position.js';\nimport { skinning } from '../../nodes/accessors/SkinningNode.js';\nimport { morphReference } from '../../nodes/accessors/MorphNode.js';\nimport { mix } from '../../nodes/math/MathNode.js';\nimport { float, vec3, vec4, bool } from '../../nodes/tsl/TSLBase.js';\nimport AONode from '../../nodes/lighting/AONode.js';\nimport { lightingContext } from '../../nodes/lighting/LightingContextNode.js';\nimport IrradianceNode from '../../nodes/lighting/IrradianceNode.js';\nimport { depth, viewZToLogarithmicDepth, viewZToOrthographicDepth } from '../../nodes/display/ViewportDepthNode.js';\nimport { cameraFar, cameraNear, cameraProjectionMatrix } from '../../nodes/accessors/Camera.js';\nimport { clipping, clippingAlpha, hardwareClipping } from '../../nodes/accessors/ClippingNode.js';\nimport NodeMaterialObserver from './manager/NodeMaterialObserver.js';\nimport getAlphaHashThreshold from '../../nodes/functions/material/getAlphaHashThreshold.js';\nimport { modelViewMatrix } from '../../nodes/accessors/ModelNode.js';\nimport { vertexColor } from '../../nodes/accessors/VertexColorNode.js';\nimport { premultiplyAlpha } from '../../nodes/display/BlendModes.js';\nimport { subBuild } from '../../nodes/core/SubBuildNode.js';\n\n/**\n * Base class for all node materials.\n *\n * @augments Material\n */\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\t/**\n\t * Represents the type of the node material.\n\t *\n\t * @type {string}\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\t/**\n\t * Constructs a new node material.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeMaterial = true;\n\n\t\t/**\n\t\t * Whether this material is affected by fog or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.fog = true;\n\n\t\t/**\n\t\t * Whether this material is affected by lights or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.lights = false;\n\n\t\t/**\n\t\t * Whether this material uses hardware clipping or not.\n\t\t * This property is managed by the engine and should not be\n\t\t * modified by apps.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.hardwareClipping = false;\n\n\t\t/**\n\t\t * Node materials which set their `lights` property to `true`\n\t\t * are affected by all lights of the scene. Sometimes selective\n\t\t * lighting is wanted which means only _some_ lights in the scene\n\t\t * affect a material. This can be achieved by creating an instance\n\t\t * of {@link LightsNode} with a list of selective\n\t\t * lights and assign the node to this property.\n\t\t *\n\t\t * ```js\n\t\t * const customLightsNode = lights( [ light1, light2 ] );\n\t\t * material.lightsNode = customLightsNode;\n\t\t * ```\n\t\t *\n\t\t * @type {?LightsNode}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * The environment of node materials can be defined by an environment\n\t\t * map assigned to the `envMap` property or by `Scene.environment`\n\t\t * if the node material is a PBR material. This node property allows to overwrite\n\t\t * the default behavior and define the environment with a custom node.\n\t\t *\n\t\t * ```js\n\t\t * material.envNode = pmremTexture( renderTarget.texture );\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = null;\n\n\t\t/**\n\t\t * The lighting of node materials might be influenced by ambient occlusion.\n\t\t * The default AO is inferred from an ambient occlusion map assigned to `aoMap`\n\t\t * and the respective `aoMapIntensity`. This node property allows to overwrite\n\t\t * the default and define the ambient occlusion with a custom node instead.\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link materialAO}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = null;\n\n\t\t/**\n\t\t * The diffuse color of node materials is by default inferred from the\n\t\t * `color` and `map` properties. This node property allows to overwrite the default\n\t\t * and define the diffuse color with a node instead.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = color( 0xff0000 ); // define red color\n\t\t * ```\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link materialColor}.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = null;\n\n\t\t/**\n\t\t * The normals of node materials are by default inferred from the `normalMap`/`normalScale`\n\t\t * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default\n\t\t * and define the normals with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing values instead,\n\t\t * use {@link materialNormal}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.normalNode = null;\n\n\t\t/**\n\t\t * The opacity of node materials is by default inferred from the `opacity`\n\t\t * and `alphaMap` properties. This node property allows to overwrite the default\n\t\t * and define the opacity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing\n\t\t * value instead, use {@link materialOpacity}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.opacityNode = null;\n\n\t\t/**\n\t\t * This node can be used to implement a variety of filter-like effects. The idea is\n\t\t * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it\n\t\t * to create an arbitrary effect and then assign the node composition to this property.\n\t\t * Everything behind the object using this material will now be affected by a filter.\n\t\t *\n\t\t * ```js\n\t\t * const material = new NodeMaterial()\n\t\t * material.transparent = true;\n\t\t *\n\t\t * // everything behind the object will be monochromatic\n\t\t * material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );\n\t\t * ```\n\t\t *\n\t\t * Backdrop computations are part of the lighting so only lit materials can use this property.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = null;\n\n\t\t/**\n\t\t * This node allows to modulate the influence of `backdropNode` to the outgoing light.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = null;\n\n\t\t/**\n\t\t * The alpha test of node materials is by default inferred from the `alphaTest`\n\t\t * property. This node property allows to overwrite the default and define the\n\t\t * alpha test with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the alpha test but modify the existing\n\t\t * value instead, use {@link materialAlphaTest}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.alphaTestNode = null;\n\n\n\t\t/**\n\t\t * Discards the fragment if the mask value is `false`.\n\t\t *\n\t\t * @type {?Node<bool>}\n\t\t * @default null\n\t\t */\n\t\tthis.maskNode = null;\n\n\t\t/**\n\t\t * The local vertex positions are computed based on multiple factors like the\n\t\t * attribute data, morphing or skinning. This node property allows to overwrite\n\t\t * the default and define local vertex positions with nodes instead.\n\t\t *\n\t\t * If you don't want to overwrite the vertex positions but modify the existing\n\t\t * values instead, use {@link positionLocal}.\n\t\t *\n\t\t *```js\n\t\t * material.positionNode = positionLocal.add( displace );\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * This node property is intended for logic which modifies geometry data once or per animation step.\n\t\t * Apps usually place such logic randomly in initialization routines or in the animation loop.\n\t\t * `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications\n\t\t * can be implemented.\n\t\t *\n\t\t * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example\n\t\t * would be a GPU based particle system that provides a node material for usage on app level. The particle\n\t\t * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is\n\t\t * eventually assigned to `geometryNode`.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.geometryNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite depth values in the fragment shader.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the position used for shadow map rendering which\n\t\t * is by default {@link positionWorld}, the vertex position\n\t\t * in world space.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowPositionNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the geometry position used for shadow map projection which\n\t\t * is by default {@link positionLocal}, the vertex position in local space.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowPositionNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * receive shadows.\n\t\t *\n\t\t * ```js\n\t\t * const totalShadows = float( 1 ).toVar();\n\t\t * material.receivedShadowNode = Fn( ( [ shadow ] ) => {\n\t\t * \ttotalShadows.mulAssign( shadow );\n\t\t * \t//return float( 1 ); // bypass received shadows\n\t\t * \treturn shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color\n\t\t * } );\n\t\t *\n\t\t * @type {?(Function|FunctionNode<vec4>)}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * casts shadows. To apply a color to shadows, you can simply do:\n\t\t *\n\t\t * ```js\n\t\t * material.castShadowNode = vec4( 1, 0, 0, 1 );\n\t\t * ```\n\t\t *\n\t\t * Which can be nice to fake colored shadows of semi-transparent objects. It\n\t\t * is also common to use the property with `Fn` function so checks are performed\n\t\t * per fragment.\n\t\t *\n\t\t * ```js\n\t\t * materialCustomShadow.castShadowNode = Fn( () => {\n\t\t * \thash( vertexIndex ).greaterThan( 0.5 ).discard();\n\t\t * \treturn materialColor;\n\t\t * } )();\n\t\t *  ```\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to define the final output of the material.\n\t\t *\n\t\t * TODO: Explain the differences to `fragmentNode`.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * MRT configuration is done on renderer or pass level. This node allows to\n\t\t * overwrite what values are written into MRT targets on material level. This\n\t\t * can be useful for implementing selective FX features that should only affect\n\t\t * specific objects.\n\t\t *\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis.mrtNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the fragment shader. Assigning a node will replace the built-in material\n\t\t * logic used in the fragment stage.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.fragmentNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the vertex shader. Assigning a node will replace the built-in material logic\n\t\t * used in the vertex stage.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexNode = null;\n\n\t\t// Deprecated properties\n\n\t\tObject.defineProperty( this, 'shadowPositionNode', { // @deprecated, r176\n\n\t\t\tget: () => {\n\n\t\t\t\treturn this.receivedShadowPositionNode;\n\n\t\t\t},\n\n\t\t\tset: ( value ) => {\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowPositionNode\" was renamed to \".receivedShadowPositionNode\".' );\n\n\t\t\t\tthis.receivedShadowPositionNode = value;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Allows to define a custom cache key that influence the material key computation\n\t * for render objects.\n\t *\n\t * @return {string} The custom cache key.\n\t */\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey( this );\n\n\t}\n\n\t/**\n\t * Builds this material with the given node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\t/**\n\t * Setups a node material observer with the given builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => subBuild( this.setupNormal( builder ), 'NORMAL', 'vec3' );\n\t\tbuilder.context.setupPositionView = () => this.setupPositionView( builder );\n\t\tbuilder.context.setupModelViewProjection = () => this.setupModelViewProjection( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tconst mvp = subBuild( this.setupVertex( builder ), 'VERTEX' );\n\n\t\tconst vertexNode = this.vertexNode || mvp;\n\n\t\tbuilder.stack.outputNode = vertexNode;\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true || this.depthTest === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tconst isCustomOutput = this.outputNode !== null;\n\n\t\t\tif ( isCustomOutput ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tif ( isCustomOutput ) output.assign( resultNode );\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < OBSERVER >\n\n\t\tbuilder.observer = this.setupObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the clipping node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ClippingNode} The clipping node.\n\t */\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.samples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Setups the hardware clipping if available on the current device.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.add( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t/**\n\t * Setups the depth of this material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).toStack();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method exists\n\t * so derived node materials can modify the implementation e.g. sprite materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( /*builder*/ ) {\n\n\t\treturn modelViewMatrix.mul( positionLocal ).xyz;\n\n\t}\n\n\t/**\n\t * Setups the position in clip space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in view space.\n\t */\n\tsetupModelViewProjection( /*builder*/ ) {\n\n\t\treturn cameraProjectionMatrix.mul( positionView );\n\n\t}\n\n\t/**\n\t * Setups the logic for the vertex stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in clip space.\n\t */\n\tsetupVertex( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tthis.setupPosition( builder );\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\t/**\n\t * Setups the computation of the position in local space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in local space.\n\t */\n\tsetupPosition( builder ) {\n\n\t\tconst { object, geometry } = builder;\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).toStack();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinning( object ).toStack();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).toStack();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).toStack();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( subBuild( this.positionNode, 'POSITION', 'vec3' ) );\n\n\t\t}\n\n\t\treturn positionLocal;\n\n\t}\n\n\t/**\n\t * Setups the computation of the material's diffuse color.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t */\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\t// MASK\n\n\t\tif ( this.maskNode !== null ) {\n\n\t\t\t// Discard if the mask is `false`\n\n\t\t\tbool( this.maskNode ).not().discard();\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = colorNode.mul( vertexColor() );\n\n\t\t}\n\n\t\t// INSTANCED COLORS\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tlet alphaTestNode = null;\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\talphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\t// OPAQUE\n\n\t\tconst isOpaque = this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false;\n\n\t\tif ( isOpaque ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t} else if ( alphaTestNode === null ) {\n\n\t\t\tdiffuseColor.a.lessThanEqual( 0 ).discard();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract interface method that can be implemented by derived materials\n\t * to setup material-specific node variables.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node variable\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the normal node from the material.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\t/**\n\t * Setups the environment node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The environment node.\n\t */\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the light map node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the lights node based on the scene, environment and material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightsNode} The lights node.\n\t */\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAO;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\t/**\n\t * This method should be implemented by most derived materials\n\t * since it defines the material's lighting model.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder ) || null;\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Setup the fog.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupFog( builder, outputNode ) {\n\n\t\tconst fogNode = builder.fogNode;\n\n\t\tif ( fogNode ) {\n\n\t\t\toutput.assign( outputNode );\n\n\t\t\toutputNode = vec4( fogNode.toVar() );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Setups premultiplied alpha.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupPremultipliedAlpha( builder, outputNode ) {\n\n\t\treturn premultiplyAlpha( outputNode );\n\n\t}\n\n\t/**\n\t * Setups the output node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\toutputNode = this.setupFog( builder, outputNode );\n\n\t\t}\n\n\t\t// PREMULTIPLIED ALPHA\n\n\t\tif ( this.premultipliedAlpha === true ) {\n\n\t\t\toutputNode = this.setupPremultipliedAlpha( builder, outputNode );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`\n\t * there is `MeshBasicNodeMaterial`. This utility method is intended for\n\t * defining all material properties of the classic type in the node type.\n\t *\n\t * @param {Material} material - The material to copy properties with their values to this node material.\n\t */\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes this material to JSON.\n\t *\n\t * @param {?(Object|string)} meta - The meta information for serialization.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Copies the properties of the given node material to this instance.\n\t *\n\t * @param {NodeMaterial} source - The material to copy.\n\t * @return {NodeMaterial} A reference to this node material.\n\t */\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\t\tthis.maskNode = source.maskNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.receivedShadowPositionNode = source.receivedShadowPositionNode;\n\t\tthis.castShadowPositionNode = source.castShadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nexport default NodeMaterial;\n"],"mappings":"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","ignoreList":[]}