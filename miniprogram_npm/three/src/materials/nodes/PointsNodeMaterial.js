import SpriteNodeMaterial from"./SpriteNodeMaterial.js";import{viewport}from"../../nodes/display/ScreenNode.js";import{positionGeometry,positionLocal,positionView}from"../../nodes/accessors/Position.js";import{modelViewMatrix}from"../../nodes/accessors/ModelNode.js";import{materialPointSize}from"../../nodes/accessors/MaterialNode.js";import{rotate}from"../../nodes/utils/RotateNode.js";import{float,vec2,vec3,vec4}from"../../nodes/tsl/TSLBase.js";import{PointsMaterial}from"../PointsMaterial.js";const _defaultValues=new PointsMaterial;class PointsNodeMaterial extends SpriteNodeMaterial{static get type(){return"PointsNodeMaterial"}constructor(e){super(),this.sizeNode=null,this.isPointsNodeMaterial=!0,this.setDefaultValues(_defaultValues),this.setValues(e)}setupPositionView(){const{positionNode:e}=this;return modelViewMatrix.mul(vec3(e||positionLocal)).xyz}setupVertex(e){const t=super.setupVertex(e);if(!0!==e.material.isNodeMaterial)return t;const{rotationNode:o,scaleNode:i,sizeNode:s}=this,a=positionGeometry.xy.toVar(),r=viewport.z.div(viewport.w);if(o&&o.isNode){const e=float(o);a.assign(rotate(a,e))}let l=null!==s?vec2(s):materialPointSize;return!0===this.sizeAttenuation&&(l=l.mul(l.div(positionView.z.negate()))),i&&i.isNode&&(l=l.mul(vec2(i))),a.mulAssign(l.mul(2)),a.assign(a.div(viewport.z)),a.y.assign(a.y.mul(r)),a.assign(a.mul(t.w)),t.addAssign(vec4(a,0,0)),t}get alphaToCoverage(){return this._useAlphaToCoverage}set alphaToCoverage(e){this._useAlphaToCoverage!==e&&(this._useAlphaToCoverage=e,this.needsUpdate=!0)}}export default PointsNodeMaterial;
//# sourceMappingURL=PointsNodeMaterial.js.map