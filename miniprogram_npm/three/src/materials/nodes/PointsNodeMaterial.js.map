{"version":3,"file":"node_modules/three/src/materials/nodes/PointsNodeMaterial.js","names":["SpriteNodeMaterial","viewport","positionGeometry","positionLocal","positionView","modelViewMatrix","materialPointSize","rotate","float","vec2","vec3","vec4","PointsMaterial","_defaultValues","PointsNodeMaterial","type","constructor","parameters","super","this","sizeNode","isPointsNodeMaterial","setDefaultValues","setValues","setupPositionView","positionNode","mul","xyz","setupVertex","builder","mvp","material","isNodeMaterial","rotationNode","scaleNode","alignedPosition","xy","toVar","aspect","z","div","w","isNode","rotation","assign","pointSize","sizeAttenuation","negate","mulAssign","y","addAssign","alphaToCoverage","_useAlphaToCoverage","value","needsUpdate"],"sources":["node_modules/three/src/materials/nodes/PointsNodeMaterial.js"],"sourcesContent":["import SpriteNodeMaterial from './SpriteNodeMaterial.js';\nimport { viewport } from '../../nodes/display/ScreenNode.js';\nimport { positionGeometry, positionLocal, positionView } from '../../nodes/accessors/Position.js';\nimport { modelViewMatrix } from '../../nodes/accessors/ModelNode.js';\nimport { materialPointSize } from '../../nodes/accessors/MaterialNode.js';\nimport { rotate } from '../../nodes/utils/RotateNode.js';\nimport { float, vec2, vec3, vec4 } from '../../nodes/tsl/TSLBase.js';\n\nimport { PointsMaterial } from '../PointsMaterial.js';\n\nconst _defaultValues = /*@__PURE__*/ new PointsMaterial();\n\n/**\n * Node material version of {@link PointsMaterial}.\n *\n * @augments SpriteNodeMaterial\n */\nclass PointsNodeMaterial extends SpriteNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new points node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This node property provides an additional way to set the point size.\n\t\t *\n\t\t * Note that WebGPU only supports point primitives with 1 pixel size. Consequently,\n\t\t * this node has no effect when the material is used with {@link Points} and a WebGPU\n\t\t * backend. If an application wants to render points with a size larger than 1 pixel,\n\t\t * the material should be used with {@link Sprite} and instancing.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.sizeNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupPositionView() {\n\n\t\tconst { positionNode } = this;\n\n\t\treturn modelViewMatrix.mul( vec3( positionNode || positionLocal ) ).xyz;\n\n\t}\n\n\tsetupVertex( builder ) {\n\n\t\tconst mvp = super.setupVertex( builder );\n\n\t\t// skip further processing if the material is not a node material\n\n\t\tif ( builder.material.isNodeMaterial !== true ) {\n\n\t\t\treturn mvp;\n\n\t\t}\n\n\t\t// ndc space\n\n\t\tconst { rotationNode, scaleNode, sizeNode } = this;\n\n\t\tconst alignedPosition = positionGeometry.xy.toVar();\n\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t// rotation\n\n\t\tif ( rotationNode && rotationNode.isNode ) {\n\n\t\t\tconst rotation = float( rotationNode );\n\n\t\t\talignedPosition.assign( rotate( alignedPosition, rotation ) );\n\n\t\t}\n\n\t\t// point size\n\n\t\tlet pointSize = sizeNode !== null ? vec2( sizeNode ) : materialPointSize;\n\n\t\tif ( this.sizeAttenuation === true ) {\n\n\t\t\tpointSize = pointSize.mul( pointSize.div( positionView.z.negate() ) );\n\n\t\t}\n\n\t\t// scale\n\n\t\tif ( scaleNode && scaleNode.isNode ) {\n\n\t\t\tpointSize = pointSize.mul( vec2( scaleNode ) );\n\n\t\t}\n\n\t\talignedPosition.mulAssign( pointSize.mul( 2 ) );\n\n\t\talignedPosition.assign( alignedPosition.div( viewport.z ) );\n\t\talignedPosition.y.assign( alignedPosition.y.mul( aspect ) );\n\n\t\t// back to clip space\n\t\talignedPosition.assign( alignedPosition.mul( mvp.w ) );\n\n\t\t//clipPos.xy += offset;\n\t\tmvp.addAssign( vec4( alignedPosition, 0, 0 ) );\n\n\t\treturn mvp;\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport default PointsNodeMaterial;\n"],"mappings":"OAAOA,uBAAwB,iCACtBC,aAAgB,2CAChBC,iBAAkBC,cAAeC,iBAAoB,2CACrDC,oBAAuB,4CACvBC,sBAAyB,+CACzBC,WAAc,yCACdC,MAAOC,KAAMC,KAAMC,SAAY,oCAE/BC,mBAAsB,uBAE/B,MAAMC,eAA+B,IAAID,eAOzC,MAAME,2BAA2Bd,mBAEhC,eAAWe,GAEV,MAAO,oBAER,CAOA,WAAAC,CAAaC,GAEZC,QAaAC,KAAKC,SAAW,KAShBD,KAAKE,sBAAuB,EAE5BF,KAAKG,iBAAkBT,gBAEvBM,KAAKI,UAAWN,EAEjB,CAEA,iBAAAO,GAEC,MAAMC,aAAEA,GAAiBN,KAEzB,OAAOd,gBAAgBqB,IAAKhB,KAAMe,GAAgBtB,gBAAkBwB,GAErE,CAEA,WAAAC,CAAaC,GAEZ,MAAMC,EAAMZ,MAAMU,YAAaC,GAI/B,IAAyC,IAApCA,EAAQE,SAASC,eAErB,OAAOF,EAMR,MAAMG,aAAEA,EAAYC,UAAEA,EAASd,SAAEA,GAAaD,KAExCgB,EAAkBjC,iBAAiBkC,GAAGC,QACtCC,EAASrC,SAASsC,EAAEC,IAAKvC,SAASwC,GAIxC,GAAKR,GAAgBA,EAAaS,OAAS,CAE1C,MAAMC,EAAWnC,MAAOyB,GAExBE,EAAgBS,OAAQrC,OAAQ4B,EAAiBQ,GAElD,CAIA,IAAIE,EAAyB,OAAbzB,EAAoBX,KAAMW,GAAad,kBA2BvD,OAzB8B,IAAzBa,KAAK2B,kBAETD,EAAYA,EAAUnB,IAAKmB,EAAUL,IAAKpC,aAAamC,EAAEQ,YAMrDb,GAAaA,EAAUQ,SAE3BG,EAAYA,EAAUnB,IAAKjB,KAAMyB,KAIlCC,EAAgBa,UAAWH,EAAUnB,IAAK,IAE1CS,EAAgBS,OAAQT,EAAgBK,IAAKvC,SAASsC,IACtDJ,EAAgBc,EAAEL,OAAQT,EAAgBc,EAAEvB,IAAKY,IAGjDH,EAAgBS,OAAQT,EAAgBT,IAAKI,EAAIW,IAGjDX,EAAIoB,UAAWvC,KAAMwB,EAAiB,EAAG,IAElCL,CAER,CAQA,mBAAIqB,GAEH,OAAOhC,KAAKiC,mBAEb,CAEA,mBAAID,CAAiBE,GAEflC,KAAKiC,sBAAwBC,IAEjClC,KAAKiC,oBAAsBC,EAC3BlC,KAAKmC,aAAc,EAIrB,iBAIcxC","ignoreList":[]}