import NodeMaterial from"./NodeMaterial.js";import{cameraProjectionMatrix}from"../../nodes/accessors/Camera.js";import{materialRotation}from"../../nodes/accessors/MaterialNode.js";import{modelViewMatrix,modelWorldMatrix}from"../../nodes/accessors/ModelNode.js";import{positionGeometry}from"../../nodes/accessors/Position.js";import{rotate}from"../../nodes/utils/RotateNode.js";import{float,vec2,vec3,vec4}from"../../nodes/tsl/TSLBase.js";import{SpriteMaterial}from"../SpriteMaterial.js";import{reference}from"../../nodes/accessors/ReferenceBaseNode.js";const _defaultValues=new SpriteMaterial;class SpriteNodeMaterial extends NodeMaterial{static get type(){return"SpriteNodeMaterial"}constructor(e){super(),this.isSpriteNodeMaterial=!0,this._useSizeAttenuation=!0,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.transparent=!0,this.setDefaultValues(_defaultValues),this.setValues(e)}setupPositionView(e){const{object:t,camera:o}=e,i=this.sizeAttenuation,{positionNode:s,rotationNode:r,scaleNode:a}=this,n=modelViewMatrix.mul(vec3(s||0));let l=vec2(modelWorldMatrix[0].xyz.length(),modelWorldMatrix[1].xyz.length());if(null!==a&&(l=l.mul(vec2(a))),!1===i)if(o.isPerspectiveCamera)l=l.mul(n.z.negate());else{const e=float(2).div(cameraProjectionMatrix.element(1).element(1));l=l.mul(e.mul(2))}let d=positionGeometry.xy;if(t.center&&!0===t.center.isVector2){const e=reference("center","vec2",t);d=d.sub(e.sub(.5))}d=d.mul(l);const c=float(r||materialRotation),m=rotate(d,c);return vec4(n.xy.add(m),n.zw)}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}get sizeAttenuation(){return this._useSizeAttenuation}set sizeAttenuation(e){this._useSizeAttenuation!==e&&(this._useSizeAttenuation=e,this.needsUpdate=!0)}}export default SpriteNodeMaterial;
//# sourceMappingURL=SpriteNodeMaterial.js.map