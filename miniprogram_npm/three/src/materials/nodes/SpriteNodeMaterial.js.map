{"version":3,"file":"node_modules/three/src/materials/nodes/SpriteNodeMaterial.js","names":["NodeMaterial","cameraProjectionMatrix","materialRotation","modelViewMatrix","modelWorldMatrix","positionGeometry","rotate","float","vec2","vec3","vec4","SpriteMaterial","reference","_defaultValues","SpriteNodeMaterial","type","constructor","parameters","super","this","isSpriteNodeMaterial","_useSizeAttenuation","positionNode","rotationNode","scaleNode","transparent","setDefaultValues","setValues","setupPositionView","builder","object","camera","sizeAttenuation","mvPosition","mul","scale","xyz","length","isPerspectiveCamera","z","negate","orthoScale","div","element","alignedPosition","xy","center","isVector2","sub","rotation","rotatedPosition","add","zw","copy","source","value","needsUpdate"],"sources":["node_modules/three/src/materials/nodes/SpriteNodeMaterial.js"],"sourcesContent":["import NodeMaterial from './NodeMaterial.js';\nimport { cameraProjectionMatrix } from '../../nodes/accessors/Camera.js';\nimport { materialRotation } from '../../nodes/accessors/MaterialNode.js';\nimport { modelViewMatrix, modelWorldMatrix } from '../../nodes/accessors/ModelNode.js';\nimport { positionGeometry } from '../../nodes/accessors/Position.js';\nimport { rotate } from '../../nodes/utils/RotateNode.js';\nimport { float, vec2, vec3, vec4 } from '../../nodes/tsl/TSLBase.js';\n\nimport { SpriteMaterial } from '../SpriteMaterial.js';\nimport { reference } from '../../nodes/accessors/ReferenceBaseNode.js';\n\nconst _defaultValues = /*@__PURE__*/ new SpriteMaterial();\n\n/**\n * Node material version of {@link SpriteMaterial}.\n *\n * @augments NodeMaterial\n */\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis._useSizeAttenuation = true;\n\n\t\t/**\n\t\t * This property makes it possible to define the position of the sprite with a\n\t\t * node. That can be useful when the material is used with instanced rendering\n\t\t * and node data are defined with an instanced attribute node:\n\t\t * ```js\n\t\t * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t * material.positionNode = instancedBufferAttribute( positionAttribute );\n\t\t * ```\n\t\t * Another possibility is to compute the instanced data with a compute shader:\n\t\t * ```js\n\t\t * const positionBuffer = instancedArray( particleCount, 'vec3' );\n\t\t * particleMaterial.positionNode = positionBuffer.toAttribute();\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * The rotation of sprite materials is by default inferred from the `rotation`,\n\t\t * property. This node property allows to overwrite the default and define\n\t\t * the rotation with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the rotation but modify the existing\n\t\t * value instead, use {@link materialRotation}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.rotationNode = null;\n\n\t\t/**\n\t\t * This node property provides an additional way to scale sprites next to\n\t\t * `Object3D.scale`. The scale transformation based in `Object3D.scale`\n\t\t * is multiplied with the scale value of this node in the vertex shader.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = null;\n\n\t\t/**\n\t\t * In Sprites, the transparent property is enabled by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method implements\n\t * the sprite specific vertex shader.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( builder ) {\n\n\t\tconst { object, camera } = builder;\n\n\t\tconst sizeAttenuation = this.sizeAttenuation;\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( vec2( scaleNode ) );\n\n\t\t}\n\n\t\tif ( sizeAttenuation === false ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );\n\t\t\t\tscale = scale.mul( orthoScale.mul( 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet alignedPosition = positionGeometry.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference( 'center', 'vec2', object );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\treturn vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\t/**\n\t * Whether to use size attenuation or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport default SpriteNodeMaterial;\n"],"mappings":"OAAOA,iBAAkB,2BAChBC,2BAA8B,yCAC9BC,qBAAwB,+CACxBC,gBAAiBC,qBAAwB,4CACzCC,qBAAwB,2CACxBC,WAAc,yCACdC,MAAOC,KAAMC,KAAMC,SAAY,oCAE/BC,mBAAsB,8BACtBC,cAAiB,6CAE1B,MAAMC,eAA+B,IAAIF,eAOzC,MAAMG,2BAA2Bd,aAEhC,eAAWe,GAEV,MAAO,oBAER,CAOA,WAAAC,CAAaC,GAEZC,QASAC,KAAKC,sBAAuB,EAE5BD,KAAKE,qBAAsB,EAmB3BF,KAAKG,aAAe,KAapBH,KAAKI,aAAe,KAUpBJ,KAAKK,UAAY,KAQjBL,KAAKM,aAAc,EAEnBN,KAAKO,iBAAkBb,gBAEvBM,KAAKQ,UAAWV,EAEjB,CASA,iBAAAW,CAAmBC,GAElB,MAAMC,OAAEA,EAAMC,OAAEA,GAAWF,EAErBG,EAAkBb,KAAKa,iBAEvBV,aAAEA,EAAYC,aAAEA,EAAYC,UAAEA,GAAcL,KAE5Cc,EAAa9B,gBAAgB+B,IAAKzB,KAAMa,GAAgB,IAE9D,IAAIa,EAAQ3B,KAAMJ,iBAAkB,GAAIgC,IAAIC,SAAUjC,iBAAkB,GAAIgC,IAAIC,UAQhF,GANmB,OAAdb,IAEJW,EAAQA,EAAMD,IAAK1B,KAAMgB,MAID,IAApBQ,EAEJ,GAAKD,EAAOO,oBAEXH,EAAQA,EAAMD,IAAKD,EAAWM,EAAEC,cAE1B,CAEN,MAAMC,EAAalC,MAAO,GAAMmC,IAAKzC,uBAAuB0C,QAAS,GAAIA,QAAS,IAClFR,EAAQA,EAAMD,IAAKO,EAAWP,IAAK,GAEpC,CAID,IAAIU,EAAkBvC,iBAAiBwC,GAEvC,GAAKf,EAAOgB,SAAsC,IAA5BhB,EAAOgB,OAAOC,UAAqB,CAExD,MAAMD,EAASlC,UAAW,SAAU,OAAQkB,GAE5Cc,EAAkBA,EAAgBI,IAAKF,EAAOE,IAAK,IAEpD,CAEAJ,EAAkBA,EAAgBV,IAAKC,GAEvC,MAAMc,EAAW1C,MAAOgB,GAAgBrB,kBAElCgD,EAAkB5C,OAAQsC,EAAiBK,GAEjD,OAAOvC,KAAMuB,EAAWY,GAAGM,IAAKD,GAAmBjB,EAAWmB,GAE/D,CAEA,IAAAC,CAAMC,GAML,OAJAnC,KAAKG,aAAegC,EAAOhC,aAC3BH,KAAKI,aAAe+B,EAAO/B,aAC3BJ,KAAKK,UAAY8B,EAAO9B,UAEjBN,MAAMmC,KAAMC,EAEpB,CAQA,mBAAItB,GAEH,OAAOb,KAAKE,mBAEb,CAEA,mBAAIW,CAAiBuB,GAEfpC,KAAKE,sBAAwBkC,IAEjCpC,KAAKE,oBAAsBkC,EAC3BpC,KAAKqC,aAAc,EAIrB,iBAIc1C","ignoreList":[]}