{"version":3,"file":"node_modules/three/src/materials/nodes/manager/NodeMaterialObserver.js","names":["refreshUniforms","_lightsCache","WeakMap","NodeMaterialObserver","constructor","builder","this","renderObjects","hasNode","containsNode","hasAnimation","object","isSkinnedMesh","renderId","firstInitialization","renderObject","has","getRenderObjectData","needsVelocity","renderer","mrt","getMRT","data","get","undefined","geometry","material","getMaterialData","id","attributes","getAttributesData","indexVersion","index","version","drawRange","start","count","worldMatrix","matrixWorld","clone","center","morphTargetInfluences","slice","bundle","transmission","width","height","context","bufferWidth","bufferHeight","lights","getLightsData","lightsNode","getLights","set","attributesData","name","attribute","property","isNode","overrideNodes","modelViewMatrix","modelNormalViewMatrix","value","isTexture","equals","lightsData","renderObjectData","copy","materialData","mtlValue","storedGeometryData","storedAttributes","storedAttributeNames","Object","keys","currentAttributeNames","length","storedAttributeData","storedIndexVersion","currentIndexVersion","morphChanged","i","map","materialLights","light","isSpotLight","push","cached","needsRefresh","nodeFrame","isStatic","static","isBundle"],"sources":["node_modules/three/src/materials/nodes/manager/NodeMaterialObserver.js"],"sourcesContent":["const refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'aoMapIntensity',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveIntensity',\n\t'emissiveMap',\n\t'envMap',\n\t'envMapIntensity',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'lightMapIntensity',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\n\n/**\n * A WeakMap to cache lights data for node materials.\n * Cache lights data by render ID to avoid unnecessary recalculations.\n *\n * @private\n * @type {WeakMap<LightsNode,Object>}\n */\nconst _lightsCache = new WeakMap();\n\n/**\n * This class is used by {@link WebGPURenderer} as management component.\n * It's primary purpose is to determine whether render objects require a\n * refresh right before they are going to be rendered or not.\n */\nclass NodeMaterialObserver {\n\n\t/**\n\t * Constructs a new node material observer.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t */\n\tconstructor( builder ) {\n\n\t\t/**\n\t\t * A node material can be used by more than one render object so the\n\t\t * monitor must maintain a list of render objects.\n\t\t *\n\t\t * @type {WeakMap<RenderObject,Object>}\n\t\t */\n\t\tthis.renderObjects = new WeakMap();\n\n\t\t/**\n\t\t * Whether the material uses node objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.hasNode = this.containsNode( builder );\n\n\t\t/**\n\t\t * Whether the node builder's 3D object is animated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\n\t\t/**\n\t\t * A list of all possible material uniforms\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.refreshUniforms = refreshUniforms;\n\n\t\t/**\n\t\t * Holds the current render ID from the node frame.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object is verified for the first time of this observer.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the given render object is verified for the first time of this observer.\n\t */\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns `true` if the current rendering produces motion vectors.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {boolean} Whether the current rendering produces motion vectors or not.\n\t */\n\tneedsVelocity( renderer ) {\n\n\t\tconst mrt = renderer.getMRT();\n\n\t\treturn ( mrt !== null && mrt.has( 'velocity' ) );\n\n\t}\n\n\t/**\n\t * Returns monitoring data for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Object} The monitoring data.\n\t */\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tid: geometry.id,\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tdata.lights = this.getLightsData( renderObject.lightsNode.getLights() );\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns an attribute data structure holding the attributes versions for\n\t * monitoring.\n\t *\n\t * @param {Object} attributes - The geometry attributes.\n\t * @return {Object} An object for monitoring the versions of attributes.\n\t */\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\t/**\n\t * Returns `true` if the node builder's material uses\n\t * node properties.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether the node builder's material uses node properties or not.\n\t */\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns a material data structure holding the material property values for\n\t * monitoring.\n\t *\n\t * @param {Material} material - The material.\n\t * @return {Object} An object for monitoring material properties.\n\t */\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has not changed its state.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Light>} lightsData - The current material lights.\n\t * @return {boolean} Whether the given render object has changed its state or not.\n\t */\n\tequals( renderObject, lightsData ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedGeometryData.id !== geometry.id ) {\n\n\t\t\tstoredGeometryData.id = geometry.id;\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return true;\n\n\t\t}\n\n\t\t// lights\n\n\t\tif ( renderObjectData.lights ) {\n\n\t\t\tfor ( let i = 0; i < lightsData.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.lights[ i ].map !== lightsData[ i ].map ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns the lights data for the given material lights.\n\t *\n\t * @param {Array<Light>} materialLights - The material lights.\n\t * @return {Array<Object>} The lights data for the given material lights.\n\t */\n\tgetLightsData( materialLights ) {\n\n\t\tconst lights = [];\n\n\t\tfor ( const light of materialLights ) {\n\n\t\t\tif ( light.isSpotLight === true && light.map !== null ) {\n\n\t\t\t\t// only add lights that have a map\n\n\t\t\t\tlights.push( { map: light.map.version } );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn lights;\n\n\t}\n\n\t/**\n\t * Returns the lights for the given lights node and render ID.\n\t *\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {number} renderId - The render ID.\n\t * @return {Array} The lights for the given lights node and render ID.\n\t */\n\tgetLights( lightsNode, renderId ) {\n\n\t\tif ( _lightsCache.has( lightsNode ) ) {\n\n\t\t\tconst cached = _lightsCache.get( lightsNode );\n\n\t\t\tif ( cached.renderId === renderId ) {\n\n\t\t\t\treturn cached.lightsData;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst lightsData = this.getLightsData( lightsNode.getLights() );\n\n\t\t_lightsCache.set( lightsNode, { renderId, lightsData } );\n\n\t\treturn lightsData;\n\n\t}\n\n\t/**\n\t * Checks if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {NodeFrame} nodeFrame - The current node frame.\n\t * @return {boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) || this.needsVelocity( nodeFrame.renderer ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst lightsData = this.getLights( renderObject.lightsNode, renderId );\n\t\tconst notEqual = this.equals( renderObject, lightsData ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\nexport default NodeMaterialObserver;\n"],"mappings":"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","ignoreList":[]}