{"version":3,"file":"node_modules/three/src/math/Box3.js","names":["Vector3","Box3","constructor","min","Infinity","max","this","isBox3","set","copy","setFromArray","array","makeEmpty","i","il","length","expandByPoint","_vector","fromArray","setFromBufferAttribute","attribute","count","fromBufferAttribute","setFromPoints","points","setFromCenterAndSize","center","size","halfSize","multiplyScalar","sub","add","setFromObject","object","precise","expandByObject","clone","box","x","y","z","isEmpty","getCenter","target","addVectors","getSize","subVectors","point","expandByVector","vector","expandByScalar","scalar","addScalar","updateWorldMatrix","geometry","undefined","positionAttribute","getAttribute","isInstancedMesh","l","isMesh","getVertexPosition","applyMatrix4","matrixWorld","boundingBox","computeBoundingBox","_box","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","distanceToSquared","radius","intersectsPlane","plane","normal","constant","intersectsTriangle","triangle","_center","_extents","_v0","a","_v1","b","_v2","c","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","crossVectors","clamp","distanceToPoint","distanceTo","getBoundingSphere","intersect","matrix","_points","translate","offset","equals","toJSON","toArray","fromJSON","json","_testAxis","v0","v1","v2","extents","j","r","Math","abs","p0","dot","p1","p2"],"sources":["node_modules/three/src/math/Box3.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\n/**\n * Represents an axis-aligned bounding box (AABB) in 3D space.\n */\nclass Box3 {\n\n\t/**\n\t * Constructs a new bounding box.\n\t *\n\t * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.\n\t * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.\n\t */\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBox3 = true;\n\n\t\t/**\n\t\t * The lower boundary of the box.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.min = min;\n\n\t\t/**\n\t\t * The upper boundary of the box.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.max = max;\n\n\t}\n\n\t/**\n\t * Sets the lower and upper boundaries of this box.\n\t * Please note that this method only copies the values from the given objects.\n\t *\n\t * @param {Vector3} min - The lower boundary of the box.\n\t * @param {Vector3} max - The upper boundary of the box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given array.\n\t *\n\t * @param {Array<number>} array - An array holding 3D position data.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given array.\n\t *\n\t * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Centers this box on the given center vector and sets this box's width, height and\n\t * depth to the given size values.\n\t *\n\t * @param {Vector3} center - The center of the box.\n\t * @param {Vector3} size - The x, y and z dimensions of the box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the world-axis-aligned bounding box for the given 3D object\n\t * (including its children), accounting for the object's, and children's,\n\t * world transforms. The function may result in a larger box than strictly necessary.\n\t *\n\t * @param {Object3D} object - The 3D object to compute the bounding box for.\n\t * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest\n\t * world-axis-aligned bounding box at the expense of more computation.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\t/**\n\t * Returns a new box with copied values from this instance.\n\t *\n\t * @return {Box3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given box to this instance.\n\t *\n\t * @param {Box3} box - The box to copy.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Makes this box empty which means in encloses a zero space in 3D.\n\t *\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns true if this box includes zero points within its bounds.\n\t * Note that a box with equal lower and upper bounds still includes one\n\t * point, the one both bounds share.\n\t *\n\t * @return {boolean} Whether this box is empty or not.\n\t */\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\t/**\n\t * Returns the center point of this box.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The center point.\n\t */\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\t/**\n\t * Returns the dimensions of this box.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this box to include the given point.\n\t *\n\t * @param {Vector3} point - The point that should be included by the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands this box equilaterally by the given vector. The width of this\n\t * box will be expanded by the x component of the vector in both\n\t * directions. The height of this box will be expanded by the y component of\n\t * the vector in both directions. The depth of this box will be\n\t * expanded by the z component of the vector in both directions.\n\t *\n\t * @param {Vector3} vector - The vector that should expand the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands each dimension of the box by the given scalar. If negative, the\n\t * dimensions of the box will be contracted.\n\t *\n\t * @param {number} scalar - The scalar value that should expand the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this box to include the given 3D object and\n\t * its children, accounting for the object's, and children's, world\n\t * transforms. The function may result in a larger box than strictly\n\t * necessary (unless the precise parameter is set to true).\n\t *\n\t * @param {Object3D} object - The 3D object that should expand the bounding box.\n\t * @param {boolean} precise - If set to `true`, the method expands the bounding box\n\t * as little as necessary at the expense of more computation.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within or on the boundaries of this box.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the bounding box contains the given point or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y &&\n\t\t\tpoint.z >= this.min.z && point.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if this bounding box includes the entirety of the given bounding box.\n\t * If this box and the given one are identical, this function also returns `true`.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the bounding box contains the given bounding box or not.\n\t */\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns a point as a proportion of this box's width, height and depth.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} A point as a proportion of this box's width, height and depth.\n\t */\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding box intersects with this bounding box.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the given bounding box intersects with this bounding box.\n\t */\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y &&\n\t\t\tbox.max.z >= this.min.z && box.min.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects with this bounding box.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {boolean} Whether the given bounding sphere intersects with this bounding box.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given plane intersects with this bounding box.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @return {boolean} Whether the given plane intersects with this bounding box.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given triangle intersects with this bounding box.\n\t *\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {boolean} Whether the given triangle intersects with this bounding box.\n\t */\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0.subVectors( triangle.a, _center );\n\t\t_v1.subVectors( triangle.b, _center );\n\t\t_v2.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1, _v0 );\n\t\t_f1.subVectors( _v2, _v1 );\n\t\t_f2.subVectors( _v0, _v2 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0, _v1, _v2, _extents );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this box.\n\t *\n\t * @param {Vector3} point - The point to clamp.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\t/**\n\t * Returns the euclidean distance from any edge of this box to the specified point. If\n\t * the given point lies inside of this box, the distance will be `0`.\n\t *\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The euclidean distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector ).distanceTo( point );\n\n\t}\n\n\t/**\n\t * Returns a bounding sphere that encloses this bounding box.\n\t *\n\t * @param {Sphere} target - The target sphere that is used to store the method's result.\n\t * @return {Sphere} The bounding sphere that encloses this bounding box.\n\t */\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the intersection of this bounding box and the given one, setting the upper\n\t * bound of this box to the lesser of the two boxes' upper bounds and the\n\t * lower bound of this box to the greater of the two boxes' lower bounds. If\n\t * there's no overlap, makes this box empty.\n\t *\n\t * @param {Box3} box - The bounding box to intersect with.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the union of this box and another and the given one, setting the upper\n\t * bound of this box to the greater of the two boxes' upper bounds and the\n\t * lower bound of this box to the lesser of the two boxes' lower bounds.\n\t *\n\t * @param {Box3} box - The bounding box that will be unioned with this instance.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Transforms this bounding box by the given 4x4 transformation matrix.\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given offset to both the upper and lower bounds of this bounding box,\n\t * effectively moving it in 3D space.\n\t *\n\t * @param {Vector3} offset - The offset that should be used to translate the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this bounding box is equal with the given one.\n\t *\n\t * @param {Box3} box - The box to test for equality.\n\t * @return {boolean} Whether this bounding box is equal with the given one.\n\t */\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding box.\n\t *\n\t * @return {Object} Serialized structure with fields representing the object state.\n\t */\n\ttoJSON() {\n\n\t\treturn {\n\t\t\tmin: this.min.toArray(),\n\t\t\tmax: this.max.toArray()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding box.\n\t *\n\t * @param {Object} json - The serialized json to set the box from.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tfromJSON( json ) {\n\n\t\tthis.min.fromArray( json.min );\n\t\tthis.max.fromArray( json.max );\n\t\treturn this;\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\nconst _box = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nexport { Box3 };\n"],"mappings":"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","ignoreList":[]}