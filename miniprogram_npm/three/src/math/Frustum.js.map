{"version":3,"file":"node_modules/three/src/math/Frustum.js","names":["WebGLCoordinateSystem","WebGPUCoordinateSystem","Vector2","Vector3","Sphere","Plane","_sphere","_defaultSpriteCenter","_vector","Frustum","constructor","p0","p1","p2","p3","p4","p5","this","planes","set","copy","frustum","i","setFromProjectionMatrix","m","coordinateSystem","reversedDepth","me","elements","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","normalize","Error","intersectsObject","object","undefined","boundingSphere","computeBoundingSphere","applyMatrix4","matrixWorld","geometry","intersectsSphere","intersectsSprite","sprite","center","offset","distanceTo","radius","sphere","negRadius","distanceToPoint","intersectsBox","box","plane","x","normal","max","min","y","z","containsPoint","point","clone"],"sources":["node_modules/three/src/math/Frustum.js"],"sourcesContent":["import { WebGLCoordinateSystem, WebGPUCoordinateSystem } from '../constants.js';\nimport { Vector2 } from './Vector2.js';\nimport { Vector3 } from './Vector3.js';\nimport { Sphere } from './Sphere.js';\nimport { Plane } from './Plane.js';\n\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _defaultSpriteCenter = /*@__PURE__*/ new Vector2( 0.5, 0.5 );\nconst _vector = /*@__PURE__*/ new Vector3();\n\n/**\n * Frustums are used to determine what is inside the camera's field of view.\n * They help speed up the rendering process - objects which lie outside a camera's\n * frustum can safely be excluded from rendering.\n *\n * This class is mainly intended for use internally by a renderer.\n */\nclass Frustum {\n\n\t/**\n\t * Constructs a new frustum.\n\t *\n\t * @param {Plane} [p0] - The first plane that encloses the frustum.\n\t * @param {Plane} [p1] - The second plane that encloses the frustum.\n\t * @param {Plane} [p2] - The third plane that encloses the frustum.\n\t * @param {Plane} [p3] - The fourth plane that encloses the frustum.\n\t * @param {Plane} [p4] - The fifth plane that encloses the frustum.\n\t * @param {Plane} [p5] - The sixth plane that encloses the frustum.\n\t */\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\t/**\n\t\t * This array holds the planes that enclose the frustum.\n\t\t *\n\t\t * @type {Array<Plane>}\n\t\t */\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\t/**\n\t * Sets the frustum planes by copying the given planes.\n\t *\n\t * @param {Plane} [p0] - The first plane that encloses the frustum.\n\t * @param {Plane} [p1] - The second plane that encloses the frustum.\n\t * @param {Plane} [p2] - The third plane that encloses the frustum.\n\t * @param {Plane} [p3] - The fourth plane that encloses the frustum.\n\t * @param {Plane} [p4] - The fifth plane that encloses the frustum.\n\t * @param {Plane} [p5] - The sixth plane that encloses the frustum.\n\t * @return {Frustum} A reference to this frustum.\n\t */\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given frustum to this instance.\n\t *\n\t * @param {Frustum} frustum - The frustum to copy.\n\t * @return {Frustum} A reference to this frustum.\n\t */\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the frustum planes from the given projection matrix.\n\t *\n\t * @param {Matrix4} m - The projection matrix.\n\t * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.\n\t * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.\n\t * @return {Frustum} A reference to this frustum.\n\t */\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\n\t\tif ( reversedDepth ) {\n\n\t\t\tplanes[ 4 ].setComponents( me2, me6, me10, me14 ).normalize(); // far\n\t\t\tplanes[ 5 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // near\n\n\t\t} else {\n\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // far\n\n\t\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); // near\n\n\t\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize(); // near\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.\n\t *\n\t * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.\n\t */\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given sprite is intersecting this frustum.\n\t *\n\t * @param {Sprite} sprite - The sprite to test.\n\t * @return {boolean} Whether the sprite is intersecting this frustum or not.\n\t */\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\n\t\tconst offset = _defaultSpriteCenter.distanceTo( sprite.center );\n\n\t\t_sphere.radius = 0.7071067811865476 + offset;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere is intersecting this frustum.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding box is intersecting this frustum.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the bounding box is intersecting this frustum or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within the frustum.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the point lies within this frustum or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns a new frustum with copied values from this instance.\n\t *\n\t * @return {Frustum} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n\nexport { Frustum };\n"],"mappings":"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","ignoreList":[]}