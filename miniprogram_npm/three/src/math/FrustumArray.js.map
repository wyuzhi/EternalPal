{"version":3,"file":"node_modules/three/src/math/FrustumArray.js","names":["WebGLCoordinateSystem","Frustum","Matrix4","_projScreenMatrix","_frustum","FrustumArray","constructor","this","coordinateSystem","intersectsObject","object","cameraArray","isArrayCamera","cameras","length","i","camera","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","reversedDepth","intersectsSprite","sprite","intersectsSphere","sphere","intersectsBox","box","containsPoint","point","clone"],"sources":["node_modules/three/src/math/FrustumArray.js"],"sourcesContent":["import { WebGLCoordinateSystem } from '../constants.js';\nimport { Frustum } from './Frustum.js';\nimport { Matrix4 } from './Matrix4.js';\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _frustum = /*@__PURE__*/ new Frustum();\n\n/**\n * FrustumArray is used to determine if an object is visible in at least one camera\n * from an array of cameras. This is particularly useful for multi-view renderers.\n*/\nclass FrustumArray {\n\n\t/**\n\t * Constructs a new frustum array.\n\t *\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The coordinate system to use.\n\t\t *\n\t\t * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}\n\t\t * @default WebGLCoordinateSystem\n\t\t */\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * Returns `true` if the 3D object's bounding sphere is intersecting any frustum\n\t * from the camera array.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.\n\t * @return {boolean} Whether the 3D object is visible in any camera.\n\t */\n\tintersectsObject( object, cameraArray ) {\n\n\t\tif ( ! cameraArray.isArrayCamera || cameraArray.cameras.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameraArray.cameras.length; i ++ ) {\n\n\t\t\tconst camera = cameraArray.cameras[ i ];\n\n\t\t\t_projScreenMatrix.multiplyMatrices(\n\t\t\t\tcamera.projectionMatrix,\n\t\t\t\tcamera.matrixWorldInverse\n\t\t\t);\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t\tif ( _frustum.intersectsObject( object ) ) {\n\n\t\t\t\treturn true; // Object is visible in at least one camera\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false; // Not visible in any camera\n\n\t}\n\n\t/**\n\t * Returns `true` if the given sprite is intersecting any frustum\n\t * from the camera array.\n\t *\n\t * @param {Sprite} sprite - The sprite to test.\n\t * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.\n\t * @return {boolean} Whether the sprite is visible in any camera.\n\t */\n\tintersectsSprite( sprite, cameraArray ) {\n\n\t\tif ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameraArray.cameras.length; i ++ ) {\n\n\t\t\tconst camera = cameraArray.cameras[ i ];\n\n\t\t\t_projScreenMatrix.multiplyMatrices(\n\t\t\t\tcamera.projectionMatrix,\n\t\t\t\tcamera.matrixWorldInverse\n\t\t\t);\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t\tif ( _frustum.intersectsSprite( sprite ) ) {\n\n\t\t\t\treturn true; // Sprite is visible in at least one camera\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false; // Not visible in any camera\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere is intersecting any frustum\n\t * from the camera array.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.\n\t * @return {boolean} Whether the sphere is visible in any camera.\n\t */\n\tintersectsSphere( sphere, cameraArray ) {\n\n\t\tif ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameraArray.cameras.length; i ++ ) {\n\n\t\t\tconst camera = cameraArray.cameras[ i ];\n\n\t\t\t_projScreenMatrix.multiplyMatrices(\n\t\t\t\tcamera.projectionMatrix,\n\t\t\t\tcamera.matrixWorldInverse\n\t\t\t);\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t\tif ( _frustum.intersectsSphere( sphere ) ) {\n\n\t\t\t\treturn true; // Sphere is visible in at least one camera\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false; // Not visible in any camera\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding box is intersecting any frustum\n\t * from the camera array.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.\n\t * @return {boolean} Whether the box is visible in any camera.\n\t */\n\tintersectsBox( box, cameraArray ) {\n\n\t\tif ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameraArray.cameras.length; i ++ ) {\n\n\t\t\tconst camera = cameraArray.cameras[ i ];\n\n\t\t\t_projScreenMatrix.multiplyMatrices(\n\t\t\t\tcamera.projectionMatrix,\n\t\t\t\tcamera.matrixWorldInverse\n\t\t\t);\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t\tif ( _frustum.intersectsBox( box ) ) {\n\n\t\t\t\treturn true; // Box is visible in at least one camera\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false; // Not visible in any camera\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within any frustum\n\t * from the camera array.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.\n\t * @return {boolean} Whether the point is visible in any camera.\n\t */\n\tcontainsPoint( point, cameraArray ) {\n\n\t\tif ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameraArray.cameras.length; i ++ ) {\n\n\t\t\tconst camera = cameraArray.cameras[ i ];\n\n\t\t\t_projScreenMatrix.multiplyMatrices(\n\t\t\t\tcamera.projectionMatrix,\n\t\t\t\tcamera.matrixWorldInverse\n\t\t\t);\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t\tif ( _frustum.containsPoint( point ) ) {\n\n\t\t\t\treturn true; // Point is visible in at least one camera\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false; // Not visible in any camera\n\n\t}\n\n\t/**\n\t * Returns a new frustum array with copied values from this instance.\n\t *\n\t * @return {FrustumArray} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new FrustumArray();\n\n\t}\n\n}\n\nexport { FrustumArray };\n"],"mappings":"OAASA,0BAA6B,yBAC7BC,YAAe,sBACfC,YAAe,eAExB,MAAMC,kBAAkC,IAAID,QACtCE,SAAyB,IAAIH,QAMnC,MAAMI,aAML,WAAAC,GAQCC,KAAKC,iBAAmBR,qBAEzB,CAUA,gBAAAS,CAAkBC,EAAQC,GAEzB,IAAOA,EAAYC,eAAgD,IAA/BD,EAAYE,QAAQC,OAEvD,OAAO,EAIR,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAYE,QAAQC,OAAQC,IAAO,CAEvD,MAAMC,EAASL,EAAYE,QAASE,GAapC,GAXAZ,kBAAkBc,iBACjBD,EAAOE,iBACPF,EAAOG,oBAGRf,SAASgB,wBACRjB,kBACAa,EAAOR,iBACPQ,EAAOK,eAGHjB,SAASK,iBAAkBC,GAE/B,OAAO,CAIT,CAEA,OAAO,CAER,CAUA,gBAAAY,CAAkBC,EAAQZ,GAEzB,IAAOA,IAAiBA,EAAYE,SAA0C,IAA/BF,EAAYE,QAAQC,OAElE,OAAO,EAIR,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAYE,QAAQC,OAAQC,IAAO,CAEvD,MAAMC,EAASL,EAAYE,QAASE,GAapC,GAXAZ,kBAAkBc,iBACjBD,EAAOE,iBACPF,EAAOG,oBAGRf,SAASgB,wBACRjB,kBACAa,EAAOR,iBACPQ,EAAOK,eAGHjB,SAASkB,iBAAkBC,GAE/B,OAAO,CAIT,CAEA,OAAO,CAER,CAUA,gBAAAC,CAAkBC,EAAQd,GAEzB,IAAOA,IAAiBA,EAAYE,SAA0C,IAA/BF,EAAYE,QAAQC,OAElE,OAAO,EAIR,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAYE,QAAQC,OAAQC,IAAO,CAEvD,MAAMC,EAASL,EAAYE,QAASE,GAapC,GAXAZ,kBAAkBc,iBACjBD,EAAOE,iBACPF,EAAOG,oBAGRf,SAASgB,wBACRjB,kBACAa,EAAOR,iBACPQ,EAAOK,eAGHjB,SAASoB,iBAAkBC,GAE/B,OAAO,CAIT,CAEA,OAAO,CAER,CAUA,aAAAC,CAAeC,EAAKhB,GAEnB,IAAOA,IAAiBA,EAAYE,SAA0C,IAA/BF,EAAYE,QAAQC,OAElE,OAAO,EAIR,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAYE,QAAQC,OAAQC,IAAO,CAEvD,MAAMC,EAASL,EAAYE,QAASE,GAapC,GAXAZ,kBAAkBc,iBACjBD,EAAOE,iBACPF,EAAOG,oBAGRf,SAASgB,wBACRjB,kBACAa,EAAOR,iBACPQ,EAAOK,eAGHjB,SAASsB,cAAeC,GAE5B,OAAO,CAIT,CAEA,OAAO,CAER,CAUA,aAAAC,CAAeC,EAAOlB,GAErB,IAAOA,IAAiBA,EAAYE,SAA0C,IAA/BF,EAAYE,QAAQC,OAElE,OAAO,EAIR,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAYE,QAAQC,OAAQC,IAAO,CAEvD,MAAMC,EAASL,EAAYE,QAASE,GAapC,GAXAZ,kBAAkBc,iBACjBD,EAAOE,iBACPF,EAAOG,oBAGRf,SAASgB,wBACRjB,kBACAa,EAAOR,iBACPQ,EAAOK,eAGHjB,SAASwB,cAAeC,GAE5B,OAAO,CAIT,CAEA,OAAO,CAER,CAOA,KAAAC,GAEC,OAAO,IAAIzB,YAEZ,SAIQA","ignoreList":[]}