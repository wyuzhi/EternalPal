class Interpolant{constructor(e,t,i,s){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==s?s:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,s=t[i],a=t[i-1];e:{t:{let r;i:{s:if(!(e<s)){for(let r=i+2;;){if(void 0===s){if(e<a)break s;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===r)break;if(a=s,s=t[++i],e<s)break t}r=t.length;break i}if(e>=a)break e;{const n=t[1];e<n&&(i=2,a=n);for(let r=i-2;;){if(void 0===a)return this._cachedIndex=0,this.copySampleValue_(0);if(i===r)break;if(s=a,a=t[--i-1],e>=a)break t}r=i,i=0}}for(;i<r;){const s=i+r>>>1;e<t[s]?r=s:i=s+1}if(s=t[i],a=t[i-1],void 0===a)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===s)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,a,s)}return this.interpolate_(i,a,e,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,s=this.valueSize,a=e*s;for(let e=0;e!==s;++e)t[e]=i[a+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}export{Interpolant};
//# sourceMappingURL=Interpolant.js.map