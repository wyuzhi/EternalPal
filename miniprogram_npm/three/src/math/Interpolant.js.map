{"version":3,"file":"node_modules/three/src/math/Interpolant.js","names":["Interpolant","constructor","parameterPositions","sampleValues","sampleSize","resultBuffer","this","_cachedIndex","undefined","valueSize","settings","DefaultSettings_","evaluate","t","pp","i1","t1","t0","validate_interval","seek","right","linear_scan","forward_scan","giveUpAt","length","copySampleValue_","t1global","mid","intervalChanged_","interpolate_","getSettings_","index","result","values","stride","offset","i","Error"],"sources":["node_modules/three/src/math/Interpolant.js"],"sourcesContent":["/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References: {@link http://www.oodesign.com/template-method-pattern.html}\n *\n * @abstract\n */\nclass Interpolant {\n\n\t/**\n\t * Constructs a new interpolant.\n\t *\n\t * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.\n\t * @param {TypedArray} sampleValues - The sample values.\n\t * @param {number} sampleSize - The sample size\n\t * @param {TypedArray} [resultBuffer] - The result buffer.\n\t */\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t/**\n\t\t * The parameter positions.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.parameterPositions = parameterPositions;\n\n\t\t/**\n\t\t * A cache index.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cachedIndex = 0;\n\n\t\t/**\n\t\t * The result buffer.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor( sampleSize );\n\n\t\t/**\n\t\t * The sample values.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.sampleValues = sampleValues;\n\n\t\t/**\n\t\t * The value size.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.valueSize = sampleSize;\n\n\t\t/**\n\t\t * The interpolation settings.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.settings = null;\n\n\t\t/**\n\t\t * The default settings object.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\t/**\n\t * Evaluate the interpolant at position `t`.\n\t *\n\t * @param {number} t - The interpolation factor.\n\t * @return {TypedArray} The result buffer.\n\t */\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\t/**\n\t * Returns the interpolation settings.\n\t *\n\t * @return {Object} The interpolation settings.\n\t */\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\t/**\n\t * Copies a sample value to the result buffer.\n\t *\n\t * @param {number} index - An index into the sample value buffer.\n\t * @return {TypedArray} The result buffer.\n\t */\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Copies a sample value to the result buffer.\n\t *\n\t * @abstract\n\t * @param {number} i1 - An index into the sample value buffer.\n\t * @param {number} t0 - The previous interpolation factor.\n\t * @param {number} t - The current interpolation factor.\n\t * @param {number} t1 - The next interpolation factor.\n\t * @return {TypedArray} The result buffer.\n\t */\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\t/**\n\t * Optional method that is executed when the interval has changed.\n\t *\n\t * @param {number} i1 - An index into the sample value buffer.\n\t * @param {number} t0 - The previous interpolation factor.\n\t * @param {number} t - The current interpolation factor.\n\t */\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\nexport { Interpolant };\n"],"mappings":"AAmBA,MAAMA,YAUL,WAAAC,CAAaC,EAAoBC,EAAcC,EAAYC,GAO1DC,KAAKJ,mBAAqBA,EAS1BI,KAAKC,aAAe,EAOpBD,KAAKD,kBAAgCG,IAAjBH,EAA6BA,EAAe,IAAIF,EAAaF,YAAaG,GAO9FE,KAAKH,aAAeA,EAOpBG,KAAKG,UAAYL,EAQjBE,KAAKI,SAAW,KAOhBJ,KAAKK,iBAAmB,CAAC,CAE1B,CAQA,QAAAC,CAAUC,GAET,MAAMC,EAAKR,KAAKJ,mBAChB,IAAIa,EAAKT,KAAKC,aACbS,EAAKF,EAAIC,GACTE,EAAKH,EAAIC,EAAK,GAEfG,EAAmB,CAElBC,EAAM,CAEL,IAAIC,EAEJC,EAAa,CAMZC,EAAc,KAAST,EAAIG,GAAO,CAEjC,IAAM,IAAIO,EAAWR,EAAK,IAAO,CAEhC,QAAYP,IAAPQ,EAAmB,CAEvB,GAAKH,EAAII,EAAK,MAAMK,EAMpB,OAFAP,EAAKD,EAAGU,OACRlB,KAAKC,aAAeQ,EACbT,KAAKmB,iBAAkBV,EAAK,EAEpC,CAEA,GAAKA,IAAOQ,EAAW,MAKvB,GAHAN,EAAKD,EACLA,EAAKF,IAAOC,GAEPF,EAAIG,EAGR,MAAMG,CAIR,CAGAC,EAAQN,EAAGU,OACX,MAAMH,CAEP,CAIA,GAASR,GAAKI,EAiDd,MAAMC,EAjDN,CAIC,MAAMQ,EAAWZ,EAAI,GAEhBD,EAAIa,IAERX,EAAK,EACLE,EAAKS,GAMN,IAAM,IAAIH,EAAWR,EAAK,IAAO,CAEhC,QAAYP,IAAPS,EAKJ,OADAX,KAAKC,aAAe,EACbD,KAAKmB,iBAAkB,GAI/B,GAAKV,IAAOQ,EAAW,MAKvB,GAHAP,EAAKC,EACLA,EAAKH,IAAOC,EAAK,GAEZF,GAAKI,EAGT,MAAME,CAIR,CAGAC,EAAQL,EACRA,EAAK,CAGN,CAMD,CAIA,KAAQA,EAAKK,GAAQ,CAEpB,MAAMO,EAAQZ,EAAKK,IAAY,EAE1BP,EAAIC,EAAIa,GAEZP,EAAQO,EAIRZ,EAAKY,EAAM,CAIb,CAOA,GALAX,EAAKF,EAAIC,GACTE,EAAKH,EAAIC,EAAK,QAIFP,IAAPS,EAGJ,OADAX,KAAKC,aAAe,EACbD,KAAKmB,iBAAkB,GAI/B,QAAYjB,IAAPQ,EAIJ,OAFAD,EAAKD,EAAGU,OACRlB,KAAKC,aAAeQ,EACbT,KAAKmB,iBAAkBV,EAAK,EAIrC,CAEAT,KAAKC,aAAeQ,EAEpBT,KAAKsB,iBAAkBb,EAAIE,EAAID,EAEhC,CAEA,OAAOV,KAAKuB,aAAcd,EAAIE,EAAIJ,EAAGG,EAEtC,CAOA,YAAAc,GAEC,OAAOxB,KAAKI,UAAYJ,KAAKK,gBAE9B,CAQA,gBAAAc,CAAkBM,GAIjB,MAAMC,EAAS1B,KAAKD,aACnB4B,EAAS3B,KAAKH,aACd+B,EAAS5B,KAAKG,UACd0B,EAASJ,EAAQG,EAElB,IAAM,IAAIE,EAAI,EAAGA,IAAMF,IAAWE,EAEjCJ,EAAQI,GAAMH,EAAQE,EAASC,GAIhC,OAAOJ,CAER,CAYA,YAAAH,GAEC,MAAM,IAAIQ,MAAO,0BAGlB,CASA,gBAAAT,GAIA,SAIQ5B","ignoreList":[]}