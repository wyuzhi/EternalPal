{"version":3,"file":"node_modules/three/src/math/Line3.js","names":["Vector3","clamp","_startP","_startEnd","_d1","_d2","_r","_c1","_c2","Line3","constructor","start","end","this","set","copy","line","getCenter","target","addVectors","multiplyScalar","delta","subVectors","distanceSq","distanceToSquared","distance","distanceTo","at","t","add","closestPointToPointParameter","point","clampToLine","startEnd2","dot","closestPointToPoint","distanceSqToLine3","c1","c2","EPSILON","s","p1","p2","q1","q2","a","e","f","sub","c","b","denom","applyMatrix4","matrix","equals","clone"],"sources":["node_modules/three/src/math/Line3.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\nimport { clamp } from './MathUtils.js';\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nconst _d1 = /*@__PURE__*/ new Vector3();\nconst _d2 = /*@__PURE__*/ new Vector3();\nconst _r = /*@__PURE__*/ new Vector3();\nconst _c1 = /*@__PURE__*/ new Vector3();\nconst _c2 = /*@__PURE__*/ new Vector3();\n\n/**\n * An analytical line segment in 3D space represented by a start and end point.\n */\nclass Line3 {\n\n\t/**\n\t * Constructs a new line segment.\n\t *\n\t * @param {Vector3} [start=(0,0,0)] - Start of the line segment.\n\t * @param {Vector3} [end=(0,0,0)] - End of the line segment.\n\t */\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\t/**\n\t\t * Start of the line segment.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.start = start;\n\n\t\t/**\n\t\t * End of the line segment.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.end = end;\n\n\t}\n\n\t/**\n\t * Sets the start and end values by copying the given vectors.\n\t *\n\t * @param {Vector3} start - The start point.\n\t * @param {Vector3} end - The end point.\n\t * @return {Line3} A reference to this line segment.\n\t */\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given line segment to this instance.\n\t *\n\t * @param {Line3} line - The line segment to copy.\n\t * @return {Line3} A reference to this line segment.\n\t */\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the center of the line segment.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The center point.\n\t */\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\t/**\n\t * Returns the delta vector of the line segment's start and end point.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The delta vector.\n\t */\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\t/**\n\t * Returns the squared Euclidean distance between the line' start and end point.\n\t *\n\t * @return {number} The squared Euclidean distance.\n\t */\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\t/**\n\t * Returns the Euclidean distance between the line' start and end point.\n\t *\n\t * @return {number} The Euclidean distance.\n\t */\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\t/**\n\t * Returns a vector at a certain position along the line segment.\n\t *\n\t * @param {number} t - A value between `[0,1]` to represent a position along the line segment.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The delta vector.\n\t */\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\t/**\n\t * Returns a point parameter based on the closest point as projected on the line segment.\n\t *\n\t * @param {Vector3} point - The point for which to return a point parameter.\n\t * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.\n\t * @return {number} The point parameter.\n\t */\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\t/**\n\t * Returns the closest point on the line for a given point.\n\t *\n\t * @param {Vector3} point - The point to compute the closest point on the line for.\n\t * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The closest point on the line.\n\t */\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\t/**\n\t * Returns the closest squared distance between this line segment and the given one.\n\t *\n\t * @param {Line3} line - The line segment to compute the closest squared distance to.\n\t * @param {Vector3} [c1] - The closest point on this line segment.\n\t * @param {Vector3} [c2] - The closest point on the given line segment.\n\t * @return {number} The squared distance between this line segment and the given one.\n\t */\n\tdistanceSqToLine3( line, c1 = _c1, c2 = _c2 ) {\n\n\t\t// from Real-Time Collision Detection by Christer Ericson, chapter 5.1.9\n\n\t\t// Computes closest points C1 and C2 of S1(s)=P1+s*(Q1-P1) and\n\t\t// S2(t)=P2+t*(Q2-P2), returning s and t. Function result is squared\n\t\t// distance between between S1(s) and S2(t)\n\n\t\tconst EPSILON = 1e-8 * 1e-8; // must be squared since we compare squared length\n\t\tlet s, t;\n\n\t\tconst p1 = this.start;\n\t\tconst p2 = line.start;\n\t\tconst q1 = this.end;\n\t\tconst q2 = line.end;\n\n\t\t_d1.subVectors( q1, p1 ); // Direction vector of segment S1\n\t\t_d2.subVectors( q2, p2 ); // Direction vector of segment S2\n\t\t_r.subVectors( p1, p2 );\n\n\t\tconst a = _d1.dot( _d1 ); // Squared length of segment S1, always nonnegative\n\t\tconst e = _d2.dot( _d2 ); // Squared length of segment S2, always nonnegative\n\t\tconst f = _d2.dot( _r );\n\n\t\t// Check if either or both segments degenerate into points\n\n\t\tif ( a <= EPSILON && e <= EPSILON ) {\n\n\t\t\t// Both segments degenerate into points\n\n\t\t\tc1.copy( p1 );\n\t\t\tc2.copy( p2 );\n\n\t\t\tc1.sub( c2 );\n\n\t\t\treturn c1.dot( c1 );\n\n\t\t}\n\n\t\tif ( a <= EPSILON ) {\n\n\t\t\t// First segment degenerates into a point\n\n\t\t\ts = 0;\n\t\t\tt = f / e; // s = 0 => t = (b*s + f) / e = f / e\n\t\t\tt = clamp( t, 0, 1 );\n\n\n\t\t} else {\n\n\t\t\tconst c = _d1.dot( _r );\n\n\t\t\tif ( e <= EPSILON ) {\n\n\t\t\t\t// Second segment degenerates into a point\n\n\t\t\t\tt = 0;\n\t\t\t\ts = clamp( - c / a, 0, 1 ); // t = 0 => s = (b*t - c) / a = -c / a\n\n\t\t\t} else {\n\n\t\t\t\t// The general nondegenerate case starts here\n\n\t\t\t\tconst b = _d1.dot( _d2 );\n\t\t\t\tconst denom = a * e - b * b; // Always nonnegative\n\n\t\t\t\t// If segments not parallel, compute closest point on L1 to L2 and\n\t\t\t\t// clamp to segment S1. Else pick arbitrary s (here 0)\n\n\t\t\t\tif ( denom !== 0 ) {\n\n\t\t\t\t\ts = clamp( ( b * f - c * e ) / denom, 0, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ts = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Compute point on L2 closest to S1(s) using\n\t\t\t\t// t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e\n\n\t\t\t\tt = ( b * s + f ) / e;\n\n\t\t\t\t// If t in [0,1] done. Else clamp t, recompute s for the new value\n\t\t\t\t// of t using s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a\n\t\t\t\t// and clamp s to [0, 1]\n\n\t\t\t\tif ( t < 0 ) {\n\n\t\t\t\t\tt = 0.;\n\t\t\t\t\ts = clamp( - c / a, 0, 1 );\n\n\t\t\t\t} else if ( t > 1 ) {\n\n\t\t\t\t\tt = 1;\n\t\t\t\t\ts = clamp( ( b - c ) / a, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tc1.copy( p1 ).add( _d1.multiplyScalar( s ) );\n\t\tc2.copy( p2 ).add( _d2.multiplyScalar( t ) );\n\n\t\tc1.sub( c2 );\n\n\t\treturn c1.dot( c1 );\n\n\t}\n\n\t/**\n\t * Applies a 4x4 transformation matrix to this line segment.\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @return {Line3} A reference to this line segment.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this line segment is equal with the given one.\n\t *\n\t * @param {Line3} line - The line segment to test for equality.\n\t * @return {boolean} Whether this line segment is equal with the given one.\n\t */\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\t/**\n\t * Returns a new line segment with copied values from this instance.\n\t *\n\t * @return {Line3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Line3 };\n"],"mappings":"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","ignoreList":[]}