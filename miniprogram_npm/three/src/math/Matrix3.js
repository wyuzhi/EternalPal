class Matrix3{constructor(t,e,s,r,i,n,h,o,l){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,s,r,i,n,h,o,l)}set(t,e,s,r,i,n,h,o,l){const a=this.elements;return a[0]=t,a[1]=r,a[2]=h,a[3]=e,a[4]=i,a[5]=o,a[6]=s,a[7]=n,a[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,r=e.elements,i=this.elements,n=s[0],h=s[3],o=s[6],l=s[1],a=s[4],m=s[7],u=s[2],c=s[5],p=s[8],M=r[0],y=r[3],x=r[6],f=r[1],k=r[4],F=r[7],v=r[2],A=r[5],_=r[8];return i[0]=n*M+h*f+o*v,i[3]=n*y+h*k+o*A,i[6]=n*x+h*F+o*_,i[1]=l*M+a*f+m*v,i[4]=l*y+a*k+m*A,i[7]=l*x+a*F+m*_,i[2]=u*M+c*f+p*v,i[5]=u*y+c*k+p*A,i[8]=u*x+c*F+p*_,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],r=t[2],i=t[3],n=t[4],h=t[5],o=t[6],l=t[7],a=t[8];return e*n*a-e*h*l-s*i*a+s*h*o+r*i*l-r*n*o}invert(){const t=this.elements,e=t[0],s=t[1],r=t[2],i=t[3],n=t[4],h=t[5],o=t[6],l=t[7],a=t[8],m=a*n-h*l,u=h*o-a*i,c=l*i-n*o,p=e*m+s*u+r*c;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const M=1/p;return t[0]=m*M,t[1]=(r*l-a*s)*M,t[2]=(h*s-r*n)*M,t[3]=u*M,t[4]=(a*e-r*o)*M,t[5]=(r*i-h*e)*M,t[6]=c*M,t[7]=(s*o-l*e)*M,t[8]=(n*e-s*i)*M,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,r,i,n,h){const o=Math.cos(i),l=Math.sin(i);return this.set(s*o,s*l,-s*(o*n+l*h)+n+t,-r*l,r*o,-r*(-l*n+o*h)+h+e,0,0,1),this}scale(t,e){return this.premultiply(_m3.makeScale(t,e)),this}rotate(t){return this.premultiply(_m3.makeRotation(-t)),this}translate(t,e){return this.premultiply(_m3.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<9;t++)if(e[t]!==s[t])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const _m3=new Matrix3;export{Matrix3};
//# sourceMappingURL=Matrix3.js.map