{"version":3,"file":"node_modules/three/src/math/Plane.js","names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","constructor","normal","constant","this","isPlane","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","addScaledVector","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals","clone"],"sources":["node_modules/three/src/math/Plane.js"],"sourcesContent":["import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\n/**\n * A two dimensional surface that extends infinitely in 3D space, represented\n * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}\n * by a unit length normal vector and a constant.\n */\nclass Plane {\n\n\t/**\n\t * Constructs a new plane.\n\t *\n\t * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.\n\t * @param {number} [constant=0] - The signed distance from the origin to the plane.\n\t */\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPlane = true;\n\n\t\t/**\n\t\t * A unit length vector defining the normal of the plane.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.normal = normal;\n\n\t\t/**\n\t\t * The signed distance from the origin to the plane.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.constant = constant;\n\n\t}\n\n\t/**\n\t * Sets the plane components by copying the given values.\n\t *\n\t * @param {Vector3} normal - The normal.\n\t * @param {number} constant - The constant.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the plane components by defining `x`, `y`, `z` as the\n\t * plane normal and `w` as the constant.\n\t *\n\t * @param {number} x - The value for the normal's x component.\n\t * @param {number} y - The value for the normal's y component.\n\t * @param {number} z - The value for the normal's z component.\n\t * @param {number} w - The constant value.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the plane from the given normal and coplanar point (that is a point\n\t * that lies onto the plane).\n\t *\n\t * @param {Vector3} normal - The normal.\n\t * @param {Vector3} point - A coplanar point.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the plane from three coplanar points. The winding order is\n\t * assumed to be counter-clockwise, and determines the direction of\n\t * the plane normal.\n\t *\n\t * @param {Vector3} a - The first coplanar point.\n\t * @param {Vector3} b - The second coplanar point.\n\t * @param {Vector3} c - The third coplanar point.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given plane to this instance.\n\t *\n\t * @param {Plane} plane - The plane to copy.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Normalizes the plane normal and adjusts the constant accordingly.\n\t *\n\t * @return {Plane} A reference to this plane.\n\t */\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Negates both the plane normal and the constant.\n\t *\n\t * @return {Plane} A reference to this plane.\n\t */\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the signed distance from the given point to this plane.\n\t *\n\t * @param {Vector3} point - The point to compute the distance for.\n\t * @return {number} The signed distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\t/**\n\t * Returns the signed distance from the given sphere to this plane.\n\t *\n\t * @param {Sphere} sphere - The sphere to compute the distance for.\n\t * @return {number} The signed distance.\n\t */\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\t/**\n\t * Projects a the given point onto the plane.\n\t *\n\t * @param {Vector3} point - The point to project.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The projected point on the plane.\n\t */\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\t/**\n\t * Returns the intersection point of the passed line and the plane. Returns\n\t * `null` if the line does not intersect. Returns the line's starting point if\n\t * the line is coplanar with the plane.\n\t *\n\t * @param {Line3} line - The line to compute the intersection for.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point.\n\t */\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given line segment intersects with (passes through) the plane.\n\t *\n\t * @param {Line3} line - The line to test.\n\t * @return {boolean} Whether the given line segment intersects with the plane or not.\n\t */\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding box intersects with the plane.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the given bounding box intersects with the plane or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects with the plane.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {boolean} Whether the given bounding sphere intersects with the plane or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\t/**\n\t * Returns a coplanar vector to the plane, by calculating the\n\t * projection of the normal at the origin onto the plane.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The coplanar point.\n\t */\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\t/**\n\t * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.\n\t *\n\t * The optional normal matrix can be pre-computed like so:\n\t * ```js\n\t * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t * ```\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.\n\t * @return {Plane} A reference to this plane.\n\t */\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates the plane by the distance defined by the given offset vector.\n\t * Note that this only affects the plane constant and will not affect the normal vector.\n\t *\n\t * @param {Vector3} offset - The offset vector.\n\t * @return {Plane} A reference to this plane.\n\t */\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this plane is equal with the given one.\n\t *\n\t * @param {Plane} plane - The plane to test for equality.\n\t * @return {boolean} Whether this plane is equal with the given one.\n\t */\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\t/**\n\t * Returns a new plane with copied values from this instance.\n\t *\n\t * @return {Plane} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Plane };\n"],"mappings":"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","ignoreList":[]}