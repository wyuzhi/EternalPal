import{Vector3}from"./Vector3.js";const _vector=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal=new Vector3;class Ray{constructor(t=new Vector3,i=new Vector3(0,0,-1)){this.origin=t,this.direction=i}set(t,i){return this.origin.copy(t),this.direction.copy(i),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,i){return i.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,_vector)),this}closestPointToPoint(t,i){i.subVectors(t,this.origin);const e=i.dot(this.direction);return e<0?i.copy(this.origin):i.copy(this.origin).addScaledVector(this.direction,e)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const i=_vector.subVectors(t,this.origin).dot(this.direction);return i<0?this.origin.distanceToSquared(t):(_vector.copy(this.origin).addScaledVector(this.direction,i),_vector.distanceToSquared(t))}distanceSqToSegment(t,i,e,r){_segCenter.copy(t).add(i).multiplyScalar(.5),_segDir.copy(i).sub(t).normalize(),_diff.copy(this.origin).sub(_segCenter);const n=.5*t.distanceTo(i),o=-this.direction.dot(_segDir),s=_diff.dot(this.direction),c=-_diff.dot(_segDir),a=_diff.lengthSq(),d=Math.abs(1-o*o);let h,l,u,g;if(d>0)if(h=o*c-s,l=o*s-c,g=n*d,h>=0)if(l>=-g)if(l<=g){const t=1/d;h*=t,l*=t,u=h*(h+o*l+2*s)+l*(o*h+l+2*c)+a}else l=n,h=Math.max(0,-(o*l+s)),u=-h*h+l*(l+2*c)+a;else l=-n,h=Math.max(0,-(o*l+s)),u=-h*h+l*(l+2*c)+a;else l<=-g?(h=Math.max(0,-(-o*n+s)),l=h>0?-n:Math.min(Math.max(-n,-c),n),u=-h*h+l*(l+2*c)+a):l<=g?(h=0,l=Math.min(Math.max(-n,-c),n),u=l*(l+2*c)+a):(h=Math.max(0,-(o*n+s)),l=h>0?n:Math.min(Math.max(-n,-c),n),u=-h*h+l*(l+2*c)+a);else l=o>0?-n:n,h=Math.max(0,-(o*l+s)),u=-h*h+l*(l+2*c)+a;return e&&e.copy(this.origin).addScaledVector(this.direction,h),r&&r.copy(_segCenter).addScaledVector(_segDir,l),u}intersectSphere(t,i){_vector.subVectors(t.center,this.origin);const e=_vector.dot(this.direction),r=_vector.dot(_vector)-e*e,n=t.radius*t.radius;if(r>n)return null;const o=Math.sqrt(n-r),s=e-o,c=e+o;return c<0?null:s<0?this.at(c,i):this.at(s,i)}intersectsSphere(t){return!(t.radius<0)&&this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const i=t.normal.dot(this.direction);if(0===i)return 0===t.distanceToPoint(this.origin)?0:null;const e=-(this.origin.dot(t.normal)+t.constant)/i;return e>=0?e:null}intersectPlane(t,i){const e=this.distanceToPlane(t);return null===e?null:this.at(e,i)}intersectsPlane(t){const i=t.distanceToPoint(this.origin);if(0===i)return!0;return t.normal.dot(this.direction)*i<0}intersectBox(t,i){let e,r,n,o,s,c;const a=1/this.direction.x,d=1/this.direction.y,h=1/this.direction.z,l=this.origin;return a>=0?(e=(t.min.x-l.x)*a,r=(t.max.x-l.x)*a):(e=(t.max.x-l.x)*a,r=(t.min.x-l.x)*a),d>=0?(n=(t.min.y-l.y)*d,o=(t.max.y-l.y)*d):(n=(t.max.y-l.y)*d,o=(t.min.y-l.y)*d),e>o||n>r?null:((n>e||isNaN(e))&&(e=n),(o<r||isNaN(r))&&(r=o),h>=0?(s=(t.min.z-l.z)*h,c=(t.max.z-l.z)*h):(s=(t.max.z-l.z)*h,c=(t.min.z-l.z)*h),e>c||s>r?null:((s>e||e!=e)&&(e=s),(c<r||r!=r)&&(r=c),r<0?null:this.at(e>=0?e:r,i)))}intersectsBox(t){return null!==this.intersectBox(t,_vector)}intersectTriangle(t,i,e,r,n){_edge1.subVectors(i,t),_edge2.subVectors(e,t),_normal.crossVectors(_edge1,_edge2);let o,s=this.direction.dot(_normal);if(s>0){if(r)return null;o=1}else{if(!(s<0))return null;o=-1,s=-s}_diff.subVectors(this.origin,t);const c=o*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(c<0)return null;const a=o*this.direction.dot(_edge1.cross(_diff));if(a<0)return null;if(c+a>s)return null;const d=-o*_diff.dot(_normal);return d<0?null:this.at(d/s,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}export{Ray};
//# sourceMappingURL=Ray.js.map