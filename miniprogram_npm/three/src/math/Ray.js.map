{"version":3,"file":"node_modules/three/src/math/Ray.js","names":["Vector3","_vector","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","constructor","origin","direction","this","set","copy","ray","at","t","target","addScaledVector","lookAt","v","sub","normalize","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","add","multiplyScalar","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","isNaN","intersectsBox","intersectTriangle","a","b","backfaceCulling","crossVectors","sign","DdN","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","transformDirection","equals","clone"],"sources":["node_modules/three/src/math/Ray.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\n\n/**\n * A ray that emits from an origin in a certain direction. The class is used by\n * {@link Raycaster} to assist with raycasting. Raycasting is used for\n * mouse picking (working out what objects in the 3D space the mouse is over)\n * amongst other things.\n */\nclass Ray {\n\n\t/**\n\t * Constructs a new ray.\n\t *\n\t * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.\n\t * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.\n\t */\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\t/**\n\t\t * The origin of the ray.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.origin = origin;\n\n\t\t/**\n\t\t * The (normalized) direction of the ray.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.direction = direction;\n\n\t}\n\n\t/**\n\t * Sets the ray's components by copying the given values.\n\t *\n\t * @param {Vector3} origin - The origin.\n\t * @param {Vector3} direction - The direction.\n\t * @return {Ray} A reference to this ray.\n\t */\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given ray to this instance.\n\t *\n\t * @param {Ray} ray - The ray to copy.\n\t * @return {Ray} A reference to this ray.\n\t */\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a vector that is located at a given distance along this ray.\n\t *\n\t * @param {number} t - The distance along the ray to retrieve a position for.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} A position on the ray.\n\t */\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\t/**\n\t * Adjusts the direction of the ray to point at the given vector in world space.\n\t *\n\t * @param {Vector3} v - The target position.\n\t * @return {Ray} A reference to this ray.\n\t */\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Shift the origin of this ray along its direction by the given distance.\n\t *\n\t * @param {number} t - The distance along the ray to interpolate.\n\t * @return {Ray} A reference to this ray.\n\t */\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the point along this ray that is closest to the given point.\n\t *\n\t * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The closest point on this ray.\n\t */\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\t/**\n\t * Returns the distance of the closest approach between this ray and the given point.\n\t *\n\t * @param {Vector3} point - A point in 3D space to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\t/**\n\t * Returns the squared distance of the closest approach between this ray and the given point.\n\t *\n\t * @param {Vector3} point - A point in 3D space to compute the distance to.\n\t * @return {number} The squared distance.\n\t */\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t}\n\n\t/**\n\t * Returns the squared distance between this ray and the given line segment.\n\t *\n\t * @param {Vector3} v0 - The start point of the line segment.\n\t * @param {Vector3} v1 - The end point of the line segment.\n\t * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.\n\t * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.\n\t * @return {number} The squared distance.\n\t */\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\t/**\n\t * Intersects this ray with the given sphere, returning the intersection\n\t * point or `null` if there is no intersection.\n\t *\n\t * @param {Sphere} sphere - The sphere to intersect.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point.\n\t */\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\t/**\n\t * Returns `true` if this ray intersects with the given sphere.\n\t *\n\t * @param {Sphere} sphere - The sphere to intersect.\n\t * @return {boolean} Whether this ray intersects with the given sphere or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\tif ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray\n\t * does not intersect with the plane.\n\t *\n\t * @param {Plane} plane - The plane to compute the distance to.\n\t * @return {?number} Whether this ray intersects with the given sphere or not.\n\t */\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\t/**\n\t * Intersects this ray with the given plane, returning the intersection\n\t * point or `null` if there is no intersection.\n\t *\n\t * @param {Plane} plane - The plane to intersect.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point.\n\t */\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\t/**\n\t * Returns `true` if this ray intersects with the given plane.\n\t *\n\t * @param {Plane} plane - The plane to intersect.\n\t * @return {boolean} Whether this ray intersects with the given plane or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Intersects this ray with the given bounding box, returning the intersection\n\t * point or `null` if there is no intersection.\n\t *\n\t * @param {Box3} box - The box to intersect.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point.\n\t */\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\t/**\n\t * Returns `true` if this ray intersects with the given box.\n\t *\n\t * @param {Box3} box - The box to intersect.\n\t * @return {boolean} Whether this ray intersects with the given box or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t}\n\n\t/**\n\t * Intersects this ray with the given triangle, returning the intersection\n\t * point or `null` if there is no intersection.\n\t *\n\t * @param {Vector3} a - The first vertex of the triangle.\n\t * @param {Vector3} b - The second vertex of the triangle.\n\t * @param {Vector3} c - The third vertex of the triangle.\n\t * @param {boolean} backfaceCulling - Whether to use backface culling or not.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point.\n\t */\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\t/**\n\t * Transforms this ray with the given 4x4 transformation matrix.\n\t *\n\t * @param {Matrix4} matrix4 - The transformation matrix.\n\t * @return {Ray} A reference to this ray.\n\t */\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this ray is equal with the given one.\n\t *\n\t * @param {Ray} ray - The ray to test for equality.\n\t * @return {boolean} Whether this ray is equal with the given one.\n\t */\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\t/**\n\t * Returns a new ray with copied values from this instance.\n\t *\n\t * @return {Ray} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Ray };\n"],"mappings":"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","ignoreList":[]}