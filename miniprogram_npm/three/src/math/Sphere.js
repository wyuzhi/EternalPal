import{Box3}from"./Box3.js";import{Vector3}from"./Vector3.js";const _box=new Box3,_v1=new Vector3,_v2=new Vector3;class Sphere{constructor(t=new Vector3,s=-1){this.isSphere=!0,this.center=t,this.radius=s}set(t,s){return this.center.copy(t),this.radius=s,this}setFromPoints(t,s){const e=this.center;void 0!==s?e.copy(s):_box.setFromPoints(t).getCenter(e);let r=0;for(let s=0,i=t.length;s<i;s++)r=Math.max(r,e.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const s=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=s*s}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,s){const e=this.center.distanceToSquared(t);return s.copy(t),e>this.radius*this.radius&&(s.sub(this.center).normalize(),s.multiplyScalar(this.radius).add(this.center)),s}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;_v1.subVectors(t,this.center);const s=_v1.lengthSq();if(s>this.radius*this.radius){const t=Math.sqrt(s),e=.5*(t-this.radius);this.center.addScaledVector(_v1,e/t),this.radius+=e}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(_v2.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(_v1.copy(t.center).add(_v2)),this.expandByPoint(_v1.copy(t.center).sub(_v2))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}export{Sphere};
//# sourceMappingURL=Sphere.js.map