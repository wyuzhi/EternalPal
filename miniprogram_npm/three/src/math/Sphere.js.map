{"version":3,"file":"node_modules/three/src/math/Sphere.js","names":["Box3","Vector3","_box","_v1","_v2","Sphere","constructor","center","radius","this","isSphere","set","copy","setFromPoints","points","optionalCenter","undefined","getCenter","maxRadiusSq","i","il","length","Math","max","distanceToSquared","sqrt","sphere","isEmpty","makeEmpty","containsPoint","point","distanceToPoint","distanceTo","intersectsSphere","radiusSum","intersectsBox","box","intersectsPlane","plane","abs","clampPoint","target","deltaLengthSq","sub","normalize","multiplyScalar","add","getBoundingBox","expandByScalar","applyMatrix4","matrix","getMaxScaleOnAxis","translate","offset","expandByPoint","subVectors","lengthSq","delta","addScaledVector","union","equals","setLength","clone","toJSON","toArray","fromJSON","json","fromArray"],"sources":["node_modules/three/src/math/Sphere.js"],"sourcesContent":["import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n/**\n * An analytical 3D sphere defined by a center and radius. This class is mainly\n * used as a Bounding Sphere for 3D objects.\n */\nclass Sphere {\n\n\t/**\n\t * Constructs a new sphere.\n\t *\n\t * @param {Vector3} [center=(0,0,0)] - The center of the sphere\n\t * @param {number} [radius=-1] - The radius of the sphere.\n\t */\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSphere = true;\n\n\t\t/**\n\t\t * The center of the sphere\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.center = center;\n\n\t\t/**\n\t\t * The radius of the sphere.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t}\n\n\t/**\n\t * Sets the sphere's components by copying the given values.\n\t *\n\t * @param {Vector3} center - The center.\n\t * @param {number} radius - The radius.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the minimum bounding sphere for list of points.\n\t * If the optional center point is given, it is used as the sphere's\n\t * center. Otherwise, the center of the axis-aligned bounding box\n\t * encompassing the points is calculated.\n\t *\n\t * @param {Array<Vector3>} points - A list of points in 3D space.\n\t * @param {Vector3} [optionalCenter] - The center of the sphere.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given sphere to this instance.\n\t *\n\t * @param {Sphere} sphere - The sphere to copy.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sphere is empty (the radius set to a negative number).\n\t *\n\t * Spheres with a radius of `0` contain only their center point and are not\n\t * considered to be empty.\n\t *\n\t * @return {boolean} Whether this sphere is empty or not.\n\t */\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\t/**\n\t * Makes this sphere empty which means in encloses a zero space in 3D.\n\t *\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere contains the given point inclusive of\n\t * the surface of the sphere.\n\t *\n\t * @param {Vector3} point - The point to check.\n\t * @return {boolean} Whether this sphere contains the given point or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\t/**\n\t * Returns the closest distance from the boundary of the sphere to the\n\t * given point. If the sphere contains the point, the distance will\n\t * be negative.\n\t *\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The distance to the point.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given one.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @return {boolean} Whether this sphere intersects with the given one or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given box.\n\t *\n\t * @param {Box3} box - The box to test.\n\t * @return {boolean} Whether this sphere intersects with the given box or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given plane.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @return {boolean} Whether this sphere intersects with the given plane or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\t/**\n\t * Clamps a point within the sphere. If the point is outside the sphere, it\n\t * will clamp it to the closest point on the edge of the sphere. Points\n\t * already inside the sphere will not be affected.\n\t *\n\t * @param {Vector3} point - The plane to clamp.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns a bounding box that encloses this sphere.\n\t *\n\t * @param {Box3} target - The target box that is used to store the method's result.\n\t * @return {Box3} The bounding box that encloses this sphere.\n\t */\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Transforms this sphere with the given 4x4 transformation matrix.\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates the sphere's center by the given offset.\n\t *\n\t * @param {Vector3} offset - The offset.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this sphere to include the given point.\n\t *\n\t * @param {Vector3} point - The point to include.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands this sphere to enclose both the original sphere and the given sphere.\n\t *\n\t * @param {Sphere} sphere - The sphere to include.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).add( _v2 ) );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).sub( _v2 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere is equal with the given one.\n\t *\n\t * @param {Sphere} sphere - The sphere to test for equality.\n\t * @return {boolean} Whether this bounding sphere is equal with the given one.\n\t */\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\t/**\n\t * Returns a new sphere with copied values from this instance.\n\t *\n\t * @return {Sphere} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding sphere.\n\t *\n\t * @return {Object} Serialized structure with fields representing the object state.\n\t */\n\ttoJSON() {\n\n\t\treturn {\n\t\t\tradius: this.radius,\n\t\t\tcenter: this.center.toArray()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding sphere.\n\t *\n\t * @param {Object} json - The serialized json to set the sphere from.\n\t * @return {Box3} A reference to this bounding sphere.\n\t */\n\tfromJSON( json ) {\n\n\t\tthis.radius = json.radius;\n\t\tthis.center.fromArray( json.center );\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Sphere };\n"],"mappings":"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","ignoreList":[]}