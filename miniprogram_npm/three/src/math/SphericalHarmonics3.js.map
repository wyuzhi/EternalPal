{"version":3,"file":"node_modules/three/src/math/SphericalHarmonics3.js","names":["Vector3","SphericalHarmonics3","constructor","this","isSphericalHarmonics3","coefficients","i","push","set","copy","zero","getAt","normal","target","x","y","z","coeff","multiplyScalar","addScaledVector","getIrradianceAt","add","sh","addScaledSH","s","scale","lerp","alpha","equals","clone","fromArray","array","offset","toArray","getBasisAt","shBasis"],"sources":["node_modules/three/src/math/SphericalHarmonics3.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\n/**\n * Represents a third-order spherical harmonics (SH). Light probes use this class\n * to encode lighting information.\n *\n * - Primary reference: {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf}\n * - Secondary reference: {@link https://www.ppsloan.org/publications/StupidSH36.pdf}\n */\nclass SphericalHarmonics3 {\n\n\t/**\n\t * Constructs a new spherical harmonics.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\t/**\n\t\t * An array holding the (9) SH coefficients.\n\t\t *\n\t\t * @type {Array<Vector3>}\n\t\t */\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the given SH coefficients to this instance by copying\n\t * the values.\n\t *\n\t * @param {Array<Vector3>} coefficients - The SH coefficients.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets all SH coefficients to `0`.\n\t *\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the radiance in the direction of the given normal.\n\t *\n\t * @param {Vector3} normal - The normal vector (assumed to be unit length)\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The radiance.\n\t */\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns the irradiance (radiance convolved with cosine lobe) in the\n\t * direction of the given normal.\n\t *\n\t * @param {Vector3} normal - The normal vector (assumed to be unit length)\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The irradiance.\n\t */\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Adds the given SH to this instance.\n\t *\n\t * @param {SphericalHarmonics3} sh - The SH to add.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * A convenience method for performing {@link SphericalHarmonics3#add} and\n\t * {@link SphericalHarmonics3#scale} at once.\n\t *\n\t * @param {SphericalHarmonics3} sh - The SH to add.\n\t * @param {number} s - The scale factor.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Scales this SH by the given scale factor.\n\t *\n\t * @param {number} s - The scale factor.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linear interpolates between the given SH and this instance by the given\n\t * alpha factor.\n\t *\n\t * @param {SphericalHarmonics3} sh - The SH to interpolate with.\n\t * @param {number} alpha - The alpha factor.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this spherical harmonics is equal with the given one.\n\t *\n\t * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.\n\t * @return {boolean} Whether this spherical harmonics is equal with the given one.\n\t */\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Copies the values of the given spherical harmonics to this instance.\n\t *\n\t * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.\n\t * @return {SphericalHarmonics3} A reference to this spherical harmonics.\n\t */\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\t/**\n\t * Returns a new spherical harmonics with copied values from this instance.\n\t *\n\t * @return {SphericalHarmonics3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Sets the SH coefficients of this instance from the given array.\n\t *\n\t * @param {Array<number>} array - An array holding the SH coefficients.\n\t * @param {number} [offset=0] - The array offset where to start copying.\n\t * @return {SphericalHarmonics3} A clone of this instance.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an array with the SH coefficients, or copies them into the provided\n\t * array. The coefficients are represented as numbers.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array.\n\t * @param {number} [offset=0] - The array offset where to start copying.\n\t * @return {Array<number>} An array with flat SH coefficients.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Computes the SH basis for the given normal vector.\n\t *\n\t * @param {Vector3} normal - The normal.\n\t * @param {Array<number>} shBasis - The target array holding the SH basis.\n\t */\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nexport { SphericalHarmonics3 };\n"],"mappings":"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","ignoreList":[]}