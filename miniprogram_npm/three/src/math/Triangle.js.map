{"version":3,"file":"node_modules/three/src/math/Triangle.js","names":["Vector3","Vector4","_v0","_v1","_v2","_v3","_vab","_vac","_vbc","_vap","_vbp","_vcp","_v40","_v41","_v42","Triangle","constructor","a","b","c","this","getNormal","target","subVectors","cross","targetLengthSq","lengthSq","multiplyScalar","Math","sqrt","set","getBarycoord","point","dot00","dot","dot01","dot02","dot11","dot12","denom","invDenom","u","v","containsPoint","x","y","getInterpolation","p1","p2","p3","v1","v2","v3","z","w","setScalar","addScaledVector","getInterpolatedAttribute","attr","i1","i2","i3","barycoord","fromBufferAttribute","isFrontFacing","direction","copy","setFromPointsAndIndices","points","i0","setFromAttributeAndIndices","attribute","clone","triangle","getArea","length","getMidpoint","addVectors","add","getPlane","setFromCoplanarPoints","intersectsBox","box","intersectsTriangle","closestPointToPoint","p","d1","d2","d3","d4","vc","d5","d6","vb","va","equals"],"sources":["node_modules/three/src/math/Triangle.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\nimport { Vector4 } from './Vector4.js';\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nconst _v40 = /*@__PURE__*/ new Vector4();\nconst _v41 = /*@__PURE__*/ new Vector4();\nconst _v42 = /*@__PURE__*/ new Vector4();\n\n/**\n * A geometric triangle as defined by three vectors representing its three corners.\n */\nclass Triangle {\n\n\t/**\n\t * Constructs a new triangle.\n\t *\n\t * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.\n\t * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.\n\t * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.\n\t */\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\t/**\n\t\t * The first corner of the triangle.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.a = a;\n\n\t\t/**\n\t\t * The second corner of the triangle.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.b = b;\n\n\t\t/**\n\t\t * The third corner of the triangle.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.c = c;\n\n\t}\n\n\t/**\n\t * Computes the normal vector of a triangle.\n\t *\n\t * @param {Vector3} a - The first corner of the triangle.\n\t * @param {Vector3} b - The second corner of the triangle.\n\t * @param {Vector3} c - The third corner of the triangle.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The triangle's normal.\n\t */\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0.subVectors( a, b );\n\t\ttarget.cross( _v0 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t/**\n\t * Computes a barycentric coordinates from the given vector.\n\t * Returns `null` if the triangle is degenerate.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t * @param {Vector3} a - The first corner of the triangle.\n\t * @param {Vector3} b - The second corner of the triangle.\n\t * @param {Vector3} c - The third corner of the triangle.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The barycentric coordinates for the given point\n\t */\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\t\t_v0.subVectors( c, a );\n\t\t_v1.subVectors( b, a );\n\t\t_v2.subVectors( point, a );\n\n\t\tconst dot00 = _v0.dot( _v0 );\n\t\tconst dot01 = _v0.dot( _v1 );\n\t\tconst dot02 = _v0.dot( _v2 );\n\t\tconst dot11 = _v1.dot( _v1 );\n\t\tconst dot12 = _v1.dot( _v2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point, when projected onto the plane of the\n\t * triangle, lies within the triangle.\n\t *\n\t * @param {Vector3} point - The point in 3D space to test.\n\t * @param {Vector3} a - The first corner of the triangle.\n\t * @param {Vector3} b - The second corner of the triangle.\n\t * @param {Vector3} c - The third corner of the triangle.\n\t * @return {boolean} Whether the given point, when projected onto the plane of the\n\t * triangle, lies within the triangle or not.\n\t */\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );\n\n\t}\n\n\t/**\n\t * Computes the value barycentrically interpolated for the given point on the\n\t * triangle. Returns `null` if the triangle is degenerate.\n\t *\n\t * @param {Vector3} point - Position of interpolated point.\n\t * @param {Vector3} p1 - The first corner of the triangle.\n\t * @param {Vector3} p2 - The second corner of the triangle.\n\t * @param {Vector3} p3 - The third corner of the triangle.\n\t * @param {Vector3} v1 - Value to interpolate of first vertex.\n\t * @param {Vector3} v2 - Value to interpolate of second vertex.\n\t * @param {Vector3} v3 - Value to interpolate of third vertex.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The interpolated value.\n\t */\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3.x );\n\t\ttarget.addScaledVector( v2, _v3.y );\n\t\ttarget.addScaledVector( v3, _v3.z );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the value barycentrically interpolated for the given attribute and indices.\n\t *\n\t * @param {BufferAttribute} attr - The attribute to interpolate.\n\t * @param {number} i1 - Index of first vertex.\n\t * @param {number} i2 - Index of second vertex.\n\t * @param {number} i3 - Index of third vertex.\n\t * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The interpolated attribute value.\n\t */\n\tstatic getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {\n\n\t\t_v40.setScalar( 0 );\n\t\t_v41.setScalar( 0 );\n\t\t_v42.setScalar( 0 );\n\n\t\t_v40.fromBufferAttribute( attr, i1 );\n\t\t_v41.fromBufferAttribute( attr, i2 );\n\t\t_v42.fromBufferAttribute( attr, i3 );\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( _v40, barycoord.x );\n\t\ttarget.addScaledVector( _v41, barycoord.y );\n\t\ttarget.addScaledVector( _v42, barycoord.z );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the triangle is oriented towards the given direction.\n\t *\n\t * @param {Vector3} a - The first corner of the triangle.\n\t * @param {Vector3} b - The second corner of the triangle.\n\t * @param {Vector3} c - The third corner of the triangle.\n\t * @param {Vector3} direction - The (normalized) direction vector.\n\t * @return {boolean} Whether the triangle is oriented towards the given direction or not.\n\t */\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0.subVectors( c, b );\n\t\t_v1.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\t/**\n\t * Sets the triangle's vertices by copying the given values.\n\t *\n\t * @param {Vector3} a - The first corner of the triangle.\n\t * @param {Vector3} b - The second corner of the triangle.\n\t * @param {Vector3} c - The third corner of the triangle.\n\t * @return {Triangle} A reference to this triangle.\n\t */\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the triangle's vertices by copying the given array values.\n\t *\n\t * @param {Array<Vector3>} points - An array with 3D points.\n\t * @param {number} i0 - The array index representing the first corner of the triangle.\n\t * @param {number} i1 - The array index representing the second corner of the triangle.\n\t * @param {number} i2 - The array index representing the third corner of the triangle.\n\t * @return {Triangle} A reference to this triangle.\n\t */\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the triangle's vertices by copying the given attribute values.\n\t *\n\t * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.\n\t * @param {number} i0 - The attribute index representing the first corner of the triangle.\n\t * @param {number} i1 - The attribute index representing the second corner of the triangle.\n\t * @param {number} i2 - The attribute index representing the third corner of the triangle.\n\t * @return {Triangle} A reference to this triangle.\n\t */\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new triangle with copied values from this instance.\n\t *\n\t * @return {Triangle} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given triangle to this instance.\n\t *\n\t * @param {Triangle} triangle - The triangle to copy.\n\t * @return {Triangle} A reference to this triangle.\n\t */\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the area of the triangle.\n\t *\n\t * @return {number} The triangle's area.\n\t */\n\tgetArea() {\n\n\t\t_v0.subVectors( this.c, this.b );\n\t\t_v1.subVectors( this.a, this.b );\n\n\t\treturn _v0.cross( _v1 ).length() * 0.5;\n\n\t}\n\n\t/**\n\t * Computes the midpoint of the triangle.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The triangle's midpoint.\n\t */\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\t/**\n\t * Computes the normal of the triangle.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The triangle's normal.\n\t */\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\t/**\n\t * Computes a plane the triangle lies within.\n\t *\n\t * @param {Plane} target - The target vector that is used to store the method's result.\n\t * @return {Plane} The plane the triangle lies within.\n\t */\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\t/**\n\t * Computes a barycentric coordinates from the given vector.\n\t * Returns `null` if the triangle is degenerate.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The barycentric coordinates for the given point\n\t */\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\t/**\n\t * Computes the value barycentrically interpolated for the given point on the\n\t * triangle. Returns `null` if the triangle is degenerate.\n\t *\n\t * @param {Vector3} point - Position of interpolated point.\n\t * @param {Vector3} v1 - Value to interpolate of first vertex.\n\t * @param {Vector3} v2 - Value to interpolate of second vertex.\n\t * @param {Vector3} v3 - Value to interpolate of third vertex.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The interpolated value.\n\t */\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point, when projected onto the plane of the\n\t * triangle, lies within the triangle.\n\t *\n\t * @param {Vector3} point - The point in 3D space to test.\n\t * @return {boolean} Whether the given point, when projected onto the plane of the\n\t * triangle, lies within the triangle or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\t/**\n\t * Returns `true` if the triangle is oriented towards the given direction.\n\t *\n\t * @param {Vector3} direction - The (normalized) direction vector.\n\t * @return {boolean} Whether the triangle is oriented towards the given direction or not.\n\t */\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\t/**\n\t * Returns `true` if this triangle intersects with the given box.\n\t *\n\t * @param {Box3} box - The box to intersect.\n\t * @return {boolean} Whether this triangle intersects with the given box or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\t/**\n\t * Returns the closest point on the triangle to the given point.\n\t *\n\t * @param {Vector3} p - The point to compute the closest point for.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The closest point on the triangle.\n\t */\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\t/**\n\t * Returns `true` if this triangle is equal with the given one.\n\t *\n\t * @param {Triangle} triangle - The triangle to test for equality.\n\t * @return {boolean} Whether this triangle is equal with the given one.\n\t */\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nexport { Triangle };\n"],"mappings":"OAASA,YAAe,sBACfC,YAAe,eAExB,MAAMC,IAAoB,IAAIF,QACxBG,IAAoB,IAAIH,QACxBI,IAAoB,IAAIJ,QACxBK,IAAoB,IAAIL,QAExBM,KAAqB,IAAIN,QACzBO,KAAqB,IAAIP,QACzBQ,KAAqB,IAAIR,QACzBS,KAAqB,IAAIT,QACzBU,KAAqB,IAAIV,QACzBW,KAAqB,IAAIX,QAEzBY,KAAqB,IAAIX,QACzBY,KAAqB,IAAIZ,QACzBa,KAAqB,IAAIb,QAK/B,MAAMc,SASL,WAAAC,CAAaC,EAAI,IAAIjB,QAAWkB,EAAI,IAAIlB,QAAWmB,EAAI,IAAInB,SAO1DoB,KAAKH,EAAIA,EAOTG,KAAKF,EAAIA,EAOTE,KAAKD,EAAIA,CAEV,CAWA,gBAAOE,CAAWJ,EAAGC,EAAGC,EAAGG,GAE1BA,EAAOC,WAAYJ,EAAGD,GACtBhB,IAAIqB,WAAYN,EAAGC,GACnBI,EAAOE,MAAOtB,KAEd,MAAMuB,EAAiBH,EAAOI,WAC9B,OAAKD,EAAiB,EAEdH,EAAOK,eAAgB,EAAIC,KAAKC,KAAMJ,IAIvCH,EAAOQ,IAAK,EAAG,EAAG,EAE1B,CAaA,mBAAOC,CAAcC,EAAOf,EAAGC,EAAGC,EAAGG,GAIpCpB,IAAIqB,WAAYJ,EAAGF,GACnBd,IAAIoB,WAAYL,EAAGD,GACnBb,IAAImB,WAAYS,EAAOf,GAEvB,MAAMgB,EAAQ/B,IAAIgC,IAAKhC,KACjBiC,EAAQjC,IAAIgC,IAAK/B,KACjBiC,EAAQlC,IAAIgC,IAAK9B,KACjBiC,EAAQlC,IAAI+B,IAAK/B,KACjBmC,EAAQnC,IAAI+B,IAAK9B,KAEjBmC,EAAUN,EAAQI,EAAQF,EAAQA,EAGxC,GAAe,IAAVI,EAGJ,OADAjB,EAAOQ,IAAK,EAAG,EAAG,GACX,KAIR,MAAMU,EAAW,EAAID,EACfE,GAAMJ,EAAQD,EAAQD,EAAQG,GAAUE,EACxCE,GAAMT,EAAQK,EAAQH,EAAQC,GAAUI,EAG9C,OAAOlB,EAAOQ,IAAK,EAAIW,EAAIC,EAAGA,EAAGD,EAElC,CAaA,oBAAOE,CAAeX,EAAOf,EAAGC,EAAGC,GAGlC,OAAkD,OAA7CC,KAAKW,aAAcC,EAAOf,EAAGC,EAAGC,EAAGd,OAM/BA,IAAIuC,GAAK,GAASvC,IAAIwC,GAAK,GAAWxC,IAAIuC,EAAIvC,IAAIwC,GAAO,EAEnE,CAgBA,uBAAOC,CAAkBd,EAAOe,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI9B,GAEvD,OAAqD,OAAhDF,KAAKW,aAAcC,EAAOe,EAAIC,EAAIC,EAAI5C,MAE1CiB,EAAOsB,EAAI,EACXtB,EAAOuB,EAAI,EACN,MAAOvB,IAASA,EAAO+B,EAAI,GAC3B,MAAO/B,IAASA,EAAOgC,EAAI,GACzB,OAIRhC,EAAOiC,UAAW,GAClBjC,EAAOkC,gBAAiBN,EAAI7C,IAAIuC,GAChCtB,EAAOkC,gBAAiBL,EAAI9C,IAAIwC,GAChCvB,EAAOkC,gBAAiBJ,EAAI/C,IAAIgD,GAEzB/B,EAER,CAaA,+BAAOmC,CAA0BC,EAAMC,EAAIC,EAAIC,EAAIC,EAAWxC,GAe7D,OAbAV,KAAK2C,UAAW,GAChB1C,KAAK0C,UAAW,GAChBzC,KAAKyC,UAAW,GAEhB3C,KAAKmD,oBAAqBL,EAAMC,GAChC9C,KAAKkD,oBAAqBL,EAAME,GAChC9C,KAAKiD,oBAAqBL,EAAMG,GAEhCvC,EAAOiC,UAAW,GAClBjC,EAAOkC,gBAAiB5C,KAAMkD,EAAUlB,GACxCtB,EAAOkC,gBAAiB3C,KAAMiD,EAAUjB,GACxCvB,EAAOkC,gBAAiB1C,KAAMgD,EAAUT,GAEjC/B,CAER,CAWA,oBAAO0C,CAAe/C,EAAGC,EAAGC,EAAG8C,GAM9B,OAJA/D,IAAIqB,WAAYJ,EAAGD,GACnBf,IAAIoB,WAAYN,EAAGC,GAGVhB,IAAIsB,MAAOrB,KAAM+B,IAAK+B,GAAc,CAE9C,CAUA,GAAAnC,CAAKb,EAAGC,EAAGC,GAMV,OAJAC,KAAKH,EAAEiD,KAAMjD,GACbG,KAAKF,EAAEgD,KAAMhD,GACbE,KAAKD,EAAE+C,KAAM/C,GAENC,IAER,CAWA,uBAAA+C,CAAyBC,EAAQC,EAAIV,EAAIC,GAMxC,OAJAxC,KAAKH,EAAEiD,KAAME,EAAQC,IACrBjD,KAAKF,EAAEgD,KAAME,EAAQT,IACrBvC,KAAKD,EAAE+C,KAAME,EAAQR,IAEdxC,IAER,CAWA,0BAAAkD,CAA4BC,EAAWF,EAAIV,EAAIC,GAM9C,OAJAxC,KAAKH,EAAE8C,oBAAqBQ,EAAWF,GACvCjD,KAAKF,EAAE6C,oBAAqBQ,EAAWZ,GACvCvC,KAAKD,EAAE4C,oBAAqBQ,EAAWX,GAEhCxC,IAER,CAOA,KAAAoD,GAEC,OAAO,IAAIpD,KAAKJ,aAAckD,KAAM9C,KAErC,CAQA,IAAA8C,CAAMO,GAML,OAJArD,KAAKH,EAAEiD,KAAMO,EAASxD,GACtBG,KAAKF,EAAEgD,KAAMO,EAASvD,GACtBE,KAAKD,EAAE+C,KAAMO,EAAStD,GAEfC,IAER,CAOA,OAAAsD,GAKC,OAHAxE,IAAIqB,WAAYH,KAAKD,EAAGC,KAAKF,GAC7Bf,IAAIoB,WAAYH,KAAKH,EAAGG,KAAKF,GAEM,GAA5BhB,IAAIsB,MAAOrB,KAAMwE,QAEzB,CAQA,WAAAC,CAAatD,GAEZ,OAAOA,EAAOuD,WAAYzD,KAAKH,EAAGG,KAAKF,GAAI4D,IAAK1D,KAAKD,GAAIQ,eAAgB,EAAI,EAE9E,CAQA,SAAAN,CAAWC,GAEV,OAAOP,SAASM,UAAWD,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAGG,EAEpD,CAQA,QAAAyD,CAAUzD,GAET,OAAOA,EAAO0D,sBAAuB5D,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAE3D,CAUA,YAAAY,CAAcC,EAAOV,GAEpB,OAAOP,SAASgB,aAAcC,EAAOZ,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAGG,EAE9D,CAaA,gBAAAwB,CAAkBd,EAAOkB,EAAIC,EAAIC,EAAI9B,GAEpC,OAAOP,SAAS+B,iBAAkBd,EAAOZ,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAG+B,EAAIC,EAAIC,EAAI9B,EAE9E,CAUA,aAAAqB,CAAeX,GAEd,OAAOjB,SAAS4B,cAAeX,EAAOZ,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAE5D,CAQA,aAAA6C,CAAeC,GAEd,OAAOlD,SAASiD,cAAe5C,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAG8C,EAExD,CAQA,aAAAgB,CAAeC,GAEd,OAAOA,EAAIC,mBAAoB/D,KAEhC,CASA,mBAAAgE,CAAqBC,EAAG/D,GAEvB,MAAML,EAAIG,KAAKH,EAAGC,EAAIE,KAAKF,EAAGC,EAAIC,KAAKD,EACvC,IAAIuB,EAAGY,EAQPhD,KAAKiB,WAAYL,EAAGD,GACpBV,KAAKgB,WAAYJ,EAAGF,GACpBR,KAAKc,WAAY8D,EAAGpE,GACpB,MAAMqE,EAAKhF,KAAK4B,IAAKzB,MACf8E,EAAKhF,KAAK2B,IAAKzB,MACrB,GAAK6E,GAAM,GAAKC,GAAM,EAGrB,OAAOjE,EAAO4C,KAAMjD,GAIrBP,KAAKa,WAAY8D,EAAGnE,GACpB,MAAMsE,EAAKlF,KAAK4B,IAAKxB,MACf+E,EAAKlF,KAAK2B,IAAKxB,MACrB,GAAK8E,GAAM,GAAKC,GAAMD,EAGrB,OAAOlE,EAAO4C,KAAMhD,GAIrB,MAAMwE,EAAKJ,EAAKG,EAAKD,EAAKD,EAC1B,GAAKG,GAAM,GAAKJ,GAAM,GAAKE,GAAM,EAIhC,OAFA9C,EAAI4C,GAAOA,EAAKE,GAETlE,EAAO4C,KAAMjD,GAAIuC,gBAAiBlD,KAAMoC,GAIhD/B,KAAKY,WAAY8D,EAAGlE,GACpB,MAAMwE,EAAKrF,KAAK4B,IAAKvB,MACfiF,EAAKrF,KAAK2B,IAAKvB,MACrB,GAAKiF,GAAM,GAAKD,GAAMC,EAGrB,OAAOtE,EAAO4C,KAAM/C,GAIrB,MAAM0E,EAAKF,EAAKJ,EAAKD,EAAKM,EAC1B,GAAKC,GAAM,GAAKN,GAAM,GAAKK,GAAM,EAIhC,OAFAtC,EAAIiC,GAAOA,EAAKK,GAETtE,EAAO4C,KAAMjD,GAAIuC,gBAAiBjD,KAAM+C,GAIhD,MAAMwC,EAAKN,EAAKI,EAAKD,EAAKF,EAC1B,GAAKK,GAAM,GAAOL,EAAKD,GAAQ,GAAOG,EAAKC,GAAQ,EAKlD,OAHApF,KAAKe,WAAYJ,EAAGD,GACpBoC,GAAMmC,EAAKD,IAAWC,EAAKD,GAASG,EAAKC,IAElCtE,EAAO4C,KAAMhD,GAAIsC,gBAAiBhD,KAAM8C,GAKhD,MAAMf,EAAQ,GAAMuD,EAAKD,EAAKH,GAK9B,OAHAhD,EAAImD,EAAKtD,EACTe,EAAIoC,EAAKnD,EAEFjB,EAAO4C,KAAMjD,GAAIuC,gBAAiBlD,KAAMoC,GAAIc,gBAAiBjD,KAAM+C,EAE3E,CAQA,MAAAyC,CAAQtB,GAEP,OAAOA,EAASxD,EAAE8E,OAAQ3E,KAAKH,IAAOwD,EAASvD,EAAE6E,OAAQ3E,KAAKF,IAAOuD,EAAStD,EAAE4E,OAAQ3E,KAAKD,EAE9F,SAIQJ","ignoreList":[]}