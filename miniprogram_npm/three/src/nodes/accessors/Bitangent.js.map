{"version":3,"file":"node_modules/three/src/nodes/accessors/Bitangent.js","names":["Fn","normalGeometry","normalLocal","normalView","normalWorld","tangentGeometry","tangentLocal","tangentView","tangentWorld","bitangentViewFrame","directionToFaceDirection","getBitangent","crossNormalTangent","varyingName","subBuildFn","material","bitangent","mul","w","xyz","flatShading","toVarying","once","bitangentGeometry","cross","normalize","toVar","bitangentLocal","bitangentView","geometry","node","hasAttribute","bitangentWorld"],"sources":["node_modules/three/src/nodes/accessors/Bitangent.js"],"sourcesContent":["import { Fn } from '../tsl/TSLCore.js';\nimport { normalGeometry, normalLocal, normalView, normalWorld } from './Normal.js';\nimport { tangentGeometry, tangentLocal, tangentView, tangentWorld } from './Tangent.js';\nimport { bitangentViewFrame } from './TangentUtils.js';\nimport { directionToFaceDirection } from '../display/FrontFacingNode.js';\n\n/**\n * Returns the bitangent node and assigns it to a varying if the material is not flat shaded.\n *\n * @tsl\n * @private\n * @param {Node<vec3>} crossNormalTangent - The cross product of the normal and tangent vectors.\n * @param {string} varyingName - The name of the varying to assign the bitangent to.\n * @returns {Node<vec3>} The bitangent node.\n */\nconst getBitangent = /*@__PURE__*/ Fn( ( [ crossNormalTangent, varyingName ], { subBuildFn, material } ) => {\n\n\tlet bitangent = crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\n\tif ( subBuildFn === 'NORMAL' && material.flatShading !== true ) {\n\n\t\tbitangent = bitangent.toVarying( varyingName );\n\n\t}\n\n\treturn bitangent;\n\n} ).once( [ 'NORMAL' ] );\n\n/**\n * TSL object that represents the bitangent attribute of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const bitangentGeometry = /*@__PURE__*/ getBitangent( normalGeometry.cross( tangentGeometry ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\n\n/**\n * TSL object that represents the vertex bitangent in local space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const bitangentLocal = /*@__PURE__*/ getBitangent( normalLocal.cross( tangentLocal ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\n\n/**\n * TSL object that represents the vertex bitangent in view space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const bitangentView = /*@__PURE__*/ ( Fn( ( { subBuildFn, geometry, material } ) => {\n\n\tlet node;\n\n\tif ( subBuildFn === 'VERTEX' || geometry.hasAttribute( 'tangent' ) ) {\n\n\t\tnode = getBitangent( normalView.cross( tangentView ), 'v_bitangentView' ).normalize();\n\n\t} else {\n\n\t\tnode = bitangentViewFrame;\n\n\t}\n\n\tif ( material.flatShading !== true ) {\n\n\t\tnode = directionToFaceDirection( node );\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'bitangentView' );\n\n/**\n * TSL object that represents the vertex bitangent in world space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const bitangentWorld = /*@__PURE__*/ getBitangent( normalWorld.cross( tangentWorld ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\n"],"mappings":"OAASA,OAAU,2BACVC,eAAgBC,YAAaC,WAAYC,gBAAmB,qBAC5DC,gBAAiBC,aAAcC,YAAaC,iBAAoB,sBAChEC,uBAA0B,2BAC1BC,6BAAgC,gCAWzC,MAAMC,aAA6BX,IAAI,EAAIY,EAAoBC,IAAiBC,aAAYC,eAE3F,IAAIC,EAAYJ,EAAmBK,IAAKZ,gBAAgBa,GAAIC,IAQ5D,MANoB,WAAfL,IAAoD,IAAzBC,EAASK,cAExCJ,EAAYA,EAAUK,UAAWR,IAI3BG,CAAS,IAEbM,KAAM,CAAE,kBAQL,MAAMC,kBAAkCZ,aAAcV,eAAeuB,MAAOnB,iBAAmB,uBAAwBoB,YAAYC,MAAO,4BAQ1I,MAAMC,eAA+BhB,aAAcT,YAAYsB,MAAOlB,cAAgB,oBAAqBmB,YAAYC,MAAO,yBAQ9H,MAAME,cAAgC5B,IAAI,EAAIc,aAAYe,WAAUd,eAE1E,IAAIe,EAkBJ,OAdCA,EAFmB,WAAfhB,GAA2Be,EAASE,aAAc,WAE/CpB,aAAcR,WAAWqB,MAAOjB,aAAe,mBAAoBkB,YAInEhB,oBAIsB,IAAzBM,EAASK,cAEbU,EAAOpB,yBAA0BoB,IAI3BA,CAAI,GAET,QAASR,KAAM,CAAE,SAAU,UAtBa,GAsBII,MAAO,wBAQ/C,MAAMM,eAA+BrB,aAAcP,YAAYoB,MAAOhB,cAAgB,oBAAqBiB,YAAYC,MAAO","ignoreList":[]}