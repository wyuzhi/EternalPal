{"version":3,"file":"node_modules/three/src/nodes/accessors/BufferAttributeNode.js","names":["InputNode","nodeObject","addMethodChaining","varying","InterleavedBufferAttribute","InterleavedBuffer","StaticDrawUsage","DynamicDrawUsage","BufferAttributeNode","type","constructor","value","bufferType","bufferStride","bufferOffset","super","this","isBufferNode","usage","instanced","attribute","global","isBufferAttribute","isInstancedBufferAttribute","getHash","builder","bufferData","globalCache","getData","undefined","node","setData","uuid","getNodeType","getTypeFromAttribute","setup","array","itemSize","getTypeLength","stride","offset","buffer","isInterleavedBuffer","bufferAttribute","setUsage","generate","nodeType","nodeAttribute","getBufferAttributeFromNode","propertyName","getPropertyName","output","shaderStage","name","build","getInputType","setInstanced","dynamicBufferAttribute","instancedBufferAttribute","instancedDynamicBufferAttribute","bufferNode"],"sources":["node_modules/three/src/nodes/accessors/BufferAttributeNode.js"],"sourcesContent":["import InputNode from '../core/InputNode.js';\nimport { nodeObject, addMethodChaining } from '../tsl/TSLCore.js';\nimport { varying } from '../core/VaryingNode.js';\n\nimport { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../../core/InterleavedBuffer.js';\nimport { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer attribute node.\n\t *\n\t * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n\t * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {number} [bufferStride=0] - The buffer stride.\n\t * @param {number} [bufferOffset=0] - The buffer offset.\n\t */\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The buffer type (e.g. `'vec3'`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer stride.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferStride = bufferStride;\n\n\t\t/**\n\t\t * The buffer offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\t/**\n\t\t * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n\t\t * if you are planning to update the attribute data per frame.\n\t\t *\n\t\t * @type {number}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * Whether the attribute is instanced or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.instanced = false;\n\n\t\t/**\n\t\t * A reference to the buffer attribute.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.attribute = null;\n\n\t\t/**\n\t\t * `BufferAttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the attribute data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the buffer attribute.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\t/**\n\t * Depending on which value was passed to the node, `setup()` behaves\n\t * differently. If no instance of `BufferAttribute` was passed, the method\n\t * creates an internal attribute and configures it respectively.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the buffer attribute node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\t/**\n\t * Sets the `usage` property to the given value.\n\t *\n\t * @param {number} value - The usage to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the `instanced` property to the given value.\n\t *\n\t * @param {boolean} value - The value to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default BufferAttributeNode;\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n"],"mappings":"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","ignoreList":[]}