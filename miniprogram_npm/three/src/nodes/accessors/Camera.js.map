{"version":3,"file":"node_modules/three/src/nodes/accessors/Camera.js","names":["uniform","renderGroup","sharedUniformGroup","Vector3","Fn","uniformArray","builtin","cameraIndex","setName","setGroup","toVarying","cameraNear","onRenderUpdate","camera","near","cameraFar","far","cameraProjectionMatrix","isArrayCamera","cameras","length","matrices","subCamera","push","projectionMatrix","element","isMultiViewCamera","toVar","once","cameraProjectionMatrixInverse","projectionMatrixInverse","cameraViewMatrix","matrixWorldInverse","cameraWorldMatrix","matrixWorld","cameraNormalMatrix","normalMatrix","cameraPosition","self","value","setFromMatrixPosition"],"sources":["node_modules/three/src/nodes/accessors/Camera.js"],"sourcesContent":["import { uniform } from '../core/UniformNode.js';\nimport { renderGroup, sharedUniformGroup } from '../core/UniformGroupNode.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Fn } from '../tsl/TSLBase.js';\nimport { uniformArray } from './UniformArrayNode.js';\nimport { builtin } from './BuiltinNode.js';\n\n/**\n * TSL object that represents the current `index` value of the camera if used ArrayCamera.\n *\n * @tsl\n * @type {UniformNode<uint>}\n */\nexport const cameraIndex = /*@__PURE__*/ uniform( 0, 'uint' ).setName( 'u_cameraIndex' ).setGroup( sharedUniformGroup( 'cameraIndex' ) ).toVarying( 'v_cameraIndex' );\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nexport const cameraNear = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nexport const cameraFar = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraProjectionMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrix );\n\n\t\t}\n\n\t\tconst cameraProjectionMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatrices' );\n\n\t\tcameraProjectionMatrix = cameraProjectionMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toVar( 'cameraProjectionMatrix' );\n\n\t} else {\n\n\t\tcameraProjectionMatrix = uniform( 'mat4' ).setName( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\n\n\t}\n\n\treturn cameraProjectionMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraProjectionMatrixInverse = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrixInverse;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrixInverse );\n\n\t\t}\n\n\t\tconst cameraProjectionMatricesInverse = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatricesInverse' );\n\n\t\tcameraProjectionMatrixInverse = cameraProjectionMatricesInverse.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toVar( 'cameraProjectionMatrixInverse' );\n\n\t} else {\n\n\t\tcameraProjectionMatrixInverse = uniform( 'mat4' ).setName( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\n\n\t}\n\n\treturn cameraProjectionMatrixInverse;\n\n} ).once() )();\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraViewMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorldInverse );\n\n\t\t}\n\n\t\tconst cameraViewMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraViewMatrices' );\n\n\t\tcameraViewMatrix = cameraViewMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toVar( 'cameraViewMatrix' );\n\n\t} else {\n\n\t\tcameraViewMatrix = uniform( 'mat4' ).setName( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\n\n\t}\n\n\treturn cameraViewMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).setName( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nexport const cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).setName( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<vec3>}\n */\nexport const cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).setName( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n"],"mappings":"OAASA,YAAe,gCACfC,YAAaC,uBAA0B,qCACvCC,YAAe,+BACfC,OAAU,2BACVC,iBAAoB,+BACpBC,YAAe,0BAQjB,MAAMC,YAA4BP,QAAS,EAAG,QAASQ,QAAS,iBAAkBC,SAAUP,mBAAoB,gBAAkBQ,UAAW,wBAQ7I,MAAMC,WAA2BX,QAAS,SAAUQ,QAAS,cAAeC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOC,cAQ7I,MAAMC,UAA0Bf,QAAS,SAAUQ,QAAS,aAAcC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOG,aAQ3I,MAAMC,uBAAyCb,IAAI,EAAIS,aAE7D,IAAII,EAEJ,GAAKJ,EAAOK,eAAiBL,EAAOM,QAAQC,OAAS,EAAI,CAExD,MAAMC,EAAW,GAEjB,IAAM,MAAMC,KAAaT,EAAOM,QAE/BE,EAASE,KAAMD,EAAUE,kBAM1BP,EAFiCZ,aAAcgB,GAAWZ,SAAUR,aAAcO,QAAS,4BAEzCiB,QAASZ,EAAOa,kBAAoBpB,QAAS,iBAAoBC,aAAcoB,MAAO,yBAEzI,MAECV,EAAyBjB,QAAS,QAASQ,QAAS,0BAA2BC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOW,mBAIjJ,OAAOP,CAAsB,IAE1BW,MA1BgD,UAkC7C,MAAMC,8BAAgDzB,IAAI,EAAIS,aAEpE,IAAIgB,EAEJ,GAAKhB,EAAOK,eAAiBL,EAAOM,QAAQC,OAAS,EAAI,CAExD,MAAMC,EAAW,GAEjB,IAAM,MAAMC,KAAaT,EAAOM,QAE/BE,EAASE,KAAMD,EAAUQ,yBAM1BD,EAFwCxB,aAAcgB,GAAWZ,SAAUR,aAAcO,QAAS,mCAElCiB,QAASZ,EAAOa,kBAAoBpB,QAAS,iBAAoBC,aAAcoB,MAAO,gCAEvJ,MAECE,EAAgC7B,QAAS,QAASQ,QAAS,iCAAkCC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOiB,0BAI/J,OAAOD,CAA6B,IAEjCD,MA1BuD,UAkCpD,MAAMG,iBAAmC3B,IAAI,EAAIS,aAEvD,IAAIkB,EAEJ,GAAKlB,EAAOK,eAAiBL,EAAOM,QAAQC,OAAS,EAAI,CAExD,MAAMC,EAAW,GAEjB,IAAM,MAAMC,KAAaT,EAAOM,QAE/BE,EAASE,KAAMD,EAAUU,oBAM1BD,EAF2B1B,aAAcgB,GAAWZ,SAAUR,aAAcO,QAAS,sBAE/CiB,QAASZ,EAAOa,kBAAoBpB,QAAS,iBAAoBC,aAAcoB,MAAO,mBAE7H,MAECI,EAAmB/B,QAAS,QAASQ,QAAS,oBAAqBC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOmB,qBAIrI,OAAOD,CAAgB,IAEpBH,MA1B0C,UAkCvC,MAAMK,kBAAkCjC,QAAS,QAASQ,QAAS,qBAAsBC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOqB,qBAQ1J,MAAMC,mBAAmCnC,QAAS,QAASQ,QAAS,sBAAuBC,SAAUR,aAAcW,gBAAgB,EAAIC,YAAcA,EAAOuB,sBAQ5J,MAAMC,eAA+BrC,QAAS,IAAIG,SAAYK,QAAS,kBAAmBC,SAAUR,aAAcW,gBAAgB,EAAIC,UAAUyB,IAAUA,EAAKC,MAAMC,sBAAuB3B,EAAOqB","ignoreList":[]}