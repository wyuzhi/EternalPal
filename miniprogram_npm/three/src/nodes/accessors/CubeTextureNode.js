import TextureNode from"./TextureNode.js";import{reflectVector,refractVector}from"./ReflectVector.js";import{nodeObject,nodeProxy,vec3}from"../tsl/TSLBase.js";import{CubeReflectionMapping,CubeRefractionMapping,WebGPUCoordinateSystem}from"../../constants.js";import{materialEnvRotation}from"./MaterialProperties.js";import{CubeTexture}from"../../textures/CubeTexture.js";const EmptyTexture=new CubeTexture;class CubeTextureNode extends TextureNode{static get type(){return"CubeTextureNode"}constructor(e,t=null,r=null,o=null){super(e,t,r,o),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const e=this.value;return e.mapping===CubeReflectionMapping?reflectVector:e.mapping===CubeRefractionMapping?refractVector:(console.error('THREE.CubeTextureNode: Mapping "%s" not supported.',e.mapping),vec3(0,0,0))}setUpdateMatrix(){}setupUV(e,t){const r=this.value;return e.renderer.coordinateSystem!==WebGPUCoordinateSystem&&r.isRenderTargetTexture||(t=vec3(t.x.negate(),t.yz)),materialEnvRotation.mul(t)}generateUV(e,t){return t.build(e,"vec3")}}export default CubeTextureNode;export const cubeTextureBase=nodeProxy(CubeTextureNode).setParameterLength(1,4).setName("cubeTexture");export const cubeTexture=(e=EmptyTexture,t=null,r=null,o=null)=>{let u;return e&&!0===e.isCubeTextureNode?(u=nodeObject(e.clone()),u.referenceNode=e.getSelf(),null!==t&&(u.uvNode=nodeObject(t)),null!==r&&(u.levelNode=nodeObject(r)),null!==o&&(u.biasNode=nodeObject(o))):u=cubeTextureBase(e,t,r,o),u};export const uniformCubeTexture=(e=EmptyTexture)=>cubeTextureBase(e);
//# sourceMappingURL=CubeTextureNode.js.map