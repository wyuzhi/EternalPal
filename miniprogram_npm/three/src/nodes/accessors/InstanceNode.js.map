{"version":3,"file":"node_modules/three/src/nodes/accessors/InstanceNode.js","names":["Node","varyingProperty","instancedBufferAttribute","instancedDynamicBufferAttribute","normalLocal","transformNormal","positionLocal","nodeProxy","vec3","mat4","NodeUpdateType","buffer","instanceIndex","InstancedInterleavedBuffer","InstancedBufferAttribute","DynamicDrawUsage","InstanceNode","type","constructor","count","instanceMatrix","instanceColor","super","this","instanceMatrixNode","instanceColorNode","updateType","FRAME","bufferColor","setup","builder","array","Math","max","element","bufferFn","usage","instanceBuffers","instancePosition","mul","xyz","assign","hasGeometryAttribute","instanceNormal","update","version","instance","setParameterLength"],"sources":["node_modules/three/src/nodes/accessors/InstanceNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { varyingProperty } from '../core/PropertyNode.js';\nimport { instancedBufferAttribute, instancedDynamicBufferAttribute } from './BufferAttributeNode.js';\nimport { normalLocal, transformNormal } from './Normal.js';\nimport { positionLocal } from './Position.js';\nimport { nodeProxy, vec3, mat4 } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { buffer } from '../accessors/BufferNode.js';\nimport { instanceIndex } from '../core/IndexNode.js';\n\nimport { InstancedInterleavedBuffer } from '../../core/InstancedInterleavedBuffer.js';\nimport { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';\nimport { DynamicDrawUsage } from '../../constants.js';\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via instancing. The code makes sure\n * vertex positions, normals and colors can be modified via instanced\n * data.\n *\n * @augments Node\n */\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instance node.\n\t *\n\t * @param {number} count - The number of instances.\n\t * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n\t * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n\t */\n\tconstructor( count, instanceMatrix, instanceColor = null ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The number of instances.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the transformation of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceMatrix = instanceMatrix;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the color of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceColor = instanceColor;\n\n\t\t/**\n\t\t * The node that represents the instance matrix data.\n\t\t *\n\t\t * @type {?Node}\n\t\t */\n\t\tthis.instanceMatrixNode = null;\n\n\t\t/**\n\t\t * The node that represents the instance color data.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.instanceColorNode = null;\n\n\t\t/**\n\t\t * The update type is set to `frame` since an update\n\t\t * of instanced buffer data must be checked per frame.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceMatrixNode`.\n\t\t *\n\t\t * @type {?InstancedInterleavedBuffer}\n\t\t */\n\t\tthis.buffer = null;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceColorNode`.\n\t\t *\n\t\t * @type {?InstancedBufferAttribute}\n\t\t */\n\t\tthis.bufferColor = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = this;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the internal buffers required an update.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t}\n\n\t}\n\n}\n\nexport default InstanceNode;\n\n/**\n * TSL function for creating an instance node.\n *\n * @tsl\n * @function\n * @param {number} count - The number of instances.\n * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n * @returns {InstanceNode}\n */\nexport const instance = /*@__PURE__*/ nodeProxy( InstanceNode ).setParameterLength( 2, 3 );\n"],"mappings":"OAAOA,SAAU,yBACRC,oBAAuB,iCACvBC,yBAA0BC,oCAAuC,kCACjEC,YAAaC,oBAAuB,qBACpCC,kBAAqB,uBACrBC,UAAWC,KAAMC,SAAY,2BAC7BC,mBAAsB,8BACtBC,WAAc,oCACdC,kBAAqB,8BAErBC,+BAAkC,kDAClCC,6BAAgC,gDAChCC,qBAAwB,qBAUjC,MAAMC,qBAAqBhB,KAE1B,eAAWiB,GAEV,MAAO,cAER,CASA,WAAAC,CAAaC,EAAOC,EAAgBC,EAAgB,MAEnDC,MAAO,QAOPC,KAAKJ,MAAQA,EAObI,KAAKH,eAAiBA,EAOtBG,KAAKF,cAAgBA,EAOrBE,KAAKC,mBAAqB,KAQ1BD,KAAKE,kBAAoB,KASzBF,KAAKG,WAAahB,eAAeiB,MAOjCJ,KAAKZ,OAAS,KAOdY,KAAKK,YAAc,IAEpB,CASA,KAAAC,CAAOC,GAEN,MAAMX,MAAEA,EAAKC,eAAEA,EAAcC,cAAEA,GAAkBE,KAEjD,IAAIC,mBAAEA,EAAkBC,kBAAEA,GAAsBF,KAEhD,GAA4B,OAAvBC,EAA8B,CAIlC,GAAKL,GAAS,IAEbK,EAAqBb,OAAQS,EAAeW,MAAO,OAAQC,KAAKC,IAAKd,EAAO,IAAMe,QAAStB,mBAErF,CAEN,MAAMD,EAAS,IAAIE,2BAA4BO,EAAeW,MAAO,GAAI,GAEzER,KAAKZ,OAASA,EAEd,MAAMwB,EAAWf,EAAegB,QAAUrB,iBAAmBZ,gCAAkCD,yBAEzFmC,EAAkB,CAEvBF,EAAUxB,EAAQ,OAAQ,GAAI,GAC9BwB,EAAUxB,EAAQ,OAAQ,GAAI,GAC9BwB,EAAUxB,EAAQ,OAAQ,GAAI,GAC9BwB,EAAUxB,EAAQ,OAAQ,GAAI,KAG/Ba,EAAqBf,QAAS4B,EAE/B,CAEAd,KAAKC,mBAAqBA,CAE3B,CAEA,GAAKH,GAAuC,OAAtBI,EAA6B,CAElD,MAAMd,EAAS,IAAIG,yBAA0BO,EAAcU,MAAO,GAE5DI,EAAWd,EAAce,QAAUrB,iBAAmBZ,gCAAkCD,yBAE9FqB,KAAKK,YAAcjB,EAEnBc,EAAoBjB,KAAM2B,EAAUxB,EAAQ,OAAQ,EAAG,IAEvDY,KAAKE,kBAAoBA,CAE1B,CAIA,MAAMa,EAAmBd,EAAmBe,IAAKjC,eAAgBkC,IAKjE,GAJAlC,cAAcmC,OAAQH,GAIjBR,EAAQY,qBAAsB,UAAa,CAE/C,MAAMC,EAAiBtC,gBAAiBD,YAAaoB,GAIrDpB,YAAYqC,OAAQE,EAErB,CAIgC,OAA3BpB,KAAKE,mBAETxB,gBAAiB,OAAQ,kBAAmBwC,OAAQlB,KAAKE,kBAI3D,CAOA,MAAAmB,GAEMrB,KAAKH,eAAegB,QAAUrB,kBAAoC,OAAhBQ,KAAKZ,QAAmBY,KAAKH,eAAeyB,UAAYtB,KAAKZ,OAAOkC,UAE1HtB,KAAKZ,OAAOkC,QAAUtB,KAAKH,eAAeyB,SAItCtB,KAAKF,eAAiBE,KAAKF,cAAce,QAAUrB,kBAAyC,OAArBQ,KAAKK,aAAwBL,KAAKF,cAAcwB,UAAYtB,KAAKK,YAAYiB,UAExJtB,KAAKK,YAAYiB,QAAUtB,KAAKF,cAAcwB,QAIhD,iBAIc7B,oBAYR,MAAM8B,SAAyBvC,UAAWS,cAAe+B,mBAAoB,EAAG","ignoreList":[]}