import{uniform}from"../core/UniformNode.js";import{renderGroup}from"../core/UniformGroupNode.js";import{Vector3}from"../../math/Vector3.js";import{cameraViewMatrix}from"./Camera.js";import{positionWorld}from"./Position.js";let uniformsLib;function getLightData(t){uniformsLib=uniformsLib||new WeakMap;let o=uniformsLib.get(t);return void 0===o&&uniformsLib.set(t,o={}),o}export function lightShadowMatrix(t){const o=getLightData(t);return o.shadowMatrix||(o.shadowMatrix=uniform("mat4").setGroup(renderGroup).onRenderUpdate((o=>(!0===t.castShadow&&!1!==o.renderer.shadowMap.enabled||t.shadow.updateMatrices(t),t.shadow.matrix))))}export function lightProjectionUV(t,o=positionWorld){const r=lightShadowMatrix(t).mul(o);return r.xyz.div(r.w)}export function lightPosition(t){const o=getLightData(t);return o.position||(o.position=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate(((o,r)=>r.value.setFromMatrixPosition(t.matrixWorld))))}export function lightTargetPosition(t){const o=getLightData(t);return o.targetPosition||(o.targetPosition=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate(((o,r)=>r.value.setFromMatrixPosition(t.target.matrixWorld))))}export function lightViewPosition(t){const o=getLightData(t);return o.viewPosition||(o.viewPosition=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate((({camera:o},r)=>{r.value=r.value||new Vector3,r.value.setFromMatrixPosition(t.matrixWorld),r.value.applyMatrix4(o.matrixWorldInverse)})))}export const lightTargetDirection=t=>cameraViewMatrix.transformDirection(lightPosition(t).sub(lightTargetPosition(t)));
//# sourceMappingURL=Lights.js.map