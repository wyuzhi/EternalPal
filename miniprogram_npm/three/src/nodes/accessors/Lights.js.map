{"version":3,"file":"node_modules/three/src/nodes/accessors/Lights.js","names":["uniform","renderGroup","Vector3","cameraViewMatrix","positionWorld","uniformsLib","getLightData","light","WeakMap","uniforms","get","undefined","set","lightShadowMatrix","data","shadowMatrix","setGroup","onRenderUpdate","frame","castShadow","renderer","shadowMap","enabled","shadow","updateMatrices","matrix","lightProjectionUV","position","spotLightCoord","mul","xyz","div","w","lightPosition","_","self","value","setFromMatrixPosition","matrixWorld","lightTargetPosition","targetPosition","target","lightViewPosition","viewPosition","camera","applyMatrix4","matrixWorldInverse","lightTargetDirection","transformDirection","sub"],"sources":["node_modules/three/src/nodes/accessors/Lights.js"],"sourcesContent":["import { uniform } from '../core/UniformNode.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { cameraViewMatrix } from './Camera.js';\nimport { positionWorld } from './Position.js';\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\n/**\n * TSL function for getting a shadow matrix uniform node for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<mat4>} The shadow matrix uniform node.\n */\nexport function lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => {\n\n\t\tif ( light.castShadow !== true || frame.renderer.shadowMap.enabled === false ) {\n\n\t\t\tlight.shadow.updateMatrices( light );\n\n\t\t}\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting projected uv coordinates for the given light.\n * Relevant when using maps with spot lights.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @param {Node<vec3>} [position=positionWorld] -The position to project.\n * @returns {Node<vec3>} The projected uvs.\n */\nexport function lightProjectionUV( light, position = positionWorld ) {\n\n\tconst spotLightCoord = lightShadowMatrix( light ).mul( position );\n\tconst projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\treturn projectionUV;\n\n}\n\n/**\n * TSL function for getting the position in world space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in world space.\n */\nexport function lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the light target position in world space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light target position in world space.\n */\nexport function lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the position in view space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light - The light source.\n * @returns {UniformNode<vec3>} The light's position in view space.\n */\nexport function lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting the light target direction for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The light's target direction.\n */\nexport const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n"],"mappings":"OAASA,YAAe,gCACfC,gBAAmB,qCACnBC,YAAe,+BACfC,qBAAwB,qBACxBC,kBAAqB,gBAE9B,IAAIC,YAEJ,SAASC,aAAcC,GAEtBF,YAAcA,aAAe,IAAIG,QAEjC,IAAIC,EAAWJ,YAAYK,IAAKH,GAIhC,YAFkBI,IAAbF,GAAyBJ,YAAYO,IAAKL,EAAOE,EAAW,CAAC,GAE3DA,CAER,QAUO,SAASI,kBAAmBN,GAElC,MAAMO,EAAOR,aAAcC,GAE3B,OAAOO,EAAKC,eAAkBD,EAAKC,aAAef,QAAS,QAASgB,SAAUf,aAAcgB,gBAAkBC,KAEnF,IAArBX,EAAMY,aAA4D,IAArCD,EAAME,SAASC,UAAUC,SAE1Df,EAAMgB,OAAOC,eAAgBjB,GAIvBA,EAAMgB,OAAOE,UAItB,QAYO,SAASC,kBAAmBnB,EAAOoB,EAAWvB,eAEpD,MAAMwB,EAAiBf,kBAAmBN,GAAQsB,IAAKF,GAGvD,OAFqBC,EAAeE,IAAIC,IAAKH,EAAeI,EAI7D,QAUO,SAASC,cAAe1B,GAE9B,MAAMO,EAAOR,aAAcC,GAE3B,OAAOO,EAAKa,WAAcb,EAAKa,SAAW3B,QAAS,IAAIE,SAAYc,SAAUf,aAAcgB,gBAAgB,CAAEiB,EAAGC,IAAUA,EAAKC,MAAMC,sBAAuB9B,EAAM+B,eAEnK,QAUO,SAASC,oBAAqBhC,GAEpC,MAAMO,EAAOR,aAAcC,GAE3B,OAAOO,EAAK0B,iBAAoB1B,EAAK0B,eAAiBxC,QAAS,IAAIE,SAAYc,SAAUf,aAAcgB,gBAAgB,CAAEiB,EAAGC,IAAUA,EAAKC,MAAMC,sBAAuB9B,EAAMkC,OAAOH,eAEtL,QAUO,SAASI,kBAAmBnC,GAElC,MAAMO,EAAOR,aAAcC,GAE3B,OAAOO,EAAK6B,eAAkB7B,EAAK6B,aAAe3C,QAAS,IAAIE,SAAYc,SAAUf,aAAcgB,gBAAgB,EAAI2B,UAAUT,KAEhIA,EAAKC,MAAQD,EAAKC,OAAS,IAAIlC,QAC/BiC,EAAKC,MAAMC,sBAAuB9B,EAAM+B,aAExCH,EAAKC,MAAMS,aAAcD,EAAOE,mBAAoB,IAItD,QAUO,MAAMC,qBAAyBxC,GAAWJ,iBAAiB6C,mBAAoBf,cAAe1B,GAAQ0C,IAAKV,oBAAqBhC","ignoreList":[]}