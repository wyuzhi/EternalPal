import Node from"../core/Node.js";import{reference}from"./ReferenceNode.js";import{materialReference}from"./MaterialReferenceNode.js";import{normalView}from"./Normal.js";import{nodeImmutable,float,vec2,vec3,mat2}from"../tsl/TSLBase.js";import{uniform}from"../core/UniformNode.js";import{normalMap}from"../display/NormalMapNode.js";import{bumpMap}from"../display/BumpMapNode.js";import{Vector2}from"../../math/Vector2.js";const _propertyCache=new Map;class MaterialNode extends Node{static get type(){return"MaterialNode"}constructor(e){super(),this.scope=e}getCache(e,t){let a=_propertyCache.get(e);return void 0===a&&(a=materialReference(e,t),_propertyCache.set(e,a)),a}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache("map"===e?"map":e+"Map","texture")}setup(e){const t=e.context.material,a=this.scope;let o=null;if(a===MaterialNode.COLOR){const e=void 0!==t.color?this.getColor(a):vec3();o=t.map&&!0===t.map.isTexture?e.mul(this.getTexture("map")):e}else if(a===MaterialNode.OPACITY){const e=this.getFloat(a);o=t.alphaMap&&!0===t.alphaMap.isTexture?e.mul(this.getTexture("alpha")):e}else if(a===MaterialNode.SPECULAR_STRENGTH)o=t.specularMap&&!0===t.specularMap.isTexture?this.getTexture("specular").r:float(1);else if(a===MaterialNode.SPECULAR_INTENSITY){const e=this.getFloat(a);o=t.specularIntensityMap&&!0===t.specularIntensityMap.isTexture?e.mul(this.getTexture(a).a):e}else if(a===MaterialNode.SPECULAR_COLOR){const e=this.getColor(a);o=t.specularColorMap&&!0===t.specularColorMap.isTexture?e.mul(this.getTexture(a).rgb):e}else if(a===MaterialNode.ROUGHNESS){const e=this.getFloat(a);o=t.roughnessMap&&!0===t.roughnessMap.isTexture?e.mul(this.getTexture(a).g):e}else if(a===MaterialNode.METALNESS){const e=this.getFloat(a);o=t.metalnessMap&&!0===t.metalnessMap.isTexture?e.mul(this.getTexture(a).b):e}else if(a===MaterialNode.EMISSIVE){const e=this.getFloat("emissiveIntensity"),r=this.getColor(a).mul(e);o=t.emissiveMap&&!0===t.emissiveMap.isTexture?r.mul(this.getTexture(a)):r}else if(a===MaterialNode.NORMAL)t.normalMap?(o=normalMap(this.getTexture("normal"),this.getCache("normalScale","vec2")),o.normalMapType=t.normalMapType):o=t.bumpMap?bumpMap(this.getTexture("bump").r,this.getFloat("bumpScale")):normalView;else if(a===MaterialNode.CLEARCOAT){const e=this.getFloat(a);o=t.clearcoatMap&&!0===t.clearcoatMap.isTexture?e.mul(this.getTexture(a).r):e}else if(a===MaterialNode.CLEARCOAT_ROUGHNESS){const e=this.getFloat(a);o=t.clearcoatRoughnessMap&&!0===t.clearcoatRoughnessMap.isTexture?e.mul(this.getTexture(a).r):e}else if(a===MaterialNode.CLEARCOAT_NORMAL)o=t.clearcoatNormalMap?normalMap(this.getTexture(a),this.getCache(a+"Scale","vec2")):normalView;else if(a===MaterialNode.SHEEN){const e=this.getColor("sheenColor").mul(this.getFloat("sheen"));o=t.sheenColorMap&&!0===t.sheenColorMap.isTexture?e.mul(this.getTexture("sheenColor").rgb):e}else if(a===MaterialNode.SHEEN_ROUGHNESS){const e=this.getFloat(a);o=t.sheenRoughnessMap&&!0===t.sheenRoughnessMap.isTexture?e.mul(this.getTexture(a).a):e,o=o.clamp(.07,1)}else if(a===MaterialNode.ANISOTROPY)if(t.anisotropyMap&&!0===t.anisotropyMap.isTexture){const e=this.getTexture(a);o=mat2(materialAnisotropyVector.x,materialAnisotropyVector.y,materialAnisotropyVector.y.negate(),materialAnisotropyVector.x).mul(e.rg.mul(2).sub(vec2(1)).normalize().mul(e.b))}else o=materialAnisotropyVector;else if(a===MaterialNode.IRIDESCENCE_THICKNESS){const e=reference("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const r=reference("0","float",t.iridescenceThicknessRange);o=e.sub(r).mul(this.getTexture(a).g).add(r)}else o=e}else if(a===MaterialNode.TRANSMISSION){const e=this.getFloat(a);o=t.transmissionMap?e.mul(this.getTexture(a).r):e}else if(a===MaterialNode.THICKNESS){const e=this.getFloat(a);o=t.thicknessMap?e.mul(this.getTexture(a).g):e}else if(a===MaterialNode.IOR)o=this.getFloat(a);else if(a===MaterialNode.LIGHT_MAP)o=this.getTexture(a).rgb.mul(this.getFloat("lightMapIntensity"));else if(a===MaterialNode.AO)o=this.getTexture(a).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else if(a===MaterialNode.LINE_DASH_OFFSET)o=t.dashOffset?this.getFloat(a):float(0);else{const t=this.getNodeType(e);o=this.getCache(a,t)}return o}}MaterialNode.ALPHA_TEST="alphaTest",MaterialNode.COLOR="color",MaterialNode.OPACITY="opacity",MaterialNode.SHININESS="shininess",MaterialNode.SPECULAR="specular",MaterialNode.SPECULAR_STRENGTH="specularStrength",MaterialNode.SPECULAR_INTENSITY="specularIntensity",MaterialNode.SPECULAR_COLOR="specularColor",MaterialNode.REFLECTIVITY="reflectivity",MaterialNode.ROUGHNESS="roughness",MaterialNode.METALNESS="metalness",MaterialNode.NORMAL="normal",MaterialNode.CLEARCOAT="clearcoat",MaterialNode.CLEARCOAT_ROUGHNESS="clearcoatRoughness",MaterialNode.CLEARCOAT_NORMAL="clearcoatNormal",MaterialNode.EMISSIVE="emissive",MaterialNode.ROTATION="rotation",MaterialNode.SHEEN="sheen",MaterialNode.SHEEN_ROUGHNESS="sheenRoughness",MaterialNode.ANISOTROPY="anisotropy",MaterialNode.IRIDESCENCE="iridescence",MaterialNode.IRIDESCENCE_IOR="iridescenceIOR",MaterialNode.IRIDESCENCE_THICKNESS="iridescenceThickness",MaterialNode.IOR="ior",MaterialNode.TRANSMISSION="transmission",MaterialNode.THICKNESS="thickness",MaterialNode.ATTENUATION_DISTANCE="attenuationDistance",MaterialNode.ATTENUATION_COLOR="attenuationColor",MaterialNode.LINE_SCALE="scale",MaterialNode.LINE_DASH_SIZE="dashSize",MaterialNode.LINE_GAP_SIZE="gapSize",MaterialNode.LINE_WIDTH="linewidth",MaterialNode.LINE_DASH_OFFSET="dashOffset",MaterialNode.POINT_SIZE="size",MaterialNode.DISPERSION="dispersion",MaterialNode.LIGHT_MAP="light",MaterialNode.AO="ao";export default MaterialNode;export const materialAlphaTest=nodeImmutable(MaterialNode,MaterialNode.ALPHA_TEST);export const materialColor=nodeImmutable(MaterialNode,MaterialNode.COLOR);export const materialShininess=nodeImmutable(MaterialNode,MaterialNode.SHININESS);export const materialEmissive=nodeImmutable(MaterialNode,MaterialNode.EMISSIVE);export const materialOpacity=nodeImmutable(MaterialNode,MaterialNode.OPACITY);export const materialSpecular=nodeImmutable(MaterialNode,MaterialNode.SPECULAR);export const materialSpecularIntensity=nodeImmutable(MaterialNode,MaterialNode.SPECULAR_INTENSITY);export const materialSpecularColor=nodeImmutable(MaterialNode,MaterialNode.SPECULAR_COLOR);export const materialSpecularStrength=nodeImmutable(MaterialNode,MaterialNode.SPECULAR_STRENGTH);export const materialReflectivity=nodeImmutable(MaterialNode,MaterialNode.REFLECTIVITY);export const materialRoughness=nodeImmutable(MaterialNode,MaterialNode.ROUGHNESS);export const materialMetalness=nodeImmutable(MaterialNode,MaterialNode.METALNESS);export const materialNormal=nodeImmutable(MaterialNode,MaterialNode.NORMAL);export const materialClearcoat=nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT);export const materialClearcoatRoughness=nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT_ROUGHNESS);export const materialClearcoatNormal=nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT_NORMAL);export const materialRotation=nodeImmutable(MaterialNode,MaterialNode.ROTATION);export const materialSheen=nodeImmutable(MaterialNode,MaterialNode.SHEEN);export const materialSheenRoughness=nodeImmutable(MaterialNode,MaterialNode.SHEEN_ROUGHNESS);export const materialAnisotropy=nodeImmutable(MaterialNode,MaterialNode.ANISOTROPY);export const materialIridescence=nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE);export const materialIridescenceIOR=nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE_IOR);export const materialIridescenceThickness=nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE_THICKNESS);export const materialTransmission=nodeImmutable(MaterialNode,MaterialNode.TRANSMISSION);export const materialThickness=nodeImmutable(MaterialNode,MaterialNode.THICKNESS);export const materialIOR=nodeImmutable(MaterialNode,MaterialNode.IOR);export const materialAttenuationDistance=nodeImmutable(MaterialNode,MaterialNode.ATTENUATION_DISTANCE);export const materialAttenuationColor=nodeImmutable(MaterialNode,MaterialNode.ATTENUATION_COLOR);export const materialLineScale=nodeImmutable(MaterialNode,MaterialNode.LINE_SCALE);export const materialLineDashSize=nodeImmutable(MaterialNode,MaterialNode.LINE_DASH_SIZE);export const materialLineGapSize=nodeImmutable(MaterialNode,MaterialNode.LINE_GAP_SIZE);export const materialLineWidth=nodeImmutable(MaterialNode,MaterialNode.LINE_WIDTH);export const materialLineDashOffset=nodeImmutable(MaterialNode,MaterialNode.LINE_DASH_OFFSET);export const materialPointSize=nodeImmutable(MaterialNode,MaterialNode.POINT_SIZE);export const materialDispersion=nodeImmutable(MaterialNode,MaterialNode.DISPERSION);export const materialLightMap=nodeImmutable(MaterialNode,MaterialNode.LIGHT_MAP);export const materialAO=nodeImmutable(MaterialNode,MaterialNode.AO);export const materialAnisotropyVector=uniform(new Vector2).onReference((function(e){return e.material})).onRenderUpdate((function({material:e}){this.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation))}));
//# sourceMappingURL=MaterialNode.js.map