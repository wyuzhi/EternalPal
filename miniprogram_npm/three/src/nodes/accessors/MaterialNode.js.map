{"version":3,"file":"node_modules/three/src/nodes/accessors/MaterialNode.js","names":["Node","reference","materialReference","normalView","nodeImmutable","float","vec2","vec3","mat2","uniform","normalMap","bumpMap","Vector2","_propertyCache","Map","MaterialNode","type","constructor","scope","super","this","getCache","property","node","get","undefined","set","getFloat","getColor","getTexture","setup","builder","material","context","COLOR","colorNode","color","map","isTexture","mul","OPACITY","opacityNode","alphaMap","SPECULAR_STRENGTH","specularMap","r","SPECULAR_INTENSITY","specularIntensityNode","specularIntensityMap","a","SPECULAR_COLOR","specularColorNode","specularColorMap","rgb","ROUGHNESS","roughnessNode","roughnessMap","g","METALNESS","metalnessNode","metalnessMap","b","EMISSIVE","emissiveIntensityNode","emissiveNode","emissiveMap","NORMAL","normalMapType","CLEARCOAT","clearcoatNode","clearcoatMap","CLEARCOAT_ROUGHNESS","clearcoatRoughnessNode","clearcoatRoughnessMap","CLEARCOAT_NORMAL","clearcoatNormalMap","SHEEN","sheenNode","sheenColorMap","SHEEN_ROUGHNESS","sheenRoughnessNode","sheenRoughnessMap","clamp","ANISOTROPY","anisotropyMap","anisotropyPolar","materialAnisotropyVector","x","y","negate","rg","sub","normalize","IRIDESCENCE_THICKNESS","iridescenceThicknessMaximum","iridescenceThicknessRange","iridescenceThicknessMap","iridescenceThicknessMinimum","add","TRANSMISSION","transmissionNode","transmissionMap","THICKNESS","thicknessNode","thicknessMap","IOR","LIGHT_MAP","AO","LINE_DASH_OFFSET","outputType","getNodeType","ALPHA_TEST","SHININESS","SPECULAR","REFLECTIVITY","ROTATION","IRIDESCENCE","IRIDESCENCE_IOR","ATTENUATION_DISTANCE","ATTENUATION_COLOR","LINE_SCALE","LINE_DASH_SIZE","LINE_GAP_SIZE","LINE_WIDTH","POINT_SIZE","DISPERSION","materialAlphaTest","materialColor","materialShininess","materialEmissive","materialOpacity","materialSpecular","materialSpecularIntensity","materialSpecularColor","materialSpecularStrength","materialReflectivity","materialRoughness","materialMetalness","materialNormal","materialClearcoat","materialClearcoatRoughness","materialClearcoatNormal","materialRotation","materialSheen","materialSheenRoughness","materialAnisotropy","materialIridescence","materialIridescenceIOR","materialIridescenceThickness","materialTransmission","materialThickness","materialIOR","materialAttenuationDistance","materialAttenuationColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineWidth","materialLineDashOffset","materialPointSize","materialDispersion","materialLightMap","materialAO","onReference","frame","onRenderUpdate","value","anisotropy","Math","cos","anisotropyRotation","sin"],"sources":["node_modules/three/src/nodes/accessors/MaterialNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { reference } from './ReferenceNode.js';\nimport { materialReference } from './MaterialReferenceNode.js';\nimport { normalView } from './Normal.js';\nimport { nodeImmutable, float, vec2, vec3, mat2 } from '../tsl/TSLBase.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { normalMap } from '../display/NormalMapNode.js';\nimport { bumpMap } from '../display/BumpMapNode.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nconst _propertyCache = new Map();\n\n/**\n * This class should simplify the node access to material properties.\n * It internal uses reference nodes to make sure  changes to material\n * properties are automatically reflected to predefined TSL objects\n * like e.g. `materialColor`.\n *\n * @augments Node\n */\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material node.\n\t *\n\t * @param {string} scope - The scope defines what kind of material property is referred by the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines what material property is referred by the node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Returns a cached reference node for the given property and type.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @param {string} type - The uniform type of the property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Returns a float-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode<float>} A material reference node representing the property access.\n\t */\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\t/**\n\t * Returns a color-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode<color>} A material reference node representing the property access.\n\t */\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\t/**\n\t * Returns a texture-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\t/**\n\t * The node setup is done depending on the selected scope. Multiple material properties\n\t * might be grouped into a single node composition if they logically belong together.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The node representing the selected scope.\n\t */\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensityNode = this.getFloat( scope );\n\n\t\t\tif ( material.specularIntensityMap && material.specularIntensityMap.isTexture === true ) {\n\n\t\t\t\tnode = specularIntensityNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else if ( scope === MaterialNode.LINE_DASH_OFFSET ) {\n\n\t\t\tnode = ( material.dashOffset ) ? this.getFloat( scope ) : float( 0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_SIZE = 'size';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO = 'ao';\n\nexport default MaterialNode;\n\n/**\n * TSL object that represents alpha test of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\n\n/**\n * TSL object that represents the diffuse color of the current material.\n * The value is composed via `color` * `map`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\n\n/**\n * TSL object that represents the shininess of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\n\n/**\n * TSL object that represents the emissive color of the current material.\n * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\n\n/**\n * TSL object that represents the opacity of the current material.\n * The value is composed via `opacity` * `alphaMap`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\n\n/**\n * TSL object that represents the specular of the current material.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\n/**\n * TSL object that represents the specular intensity of the current material.\n * The value is composed via `specularIntensity` * `specularMap.a`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\n\n/**\n * TSL object that represents the specular color of the current material.\n * The value is composed via `specularColor` * `specularMap.rgb`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\n/**\n * TSL object that represents the specular strength of the current material.\n * The value is composed via `specularMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\n\n/**\n * TSL object that represents the reflectivity of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\n\n/**\n * TSL object that represents the roughness of the current material.\n * The value is composed via `roughness` * `roughnessMap.g`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\n\n/**\n * TSL object that represents the metalness of the current material.\n * The value is composed via `metalness` * `metalnessMap.b`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\n\n/**\n * TSL object that represents the normal of the current material.\n * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL );\n\n/**\n * TSL object that represents the clearcoat of the current material.\n * The value is composed via `clearcoat` * `clearcoatMap.r`\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\n\n/**\n * TSL object that represents the clearcoat roughness of the current material.\n * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\n\n/**\n * TSL object that represents the clearcoat normal of the current material.\n * The value will be either `clearcoatNormalMap` or `normalView`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL );\n\n/**\n * TSL object that represents the rotation of the current sprite material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\n\n/**\n * TSL object that represents the sheen color of the current material.\n * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\n\n/**\n * TSL object that represents the sheen roughness of the current material.\n * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\n\n/**\n * TSL object that represents the anisotropy of the current material.\n *\n * @tsl\n * @type {Node<vec2>}\n */\nexport const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\n\n/**\n * TSL object that represents the iridescence of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\n\n/**\n * TSL object that represents the iridescence IOR of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\n\n/**\n * TSL object that represents the iridescence thickness of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\n\n/**\n * TSL object that represents the transmission of the current material.\n * The value is composed via `transmission` * `transmissionMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\n\n/**\n * TSL object that represents the thickness of the current material.\n * The value is composed via `thickness` * `thicknessMap.g`.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\n\n/**\n * TSL object that represents the IOR of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\n\n/**\n * TSL object that represents the attenuation distance of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\n\n/**\n * TSL object that represents the attenuation color of the current material.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\n\n/**\n * TSL object that represents the scale of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\n\n/**\n * TSL object that represents the dash size of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\n\n/**\n * TSL object that represents the gap size of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\n\n/**\n * TSL object that represents the line width of the current line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\n\n/**\n * TSL object that represents the dash offset of the current line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\n\n/**\n * TSL object that represents the point size of the current points material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialPointSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_SIZE );\n\n/**\n * TSL object that represents the dispersion of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\n\n/**\n * TSL object that represents the light map of the current material.\n * The value is composed via `lightMapIntensity` * `lightMap.rgb`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\n\n/**\n * TSL object that represents the ambient occlusion map of the current material.\n * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const materialAO = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO );\n\n/**\n * TSL object that represents the anisotropy vector of the current material.\n *\n * @tsl\n * @type {Node<vec2>}\n */\nexport const materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n"],"mappings":"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","ignoreList":[]}