import Object3DNode from"./Object3DNode.js";import{Fn,nodeImmutable}from"../tsl/TSLBase.js";import{uniform}from"../core/UniformNode.js";import{Matrix4}from"../../math/Matrix4.js";import{cameraViewMatrix}from"./Camera.js";import{Matrix3}from"../../math/Matrix3.js";class ModelNode extends Object3DNode{static get type(){return"ModelNode"}constructor(e){super(e)}update(e){this.object3d=e.object,super.update(e)}}export default ModelNode;export const modelDirection=nodeImmutable(ModelNode,ModelNode.DIRECTION);export const modelWorldMatrix=nodeImmutable(ModelNode,ModelNode.WORLD_MATRIX);export const modelPosition=nodeImmutable(ModelNode,ModelNode.POSITION);export const modelScale=nodeImmutable(ModelNode,ModelNode.SCALE);export const modelViewPosition=nodeImmutable(ModelNode,ModelNode.VIEW_POSITION);export const modelRadius=nodeImmutable(ModelNode,ModelNode.RADIUS);export const modelNormalMatrix=uniform(new Matrix3).onObjectUpdate((({object:e},o)=>o.value.getNormalMatrix(e.matrixWorld)));export const modelWorldMatrixInverse=uniform(new Matrix4).onObjectUpdate((({object:e},o)=>o.value.copy(e.matrixWorld).invert()));export const modelViewMatrix=Fn((e=>e.renderer.overrideNodes.modelViewMatrix||mediumpModelViewMatrix)).once()().toVar("modelViewMatrix");export const mediumpModelViewMatrix=cameraViewMatrix.mul(modelWorldMatrix);export const highpModelViewMatrix=Fn((e=>(e.context.isHighPrecisionModelViewMatrix=!0,uniform("mat4").onObjectUpdate((({object:e,camera:o})=>e.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse,e.matrixWorld)))))).once()().toVar("highpModelViewMatrix");export const highpModelNormalViewMatrix=Fn((e=>{const o=e.context.isHighPrecisionModelViewMatrix;return uniform("mat3").onObjectUpdate((({object:e,camera:t})=>(!0!==o&&e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix))))})).once()().toVar("highpModelNormalViewMatrix");
//# sourceMappingURL=ModelNode.js.map