{"version":3,"file":"node_modules/three/src/nodes/accessors/ModelNode.js","names":["Object3DNode","Fn","nodeImmutable","uniform","Matrix4","cameraViewMatrix","Matrix3","ModelNode","type","constructor","scope","super","update","frame","this","object3d","object","modelDirection","DIRECTION","modelWorldMatrix","WORLD_MATRIX","modelPosition","POSITION","modelScale","SCALE","modelViewPosition","VIEW_POSITION","modelRadius","RADIUS","modelNormalMatrix","onObjectUpdate","self","value","getNormalMatrix","matrixWorld","modelWorldMatrixInverse","copy","invert","modelViewMatrix","builder","renderer","overrideNodes","mediumpModelViewMatrix","once","toVar","mul","highpModelViewMatrix","context","isHighPrecisionModelViewMatrix","camera","multiplyMatrices","matrixWorldInverse","highpModelNormalViewMatrix","normalMatrix"],"sources":["node_modules/three/src/nodes/accessors/ModelNode.js"],"sourcesContent":["import Object3DNode from './Object3DNode.js';\nimport { Fn, nodeImmutable } from '../tsl/TSLBase.js';\nimport { uniform } from '../core/UniformNode.js';\n\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { cameraViewMatrix } from './Camera.js';\nimport { Matrix3 } from '../../math/Matrix3.js';\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments Object3DNode\n */\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object model node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\t/**\n\t * Extracts the model reference from the frame state and then\n\t * updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default ModelNode;\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @tsl\n * @type {ModelNode<mat4>}\n */\nexport const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\n/**\n * TSL object that represents the object's radius.\n *\n * @tsl\n * @type {ModelNode<float>}\n */\nexport const modelRadius = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.RADIUS );\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nexport const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;\n\n} ).once() )().toVar( 'modelViewMatrix' );\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelViewMatrix' );\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat3>}\n */\nexport const highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelNormalViewMatrix' );\n"],"mappings":"OAAOA,iBAAkB,2BAChBC,GAAIC,kBAAqB,2BACzBC,YAAe,gCAEfC,YAAe,+BACfC,qBAAwB,qBACxBC,YAAe,wBAUxB,MAAMC,kBAAkBP,aAEvB,eAAWQ,GAEV,MAAO,WAER,CAOA,WAAAC,CAAaC,GAEZC,MAAOD,EAER,CAQA,MAAAE,CAAQC,GAEPC,KAAKC,SAAWF,EAAMG,OAEtBL,MAAMC,OAAQC,EAEf,iBAIcN,iBAQR,MAAMU,eAA+Bf,cAAeK,UAAWA,UAAUW,kBAQzE,MAAMC,iBAAiCjB,cAAeK,UAAWA,UAAUa,qBAQ3E,MAAMC,cAA8BnB,cAAeK,UAAWA,UAAUe,iBAQxE,MAAMC,WAA2BrB,cAAeK,UAAWA,UAAUiB,cAQrE,MAAMC,kBAAkCvB,cAAeK,UAAWA,UAAUmB,sBAQ5E,MAAMC,YAA4BzB,cAAeK,UAAWA,UAAUqB,eAQtE,MAAMC,kBAAkC1B,QAAS,IAAIG,SAAYwB,gBAAgB,EAAId,UAAUe,IAAUA,EAAKC,MAAMC,gBAAiBjB,EAAOkB,sBAQ5I,MAAMC,wBAAwChC,QAAS,IAAIC,SAAY0B,gBAAgB,EAAId,UAAUe,IAAUA,EAAKC,MAAMI,KAAMpB,EAAOkB,aAAcG,kBAQrJ,MAAMC,gBAAkCrC,IAAMsC,GAE7CA,EAAQC,SAASC,cAAcH,iBAAmBI,yBAEtDC,MAJyC,GAI9BC,MAAO,0BAUf,MAAMF,uBAAuCrC,iBAAiBwC,IAAK1B,yBAWnE,MAAM2B,qBAAuC7C,IAAMsC,IAEzDA,EAAQQ,QAAQC,gCAAiC,EAE1C7C,QAAS,QAAS2B,gBAAgB,EAAId,SAAQiC,YAE7CjC,EAAOsB,gBAAgBY,iBAAkBD,EAAOE,mBAAoBnC,EAAOkB,kBAIhFS,MAV8C,GAUnCC,MAAO,+BASf,MAAMQ,2BAA6CnD,IAAMsC,IAE/D,MAAMS,EAAiCT,EAAQQ,QAAQC,+BAEvD,OAAO7C,QAAS,QAAS2B,gBAAgB,EAAId,SAAQiC,cAEZ,IAAnCD,GAEJhC,EAAOsB,gBAAgBY,iBAAkBD,EAAOE,mBAAoBnC,EAAOkB,aAIrElB,EAAOqC,aAAapB,gBAAiBjB,EAAOsB,mBAEjD,IAEAK,MAhBoD,GAgBzCC,MAAO","ignoreList":[]}