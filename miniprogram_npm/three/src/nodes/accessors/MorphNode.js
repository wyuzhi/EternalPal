import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{float,nodeProxy,Fn,ivec2,int,If}from"../tsl/TSLBase.js";import{uniform}from"../core/UniformNode.js";import{reference}from"./ReferenceNode.js";import{positionLocal}from"./Position.js";import{normalLocal}from"./Normal.js";import{textureLoad}from"./TextureNode.js";import{instanceIndex,vertexIndex}from"../core/IndexNode.js";import{Loop}from"../utils/LoopNode.js";import{DataArrayTexture}from"../../textures/DataArrayTexture.js";import{Vector2}from"../../math/Vector2.js";import{Vector4}from"../../math/Vector4.js";import{FloatType}from"../../constants.js";const _morphTextures=new WeakMap,_morphVec4=new Vector4,getMorph=Fn((({bufferMap:e,influence:t,stride:o,width:r,depth:s,offset:i})=>{const n=int(vertexIndex).mul(o).add(i),m=n.div(r),p=n.sub(m.mul(r));return textureLoad(e,ivec2(p,m)).depth(s).xyz.mul(t)}));function getEntry(e){const t=void 0!==e.morphAttributes.position,o=void 0!==e.morphAttributes.normal,r=void 0!==e.morphAttributes.color,s=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,i=void 0!==s?s.length:0;let n=_morphTextures.get(e);if(void 0===n||n.count!==i){void 0!==n&&n.texture.dispose();const s=e.morphAttributes.position||[],m=e.morphAttributes.normal||[],p=e.morphAttributes.color||[];let h=0;!0===t&&(h=1),!0===o&&(h=2),!0===r&&(h=3);let u=e.attributes.position.count*h,c=1;const a=4096;u>a&&(c=Math.ceil(u/a),u=a);const d=new Float32Array(u*c*4*i),f=new DataArrayTexture(d,u,c,i);f.type=FloatType,f.needsUpdate=!0;const l=4*h;for(let e=0;e<i;e++){const i=s[e],n=m[e],h=p[e],a=u*c*4*e;for(let e=0;e<i.count;e++){const s=e*l;!0===t&&(_morphVec4.fromBufferAttribute(i,e),d[a+s+0]=_morphVec4.x,d[a+s+1]=_morphVec4.y,d[a+s+2]=_morphVec4.z,d[a+s+3]=0),!0===o&&(_morphVec4.fromBufferAttribute(n,e),d[a+s+4]=_morphVec4.x,d[a+s+5]=_morphVec4.y,d[a+s+6]=_morphVec4.z,d[a+s+7]=0),!0===r&&(_morphVec4.fromBufferAttribute(h,e),d[a+s+8]=_morphVec4.x,d[a+s+9]=_morphVec4.y,d[a+s+10]=_morphVec4.z,d[a+s+11]=4===h.itemSize?_morphVec4.w:1)}}n={count:i,texture:f,stride:h,size:new Vector2(u,c)},_morphTextures.set(e,n),e.addEventListener("dispose",(function t(){f.dispose(),_morphTextures.delete(e),e.removeEventListener("dispose",t)}))}return n}class MorphNode extends Node{static get type(){return"MorphNode"}constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=uniform(1),this.updateType=NodeUpdateType.OBJECT}setup(e){const{geometry:t}=e,o=void 0!==t.morphAttributes.position,r=t.hasAttribute("normal")&&void 0!==t.morphAttributes.normal,s=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,i=void 0!==s?s.length:0,{texture:n,stride:m,size:p}=getEntry(t);!0===o&&positionLocal.mulAssign(this.morphBaseInfluence),!0===r&&normalLocal.mulAssign(this.morphBaseInfluence);const h=int(p.width);Loop(i,(({i:e})=>{const t=float(0).toVar();this.mesh.count>1&&null!==this.mesh.morphTexture&&void 0!==this.mesh.morphTexture?t.assign(textureLoad(this.mesh.morphTexture,ivec2(int(e).add(1),int(instanceIndex))).r):t.assign(reference("morphTargetInfluences","float").element(e).toVar()),If(t.notEqual(0),(()=>{!0===o&&positionLocal.addAssign(getMorph({bufferMap:n,influence:t,stride:m,width:h,depth:e,offset:int(0)})),!0===r&&normalLocal.addAssign(getMorph({bufferMap:n,influence:t,stride:m,width:h,depth:e,offset:int(1)}))}))}))}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce(((e,t)=>e+t),0)}}export default MorphNode;export const morphReference=nodeProxy(MorphNode).setParameterLength(1);
//# sourceMappingURL=MorphNode.js.map