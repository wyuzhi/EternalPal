{"version":3,"file":"node_modules/three/src/nodes/accessors/MorphNode.js","names":["Node","NodeUpdateType","float","nodeProxy","Fn","ivec2","int","If","uniform","reference","positionLocal","normalLocal","textureLoad","instanceIndex","vertexIndex","Loop","DataArrayTexture","Vector2","Vector4","FloatType","_morphTextures","WeakMap","_morphVec4","getMorph","bufferMap","influence","stride","width","depth","offset","texelIndex","mul","add","y","div","x","sub","xyz","getEntry","geometry","hasMorphPosition","undefined","morphAttributes","position","hasMorphNormals","normal","hasMorphColors","color","morphAttribute","morphTargetsCount","length","entry","get","count","texture","dispose","morphTargets","morphNormals","morphColors","vertexDataCount","attributes","height","maxTextureSize","Math","ceil","buffer","Float32Array","bufferTexture","type","needsUpdate","vertexDataStride","i","morphTarget","morphNormal","morphColor","j","fromBufferAttribute","z","itemSize","w","size","set","addEventListener","disposeTexture","delete","removeEventListener","MorphNode","constructor","mesh","super","this","morphBaseInfluence","updateType","OBJECT","setup","builder","hasAttribute","mulAssign","toVar","morphTexture","assign","r","element","notEqual","addAssign","update","morphTargetsRelative","value","morphTargetInfluences","reduce","a","b","morphReference","setParameterLength"],"sources":["node_modules/three/src/nodes/accessors/MorphNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { float, nodeProxy, Fn, ivec2, int, If } from '../tsl/TSLBase.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { reference } from './ReferenceNode.js';\nimport { positionLocal } from './Position.js';\nimport { normalLocal } from './Normal.js';\nimport { textureLoad } from './TextureNode.js';\nimport { instanceIndex, vertexIndex } from '../core/IndexNode.js';\nimport { Loop } from '../utils/LoopNode.js';\n\nimport { DataArrayTexture } from '../../textures/DataArrayTexture.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { FloatType } from '../../constants.js';\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth ).xyz;\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for morph target animation.\n *\n * @augments Node\n */\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\t/**\n\t * Constructs a new morph node.\n\t *\n\t * @param {Mesh} mesh - The mesh holding the morph targets.\n\t */\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The mesh holding the morph targets.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = mesh;\n\n\t\t/**\n\t\t * A uniform node which represents the morph base influence value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\t/**\n\t\t * The update type overwritten since morph nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Setups the morph node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tIf( influence.notEqual( 0 ), () => {\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\t\tbufferMap,\n\t\t\t\t\t\tinfluence,\n\t\t\t\t\t\tstride,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tdepth: i,\n\t\t\t\t\t\toffset: int( 0 )\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\t\tbufferMap,\n\t\t\t\t\t\tinfluence,\n\t\t\t\t\t\tstride,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tdepth: i,\n\t\t\t\t\t\toffset: int( 1 )\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the state of the morphed mesh by updating the base influence.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\nexport default MorphNode;\n\n/**\n * TSL function for creating a morph node.\n *\n * @tsl\n * @function\n * @param {Mesh} mesh - The mesh holding the morph targets.\n * @returns {MorphNode}\n */\nexport const morphReference = /*@__PURE__*/ nodeProxy( MorphNode ).setParameterLength( 1 );\n"],"mappings":"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","ignoreList":[]}