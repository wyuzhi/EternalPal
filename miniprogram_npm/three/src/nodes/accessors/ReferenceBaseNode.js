import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{nodeObject}from"../tsl/TSLCore.js";import ArrayElementNode from"../utils/ArrayElementNode.js";class ReferenceElementNode extends ArrayElementNode{static get type(){return"ReferenceElementNode"}constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),r=this.referenceNode.getNodeType(),o=this.getNodeType();return e.format(t,r,o)}}class ReferenceBaseNode extends Node{static get type(){return"ReferenceBaseNode"}constructor(e,t,r=null,o=null){super(),this.property=e,this.uniformType=t,this.object=r,this.count=o,this.properties=e.split("."),this.reference=r,this.node=null,this.group=null,this.updateType=NodeUpdateType.OBJECT}setGroup(e){return this.group=e,this}element(e){return nodeObject(new ReferenceElementNode(this,nodeObject(e)))}setNodeType(e){const t=uniform(null,e).getSelf();null!==this.group&&t.setGroup(this.group),this.node=t}getNodeType(e){return null===this.node&&(this.updateReference(e),this.updateValue()),this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let r=e[t[0]];for(let e=1;e<t.length;e++)r=r[t[e]];return r}updateReference(e){return this.reference=null!==this.object?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}export default ReferenceBaseNode;export const reference=(e,t,r)=>nodeObject(new ReferenceBaseNode(e,t,r));export const referenceBuffer=(e,t,r,o)=>nodeObject(new ReferenceBaseNode(e,t,o,r));
//# sourceMappingURL=ReferenceBaseNode.js.map