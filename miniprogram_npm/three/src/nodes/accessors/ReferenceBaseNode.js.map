{"version":3,"file":"node_modules/three/src/nodes/accessors/ReferenceBaseNode.js","names":["Node","NodeUpdateType","uniform","nodeObject","ArrayElementNode","ReferenceElementNode","type","constructor","referenceNode","indexNode","super","this","isReferenceElementNode","getNodeType","uniformType","generate","builder","snippet","arrayType","elementType","format","ReferenceBaseNode","property","object","count","properties","split","reference","node","group","updateType","OBJECT","setGroup","element","setNodeType","getSelf","updateReference","updateValue","getValueFromReference","value","i","length","state","setup","update","Array","isArray","array","name","referenceBuffer"],"sources":["node_modules/three/src/nodes/accessors/ReferenceBaseNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { nodeObject } from '../tsl/TSLCore.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {ReferenceBaseNode} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link ReferenceBaseNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {?ReferenceBaseNode}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {string} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference base node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {?Object} [object=null] - The object the property belongs to.\n\t * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceBaseNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {string} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType ).getSelf();\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link ReferenceBaseNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ReferenceBaseNode;\n\n/**\n * TSL function for creating a reference base node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nexport const reference = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference base node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {number} count - The number of value inside the array-like object.\n * @param {Object} [object] - An array-like object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nexport const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceBaseNode( name, type, object, count ) );\n"],"mappings":"OAAOA,SAAU,yBACRC,mBAAsB,8BACtBC,YAAe,gCACfC,eAAkB,2BACpBC,qBAAsB,+BAW7B,MAAMC,6BAA6BD,iBAElC,eAAWE,GAEV,MAAO,sBAER,CAQA,WAAAC,CAAaC,EAAeC,GAE3BC,MAAOF,EAAeC,GAStBE,KAAKH,cAAgBA,EASrBG,KAAKC,wBAAyB,CAE/B,CAQA,WAAAC,GAEC,OAAOF,KAAKH,cAAcM,WAE3B,CAEA,QAAAC,CAAUC,GAET,MAAMC,EAAUP,MAAMK,SAAUC,GAC1BE,EAAYP,KAAKH,cAAcK,cAC/BM,EAAcR,KAAKE,cAEzB,OAAOG,EAAQI,OAAQH,EAASC,EAAWC,EAE5C,EAYD,MAAME,0BAA0BrB,KAE/B,eAAWM,GAEV,MAAO,mBAER,CAUA,WAAAC,CAAae,EAAUR,EAAaS,EAAS,KAAMC,EAAQ,MAE1Dd,QAOAC,KAAKW,SAAWA,EAOhBX,KAAKG,YAAcA,EAQnBH,KAAKY,OAASA,EAQdZ,KAAKa,MAAQA,EAQbb,KAAKc,WAAaH,EAASI,MAAO,KASlCf,KAAKgB,UAAYJ,EAQjBZ,KAAKiB,KAAO,KAQZjB,KAAKkB,MAAQ,KAQblB,KAAKmB,WAAa7B,eAAe8B,MAElC,CAQA,QAAAC,CAAUH,GAIT,OAFAlB,KAAKkB,MAAQA,EAENlB,IAER,CASA,OAAAsB,CAASxB,GAER,OAAON,WAAY,IAAIE,qBAAsBM,KAAMR,WAAYM,IAEhE,CAQA,WAAAyB,CAAapB,GAEZ,MAAMc,EAAO1B,QAAS,KAAMY,GAAcqB,UAEtB,OAAfxB,KAAKkB,OAETD,EAAKI,SAAUrB,KAAKkB,OAIrBlB,KAAKiB,KAAOA,CAEb,CASA,WAAAf,CAAaG,GASZ,OAPmB,OAAdL,KAAKiB,OAETjB,KAAKyB,gBAAiBpB,GACtBL,KAAK0B,eAIC1B,KAAKiB,KAAKf,YAAaG,EAE/B,CAQA,qBAAAsB,CAAuBf,EAASZ,KAAKgB,WAEpC,MAAMF,WAAEA,GAAed,KAEvB,IAAI4B,EAAQhB,EAAQE,EAAY,IAEhC,IAAM,IAAIe,EAAI,EAAGA,EAAIf,EAAWgB,OAAQD,IAEvCD,EAAQA,EAAOd,EAAYe,IAI5B,OAAOD,CAER,CASA,eAAAH,CAAiBM,GAIhB,OAFA/B,KAAKgB,UAA4B,OAAhBhB,KAAKY,OAAkBZ,KAAKY,OAASmB,EAAMnB,OAErDZ,KAAKgB,SAEb,CAOA,KAAAgB,GAIC,OAFAhC,KAAK0B,cAEE1B,KAAKiB,IAEb,CAOA,MAAAgB,GAECjC,KAAK0B,aAEN,CAMA,WAAAA,GAEoB,OAAd1B,KAAKiB,MAAgBjB,KAAKuB,YAAavB,KAAKG,aAEjD,MAAMyB,EAAQ5B,KAAK2B,wBAEdO,MAAMC,QAASP,GAEnB5B,KAAKiB,KAAKmB,MAAQR,EAIlB5B,KAAKiB,KAAKW,MAAQA,CAIpB,iBAIclB,yBAYR,MAAMM,UAAY,CAAEqB,EAAM1C,EAAMiB,IAAYpB,WAAY,IAAIkB,kBAAmB2B,EAAM1C,EAAMiB,WAc3F,MAAM0B,gBAAkB,CAAED,EAAM1C,EAAMkB,EAAOD,IAAYpB,WAAY,IAAIkB,kBAAmB2B,EAAM1C,EAAMiB,EAAQC","ignoreList":[]}