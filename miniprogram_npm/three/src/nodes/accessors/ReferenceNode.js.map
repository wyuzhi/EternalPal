{"version":3,"file":"node_modules/three/src/nodes/accessors/ReferenceNode.js","names":["Node","NodeUpdateType","uniform","texture","cubeTexture","buffer","nodeObject","uniformArray","ArrayElementNode","ReferenceElementNode","type","constructor","referenceNode","indexNode","super","this","isReferenceElementNode","getNodeType","uniformType","generate","builder","snippet","arrayType","elementType","format","ReferenceNode","property","object","count","properties","split","reference","node","group","name","updateType","OBJECT","element","setGroup","setName","label","console","warn","setNodeType","Array","isArray","getValueFromReference","getSelf","updateReference","updateValue","value","i","length","state","setup","update","array","referenceBuffer"],"sources":["node_modules/three/src/nodes/accessors/ReferenceNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { texture } from './TextureNode.js';\nimport { cubeTexture } from './CubeTextureNode.js';\nimport { buffer } from './BufferNode.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\nimport { uniformArray } from './UniformArrayNode.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {?ReferenceNode} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link ReferenceNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {?ReferenceNode}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {string} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * This type of node establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {?Object} [object=null] - The object the property belongs to.\n\t * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An optional label of the internal uniform node.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the name for the internal uniform.\n\t *\n\t * @param {string} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the label for the internal uniform.\n\t *\n\t * @deprecated\n\t * @param {string} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tconsole.warn( 'THREE.TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {string} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.setName( this.name );\n\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link ReferenceNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ReferenceNode;\n\n/**\n * TSL function for creating a reference node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {?Object} [object] - The object the property belongs to.\n * @returns {ReferenceNode}\n */\nexport const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {number} count - The number of value inside the array-like object.\n * @param {Object} object - An array-like object the property belongs to.\n * @returns {ReferenceNode}\n */\nexport const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n"],"mappings":"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","ignoreList":[]}