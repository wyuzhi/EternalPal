import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{nodeObject}from"../tsl/TSLBase.js";import{attribute}from"../core/AttributeNode.js";import{reference,referenceBuffer}from"./ReferenceNode.js";import{add}from"../math/OperatorNode.js";import{normalLocal}from"./Normal.js";import{positionLocal,positionPrevious}from"./Position.js";import{tangentLocal}from"./Tangent.js";import{uniform}from"../core/UniformNode.js";import{buffer}from"./BufferNode.js";import{getDataFromObject}from"../core/NodeUtils.js";import{storage}from"./StorageBufferNode.js";import{InstancedBufferAttribute}from"../../core/InstancedBufferAttribute.js";import{instanceIndex}from"../core/IndexNode.js";const _frameId=new WeakMap;class SkinningNode extends Node{static get type(){return"SkinningNode"}constructor(e){super("void"),this.skinnedMesh=e,this.updateType=NodeUpdateType.OBJECT,this.skinIndexNode=attribute("skinIndex","uvec4"),this.skinWeightNode=attribute("skinWeight","vec4"),this.bindMatrixNode=reference("bindMatrix","mat4"),this.bindMatrixInverseNode=reference("bindMatrixInverse","mat4"),this.boneMatricesNode=referenceBuffer("skeleton.boneMatrices","mat4",e.skeleton.bones.length),this.positionNode=positionLocal,this.toPositionNode=positionLocal,this.previousBoneMatricesNode=null}getSkinnedPosition(e=this.boneMatricesNode,t=this.positionNode){const{skinIndexNode:o,skinWeightNode:n,bindMatrixNode:i,bindMatrixInverseNode:r}=this,s=e.element(o.x),a=e.element(o.y),d=e.element(o.z),m=e.element(o.w),c=i.mul(t),u=add(s.mul(n.x).mul(c),a.mul(n.y).mul(c),d.mul(n.z).mul(c),m.mul(n.w).mul(c));return r.mul(u).xyz}getSkinnedNormal(e=this.boneMatricesNode,t=normalLocal){const{skinIndexNode:o,skinWeightNode:n,bindMatrixNode:i,bindMatrixInverseNode:r}=this,s=e.element(o.x),a=e.element(o.y),d=e.element(o.z),m=e.element(o.w);let c=add(n.x.mul(s),n.y.mul(a),n.z.mul(d),n.w.mul(m));return c=r.mul(c).mul(i),c.transformDirection(t).xyz}getPreviousSkinnedPosition(e){const t=e.object;return null===this.previousBoneMatricesNode&&(t.skeleton.previousBoneMatrices=new Float32Array(t.skeleton.boneMatrices),this.previousBoneMatricesNode=referenceBuffer("skeleton.previousBoneMatrices","mat4",t.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,positionPrevious)}needsPreviousBoneMatrices(e){const t=e.renderer.getMRT();return t&&t.has("velocity")||!0===getDataFromObject(e.object).useVelocity}setup(e){this.needsPreviousBoneMatrices(e)&&positionPrevious.assign(this.getPreviousSkinnedPosition(e));const t=this.getSkinnedPosition();if(this.toPositionNode&&this.toPositionNode.assign(t),e.hasGeometryAttribute("normal")){const t=this.getSkinnedNormal();normalLocal.assign(t),e.hasGeometryAttribute("tangent")&&tangentLocal.assign(t)}return t}generate(e,t){if("void"!==t)return super.generate(e,t)}update(e){const t=e.object&&e.object.skeleton?e.object.skeleton:this.skinnedMesh.skeleton;_frameId.get(t)!==e.frameId&&(_frameId.set(t,e.frameId),null!==this.previousBoneMatricesNode&&t.previousBoneMatrices.set(t.boneMatrices),t.update())}}export default SkinningNode;export const skinning=e=>nodeObject(new SkinningNode(e));export const computeSkinning=(e,t=null)=>{const o=new SkinningNode(e);return o.positionNode=storage(new InstancedBufferAttribute(e.geometry.getAttribute("position").array,3),"vec3").setPBO(!0).toReadOnly().element(instanceIndex).toVar(),o.skinIndexNode=storage(new InstancedBufferAttribute(new Uint32Array(e.geometry.getAttribute("skinIndex").array),4),"uvec4").setPBO(!0).toReadOnly().element(instanceIndex).toVar(),o.skinWeightNode=storage(new InstancedBufferAttribute(e.geometry.getAttribute("skinWeight").array,4),"vec4").setPBO(!0).toReadOnly().element(instanceIndex).toVar(),o.bindMatrixNode=uniform(e.bindMatrix,"mat4"),o.bindMatrixInverseNode=uniform(e.bindMatrixInverse,"mat4"),o.boneMatricesNode=buffer(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length),o.toPositionNode=t,nodeObject(o)};
//# sourceMappingURL=SkinningNode.js.map