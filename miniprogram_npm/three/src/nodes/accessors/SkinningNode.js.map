{"version":3,"file":"node_modules/three/src/nodes/accessors/SkinningNode.js","names":["Node","NodeUpdateType","nodeObject","attribute","reference","referenceBuffer","add","normalLocal","positionLocal","positionPrevious","tangentLocal","uniform","buffer","getDataFromObject","storage","InstancedBufferAttribute","instanceIndex","_frameId","WeakMap","SkinningNode","type","constructor","skinnedMesh","super","this","updateType","OBJECT","skinIndexNode","skinWeightNode","bindMatrixNode","bindMatrixInverseNode","boneMatricesNode","skeleton","bones","length","positionNode","toPositionNode","previousBoneMatricesNode","getSkinnedPosition","boneMatrices","position","boneMatX","element","x","boneMatY","y","boneMatZ","z","boneMatW","w","skinVertex","mul","skinned","xyz","getSkinnedNormal","normal","skinMatrix","transformDirection","getPreviousSkinnedPosition","builder","object","previousBoneMatrices","Float32Array","needsPreviousBoneMatrices","mrt","renderer","getMRT","has","useVelocity","setup","assign","skinPosition","hasGeometryAttribute","skinNormal","generate","output","update","frame","get","frameId","set","skinning","computeSkinning","toPosition","node","geometry","getAttribute","array","setPBO","toReadOnly","toVar","Uint32Array","bindMatrix","bindMatrixInverse"],"sources":["node_modules/three/src/nodes/accessors/SkinningNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { reference, referenceBuffer } from './ReferenceNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { normalLocal } from './Normal.js';\nimport { positionLocal, positionPrevious } from './Position.js';\nimport { tangentLocal } from './Tangent.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { buffer } from './BufferNode.js';\nimport { getDataFromObject } from '../core/NodeUtils.js';\nimport { storage } from './StorageBufferNode.js';\nimport { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';\nimport { instanceIndex } from '../core/IndexNode.js';\n\nconst _frameId = new WeakMap();\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for skinning/skeletal animation.\n *\n * @augments Node\n */\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\t/**\n\t * Constructs a new skinning node.\n\t *\n\t * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n\t */\n\tconstructor( skinnedMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The skinned mesh.\n\t\t *\n\t\t * @type {SkinnedMesh}\n\t\t */\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\t/**\n\t\t * The update type overwritten since skinning nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\t/**\n\t\t * The skin index attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\n\t\t/**\n\t\t * The skin weight attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\t/**\n\t\t * The bind matrix node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\n\t\t/**\n\t\t * The bind matrix inverse node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\n\t\t/**\n\t\t * The bind matrices as a uniform buffer node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t/**\n\t\t * The current vertex position in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.positionNode = positionLocal;\n\n\t\t/**\n\t\t * The result of vertex position in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.toPositionNode = positionLocal;\n\n\t\t/**\n\t\t * The previous bind matrices as a uniform buffer node.\n\t\t * Required for computing motion vectors.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex position via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = this.positionNode ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.\n\t * @return {Node<vec3>} The transformed vertex normal.\n\t */\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\t/**\n\t * Computes the transformed/skinned vertex position of the previous frame.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The skinned position from the previous frame.\n\t */\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\t/**\n\t * Returns `true` if bone matrices from the previous frame are required. Relevant\n\t * when computing motion vectors with {@link VelocityNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether bone matrices from the previous frame are required or not.\n\t */\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn ( mrt && mrt.has( 'velocity' ) ) || getDataFromObject( builder.object ).useVelocity === true;\n\n\t}\n\n\t/**\n\t * Setups the skinning node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\t\tif ( this.toPositionNode ) this.toPositionNode.assign( skinPosition );\n\n\t\t//\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skinPosition;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the skinning node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn super.generate( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the state of the skinned mesh by updating the skeleton once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\nexport default SkinningNode;\n\n/**\n * TSL function for creating a skinning node.\n *\n * @tsl\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nexport const skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\n\n/**\n * TSL function for computing skinning.\n *\n * @tsl\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @param {Node<vec3>} [toPosition=null] - The target position.\n * @returns {SkinningNode}\n */\nexport const computeSkinning = ( skinnedMesh, toPosition = null ) => {\n\n\tconst node = new SkinningNode( skinnedMesh );\n\tnode.positionNode = storage( new InstancedBufferAttribute( skinnedMesh.geometry.getAttribute( 'position' ).array, 3 ), 'vec3' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.skinIndexNode = storage( new InstancedBufferAttribute( new Uint32Array( skinnedMesh.geometry.getAttribute( 'skinIndex' ).array ), 4 ), 'uvec4' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.skinWeightNode = storage( new InstancedBufferAttribute( skinnedMesh.geometry.getAttribute( 'skinWeight' ).array, 4 ), 'vec4' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\tnode.bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\tnode.boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\tnode.toPositionNode = toPosition;\n\n\treturn nodeObject( node );\n\n};\n"],"mappings":"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","ignoreList":[]}