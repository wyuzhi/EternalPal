{"version":3,"file":"node_modules/three/src/nodes/accessors/StorageBufferNode.js","names":["BufferNode","bufferAttribute","nodeObject","varying","storageElement","NodeAccess","getTypeFromLength","StorageBufferNode","type","constructor","value","bufferType","bufferCount","nodeType","structTypeNode","isStruct","layout","isStorageBufferAttribute","isStorageInstancedBufferAttribute","count","itemSize","super","this","isStorageBufferNode","access","READ_WRITE","isAtomic","isPBO","_attribute","_varying","global","isInstancedBufferAttribute","getHash","builder","bufferData","globalCache","getData","undefined","node","setData","uuid","getInputType","isIndirectStorageBufferAttribute","element","indexNode","setPBO","getPBO","setAccess","toReadOnly","READ_ONLY","setAtomic","toAtomic","getAttributeData","attribute","getNodeType","isAvailable","getMemberType","name","generate","build","output","registerTransform","storage","storageObject","console","warn"],"sources":["node_modules/three/src/nodes/accessors/StorageBufferNode.js"],"sourcesContent":["import BufferNode from './BufferNode.js';\nimport { bufferAttribute } from './BufferAttributeNode.js';\nimport { nodeObject, varying } from '../tsl/TSLBase.js';\nimport { storageElement } from '../utils/StorageArrayElementNode.js';\nimport { NodeAccess } from '../core/constants.js';\nimport { getTypeFromLength } from '../core/NodeUtils.js';\n\n/**\n * This node is used in context of compute shaders and allows to define a\n * storage buffer for data. A typical workflow is to create instances of\n * this node with the convenience functions `attributeArray()` or `instancedArray()`,\n * setup up a compute shader that writes into the buffers and then convert\n * the storage buffers to attribute nodes for rendering.\n *\n * ```js\n * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node\n *\n * const computeInit = Fn( () => { // the compute shader\n *\n * \tconst position = positionBuffer.element( instanceIndex );\n *\n * \t// compute position data\n *\n * \tposition.x = 1;\n * \tposition.y = 1;\n * \tposition.z = 1;\n *\n * } )().compute( particleCount );\n *\n * const particleMaterial = new THREE.SpriteNodeMaterial();\n * particleMaterial.positionNode = positionBuffer.toAttribute();\n *\n * renderer.computeAsync( computeInit );\n *\n * ```\n *\n * @augments BufferNode\n */\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage buffer node.\n\t *\n\t * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n\t * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {number} [bufferCount=0] - The buffer count.\n\t */\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tlet nodeType, structTypeNode = null;\n\n\t\tif ( bufferType && bufferType.isStruct ) {\n\n\t\t\tnodeType = 'struct';\n\t\t\tstructTypeNode = bufferType.layout;\n\n\t\t\tif ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tbufferCount = value.count;\n\n\t\t\t}\n\n\t\t} else if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tnodeType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t} else {\n\n\t\t\tnodeType = bufferType;\n\n\t\t}\n\n\t\tsuper( value, nodeType, bufferCount );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferNode = true;\n\n\n\t\t/**\n\t\t * The buffer struct type.\n\t\t *\n\t\t * @type {?StructTypeNode}\n\t\t * @default null\n\t\t */\n\t\tthis.structTypeNode = structTypeNode;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'readWrite'\n\t\t */\n\t\tthis.access = NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * Whether the node is atomic or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isAtomic = false;\n\n\t\t/**\n\t\t * Whether the node represents a PBO or not.\n\t\t * Only relevant for WebGL.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isPBO = false;\n\n\t\t/**\n\t\t * A reference to the internal buffer attribute node.\n\t\t *\n\t\t * @type {?BufferAttributeNode}\n\t\t * @default null\n\t\t */\n\t\tthis._attribute = null;\n\n\t\t/**\n\t\t * A reference to the internal varying node.\n\t\t *\n\t\t * @type {?VaryingNode}\n\t\t * @default null\n\t\t */\n\t\tthis._varying = null;\n\n\t\t/**\n\t\t * `StorageBufferNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the buffer data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\t/**\n\t * Enables element access with the given index node.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {StorageArrayElementNode} A node representing the element access.\n\t */\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\t/**\n\t * Defines whether this node is a PBO or not. Only relevant for WebGL.\n\t *\n\t * @param {boolean} value - The value so set.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the `isPBO` value.\n\t *\n\t * @return {boolean} Whether the node represents a PBO or not.\n\t */\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {string} value - The node access.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Defines whether the node is atomic or not.\n\t *\n\t * @param {boolean} value - The atomic flag.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for making this node atomic.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\t/**\n\t * Returns attribute data for this storage buffer node.\n\t *\n\t * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.\n\t */\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type from the availability of storage buffers\n\t * and the attribute data.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) {\n\n\t\t\treturn this.structTypeNode.getNodeType( builder );\n\n\t\t}\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the type of a member of the struct.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the member.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\tif ( this.structTypeNode !== null ) {\n\n\t\t\treturn this.structTypeNode.getMemberType( builder, name );\n\n\t\t}\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage buffer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) this.structTypeNode.build( builder );\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default StorageBufferNode;\n\n/**\n * TSL function for creating a storage buffer node.\n *\n * @tsl\n * @function\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {?(string|Struct)} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [count=0] - The buffer count.\n * @returns {StorageBufferNode}\n */\nexport const storage = ( value, type = null, count = 0 ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use `storage().setPBO( true )` instead.\n *\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {?string} type - The buffer type (e.g. `'vec3'`).\n * @param {number} count - The buffer count.\n * @returns {StorageBufferNode}\n */\nexport const storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n"],"mappings":"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","ignoreList":[]}