{"version":3,"file":"node_modules/three/src/nodes/accessors/StorageTextureNode.js","names":["TextureNode","nodeProxy","NodeAccess","StorageTextureNode","type","constructor","value","uvNode","storeNode","super","this","isStorageTextureNode","access","WRITE_ONLY","getInputType","setup","builder","properties","getNodeProperties","setAccess","generate","output","snippet","generateStore","toReadWrite","READ_WRITE","toReadOnly","READ_ONLY","toWriteOnly","depthNode","textureProperty","uvSnippet","build","is3DTexture","storeSnippet","depthSnippet","generateTextureStore","addLineFlowCode","clone","newNode","storageTexture","setParameterLength","textureStore","node","toStack"],"sources":["node_modules/three/src/nodes/accessors/StorageTextureNode.js"],"sourcesContent":["import TextureNode from './TextureNode.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\nimport { NodeAccess } from '../core/constants.js';\n\n/**\n * This special version of a texture node can be used to\n * write data into a storage texture with a compute shader.\n *\n * ```js\n * const storageTexture = new THREE.StorageTexture( width, height );\n *\n * const computeTexture = Fn( ( { storageTexture } ) => {\n *\n * \tconst posX = instanceIndex.mod( width );\n * \tconst posY = instanceIndex.div( width );\n * \tconst indexUV = uvec2( posX, posY );\n *\n * \t// generate RGB values\n *\n * \tconst r = 1;\n * \tconst g = 1;\n * \tconst b = 1;\n *\n * \ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n *\n * } );\n *\n * const computeNode = computeTexture( { storageTexture } ).compute( width * height );\n * renderer.computeAsync( computeNode );\n * ```\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments TextureNode\n */\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage texture node.\n\t *\n\t * @param {StorageTexture} value - The storage texture.\n\t * @param {Node<vec2|vec3>} uvNode - The uv node.\n\t * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n\t */\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\t/**\n\t\t * The value node that should be stored in the texture.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTextureNode = true;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'writeOnly'\n\t\t */\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'storageTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t\treturn properties;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {string} value - The node access.\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage node. If no `storeNode`\n\t * is defined, the texture node is generated as normal texture.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read/write node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a write-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode, depthNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, this.value.is3DTexture === true ? 'uvec3' : 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, depthSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = super.clone();\n\t\tnewNode.storeNode = this.storeNode;\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default StorageTextureNode;\n\n/**\n * TSL function for creating a storage texture node.\n *\n * @tsl\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {?Node<vec2|vec3>} uvNode - The uv node.\n * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nexport const storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode ).setParameterLength( 1, 3 );\n\n\n/**\n * TODO: Explain difference to `storageTexture()`.\n *\n * @tsl\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nexport const textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.toStack();\n\n\treturn node;\n\n};\n"],"mappings":"OAAOA,gBAAiB,0BACfC,cAAiB,2BACjBC,eAAkB,uBAiC3B,MAAMC,2BAA2BH,YAEhC,eAAWI,GAEV,MAAO,oBAER,CASA,WAAAC,CAAaC,EAAOC,EAAQC,EAAY,MAEvCC,MAAOH,EAAOC,GAQdG,KAAKF,UAAYA,EASjBE,KAAKC,sBAAuB,EAQ5BD,KAAKE,OAASV,WAAWW,UAE1B,CAQA,YAAAC,GAEC,MAAO,gBAER,CAEA,KAAAC,CAAOC,GAENP,MAAMM,MAAOC,GAEb,MAAMC,EAAaD,EAAQE,kBAAmBR,MAG9C,OAFAO,EAAWT,UAAYE,KAAKF,UAErBS,CAER,CAQA,SAAAE,CAAWb,GAGV,OADAI,KAAKE,OAASN,EACPI,IAER,CAUA,QAAAU,CAAUJ,EAASK,GAElB,IAAIC,EAYJ,OARCA,EAFuB,OAAnBZ,KAAKF,UAECE,KAAKa,cAAeP,GAIpBP,MAAMW,SAAUJ,EAASK,GAI7BC,CAER,CAOA,WAAAE,GAEC,OAAOd,KAAKS,UAAWjB,WAAWuB,WAEnC,CAOA,UAAAC,GAEC,OAAOhB,KAAKS,UAAWjB,WAAWyB,UAEnC,CAOA,WAAAC,GAEC,OAAOlB,KAAKS,UAAWjB,WAAWW,WAEnC,CAOA,aAAAU,CAAeP,GAEd,MAAMC,EAAaD,EAAQE,kBAAmBR,OAExCH,OAAEA,EAAMC,UAAEA,EAASqB,UAAEA,GAAcZ,EAEnCa,EAAkBrB,MAAMW,SAAUJ,EAAS,YAC3Ce,EAAYxB,EAAOyB,MAAOhB,GAAoC,IAA3BN,KAAKJ,MAAM2B,YAAuB,QAAU,SAC/EC,EAAe1B,EAAUwB,MAAOhB,EAAS,QACzCmB,EAAeN,EAAYA,EAAUG,MAAOhB,EAAS,OAAU,KAE/DM,EAAUN,EAAQoB,qBAAsBpB,EAASc,EAAiBC,EAAWI,EAAcD,GAEjGlB,EAAQqB,gBAAiBf,EAASZ,KAEnC,CAEA,KAAA4B,GAEC,MAAMC,EAAU9B,MAAM6B,QAEtB,OADAC,EAAQ/B,UAAYE,KAAKF,UAClB+B,CAER,iBAIcpC,0BAYR,MAAMqC,eAA+BvC,UAAWE,oBAAqBsC,mBAAoB,EAAG,UAa5F,MAAMC,aAAe,CAAEpC,EAAOC,EAAQC,KAE5C,MAAMmC,EAAOH,eAAgBlC,EAAOC,EAAQC,GAI5C,OAFmB,OAAdA,GAAqBmC,EAAKC,UAExBD,CAAI","ignoreList":[]}