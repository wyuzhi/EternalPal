import TextureNode from"./TextureNode.js";import{nodeProxy,vec3,Fn,If,int}from"../tsl/TSLBase.js";import{textureSize}from"./TextureSizeNode.js";const normal=Fn((({texture:e,uv:t})=>{const r=1e-4,s=vec3().toVar();return If(t.x.lessThan(r),(()=>{s.assign(vec3(1,0,0))})).ElseIf(t.y.lessThan(r),(()=>{s.assign(vec3(0,1,0))})).ElseIf(t.z.lessThan(r),(()=>{s.assign(vec3(0,0,1))})).ElseIf(t.x.greaterThan(.9999),(()=>{s.assign(vec3(-1,0,0))})).ElseIf(t.y.greaterThan(.9999),(()=>{s.assign(vec3(0,-1,0))})).ElseIf(t.z.greaterThan(.9999),(()=>{s.assign(vec3(0,0,-1))})).Else((()=>{const r=.01,a=e.sample(t.add(vec3(-.01,0,0))).r.sub(e.sample(t.add(vec3(r,0,0))).r),n=e.sample(t.add(vec3(0,-.01,0))).r.sub(e.sample(t.add(vec3(0,r,0))).r),u=e.sample(t.add(vec3(0,0,-.01))).r.sub(e.sample(t.add(vec3(0,0,r))).r);s.assign(vec3(a,n,u))})),s.normalize()}));class Texture3DNode extends TextureNode{static get type(){return"Texture3DNode"}constructor(e,t=null,r=null){super(e,t,r),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return vec3(.5,.5,.5)}setUpdateMatrix(){}setupUV(e,t){const r=this.value;return!e.isFlipY()||!0!==r.isRenderTargetTexture&&!0!==r.isFramebufferTexture||(t=this.sampler?t.flipY():t.setY(int(textureSize(this,this.levelNode).y).sub(t.y).sub(1))),t}generateUV(e,t){return t.build(e,"vec3")}normal(e){return normal({texture:this,uv:e})}}export default Texture3DNode;export const texture3D=nodeProxy(Texture3DNode).setParameterLength(1,3);
//# sourceMappingURL=Texture3DNode.js.map