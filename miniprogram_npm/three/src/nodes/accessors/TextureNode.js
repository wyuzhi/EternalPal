import UniformNode,{uniform}from"../core/UniformNode.js";import{uv}from"./UV.js";import{textureSize}from"./TextureSizeNode.js";import{colorSpaceToWorking}from"../display/ColorSpaceNode.js";import{expression}from"../code/ExpressionNode.js";import{maxMipLevel}from"../utils/MaxMipLevelNode.js";import{nodeProxy,vec3,nodeObject,int}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{IntType,NearestFilter,UnsignedIntType}from"../../constants.js";import{Texture}from"../../textures/Texture.js";const EmptyTexture=new Texture;class TextureNode extends UniformNode{static get type(){return"TextureNode"}constructor(e=EmptyTexture,t=null,r=null,o=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=r,this.biasNode=o,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=NodeUpdateType.NONE,this.referenceNode=null,this._value=e,this._matrixUniform=null,this.setUpdateMatrix(null===t)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":this.value.type===UnsignedIntType?"uvec4":this.value.type===IntType?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return uv(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){return null===this._matrixUniform&&(this._matrixUniform=uniform(this.value.matrix)),this._matrixUniform.mul(vec3(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?NodeUpdateType.OBJECT:NodeUpdateType.NONE,this}setupUV(e,t){const r=this.value;return e.isFlipY()&&(r.image instanceof ImageBitmap&&!0===r.flipY||!0===r.isRenderTargetTexture||!0===r.isFramebufferTexture||!0===r.isDepthTexture)&&(t=this.sampler?t.flipY():t.setY(int(textureSize(this,this.levelNode).y).sub(t.y).sub(1))),t}setup(e){const t=e.getNodeProperties(this);t.referenceNode=this.referenceNode;const r=this.value;if(!r||!0!==r.isTexture)throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");let o=this.uvNode;null!==o&&!0!==e.context.forceUVContext||!e.context.getUV||(o=e.context.getUV(this,e)),o||(o=this.getDefaultUV()),!0===this.updateMatrix&&(o=this.getTransformedUV(o)),o=this.setupUV(e,o);let s=this.levelNode;null===s&&e.context.getTextureLevel&&(s=e.context.getTextureLevel(this)),t.uvNode=o,t.levelNode=s,t.biasNode=this.biasNode,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,!0===this.sampler?"vec2":"ivec2")}generateSnippet(e,t,r,o,s,i,n,a){const l=this.value;let u;return u=o?e.generateTextureLevel(l,t,r,o,i):s?e.generateTextureBias(l,t,r,s,i):a?e.generateTextureGrad(l,t,r,a,i):n?e.generateTextureCompare(l,t,r,n,i):!1===this.sampler?e.generateTextureLoad(l,t,r,i):e.generateTexture(l,t,r,i),u}generate(e,t){const r=this.value,o=e.getNodeProperties(this),s=super.generate(e,"property");if(/^sampler/.test(t))return s+"_sampler";if(e.isReference(t))return s;{const i=e.getDataFromNode(this);let n=i.propertyName;if(void 0===n){const{uvNode:t,levelNode:r,biasNode:a,compareNode:l,depthNode:u,gradNode:d}=o,p=this.generateUV(e,t),c=r?r.build(e,"float"):null,h=a?a.build(e,"float"):null,m=u?u.build(e,"int"):null,N=l?l.build(e,"float"):null,x=d?[d[0].build(e,"vec2"),d[1].build(e,"vec2")]:null,f=e.getVarFromNode(this);n=e.getPropertyName(f);const v=this.generateSnippet(e,s,p,c,h,m,N,x);e.addLineFlowCode(`${n} = ${v}`,this),i.snippet=v,i.propertyName=n}let a=n;const l=this.getNodeType(e);return e.needsToWorkingColorSpace(r)&&(a=colorSpaceToWorking(expression(a,l),r.colorSpace).setup(e).build(e,l)),e.format(a,l,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){return console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead."),this.sample(e)}sample(e){const t=this.clone();return t.uvNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}load(e){return this.sample(e).setSampler(!1)}blur(e){const t=this.clone();t.biasNode=nodeObject(e).mul(maxMipLevel(t)),t.referenceNode=this.getSelf();const r=t.value;return!1===t.generateMipmaps&&(r&&!1===r.generateMipmaps||r.minFilter===NearestFilter||r.magFilter===NearestFilter)&&(console.warn("THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."),t.biasNode=null),nodeObject(t)}level(e){const t=this.clone();return t.levelNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}size(e){return textureSize(this,e)}bias(e){const t=this.clone();return t.biasNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}compare(e){const t=this.clone();return t.compareNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}grad(e,t){const r=this.clone();return r.gradNode=[nodeObject(e),nodeObject(t)],r.referenceNode=this.getSelf(),nodeObject(r)}depth(e){const t=this.clone();return t.depthNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid,e.sampler=this.sampler,e.updateMatrix=this.updateMatrix,e.updateType=this.updateType}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value],this.sampler=e.sampler,this.updateMatrix=e.updateMatrix,this.updateType=e.updateType}update(){const e=this.value,t=this._matrixUniform;null!==t&&(t.value=e.matrix),!0===e.matrixAutoUpdate&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e}}export default TextureNode;const textureBase=nodeProxy(TextureNode).setParameterLength(1,4).setName("texture");export const texture=(e=EmptyTexture,t=null,r=null,o=null)=>{let s;return e&&!0===e.isTextureNode?(s=nodeObject(e.clone()),s.referenceNode=e.getSelf(),null!==t&&(s.uvNode=nodeObject(t)),null!==r&&(s.levelNode=nodeObject(r)),null!==o&&(s.biasNode=nodeObject(o))):s=textureBase(e,t,r,o),s};export const uniformTexture=(e=EmptyTexture)=>texture(e);export const textureLoad=(...e)=>texture(...e).setSampler(!1);export const sampler=e=>(!0===e.isNode?e:texture(e)).convert("sampler");export const samplerComparison=e=>(!0===e.isNode?e:texture(e)).convert("samplerComparison");
//# sourceMappingURL=TextureNode.js.map