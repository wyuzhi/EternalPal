{"version":3,"file":"node_modules/three/src/nodes/accessors/TextureNode.js","names":["UniformNode","uniform","uv","textureSize","colorSpaceToWorking","expression","maxMipLevel","nodeProxy","vec3","nodeObject","int","NodeUpdateType","IntType","NearestFilter","UnsignedIntType","Texture","EmptyTexture","TextureNode","type","constructor","value","uvNode","levelNode","biasNode","super","this","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","updateType","NONE","referenceNode","_value","_matrixUniform","setUpdateMatrix","getUniformHash","uuid","getNodeType","isDepthTexture","getInputType","getDefaultUV","channel","updateReference","getTransformedUV","matrix","mul","xy","OBJECT","setupUV","builder","texture","isFlipY","image","ImageBitmap","flipY","isRenderTargetTexture","isFramebufferTexture","setY","y","sub","setup","properties","getNodeProperties","isTexture","Error","context","forceUVContext","getUV","getTextureLevel","generateUV","build","generateSnippet","textureProperty","uvSnippet","levelSnippet","biasSnippet","depthSnippet","compareSnippet","gradSnippet","snippet","generateTextureLevel","generateTextureBias","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","generate","output","test","isReference","nodeData","getDataFromNode","propertyName","undefined","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","nodeType","needsToWorkingColorSpace","colorSpace","format","setSampler","getSampler","console","warn","sample","textureNode","clone","getSelf","load","blur","amountNode","map","generateMipmaps","minFilter","magFilter","level","size","bias","compare","grad","gradNodeX","gradNodeY","depth","serialize","data","toJSON","meta","deserialize","textures","update","matrixUniform","matrixAutoUpdate","newNode","textureBase","setParameterLength","setName","uniformTexture","textureLoad","params","isNode","convert","samplerComparison"],"sources":["node_modules/three/src/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UV.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToWorking } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { nodeProxy, vec3, nodeObject, int } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nimport { IntType, NearestFilter, UnsignedIntType } from '../../constants.js';\n\nimport { Texture } from '../../textures/Texture.js';\n\nconst EmptyTexture = /*@__PURE__*/ new Texture();\n\n/**\n * This type of uniform node represents a 2D texture.\n *\n * @augments UniformNode\n */\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture node.\n\t *\n\t * @param {Texture} [value=EmptyTexture] - The texture.\n\t * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n\t * @param {?Node<int>} [levelNode=null] - The level node.\n\t * @param {?Node<float>} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureNode = true;\n\n\t\t/**\n\t\t * Represents the texture coordinates.\n\t\t *\n\t\t * @type {?Node<vec2|vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * Represents the mip level that should be selected.\n\t\t *\n\t\t * @type {?Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Represents the bias to be applied during level-of-detail computation.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.biasNode = biasNode;\n\n\t\t/**\n\t\t * Represents a reference value a texture sample is compared to.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.compareNode = null;\n\n\t\t/**\n\t\t * When using texture arrays, the depth node defines the layer to select.\n\t\t *\n\t\t * @type {?Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * When defined, a texture is sampled using explicit gradients.\n\t\t *\n\t\t * @type {?Array<Node<vec2>>}\n\t\t * @default null\n\t\t */\n\t\tthis.gradNode = null;\n\n\t\t/**\n\t\t * Whether texture values should be sampled or fetched.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sampler = true;\n\n\t\t/**\n\t\t * Whether the uv transformation matrix should be\n\t\t * automatically updated or not. Use `setUpdateMatrix()`\n\t\t * if you want to change the value of the property.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.updateMatrix = false;\n\n\t\t/**\n\t\t * By default the `update()` method is not executed. `setUpdateMatrix()`\n\t\t * sets the value to `frame` when the uv transformation matrix should\n\t\t * automatically be updated.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The reference node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = null;\n\n\t\t/**\n\t\t * The texture value is stored in a private property.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * The uniform node that represents the uv transformation matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {?UniformNode<mat3>}\n\t\t */\n\t\tthis._matrixUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\t/**\n\t * Overwritten since the uniform hash is defined by the texture's UUID.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The uniform hash.\n\t */\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the texture type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the current texture's channel.\n\t *\n\t * @return {AttributeNode<vec2>} The default uvs.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\t/**\n\t * Overwritten to always return the texture reference of the node.\n\t *\n\t * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Texture} The texture reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\t/**\n\t * Transforms the given uv node with the texture transformation matrix.\n\t *\n\t * @param {Node} uvNode - The uv node to transform.\n\t * @return {Node} The transformed uv node.\n\t */\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\t/**\n\t * Defines whether the uv transformation matrix should automatically be updated or not.\n\t *\n\t * @param {boolean} value - The update toggle.\n\t * @return {TextureNode} A reference to this node.\n\t */\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Setups texture node by preparing the internal nodes for code generation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().' );\n\n\t\t}\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this, builder );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\t/**\n\t * Generates the snippet for the texture sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} textureProperty - The texture property.\n\t * @param {string} uvSnippet - The uv snippet.\n\t * @param {?string} levelSnippet - The level snippet.\n\t * @param {?string} biasSnippet - The bias snippet.\n\t * @param {?string} depthSnippet - The depth snippet.\n\t * @param {?string} compareSnippet - The compare snippet.\n\t * @param {?Array<string>} gradSnippet - The grad snippet.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( /^sampler/.test( output ) ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the sampler value.\n\t *\n\t * @param {boolean} value - The sampler value to set.\n\t * @return {TextureNode} A reference to this texture node.\n\t */\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the sampler value.\n\t *\n\t * @return {boolean} The sampler value.\n\t */\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\t/**\n\t * @function\n\t * @deprecated since r172. Use {@link TextureNode#sample} instead.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tuv( uvNode ) { // @deprecated, r172\n\n\t\tconsole.warn( 'THREE.TextureNode: .uv() has been renamed. Use .sample() instead.' );\n\n\t\treturn this.sample( uvNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given uv node.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tsample( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * TSL function for creating a texture node that fetches/loads texels without interpolation.\n\t *\n\t * @param {Node<uvec2>} uvNode - The uv node.\n\t * @returns {TextureNode} A texture node representing the texture load.\n\t */\n\tload( uvNode ) {\n\n\t\treturn this.sample( uvNode ).setSampler( false );\n\n\t}\n\n\t/**\n\t * Samples a blurred version of the texture by defining an internal bias.\n\t *\n\t * @param {Node<float>} amountNode - How blurred the texture should be.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\tconst map = textureNode.value;\n\n\t\tif ( textureNode.generateMipmaps === false && ( map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter ) ) {\n\n\t\t\tconsole.warn( 'THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.' );\n\n\t\t\ttextureNode.biasNode = null;\n\n\t\t}\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a specific mip of the texture.\n\t *\n\t * @param {Node<int>} levelNode - The mip level to sample.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Returns the texture size of the requested level.\n\t *\n\t * @param {Node<int>} levelNode - The level to compute the size for.\n\t * @return {TextureSizeNode} The texture size.\n\t */\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given bias.\n\t *\n\t * @param {Node<float>} biasNode - The bias node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by executing a compare operation.\n\t *\n\t * @param {Node<float>} compareNode - The node that defines the compare value.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture using an explicit gradient.\n\t *\n\t * @param {Node<vec2>} gradNodeX - The gradX node.\n\t * @param {Node<vec2>} gradNodeY - The gradY node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by defining a depth node.\n\t *\n\t * @param {Node<int>} depthNode - The depth node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\t/**\n\t * The update is used to implement the update of the uv transformation matrix.\n\t */\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Clones the texture node.\n\t *\n\t * @return {TextureNode} The cloned texture node.\n\t */\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default TextureNode;\n\n/**\n * TSL function for creating a texture node.\n *\n * @tsl\n * @function\n * @param {?Texture} value - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureBase = /*@__PURE__*/ nodeProxy( TextureNode ).setParameterLength( 1, 4 ).setName( 'texture' );\n\n/**\n * TSL function for creating a texture node or sample a texture node already existing.\n *\n * @tsl\n * @function\n * @param {?Texture|TextureNode} [value=EmptyTexture] - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nexport const texture = ( value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null ) => {\n\n\tlet textureNode;\n\n\tif ( value && value.isTextureNode === true ) {\n\n\t\ttextureNode = nodeObject( value.clone() );\n\t\ttextureNode.referenceNode = value.getSelf(); // Ensure the reference is set to the original node\n\n\t\tif ( uvNode !== null ) textureNode.uvNode = nodeObject( uvNode );\n\t\tif ( levelNode !== null ) textureNode.levelNode = nodeObject( levelNode );\n\t\tif ( biasNode !== null ) textureNode.biasNode = nodeObject( biasNode );\n\n\t} else {\n\n\t\ttextureNode = textureBase( value, uvNode, levelNode, biasNode );\n\n\t}\n\n\treturn textureNode;\n\n};\n\n/**\n * TSL function for creating a uniform texture node.\n *\n * @tsl\n * @function\n * @param {?Texture} value - The texture.\n * @returns {TextureNode}\n */\nexport const uniformTexture = ( value = EmptyTexture ) => texture( value );\n\n/**\n * TSL function for creating a texture node that fetches/loads texels without interpolation.\n *\n * @tsl\n * @function\n * @param {?Texture|TextureNode} [value=EmptyTexture] - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nexport const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\n/**\n * Converts a texture or texture node to a sampler.\n *\n * @tsl\n * @function\n * @param {TextureNode|Texture} value - The texture or texture node to convert.\n * @returns {Node}\n */\nexport const sampler = ( value ) => ( value.isNode === true ? value : texture( value ) ).convert( 'sampler' );\n\n/**\n * Converts a texture or texture node to a sampler comparison.\n *\n * @tsl\n * @function\n * @param {TextureNode|Texture} value - The texture or texture node to convert.\n * @returns {Node}\n */\nexport const samplerComparison = ( value ) => ( value.isNode === true ? value : texture( value ) ).convert( 'samplerComparison' );\n"],"mappings":"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","ignoreList":[]}