{"version":3,"file":"node_modules/three/src/nodes/accessors/UniformArrayNode.js","names":["nodeObject","NodeUpdateType","getValueType","ArrayElementNode","BufferNode","UniformArrayElementNode","type","constructor","uniformArrayNode","indexNode","super","this","isArrayBufferElementNode","generate","builder","snippet","getNodeType","paddedType","node","getPaddedType","format","UniformArrayNode","value","elementType","array","updateType","RENDER","isArrayBufferNode","getElementType","test","charAt","update","i","length","index","vector","r","g","b","matrix","elements","x","y","z","w","setup","arrayType","Float32Array","paddedElementLength","getTypeLength","Int32Array","Uint32Array","bufferCount","bufferType","element","uniformArray","values","nodeType"],"sources":["node_modules/three/src/nodes/accessors/UniformArrayNode.js"],"sourcesContent":["import { nodeObject } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { getValueType } from '../core/NodeUtils.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport BufferNode from './BufferNode.js';\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n\t * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n\t */\n\tconstructor( uniformArrayNode, indexNode ) {\n\n\t\tsuper( uniformArrayNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\t\tconst paddedType = this.node.getPaddedType();\n\n\t\treturn builder.format( snippet, paddedType, type );\n\n\t}\n\n}\n\n/**\n * Similar to {@link BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform array node.\n\t *\n\t * @param {Array<any>} value - Array holding the buffer data.\n\t * @param {?string} [elementType=null] - The data type of a buffer element.\n\t */\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Array holding the buffer data. Unlike {@link BufferNode}, the array can\n\t\t * hold number primitives as well as three.js objects like vectors, matrices\n\t\t * or colors.\n\t\t *\n\t\t * @type {Array<any>}\n\t\t */\n\t\tthis.array = value;\n\n\t\t/**\n\t\t * The data type of an array element.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;\n\n\t\t/**\n\t\t * The padded type. Uniform buffers must conform to a certain buffer layout\n\t\t * so a separate type is computed to ensure correct buffer size.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.paddedType = this.getPaddedType();\n\n\t\t/**\n\t\t * Overwritten since uniform array nodes are updated per render.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the\n\t * {@link UniformArrayNode#paddedType}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.paddedType;\n\n\t}\n\n\t/**\n\t * The data type of the array elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Returns the padded type based on the element type.\n\t *\n\t * @return {string} The padded type.\n\t */\n\tgetPaddedType() {\n\n\t\tconst elementType = this.elementType;\n\n\t\tlet paddedType = 'vec4';\n\n\t\tif ( elementType === 'mat2' ) {\n\n\t\t\tpaddedType = 'mat2';\n\n\t\t} else if ( /mat/.test( elementType ) === true ) {\n\n\t\t\tpaddedType = 'mat4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'i' ) {\n\n\t\t\tpaddedType = 'ivec4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'u' ) {\n\n\t\t\tpaddedType = 'uvec4';\n\n\t\t}\n\n\t\treturn paddedType;\n\n\t}\n\n\t/**\n\t * The update makes sure to correctly transfer the data from the (complex) objects\n\t * in the array to the internal, correctly padded value buffer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementType = this.elementType;\n\n\t\tif ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat2' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\t\t\t\tvalue[ index + 3 ] = matrix.elements[ 3 ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat3' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\n\t\t\t\tvalue[ index + 4 ] = matrix.elements[ 3 ];\n\t\t\t\tvalue[ index + 5 ] = matrix.elements[ 4 ];\n\t\t\t\tvalue[ index + 6 ] = matrix.elements[ 5 ];\n\n\t\t\t\tvalue[ index + 8 ] = matrix.elements[ 6 ];\n\t\t\t\tvalue[ index + 9 ] = matrix.elements[ 7 ];\n\t\t\t\tvalue[ index + 10 ] = matrix.elements[ 8 ];\n\n\t\t\t\tvalue[ index + 15 ] = 1;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat4' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tfor ( let i = 0; i < matrix.elements.length; i ++ ) {\n\n\t\t\t\t\tvalue[ index + i ] = matrix.elements[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implement the value buffer creation based on the array data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {null}\n\t */\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\t\tconst elementType = this.elementType;\n\n\t\tlet arrayType = Float32Array;\n\n\t\tconst paddedType = this.paddedType;\n\t\tconst paddedElementLength = builder.getTypeLength( paddedType );\n\n\t\tif ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\tif ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * paddedElementLength );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = paddedType;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default `element()` method to provide element access\n\t * based on {@link UniformArrayNode}.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {UniformArrayElementNode}\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\nexport default UniformArrayNode;\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @tsl\n * @function\n * @param {Array<any>} values - Array-like data.\n * @param {?string} [nodeType] - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nexport const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n"],"mappings":"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","ignoreList":[]}