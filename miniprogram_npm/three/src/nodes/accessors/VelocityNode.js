import TempNode from"../core/TempNode.js";import{modelViewMatrix}from"./ModelNode.js";import{positionLocal,positionPrevious}from"./Position.js";import{nodeImmutable}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{Matrix4}from"../../math/Matrix4.js";import{uniform}from"../core/UniformNode.js";import{sub}from"../math/OperatorNode.js";import{cameraProjectionMatrix}from"./Camera.js";import{renderGroup}from"../core/UniformGroupNode.js";const _objectData=new WeakMap;class VelocityNode extends TempNode{static get type(){return"VelocityNode"}constructor(){super("vec2"),this.projectionMatrix=null,this.updateType=NodeUpdateType.OBJECT,this.updateAfterType=NodeUpdateType.OBJECT,this.previousModelWorldMatrix=uniform(new Matrix4),this.previousProjectionMatrix=uniform(new Matrix4).setGroup(renderGroup),this.previousCameraViewMatrix=uniform(new Matrix4)}setProjectionMatrix(r){this.projectionMatrix=r}update({frameId:r,camera:e,object:t}){const o=getPreviousMatrix(t);this.previousModelWorldMatrix.value.copy(o);const i=getData(e);i.frameId!==r&&(i.frameId=r,void 0===i.previousProjectionMatrix?(i.previousProjectionMatrix=new Matrix4,i.previousCameraViewMatrix=new Matrix4,i.currentProjectionMatrix=new Matrix4,i.currentCameraViewMatrix=new Matrix4,i.previousProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),i.previousCameraViewMatrix.copy(e.matrixWorldInverse)):(i.previousProjectionMatrix.copy(i.currentProjectionMatrix),i.previousCameraViewMatrix.copy(i.currentCameraViewMatrix)),i.currentProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),i.currentCameraViewMatrix.copy(e.matrixWorldInverse),this.previousProjectionMatrix.value.copy(i.previousProjectionMatrix),this.previousCameraViewMatrix.value.copy(i.previousCameraViewMatrix))}updateAfter({object:r}){getPreviousMatrix(r).copy(r.matrixWorld)}setup(){const r=null===this.projectionMatrix?cameraProjectionMatrix:uniform(this.projectionMatrix),e=this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix),t=r.mul(modelViewMatrix).mul(positionLocal),o=this.previousProjectionMatrix.mul(e).mul(positionPrevious),i=t.xy.div(t.w),a=o.xy.div(o.w);return sub(i,a)}}function getData(r){let e=_objectData.get(r);return void 0===e&&(e={},_objectData.set(r,e)),e}function getPreviousMatrix(r,e=0){const t=getData(r);let o=t[e];return void 0===o&&(t[e]=o=new Matrix4,t[e].copy(r.matrixWorld)),o}export default VelocityNode;export const velocity=nodeImmutable(VelocityNode);
//# sourceMappingURL=VelocityNode.js.map