{"version":3,"file":"node_modules/three/src/nodes/accessors/VelocityNode.js","names":["TempNode","modelViewMatrix","positionLocal","positionPrevious","nodeImmutable","NodeUpdateType","Matrix4","uniform","sub","cameraProjectionMatrix","renderGroup","_objectData","WeakMap","VelocityNode","type","constructor","super","this","projectionMatrix","updateType","OBJECT","updateAfterType","previousModelWorldMatrix","previousProjectionMatrix","setGroup","previousCameraViewMatrix","setProjectionMatrix","update","frameId","camera","object","previousModelMatrix","getPreviousMatrix","value","copy","cameraData","getData","undefined","currentProjectionMatrix","currentCameraViewMatrix","matrixWorldInverse","updateAfter","matrixWorld","setup","previousModelViewMatrix","mul","clipPositionCurrent","clipPositionPrevious","ndcPositionCurrent","xy","div","w","ndcPositionPrevious","objectData","get","set","index","matrix","velocity"],"sources":["node_modules/three/src/nodes/accessors/VelocityNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { modelViewMatrix } from './ModelNode.js';\nimport { positionLocal, positionPrevious } from './Position.js';\nimport { nodeImmutable } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { sub } from '../math/OperatorNode.js';\nimport { cameraProjectionMatrix } from './Camera.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\n\nconst _objectData = new WeakMap();\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The current projection matrix.\n\t\t *\n\t\t * @type {?Matrix4}\n\t\t * @default null\n\t\t */\n\t\tthis.projectionMatrix = null;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes save data after the update.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Uniform node representing the previous model matrix in world space.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * Uniform node representing the previous projection matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the previous view matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\t/**\n\t * Sets the given projection matrix.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix to set.\n\t */\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\t/**\n\t * Updates velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten to updated velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\t/**\n\t * Implements the velocity computation based on the previous and current vertex data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec2>} The motion vector.\n\t */\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\t\tobjectData[ index ].copy( object.matrixWorld );\n\n\t}\n\n\treturn matrix;\n\n}\n\nexport default VelocityNode;\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @tsl\n * @type {VelocityNode}\n */\nexport const velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n"],"mappings":"OAAOA,aAAc,6BACZC,oBAAuB,wBACvBC,cAAeC,qBAAwB,uBACvCC,kBAAqB,2BACrBC,mBAAsB,8BACtBC,YAAe,+BACfC,YAAe,gCACfC,QAAW,iCACXC,2BAA8B,qBAC9BC,gBAAmB,8BAE5B,MAAMC,YAAc,IAAIC,QAYxB,MAAMC,qBAAqBb,SAE1B,eAAWc,GAEV,MAAO,cAER,CAKA,WAAAC,GAECC,MAAO,QAQPC,KAAKC,iBAAmB,KAQxBD,KAAKE,WAAad,eAAee,OAQjCH,KAAKI,gBAAkBhB,eAAee,OAQtCH,KAAKK,yBAA2Bf,QAAS,IAAID,SAQ7CW,KAAKM,yBAA2BhB,QAAS,IAAID,SAAYkB,SAAUd,aAQnEO,KAAKQ,yBAA2BlB,QAAS,IAAID,QAE9C,CAOA,mBAAAoB,CAAqBR,GAEpBD,KAAKC,iBAAmBA,CAEzB,CAOA,MAAAS,EAAQC,QAAEA,EAAOC,OAAEA,EAAMC,OAAEA,IAE1B,MAAMC,EAAsBC,kBAAmBF,GAE/Cb,KAAKK,yBAAyBW,MAAMC,KAAMH,GAI1C,MAAMI,EAAaC,QAASP,GAEvBM,EAAWP,UAAYA,IAE3BO,EAAWP,QAAUA,OAEwBS,IAAxCF,EAAWZ,0BAEfY,EAAWZ,yBAA2B,IAAIjB,QAC1C6B,EAAWV,yBAA2B,IAAInB,QAE1C6B,EAAWG,wBAA0B,IAAIhC,QACzC6B,EAAWI,wBAA0B,IAAIjC,QAEzC6B,EAAWZ,yBAAyBW,KAAMjB,KAAKC,kBAAoBW,EAAOX,kBAC1EiB,EAAWV,yBAAyBS,KAAML,EAAOW,sBAIjDL,EAAWZ,yBAAyBW,KAAMC,EAAWG,yBACrDH,EAAWV,yBAAyBS,KAAMC,EAAWI,0BAItDJ,EAAWG,wBAAwBJ,KAAMjB,KAAKC,kBAAoBW,EAAOX,kBACzEiB,EAAWI,wBAAwBL,KAAML,EAAOW,oBAEhDvB,KAAKM,yBAAyBU,MAAMC,KAAMC,EAAWZ,0BACrDN,KAAKQ,yBAAyBQ,MAAMC,KAAMC,EAAWV,0BAIvD,CAOA,WAAAgB,EAAaX,OAAEA,IAEdE,kBAAmBF,GAASI,KAAMJ,EAAOY,YAE1C,CAQA,KAAAC,GAEC,MAAMzB,EAA+C,OAA1BD,KAAKC,iBAA8BT,uBAAyBF,QAASU,KAAKC,kBAE/F0B,EAA0B3B,KAAKQ,yBAAyBoB,IAAK5B,KAAKK,0BAElEwB,EAAsB5B,EAAiB2B,IAAK5C,iBAAkB4C,IAAK3C,eACnE6C,EAAuB9B,KAAKM,yBAAyBsB,IAAKD,GAA0BC,IAAK1C,kBAEzF6C,EAAqBF,EAAoBG,GAAGC,IAAKJ,EAAoBK,GACrEC,EAAsBL,EAAqBE,GAAGC,IAAKH,EAAqBI,GAI9E,OAFiB3C,IAAKwC,EAAoBI,EAI3C,EAID,SAAShB,QAASN,GAEjB,IAAIuB,EAAa1C,YAAY2C,IAAKxB,GASlC,YAPoBO,IAAfgB,IAEJA,EAAa,CAAC,EACd1C,YAAY4C,IAAKzB,EAAQuB,IAInBA,CAER,CAEA,SAASrB,kBAAmBF,EAAQ0B,EAAQ,GAE3C,MAAMH,EAAajB,QAASN,GAE5B,IAAI2B,EAASJ,EAAYG,GASzB,YAPgBnB,IAAXoB,IAEJJ,EAAYG,GAAUC,EAAS,IAAInD,QACnC+C,EAAYG,GAAQtB,KAAMJ,EAAOY,cAI3Be,CAER,gBAEe5C,oBAQR,MAAM6C,SAAyBtD,cAAeS","ignoreList":[]}