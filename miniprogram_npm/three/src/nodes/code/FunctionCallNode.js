import TempNode from"../core/TempNode.js";import{addMethodChaining,nodeArray,nodeObject,nodeObjects,float}from"../tsl/TSLCore.js";class FunctionCallNode extends TempNode{static get type(){return"FunctionCallNode"}constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],n=this.functionNode,o=n.getInputs(e),r=this.parameters,s=(t,n)=>{const o=n.type;let r;return r="pointer"===o?"&"+t.build(e):t.build(e,o),r};if(Array.isArray(r)){if(r.length>o.length)console.error("THREE.TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."),r.length=o.length;else if(r.length<o.length)for(console.error("THREE.TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");r.length<o.length;)r.push(float(0));for(let e=0;e<r.length;e++)t.push(s(r[e],o[e]))}else for(const e of o){const n=r[e.name];void 0!==n?t.push(s(n,e)):(console.error(`THREE.TSL: Input '${e.name}' not found in 'Fn()'.`),t.push(s(float(0),e)))}return`${n.build(e,"property")}( ${t.join(", ")} )`}}export default FunctionCallNode;export const call=(e,...t)=>(t=t.length>1||t[0]&&!0===t[0].isNode?nodeArray(t):nodeObjects(t[0]),nodeObject(new FunctionCallNode(nodeObject(e),t)));addMethodChaining("call",call);
//# sourceMappingURL=FunctionCallNode.js.map