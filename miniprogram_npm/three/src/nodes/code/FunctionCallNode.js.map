{"version":3,"file":"node_modules/three/src/nodes/code/FunctionCallNode.js","names":["TempNode","addMethodChaining","nodeArray","nodeObject","nodeObjects","float","FunctionCallNode","type","constructor","functionNode","parameters","super","this","setParameters","getParameters","getNodeType","builder","generate","params","inputs","getInputs","generateInput","node","inputNode","output","build","Array","isArray","length","console","error","push","i","name","undefined","join","call","func","isNode"],"sources":["node_modules/three/src/nodes/code/FunctionCallNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeArray, nodeObject, nodeObjects, float } from '../tsl/TSLCore.js';\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function call node.\n\t *\n\t * @param {?FunctionNode} functionNode - The function node.\n\t * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.\n\t */\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The function node.\n\t\t *\n\t\t * @type {?FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.functionNode = functionNode;\n\n\t\t/**\n\t\t * The parameters of the function call.\n\t\t *\n\t\t * @type {Object<string, Node>}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t}\n\n\t/**\n\t * Sets the parameters of the function call node.\n\t *\n\t * @param {Object<string, Node>} parameters - The parameters to set.\n\t * @return {FunctionCallNode} A reference to this node.\n\t */\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the parameters of the function call node.\n\t *\n\t * @return {Object<string, Node>} The parameters of this node.\n\t */\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tif ( parameters.length > inputs.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TSL: The number of provided parameters exceeds the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\tparameters.length = inputs.length;\n\n\t\t\t} else if ( parameters.length < inputs.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TSL: The number of provided parameters is less than the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\twhile ( parameters.length < inputs.length ) {\n\n\t\t\t\t\tparameters.push( float( 0 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( `THREE.TSL: Input '${ inputNode.name }' not found in \\'Fn()\\'.` );\n\n\t\t\t\t\tparams.push( generateInput( float( 0 ), inputNode ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${ functionName }( ${ params.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default FunctionCallNode;\n\nexport const call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n"],"mappings":"OAAOA,aAAc,6BACZC,kBAAmBC,UAAWC,WAAYC,YAAaC,UAAa,oBAS7E,MAAMC,yBAAyBN,SAE9B,eAAWO,GAEV,MAAO,kBAER,CAQA,WAAAC,CAAaC,EAAe,KAAMC,EAAa,CAAC,GAE/CC,QAQAC,KAAKH,aAAeA,EAQpBG,KAAKF,WAAaA,CAEnB,CAQA,aAAAG,CAAeH,GAId,OAFAE,KAAKF,WAAaA,EAEXE,IAER,CAOA,aAAAE,GAEC,OAAOF,KAAKF,UAEb,CAEA,WAAAK,CAAaC,GAEZ,OAAOJ,KAAKH,aAAaM,YAAaC,EAEvC,CAEA,QAAAC,CAAUD,GAET,MAAME,EAAS,GAETT,EAAeG,KAAKH,aAEpBU,EAASV,EAAaW,UAAWJ,GACjCN,EAAaE,KAAKF,WAElBW,EAAgB,CAAEC,EAAMC,KAE7B,MAAMhB,EAAOgB,EAAUhB,KAGvB,IAAIiB,EAKJ,OAHeA,EAJU,YAATjB,EAIQ,IAAMe,EAAKG,MAAOT,GAC5BM,EAAKG,MAAOT,EAAST,GAE5BiB,CAAM,EAId,GAAKE,MAAMC,QAASjB,GAAe,CAElC,GAAKA,EAAWkB,OAAST,EAAOS,OAE/BC,QAAQC,MAAO,iGAEfpB,EAAWkB,OAAST,EAAOS,YAErB,GAAKlB,EAAWkB,OAAST,EAAOS,OAItC,IAFAC,QAAQC,MAAO,sGAEPpB,EAAWkB,OAAST,EAAOS,QAElClB,EAAWqB,KAAM1B,MAAO,IAM1B,IAAM,IAAI2B,EAAI,EAAGA,EAAItB,EAAWkB,OAAQI,IAEvCd,EAAOa,KAAMV,EAAeX,EAAYsB,GAAKb,EAAQa,IAIvD,MAEC,IAAM,MAAMT,KAAaJ,EAAS,CAEjC,MAAMG,EAAOZ,EAAYa,EAAUU,WAErBC,IAATZ,EAEJJ,EAAOa,KAAMV,EAAeC,EAAMC,KAIlCM,QAAQC,MAAO,qBAAsBP,EAAUU,8BAE/Cf,EAAOa,KAAMV,EAAehB,MAAO,GAAKkB,IAI1C,CAMD,MAAO,GAFcd,EAAagB,MAAOT,EAAS,gBAEpBE,EAAOiB,KAAM,SAE5C,iBAIc7B,wBAER,MAAM8B,KAAO,CAAEC,KAASnB,KAE9BA,EAASA,EAAOU,OAAS,GAAOV,EAAQ,KAA8B,IAAvBA,EAAQ,GAAIoB,OAAoBpC,UAAWgB,GAAWd,YAAac,EAAQ,IAEnHf,WAAY,IAAIG,iBAAkBH,WAAYkC,GAAQnB,KAI9DjB,kBAAmB,OAAQmC","ignoreList":[]}