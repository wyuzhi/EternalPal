{"version":3,"file":"node_modules/three/src/nodes/code/FunctionNode.js","names":["CodeNode","nodeObject","FunctionNode","type","constructor","code","includes","language","super","getNodeType","builder","this","getNodeFunction","getInputs","inputs","nodeData","getDataFromNode","nodeFunction","undefined","parser","parseFunction","generate","output","name","nodeCode","getCodeFromNode","propertyName","getPropertyName","getCode","format","nativeFn","i","length","include","functionNode","fn","params","call","glslFn","wgslFn"],"sources":["node_modules/three/src/nodes/code/FunctionNode.js"],"sourcesContent":["import CodeNode from './CodeNode.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\n\n/**\n * This class represents a native shader function. It can be used to implement\n * certain aspects of a node material with native shader code. There are two predefined\n * TSL functions for easier usage.\n *\n * - `wgslFn`: Creates a WGSL function node.\n * - `glslFn`: Creates a GLSL function node.\n *\n * A basic example with one include looks like so:\n *\n * ```js\n * const desaturateWGSLFn = wgslFn( `\n *\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n *\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n *\t\treturn vec3<f32>( dot( lum, color ) );\n *\t}`\n *);\n * const someWGSLFn = wgslFn( `\n *\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n * \t\treturn desaturate( color );\n * \t}\n * `, [ desaturateWGSLFn ] );\n * material.colorNode = someWGSLFn( { color: texture( map ) } );\n *```\n * @augments CodeNode\n */\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function node.\n\t *\n\t * @param {string} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\t/**\n\t * Returns the inputs of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<NodeFunctionInput>} The inputs.\n\t */\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\t/**\n\t * Returns the node function for this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeFunction} The node function.\n\t */\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default FunctionNode;\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nexport const glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nexport const wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n"],"mappings":"OAAOA,aAAc,uBACZC,eAAkB,oBA4B3B,MAAMC,qBAAqBF,SAE1B,eAAWG,GAEV,MAAO,cAER,CASA,WAAAC,CAAaC,EAAO,GAAIC,EAAW,GAAIC,EAAW,IAEjDC,MAAOH,EAAMC,EAAUC,EAExB,CAEA,WAAAE,CAAaC,GAEZ,OAAOC,KAAKC,gBAAiBF,GAAUP,IAExC,CAQA,SAAAU,CAAWH,GAEV,OAAOC,KAAKC,gBAAiBF,GAAUI,MAExC,CAQA,eAAAF,CAAiBF,GAEhB,MAAMK,EAAWL,EAAQM,gBAAiBL,MAE1C,IAAIM,EAAeF,EAASE,aAU5B,YARsBC,IAAjBD,IAEJA,EAAeP,EAAQS,OAAOC,cAAeT,KAAKN,MAElDU,EAASE,aAAeA,GAIlBA,CAER,CAEA,QAAAI,CAAUX,EAASY,GAElBd,MAAMa,SAAUX,GAEhB,MAAMO,EAAeN,KAAKC,gBAAiBF,GAErCa,EAAON,EAAaM,KACpBpB,EAAOc,EAAad,KAEpBqB,EAAWd,EAAQe,gBAAiBd,KAAMR,GAElC,KAAToB,IAIJC,EAASD,KAAOA,GAIjB,MAAMG,EAAehB,EAAQiB,gBAAiBH,GAExCnB,EAAOM,KAAKC,gBAAiBF,GAAUkB,QAASF,GAItD,OAFAF,EAASnB,KAAOA,EAAO,KAEP,aAAXiB,EAEGI,EAIAhB,EAAQmB,OAAQ,GAAIH,MAAmBvB,EAAMmB,EAItD,iBAIcpB,aAEf,MAAM4B,SAAW,CAAEzB,EAAMC,EAAW,GAAIC,EAAW,MAElD,IAAM,IAAIwB,EAAI,EAAGA,EAAIzB,EAAS0B,OAAQD,IAAO,CAE5C,MAAME,EAAU3B,EAAUyB,GAIF,mBAAZE,IAEX3B,EAAUyB,GAAME,EAAQC,aAI1B,CAEA,MAAMA,EAAejC,WAAY,IAAIC,aAAcG,EAAMC,EAAUC,IAE7D4B,EAAK,IAAKC,IAAYF,EAAaG,QAASD,GAGlD,OAFAD,EAAGD,aAAeA,EAEXC,CAAE,SAIH,MAAMG,OAAS,CAAEjC,EAAMC,IAAcwB,SAAUzB,EAAMC,EAAU,eAC/D,MAAMiC,OAAS,CAAElC,EAAMC,IAAcwB,SAAUzB,EAAMC,EAAU","ignoreList":[]}