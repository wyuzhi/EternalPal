{"version":3,"file":"node_modules/three/src/nodes/code/ScriptableValueNode.js","names":["Node","arrayBufferToBase64","base64ToArrayBuffer","nodeProxy","float","EventDispatcher","ScriptableValueNode","type","constructor","value","super","this","_value","_cache","inputType","outputType","events","isScriptableValueNode","isScriptableOutputNode","val","ArrayBuffer","URL","revokeObjectURL","dispatchEvent","refresh","getValue","createObjectURL","Blob","undefined","isVector2","isVector3","isVector4","isColor","isMatrix3","isMatrix4","getNodeType","builder","isNode","setup","serialize","data","toJSON","meta","uuid","deserialize","textures","nodes","scriptableValue","setParameterLength"],"sources":["node_modules/three/src/nodes/code/ScriptableValueNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { arrayBufferToBase64, base64ToArrayBuffer } from '../core/NodeUtils.js';\nimport { nodeProxy, float } from '../tsl/TSLBase.js';\n\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\n\n/**\n * `ScriptableNode` uses this class to manage script inputs and outputs.\n *\n * @augments Node\n */\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {any} [value=null] - The value.\n\t */\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A reference to the value.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Depending on the type of `_value`, this property might cache parsed data.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._cache = null;\n\n\t\t/**\n\t\t * If this node represents an input, this property represents the input type.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.inputType = null;\n\n\t\t/**\n\t\t * If this node represents an output, this property represents the output type.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.outputType = null;\n\n\t\t/**\n\t\t * An event dispatcher for managing events.\n\t\t *\n\t\t * @type {EventDispatcher}\n\t\t */\n\t\tthis.events = new EventDispatcher();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node represents an output or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\t/**\n\t * The node's value.\n\t *\n\t * @type {any}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Dispatches the `refresh` event.\n\t */\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\t/**\n\t * The `value` property usually represents a node or even binary data in form of array buffers.\n\t * In this case, this method tries to return the actual value behind the complex type.\n\t *\n\t * @return {any} The value.\n\t */\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the value.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\nexport default ScriptableValueNode;\n\n/**\n * TSL function for creating a scriptable value node.\n *\n * @tsl\n * @function\n * @param {any} [value] - The value.\n * @returns {ScriptableValueNode}\n */\nexport const scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode ).setParameterLength( 1 );\n"],"mappings":"OAAOA,SAAU,yBACRC,oBAAqBC,wBAA2B,8BAChDC,UAAWC,UAAa,2BAExBC,oBAAuB,gCAOhC,MAAMC,4BAA4BN,KAEjC,eAAWO,GAEV,MAAO,qBAER,CAOA,WAAAC,CAAaC,EAAQ,MAEpBC,QAQAC,KAAKC,OAASH,EAQdE,KAAKE,OAAS,KAQdF,KAAKG,UAAY,KAQjBH,KAAKI,WAAa,KAOlBJ,KAAKK,OAAS,IAAIX,gBASlBM,KAAKM,uBAAwB,CAE9B,CASA,0BAAIC,GAEH,OAA2B,OAApBP,KAAKI,UAEb,CAEA,SAAIN,CAAOU,GAELR,KAAKC,SAAWO,IAEhBR,KAAKE,QAA6B,QAAnBF,KAAKG,WAAuBH,KAAKF,MAAMA,iBAAiBW,cAE3EC,IAAIC,gBAAiBX,KAAKE,QAE1BF,KAAKE,OAAS,MAIfF,KAAKC,OAASO,EAEdR,KAAKK,OAAOO,cAAe,CAAEhB,KAAM,WAEnCI,KAAKa,UAEN,CAOA,SAAIf,GAEH,OAAOE,KAAKC,MAEb,CAKA,OAAAY,GAECb,KAAKK,OAAOO,cAAe,CAAEhB,KAAM,WAEpC,CAQA,QAAAkB,GAEC,MAAMhB,EAAQE,KAAKF,MAEnB,GAAKA,GAAyB,OAAhBE,KAAKE,QAAsC,QAAnBF,KAAKG,WAAuBL,EAAMA,iBAAiBW,YAExFT,KAAKE,OAASQ,IAAIK,gBAAiB,IAAIC,KAAM,CAAElB,EAAMA,cAE/C,GAAKA,GAAyB,OAAhBA,EAAMA,YAAkCmB,IAAhBnB,EAAMA,SAC3B,QAAnBE,KAAKG,WAA0C,WAAnBH,KAAKG,YAAmD,iBAAhBL,EAAMA,OACzD,WAAnBE,KAAKG,WAAiD,iBAAhBL,EAAMA,OACzB,YAAnBE,KAAKG,WAA2BL,EAAMA,MAAMoB,WACzB,YAAnBlB,KAAKG,WAA2BL,EAAMA,MAAMqB,WACzB,YAAnBnB,KAAKG,WAA2BL,EAAMA,MAAMsB,WACzB,UAAnBpB,KAAKG,WAAyBL,EAAMA,MAAMuB,SACvB,YAAnBrB,KAAKG,WAA2BL,EAAMA,MAAMwB,WACzB,YAAnBtB,KAAKG,WAA2BL,EAAMA,MAAMyB,WAG9C,OAAOzB,EAAMA,MAId,OAAOE,KAAKE,QAAUJ,CAEvB,CAQA,WAAA0B,CAAaC,GAEZ,OAAOzB,KAAKF,OAASE,KAAKF,MAAM4B,OAAS1B,KAAKF,MAAM0B,YAAaC,GAAY,OAE9E,CAEA,KAAAE,GAEC,OAAO3B,KAAKF,OAASE,KAAKF,MAAM4B,OAAS1B,KAAKF,MAAQL,OAEvD,CAEA,SAAAmC,CAAWC,GAEV9B,MAAM6B,UAAWC,GAEG,OAAf7B,KAAKF,MAEe,gBAAnBE,KAAKG,UAET0B,EAAK/B,MAAQR,oBAAqBU,KAAKF,OAIvC+B,EAAK/B,MAAQE,KAAKF,MAAQE,KAAKF,MAAMgC,OAAQD,EAAKE,MAAOC,KAAO,KAMjEH,EAAK/B,MAAQ,KAId+B,EAAK1B,UAAYH,KAAKG,UACtB0B,EAAKzB,WAAaJ,KAAKI,UAExB,CAEA,WAAA6B,CAAaJ,GAEZ9B,MAAMkC,YAAaJ,GAEnB,IAAI/B,EAAQ,KAEQ,OAAf+B,EAAK/B,QAIRA,EAFuB,gBAAnB+B,EAAK1B,UAEDZ,oBAAqBsC,EAAK/B,OAEJ,YAAnB+B,EAAK1B,UAER0B,EAAKE,KAAKG,SAAUL,EAAK/B,OAIzB+B,EAAKE,KAAKI,MAAON,EAAK/B,QAAW,MAM3CE,KAAKF,MAAQA,EAEbE,KAAKG,UAAY0B,EAAK1B,UACtBH,KAAKI,WAAayB,EAAKzB,UAExB,iBAIcT,2BAUR,MAAMyC,gBAAgC5C,UAAWG,qBAAsB0C,mBAAoB","ignoreList":[]}