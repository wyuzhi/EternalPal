import TempNode from"../core/TempNode.js";import{addMethodChaining,nodeProxy}from"../tsl/TSLCore.js";import{vectorComponents}from"../core/constants.js";class AssignNode extends TempNode{static get type(){return"AssignNode"}constructor(e,t){super(),this.targetNode=e,this.sourceNode=t,this.isAssignNode=!0}hasDependencies(){return!1}getNodeType(e,t){return"void"!==t?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(!1===e.isAvailable("swizzleAssign")&&t.isSplitNode&&t.components.length>1){const o=e.getTypeLength(t.node.getNodeType(e));return vectorComponents.join("").slice(0,o)!==t.components}return!1}setup(e){const{targetNode:t,sourceNode:o}=this;e.getNodeProperties(t).assign=!0;const s=e.getNodeProperties(this);s.sourceNode=o,s.targetNode=t.context({assign:!0})}generate(e,t){const{targetNode:o,sourceNode:s}=e.getNodeProperties(this),i=this.needsSplitAssign(e),n=o.getNodeType(e),d=o.build(e),r=s.build(e,n),g=s.getNodeType(e),a=e.getDataFromNode(this);let p;if(!0===a.initialized)"void"!==t&&(p=d);else if(i){const s=e.getVarFromNode(this,null,n),i=e.getPropertyName(s);e.addLineFlowCode(`${i} = ${r}`,this);const g=o.node,a=g.node.context({assign:!0}).build(e);for(let t=0;t<g.components.length;t++){const o=g.components[t];e.addLineFlowCode(`${a}.${o} = ${i}[ ${t} ]`,this)}"void"!==t&&(p=d)}else p=`${d} = ${r}`,"void"!==t&&"void"!==g||(e.addLineFlowCode(p,this),"void"!==t&&(p=d));return a.initialized=!0,e.format(p,n,t)}}export default AssignNode;export const assign=nodeProxy(AssignNode).setParameterLength(2);addMethodChaining("assign",assign);
//# sourceMappingURL=AssignNode.js.map