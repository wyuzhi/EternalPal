{"version":3,"file":"node_modules/three/src/nodes/core/AssignNode.js","names":["TempNode","addMethodChaining","nodeProxy","vectorComponents","AssignNode","type","constructor","targetNode","sourceNode","super","this","isAssignNode","hasDependencies","getNodeType","builder","output","needsSplitAssign","isAvailable","isSplitNode","components","length","targetLength","getTypeLength","node","join","slice","setup","getNodeProperties","assign","properties","context","generate","targetType","target","build","source","sourceType","nodeData","getDataFromNode","snippet","initialized","sourceVar","getVarFromNode","sourceProperty","getPropertyName","addLineFlowCode","splitNode","targetRoot","i","component","format","setParameterLength"],"sources":["node_modules/three/src/nodes/core/AssignNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\nimport { vectorComponents } from '../core/constants.js';\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\t/**\n\t * Constructs a new assign node.\n\t *\n\t * @param {Node} targetNode - The target node.\n\t * @param {Node} sourceNode - The source type.\n\t */\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The target node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t\t/**\n\t\t * The source node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAssignNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes. This method\n\t * is overwritten since it always returns `false` (assigns are unique).\n\t *\n\t * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n\t */\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Whether a split is required when assigning source to target. This can happen when the component length of\n\t * target and source data type does not match.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether a split is required when assigning source to target.\n\t */\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDifferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst targetProperties = builder.getNodeProperties( targetNode );\n\t\ttargetProperties.assign = true;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.sourceNode = sourceNode;\n\t\tproperties.targetNode = targetNode.context( { assign: true } );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = builder.getNodeProperties( this );\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst splitNode = targetNode.node;\n\t\t\tconst splitTargetNode = splitNode.node.context( { assign: true } );\n\n\t\t\tconst targetRoot = splitTargetNode.build( builder );\n\n\t\t\tfor ( let i = 0; i < splitNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = splitNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\nexport default AssignNode;\n\n/**\n * TSL function for creating an assign node.\n *\n * @tsl\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nexport const assign = /*@__PURE__*/ nodeProxy( AssignNode ).setParameterLength( 2 );\n\naddMethodChaining( 'assign', assign );\n"],"mappings":"OAAOA,aAAc,6BACZC,kBAAmBC,cAAiB,2BACpCC,qBAAwB,uBAQjC,MAAMC,mBAAmBJ,SAExB,eAAWK,GAEV,MAAO,YAER,CAQA,WAAAC,CAAaC,EAAYC,GAExBC,QAOAC,KAAKH,WAAaA,EAOlBG,KAAKF,WAAaA,EASlBE,KAAKC,cAAe,CAErB,CAQA,eAAAC,GAEC,OAAO,CAER,CAEA,WAAAC,CAAaC,EAASC,GAErB,MAAkB,SAAXA,EAAoBL,KAAKH,WAAWM,YAAaC,GAAY,MAErE,CASA,gBAAAE,CAAkBF,GAEjB,MAAMP,WAAEA,GAAeG,KAEvB,IAAgD,IAA3CI,EAAQG,YAAa,kBAA+BV,EAAWW,aAAeX,EAAWY,WAAWC,OAAS,EAAI,CAErH,MAAMC,EAAeP,EAAQQ,cAAef,EAAWgB,KAAKV,YAAaC,IAGzE,OAF8BX,iBAAiBqB,KAAM,IAAKC,MAAO,EAAGJ,KAAmBd,EAAWY,UAInG,CAEA,OAAO,CAER,CAEA,KAAAO,CAAOZ,GAEN,MAAMP,WAAEA,EAAUC,WAAEA,GAAeE,KAEVI,EAAQa,kBAAmBpB,GACnCqB,QAAS,EAE1B,MAAMC,EAAaf,EAAQa,kBAAmBjB,MAC9CmB,EAAWrB,WAAaA,EACxBqB,EAAWtB,WAAaA,EAAWuB,QAAS,CAAEF,QAAQ,GAEvD,CAEA,QAAAG,CAAUjB,EAASC,GAElB,MAAMR,WAAEA,EAAUC,WAAEA,GAAeM,EAAQa,kBAAmBjB,MAExDM,EAAmBN,KAAKM,iBAAkBF,GAE1CkB,EAAazB,EAAWM,YAAaC,GAErCmB,EAAS1B,EAAW2B,MAAOpB,GAC3BqB,EAAS3B,EAAW0B,MAAOpB,EAASkB,GAEpCI,EAAa5B,EAAWK,YAAaC,GAErCuB,EAAWvB,EAAQwB,gBAAiB5B,MAI1C,IAAI6B,EAEJ,IAA8B,IAAzBF,EAASG,YAEG,SAAXzB,IAEJwB,EAAUN,QAIL,GAAKjB,EAAmB,CAE9B,MAAMyB,EAAY3B,EAAQ4B,eAAgBhC,KAAM,KAAMsB,GAChDW,EAAiB7B,EAAQ8B,gBAAiBH,GAEhD3B,EAAQ+B,gBAAiB,GAAIF,OAAsBR,IAAWzB,MAE9D,MAAMoC,EAAYvC,EAAWgB,KAGvBwB,EAFkBD,EAAUvB,KAAKO,QAAS,CAAEF,QAAQ,IAEvBM,MAAOpB,GAE1C,IAAM,IAAIkC,EAAI,EAAGA,EAAIF,EAAU3B,WAAWC,OAAQ4B,IAAO,CAExD,MAAMC,EAAYH,EAAU3B,WAAY6B,GAExClC,EAAQ+B,gBAAiB,GAAIE,KAAgBE,OAAiBN,MAAqBK,MAAQtC,KAE5F,CAEgB,SAAXK,IAEJwB,EAAUN,EAIZ,MAECM,EAAU,GAAIN,OAAcE,IAEZ,SAAXpB,GAAoC,SAAfqB,IAEzBtB,EAAQ+B,gBAAiBN,EAAS7B,MAElB,SAAXK,IAEJwB,EAAUN,IAUb,OAFAI,EAASG,aAAc,EAEhB1B,EAAQoC,OAAQX,EAASP,EAAYjB,EAE7C,iBAIcX,kBAWR,MAAMwB,OAAuB1B,UAAWE,YAAa+C,mBAAoB,GAEhFlD,kBAAmB,SAAU2B","ignoreList":[]}