{"version":3,"file":"node_modules/three/src/nodes/core/AttributeNode.js","names":["Node","nodeObject","varying","AttributeNode","type","constructor","attributeName","nodeType","super","this","global","_attributeName","getHash","builder","getAttributeName","getNodeType","hasGeometryAttribute","attribute","geometry","getAttribute","getTypeFromAttribute","setAttributeName","generate","attributeType","nodeAttribute","shaderStage","format","name","build","console","warn","generateConst","serialize","data","deserialize"],"sources":["node_modules/three/src/nodes/core/AttributeNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { nodeObject, varying } from '../tsl/TSLBase.js';\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new attribute node.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * `AttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Sets the attribute name to the given value. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @return {AttributeNode} A reference to this node.\n\t */\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the attribute name of this node. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\nexport default AttributeNode;\n\n/**\n * TSL function for creating an attribute node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the attribute.\n * @param {?string} [nodeType=null] - The node type.\n * @returns {AttributeNode}\n */\nexport const attribute = ( name, nodeType = null ) => nodeObject( new AttributeNode( name, nodeType ) );\n"],"mappings":"OAAOA,SAAU,mBACRC,WAAYC,YAAe,oBAOpC,MAAMC,sBAAsBH,KAE3B,eAAWI,GAEV,MAAO,eAER,CAQA,WAAAC,CAAaC,EAAeC,EAAW,MAEtCC,MAAOD,GAQPE,KAAKC,QAAS,EAEdD,KAAKE,eAAiBL,CAEvB,CAEA,OAAAM,CAASC,GAER,OAAOJ,KAAKK,iBAAkBD,EAE/B,CAEA,WAAAE,CAAaF,GAEZ,IAAIN,EAAWE,KAAKF,SAEpB,GAAkB,OAAbA,EAAoB,CAExB,MAAMD,EAAgBG,KAAKK,iBAAkBD,GAE7C,GAAKA,EAAQG,qBAAsBV,GAAkB,CAEpD,MAAMW,EAAYJ,EAAQK,SAASC,aAAcb,GAEjDC,EAAWM,EAAQO,qBAAsBH,EAE1C,MAECV,EAAW,OAIb,CAEA,OAAOA,CAER,CAUA,gBAAAc,CAAkBf,GAIjB,OAFAG,KAAKE,eAAiBL,EAEfG,IAER,CAUA,gBAAAK,GAEC,OAAOL,KAAKE,cAEb,CAEA,QAAAW,CAAUT,GAET,MAAMP,EAAgBG,KAAKK,iBAAkBD,GACvCN,EAAWE,KAAKM,YAAaF,GAGnC,IAA2B,IAFDA,EAAQG,qBAAsBV,GAEtB,CAEjC,MAAMW,EAAYJ,EAAQK,SAASC,aAAcb,GAC3CiB,EAAgBV,EAAQO,qBAAsBH,GAE9CO,EAAgBX,EAAQM,aAAcb,EAAeiB,GAE3D,GAA6B,WAAxBV,EAAQY,YAEZ,OAAOZ,EAAQa,OAAQF,EAAcG,KAAMJ,EAAehB,GAM1D,OAFoBL,QAASO,MAEVmB,MAAOf,EAASN,EAIrC,CAIC,OAFAsB,QAAQC,KAAM,oCAAqCxB,6BAE5CO,EAAQkB,cAAexB,EAIhC,CAEA,SAAAyB,CAAWC,GAEVzB,MAAMwB,UAAWC,GAEjBA,EAAKvB,OAASD,KAAKC,OACnBuB,EAAKtB,eAAiBF,KAAKE,cAE5B,CAEA,WAAAuB,CAAaD,GAEZzB,MAAM0B,YAAaD,GAEnBxB,KAAKC,OAASuB,EAAKvB,OACnBD,KAAKE,eAAiBsB,EAAKtB,cAE5B,iBAIcR,qBAWR,MAAMc,UAAY,CAAEU,EAAMpB,EAAW,OAAUN,WAAY,IAAIE,cAAewB,EAAMpB","ignoreList":[]}