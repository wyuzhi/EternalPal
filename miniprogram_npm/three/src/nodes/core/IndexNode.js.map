{"version":3,"file":"node_modules/three/src/nodes/core/IndexNode.js","names":["Node","nodeImmutable","varying","IndexNode","type","constructor","scope","super","this","isIndexNode","generate","builder","nodeType","getNodeType","propertyName","output","VERTEX","getVertexIndex","INSTANCE","getInstanceIndex","DRAW","getDrawIndex","INVOCATION_LOCAL","getInvocationLocalIndex","INVOCATION_SUBGROUP","getInvocationSubgroupIndex","SUBGROUP","Error","getSubgroupIndex","shaderStage","build","vertexIndex","instanceIndex","subgroupIndex","invocationSubgroupIndex","invocationLocalIndex","drawIndex"],"sources":["node_modules/three/src/nodes/core/IndexNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { nodeImmutable, varying } from '../tsl/TSLBase.js';\n\n/**\n * This class represents shader indices of different types. The following predefined node\n * objects cover frequent use cases:\n *\n * - `vertexIndex`: The index of a vertex within a mesh.\n * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.\n * - `drawIndex`: The index of a draw call.\n * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.\n * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.\n * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.\n *\n * @augments Node\n */\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\t/**\n\t * Constructs a new index node.\n\t *\n\t * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The scope of the index node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\nexport default IndexNode;\n\n/**\n * TSL object that represents the index of a vertex within a mesh.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\n\n/**\n * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\n\n/**\n * TSL object that represents the index of the subgroup the current compute invocation belongs to.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a subgroup.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a workgroup load.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\n\n/**\n * TSL object that represents the index of a draw call.\n *\n * @tsl\n * @type {IndexNode}\n */\nexport const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n"],"mappings":"OAAOA,SAAU,mBACRC,cAAeC,YAAe,oBAevC,MAAMC,kBAAkBH,KAEvB,eAAWI,GAEV,MAAO,WAER,CAOA,WAAAC,CAAaC,GAEZC,MAAO,QAOPC,KAAKF,MAAQA,EASbE,KAAKC,aAAc,CAEpB,CAEA,QAAAC,CAAUC,GAET,MAAMC,EAAWJ,KAAKK,YAAaF,GAC7BL,EAAQE,KAAKF,MAEnB,IAAIQ,EAgCAC,EA9BJ,GAAKT,IAAUH,UAAUa,OAExBF,EAAeH,EAAQM,sBAEjB,GAAKX,IAAUH,UAAUe,SAE/BJ,EAAeH,EAAQQ,wBAEjB,GAAKb,IAAUH,UAAUiB,KAE/BN,EAAeH,EAAQU,oBAEjB,GAAKf,IAAUH,UAAUmB,iBAE/BR,EAAeH,EAAQY,+BAEjB,GAAKjB,IAAUH,UAAUqB,oBAE/BV,EAAeH,EAAQc,iCAEjB,IAAKnB,IAAUH,UAAUuB,SAM/B,MAAM,IAAIC,MAAO,mCAAqCrB,GAJtDQ,EAAeH,EAAQiB,kBAMxB,CAIA,GAA6B,WAAxBjB,EAAQkB,aAAoD,YAAxBlB,EAAQkB,YAEhDd,EAASD,MAEH,CAINC,EAFoBb,QAASM,MAERsB,MAAOnB,EAASC,EAEtC,CAEA,OAAOG,CAER,EAIDZ,UAAUa,OAAS,SACnBb,UAAUe,SAAW,WACrBf,UAAUuB,SAAW,WACrBvB,UAAUmB,iBAAmB,kBAC7BnB,UAAUqB,oBAAsB,qBAChCrB,UAAUiB,KAAO,sBAEFjB,iBAQR,MAAM4B,YAA4B9B,cAAeE,UAAWA,UAAUa,eAQtE,MAAMgB,cAA8B/B,cAAeE,UAAWA,UAAUe,iBAQxE,MAAMe,cAA8BhC,cAAeE,UAAWA,UAAUuB,iBAQxE,MAAMQ,wBAAwCjC,cAAeE,UAAWA,UAAUqB,4BAQlF,MAAMW,qBAAqClC,cAAeE,UAAWA,UAAUmB,yBAQ/E,MAAMc,UAA0BnC,cAAeE,UAAWA,UAAUiB","ignoreList":[]}