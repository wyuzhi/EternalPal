{"version":3,"file":"node_modules/three/src/nodes/core/InputNode.js","names":["Node","getValueType","getValueFromType","arrayBufferToBase64","InputNode","type","constructor","value","nodeType","super","this","isInputNode","precision","getNodeType","getInputType","builder","setPrecision","serialize","data","toArray","valueType","deserialize","Array","isArray","fromArray","generate","console","warn"],"sources":["node_modules/three/src/nodes/core/InputNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInputNode = true;\n\n\t\t/**\n\t\t * The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t\t *\n\t\t * @type {any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * The precision of the value in the shader.\n\t\t *\n\t\t * @type {?('low'|'medium'|'high')}\n\t\t * @default null\n\t\t */\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the input type of the node which is by default the node type. Derived modules\n\t * might overwrite this method and use a fixed type or compute one analytically.\n\t *\n\t * A typical example for different input and node types are textures. The input type of a\n\t * normal RGBA texture is `texture` whereas its node type is `vec4`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets the precision to the given value. The method can be\n\t * overwritten in derived classes if the final precision must be computed\n\t * analytically.\n\t *\n\t * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n\t * @return {InputNode} A reference to this node.\n\t */\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nexport default InputNode;\n"],"mappings":"OAAOA,SAAU,mBACRC,aAAcC,iBAAkBC,wBAA2B,iBAOpE,MAAMC,kBAAkBJ,KAEvB,eAAWK,GAEV,MAAO,WAER,CAQA,WAAAC,CAAaC,EAAOC,EAAW,MAE9BC,MAAOD,GASPE,KAAKC,aAAc,EAOnBD,KAAKH,MAAQA,EAQbG,KAAKE,UAAY,IAElB,CAEA,WAAAC,GAEC,OAAuB,OAAlBH,KAAKF,SAEFP,aAAcS,KAAKH,OAIpBG,KAAKF,QAEb,CAYA,YAAAM,CAAcC,GAEb,OAAOL,KAAKG,YAAaE,EAE1B,CAUA,YAAAC,CAAcJ,GAIb,OAFAF,KAAKE,UAAYA,EAEVF,IAER,CAEA,SAAAO,CAAWC,GAEVT,MAAMQ,UAAWC,GAEjBA,EAAKX,MAAQG,KAAKH,MAEbG,KAAKH,OAASG,KAAKH,MAAMY,UAAUD,EAAKX,MAAQG,KAAKH,MAAMY,WAEhED,EAAKE,UAAYnB,aAAcS,KAAKH,OACpCW,EAAKV,SAAWE,KAAKF,SAEG,gBAAnBU,EAAKE,YAA8BF,EAAKX,MAAQJ,oBAAqBe,EAAKX,QAE/EW,EAAKN,UAAYF,KAAKE,SAEvB,CAEA,WAAAS,CAAaH,GAEZT,MAAMY,YAAaH,GAEnBR,KAAKF,SAAWU,EAAKV,SACrBE,KAAKH,MAAQe,MAAMC,QAASL,EAAKX,OAAUL,iBAAkBgB,EAAKE,aAAcF,EAAKX,OAAUW,EAAKX,MAEpGG,KAAKE,UAAYM,EAAKN,WAAa,KAE9BF,KAAKH,OAASG,KAAKH,MAAMiB,YAAYd,KAAKH,MAAQG,KAAKH,MAAMiB,UAAWN,EAAKX,OAEnF,CAEA,QAAAkB,GAECC,QAAQC,KAAM,qBAEf,iBAIcvB","ignoreList":[]}