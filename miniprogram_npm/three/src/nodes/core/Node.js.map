{"version":3,"file":"node_modules/three/src/nodes/core/Node.js","names":["NodeUpdateType","getNodeChildren","getCacheKey","hash","EventDispatcher","MathUtils","_parentBuildStage","analyze","generate","_nodeId","Node","type","constructor","nodeType","super","this","updateType","NONE","updateBeforeType","updateAfterType","uuid","generateUUID","version","global","parents","isNode","_cacheKey","_cacheKeyVersion","Object","defineProperty","value","needsUpdate","onUpdate","callback","update","bind","getSelf","onFrameUpdate","FRAME","onRenderUpdate","RENDER","onObjectUpdate","OBJECT","onReference","updateReference","self","isGlobal","getChildren","childNode","dispose","dispatchEvent","traverse","force","customCacheKey","getScope","getHash","getUpdateType","getUpdateBeforeType","getUpdateAfterType","getElementType","builder","getNodeType","getMemberType","nodeProperties","getNodeProperties","outputNode","getShared","getNodeFromHash","getArrayCount","setup","index","output","usageCount","increaseUsage","nodeData","getDataFromNode","stages","shaderStage","push","values","build","updateBefore","console","warn","updateAfter","refNode","buildStages","buildStage","parentBuildStage","previousBuildStage","getBuildStage","setBuildStage","addNode","addChain","result","properties","initialized","childProperties","length","snippet","undefined","generated","flowCodes","context","nodeBlock","addFlowCodeHierarchy","format","removeChain","addSequentialNode","getSerializeChildren","serialize","json","nodeChildren","inputNodes","property","Number","isInteger","toJSON","meta","keys","deserialize","nodes","Array","isArray","inputArray","inputObject","subProperty","isRoot","textures","images","data","extractFromCache","cache","key","metadata","generator"],"sources":["node_modules/three/src/nodes/core/Node.js"],"sourcesContent":["import { NodeUpdateType } from './constants.js';\nimport { getNodeChildren, getCacheKey, hash } from './NodeUtils.js';\n\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { MathUtils } from '../../math/MathUtils.js';\n\nconst _parentBuildStage = {\n\tanalyze: 'setup',\n\tgenerate: 'analyze'\n};\n\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\t/**\n\t * Constructs a new node.\n\t *\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.nodeType = nodeType;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The UUID of the node.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t/**\n\t\t * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether this node is global or not. This property is relevant for the internal\n\t\t * node caching system. All nodes which should be declared just once should\n\t\t * set this flag to `true` (a typical example is {@link AttributeNode}).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.global = false;\n\n\t\t/**\n\t\t * Create a list of parents for this node during the build process.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.parents = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNode = true;\n\n\t\t// private\n\n\t\t/**\n\t\t * The cache key of this node.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheKey = null;\n\n\t\t/**\n\t\t * The cache key 's version.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the node should be regenerated.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The type of the class. The value is usually the constructor name.\n\t *\n\t * @type {string}\n \t * @readonly\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @param {string} updateType - The update type.\n\t * @return {Node} A reference to this node.\n\t */\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `FRAME`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `RENDER`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `OBJECT`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#updateReference}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The `this` reference might point to a Proxy so this method can be used\n\t * to get the reference to the actual node instance.\n\t *\n\t * @return {Node} A reference to the node.\n\t */\n\tgetSelf() {\n\n\t\t// Returns non-node object.\n\n\t\treturn this.self || this;\n\n\t}\n\n\t/**\n\t * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n\t * to such objects based on a given state (e.g. the current node frame or builder).\n\t *\n\t * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {any} The updated reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * By default this method returns the value of the {@link Node#global} flag. This method\n\t * can be overwritten in derived classes if an analytical way is required to determine the\n\t * global cache referring to the current shader-stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t/**\n\t * Generator function that can be used to iterate over the child nodes.\n\t *\n\t * @generator\n\t * @yields {Node} A child node.\n\t */\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method dispatches the `dispose` event. This event can be used\n\t * to register event listeners for clean up tasks.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Callback for {@link Node#traverse}.\n\t *\n\t * @callback traverseCallback\n\t * @param {Node} node - The current node.\n\t */\n\n\t/**\n\t * Can be used to traverse through the node's hierarchy.\n\t *\n\t * @param {traverseCallback} callback - A callback that is executed per node.\n\t */\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the cache key for this node.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n\t * @return {number} The cache key of the node.\n\t */\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = hash( getCacheKey( this, force ), this.customCacheKey() );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\t/**\n\t * Generate a custom cache key for this node.\n\t *\n\t * @return {number} The cache key of the node.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the references to this node which is by default `this`.\n\t *\n\t * @return {Node} A reference to this node.\n\t */\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hash of the node which is used to identify the node. By default it's\n\t * the {@link Node#uuid} however derived node classes might have to overwrite this method\n\t * depending on their implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#update}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateBefore}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateAfter}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\t/**\n\t * Certain types are composed of multiple elements. For example a `vec3`\n\t * is composed of three `float` values. This method returns the type of\n\t * these elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\t/**\n\t * Returns the node member type for the given name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the node.\n\t */\n\tgetMemberType( /*builder, name*/ ) {\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * This method is used during the build process of a node and ensures\n\t * equal nodes are not built multiple times but just once. For example if\n\t * `attribute( 'uv' )` is used multiple times by the user, the build\n\t * process makes sure to process just the first node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The shared node if possible. Otherwise `this` is returned.\n\t */\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\t/**\n\t * Returns the number of elements in the node array.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?number} The number of elements in the node array.\n\t */\n\tgetArrayCount( /*builder*/ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n\t * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.\n\t * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\t/**\n\t * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n\t * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?Node} output - The target output node.\n\t */\n\tanalyze( builder, output = null ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( this.parents === true ) {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this, 'any' );\n\t\t\tnodeData.stages = nodeData.stages || {};\n\t\t\tnodeData.stages[ builder.shaderStage ] = nodeData.stages[ builder.shaderStage ] || [];\n\t\t\tnodeData.stages[ builder.shaderStage ].push( output );\n\n\t\t}\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n\t * This state builds the output node and returns the resulting shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?string} output - Can be used to define the output type.\n\t * @return {?string} The generated shader string.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state before it is used to render an object.\n\t * The {@link Node#updateBeforeType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state after it was used to render an object.\n\t * The {@link Node#updateAfterType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state when it is used to render an object.\n\t * The {@link Node#updateType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * This method performs the build of a node. The behavior and return value depend on the current build stage:\n\t * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.\n\t * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.\n\t * - **generate**: Generates the shader code for the node. Returns the generated shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string|Node|null} [output=null] - Can be used to define the output type.\n\t * @return {Node|string|null} The result of the build process, depending on the build stage.\n\t */\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.buildStages = nodeData.buildStages || {};\n\t\tnodeData.buildStages[ builder.buildStage ] = true;\n\n\t\tconst parentBuildStage = _parentBuildStage[ builder.buildStage ];\n\n\t\tif ( parentBuildStage && nodeData.buildStages[ parentBuildStage ] !== true ) {\n\n\t\t\t// force parent build stage (setup or analyze)\n\n\t\t\tconst previousBuildStage = builder.getBuildStage();\n\n\t\t\tbuilder.setBuildStage( parentBuildStage );\n\n\t\t\tthis.build( builder );\n\n\t\t\tbuilder.setBuildStage( previousBuildStage );\n\n\t\t}\n\n\t\t//\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\t//const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.setup( builder ) || properties.outputNode || null;\n\n\t\t\t\t/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n\n\t\t\t\t\t// !! no outputNode !!\n\t\t\t\t\t//outputNode = builder.stack;\n\n\t\t\t\t}*/\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tif ( childNode.parents === true ) {\n\n\t\t\t\t\t\t\tconst childProperties = builder.getNodeProperties( childNode );\n\t\t\t\t\t\t\tchildProperties.parents = childProperties.parents || [];\n\t\t\t\t\t\t\tchildProperties.parents.push( this );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties.outputNode;\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tif ( nodeData.generated === undefined ) {\n\n\t\t\t\t\t\tnodeData.generated = true;\n\n\t\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.Node: Recursion detected.', this );\n\n\t\t\t\t\t\tresult = '/* Recursion detected. */';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the child nodes as a JSON object.\n\t *\n\t * @return {Array<Object>} An iterable list of serialized child objects as JSON.\n\t */\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\t/**\n\t * Serializes the node to JSON.\n\t *\n\t * @param {Object} json - The output JSON object.\n\t */\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deserializes the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON object.\n\t */\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the node into the three.js JSON Object/Scene format.\n\t *\n\t * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.7,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default Node;\n"],"mappings":"OAASA,mBAAsB,wBACtBC,gBAAiBC,YAAaC,SAAY,wBAE1CC,oBAAuB,uCACvBC,cAAiB,0BAE1B,MAAMC,kBAAoB,CACzBC,QAAS,QACTC,SAAU,WAGX,IAAIC,QAAU,EAOd,MAAMC,aAAaN,gBAElB,eAAWO,GAEV,MAAO,MAER,CAOA,WAAAC,CAAaC,EAAW,MAEvBC,QAQAC,KAAKF,SAAWA,EAQhBE,KAAKC,WAAahB,eAAeiB,KAQjCF,KAAKG,iBAAmBlB,eAAeiB,KAQvCF,KAAKI,gBAAkBnB,eAAeiB,KAQtCF,KAAKK,KAAOf,UAAUgB,eAStBN,KAAKO,QAAU,EAUfP,KAAKQ,QAAS,EAQdR,KAAKS,SAAU,EASfT,KAAKU,QAAS,EAWdV,KAAKW,UAAY,KASjBX,KAAKY,iBAAmB,EAExBC,OAAOC,eAAgBd,KAAM,KAAM,CAAEe,MAAOrB,WAE7C,CASA,eAAIsB,CAAaD,IAED,IAAVA,GAEJf,KAAKO,SAIP,CAQA,QAAIX,GAEH,OAAOI,KAAKH,YAAYD,IAEzB,CASA,QAAAqB,CAAUC,EAAUjB,GAKnB,OAHAD,KAAKC,WAAaA,EAClBD,KAAKmB,OAASD,EAASE,KAAMpB,KAAKqB,WAE3BrB,IAER,CASA,aAAAsB,CAAeJ,GAEd,OAAOlB,KAAKiB,SAAUC,EAAUjC,eAAesC,MAEhD,CASA,cAAAC,CAAgBN,GAEf,OAAOlB,KAAKiB,SAAUC,EAAUjC,eAAewC,OAEhD,CASA,cAAAC,CAAgBR,GAEf,OAAOlB,KAAKiB,SAAUC,EAAUjC,eAAe0C,OAEhD,CAQA,WAAAC,CAAaV,GAIZ,OAFAlB,KAAK6B,gBAAkBX,EAASE,KAAMpB,KAAKqB,WAEpCrB,IAER,CAQA,OAAAqB,GAIC,OAAOrB,KAAK8B,MAAQ9B,IAErB,CASA,eAAA6B,GAEC,OAAO7B,IAER,CAUA,QAAA+B,GAEC,OAAO/B,KAAKQ,MAEb,CAQA,YAAEwB,GAED,IAAM,MAAMC,UAAEA,KAAe/C,gBAAiBc,YAEvCiC,CAIR,CAMA,OAAAC,GAEClC,KAAKmC,cAAe,CAAEvC,KAAM,WAE7B,CAcA,QAAAwC,CAAUlB,GAETA,EAAUlB,MAEV,IAAM,MAAMiC,KAAajC,KAAKgC,cAE7BC,EAAUG,SAAUlB,EAItB,CAQA,WAAA/B,CAAakD,GAAQ,GAWpB,OAPe,KAFfA,EAAQA,GAASrC,KAAKO,UAAYP,KAAKY,mBAEG,OAAnBZ,KAAKW,YAE3BX,KAAKW,UAAYvB,KAAMD,YAAaa,KAAMqC,GAASrC,KAAKsC,kBACxDtC,KAAKY,iBAAmBZ,KAAKO,SAIvBP,KAAKW,SAEb,CAOA,cAAA2B,GAEC,OAAO,CAER,CAOA,QAAAC,GAEC,OAAOvC,IAER,CAUA,OAAAwC,GAEC,OAAOxC,KAAKK,IAEb,CAOA,aAAAoC,GAEC,OAAOzC,KAAKC,UAEb,CAOA,mBAAAyC,GAEC,OAAO1C,KAAKG,gBAEb,CAOA,kBAAAwC,GAEC,OAAO3C,KAAKI,eAEb,CAUA,cAAAwC,CAAgBC,GAEf,MAAMjD,EAAOI,KAAK8C,YAAaD,GAG/B,OAFoBA,EAAQD,eAAgBhD,EAI7C,CASA,aAAAmD,GAEC,MAAO,MAER,CAQA,WAAAD,CAAaD,GAEZ,MAAMG,EAAiBH,EAAQI,kBAAmBjD,MAElD,OAAKgD,EAAeE,WAEZF,EAAeE,WAAWJ,YAAaD,GAIxC7C,KAAKF,QAEb,CAWA,SAAAqD,CAAWN,GAEV,MAAMzD,EAAOY,KAAKwC,QAASK,GAG3B,OAFqBA,EAAQO,gBAAiBhE,IAEvBY,IAExB,CAQA,aAAAqD,GAEC,OAAO,IAER,CAUA,KAAAC,CAAOT,GAEN,MAAMG,EAAiBH,EAAQI,kBAAmBjD,MAElD,IAAIuD,EAAQ,EAEZ,IAAM,MAAMtB,KAAajC,KAAKgC,cAE7BgB,EAAgB,OAASO,KAAatB,EAMvC,OAAOe,EAAeE,YAAc,IAErC,CASA,OAAA1D,CAASqD,EAASW,EAAS,MAE1B,MAAMC,EAAaZ,EAAQa,cAAe1D,MAE1C,IAAsB,IAAjBA,KAAKS,QAAmB,CAE5B,MAAMkD,EAAWd,EAAQe,gBAAiB5D,KAAM,OAChD2D,EAASE,OAASF,EAASE,QAAU,CAAC,EACtCF,EAASE,OAAQhB,EAAQiB,aAAgBH,EAASE,OAAQhB,EAAQiB,cAAiB,GACnFH,EAASE,OAAQhB,EAAQiB,aAAcC,KAAMP,EAE9C,CAEA,GAAoB,IAAfC,EAAmB,CAIvB,MAAMT,EAAiBH,EAAQI,kBAAmBjD,MAElD,IAAM,MAAMiC,KAAapB,OAAOmD,OAAQhB,GAElCf,IAAkC,IAArBA,EAAUvB,QAE3BuB,EAAUgC,MAAOpB,EAAS7C,KAM7B,CAED,CAUA,QAAAP,CAAUoD,EAASW,GAElB,MAAMN,WAAEA,GAAeL,EAAQI,kBAAmBjD,MAElD,GAAKkD,IAAoC,IAAtBA,EAAWxC,OAE7B,OAAOwC,EAAWe,MAAOpB,EAASW,EAIpC,CAUA,YAAAU,GAECC,QAAQC,KAAM,qBAEf,CAUA,WAAAC,GAECF,QAAQC,KAAM,qBAEf,CAUA,MAAAjD,GAECgD,QAAQC,KAAM,qBAEf,CAYA,KAAAH,CAAOpB,EAASW,EAAS,MAExB,MAAMc,EAAUtE,KAAKmD,UAAWN,GAEhC,GAAK7C,OAASsE,EAEb,OAAOA,EAAQL,MAAOpB,EAASW,GAMhC,MAAMG,EAAWd,EAAQe,gBAAiB5D,MAC1C2D,EAASY,YAAcZ,EAASY,aAAe,CAAC,EAChDZ,EAASY,YAAa1B,EAAQ2B,aAAe,EAE7C,MAAMC,EAAmBlF,kBAAmBsD,EAAQ2B,YAEpD,GAAKC,IAAiE,IAA7Cd,EAASY,YAAaE,GAA8B,CAI5E,MAAMC,EAAqB7B,EAAQ8B,gBAEnC9B,EAAQ+B,cAAeH,GAEvBzE,KAAKiE,MAAOpB,GAEZA,EAAQ+B,cAAeF,EAExB,CAIA7B,EAAQgC,QAAS7E,MACjB6C,EAAQiC,SAAU9E,MAOlB,IAAI+E,EAAS,KAEb,MAAMP,EAAa3B,EAAQ8B,gBAE3B,GAAoB,UAAfH,EAAyB,CAE7BxE,KAAK6B,gBAAiBgB,GAEtB,MAAMmC,EAAanC,EAAQI,kBAAmBjD,MAE9C,IAAgC,IAA3BgF,EAAWC,YAAuB,CAItCD,EAAWC,aAAc,EACzBD,EAAW9B,WAAalD,KAAKsD,MAAOT,IAAamC,EAAW9B,YAAc,KAS1E,IAAM,MAAMjB,KAAapB,OAAOmD,OAAQgB,GAEvC,GAAK/C,IAAkC,IAArBA,EAAUvB,OAAkB,CAE7C,IAA2B,IAAtBuB,EAAUxB,QAAmB,CAEjC,MAAMyE,EAAkBrC,EAAQI,kBAAmBhB,GACnDiD,EAAgBzE,QAAUyE,EAAgBzE,SAAW,GACrDyE,EAAgBzE,QAAQsD,KAAM/D,KAE/B,CAEAiC,EAAUgC,MAAOpB,EAElB,CAIF,CAEAkC,EAASC,EAAW9B,UAErB,MAAO,GAAoB,YAAfsB,EAEXxE,KAAKR,QAASqD,EAASW,QAEjB,GAAoB,aAAfgB,EAA4B,CAIvC,GAFgD,IAAzBxE,KAAKP,SAAS0F,OAEf,CAErB,MAAMvF,EAAOI,KAAK8C,YAAaD,GACzBc,EAAWd,EAAQe,gBAAiB5D,MAE1C+E,EAASpB,EAASyB,aAEFC,IAAXN,OAEwBM,IAAvB1B,EAAS2B,WAEb3B,EAAS2B,WAAY,EAErBP,EAAS/E,KAAKP,SAAUoD,IAAa,GAErCc,EAASyB,QAAUL,IAInBZ,QAAQC,KAAM,kCAAmCpE,MAEjD+E,EAAS,kCAIwBM,IAAvB1B,EAAS4B,gBAAyDF,IAA9BxC,EAAQ2C,QAAQC,WAE/D5C,EAAQ6C,qBAAsB1F,KAAM6C,EAAQ2C,QAAQC,WAIrDV,EAASlC,EAAQ8C,OAAQZ,EAAQnF,EAAM4D,EAExC,MAECuB,EAAS/E,KAAKP,SAAUoD,EAASW,IAAY,EAI/C,CAKA,OAHAX,EAAQ+C,YAAa5F,MACrB6C,EAAQgD,kBAAmB7F,MAEpB+E,CAER,CAOA,oBAAAe,GAEC,OAAO5G,gBAAiBc,KAEzB,CAOA,SAAA+F,CAAWC,GAEV,MAAMC,EAAejG,KAAK8F,uBAEpBI,EAAa,CAAC,EAEpB,IAAM,MAAMC,SAAEA,EAAQ5C,MAAEA,EAAKtB,UAAEA,KAAegE,OAE9BZ,IAAV9B,QAE4B8B,IAA3Ba,EAAYC,KAEhBD,EAAYC,GAAaC,OAAOC,UAAW9C,GAAU,GAAK,CAAC,GAI5D2C,EAAYC,GAAY5C,GAAUtB,EAAUqE,OAAQN,EAAKO,MAAOlG,MAIhE6F,EAAYC,GAAalE,EAAUqE,OAAQN,EAAKO,MAAOlG,KAMpDQ,OAAO2F,KAAMN,GAAaf,OAAS,IAEvCa,EAAKE,WAAaA,EAIpB,CAOA,WAAAO,CAAaT,GAEZ,QAAyBX,IAApBW,EAAKE,WAA2B,CAEpC,MAAMQ,EAAQV,EAAKO,KAAKG,MAExB,IAAM,MAAMP,KAAYH,EAAKE,WAE5B,GAAKS,MAAMC,QAASZ,EAAKE,WAAYC,IAAe,CAEnD,MAAMU,EAAa,GAEnB,IAAM,MAAMxG,KAAQ2F,EAAKE,WAAYC,GAEpCU,EAAW9C,KAAM2C,EAAOrG,IAIzBL,KAAMmG,GAAaU,CAEpB,MAAO,GAA4C,iBAAhCb,EAAKE,WAAYC,GAA0B,CAE7D,MAAMW,EAAc,CAAC,EAErB,IAAM,MAAMC,KAAef,EAAKE,WAAYC,GAAa,CAExD,MAAM9F,EAAO2F,EAAKE,WAAYC,GAAYY,GAE1CD,EAAaC,GAAgBL,EAAOrG,EAErC,CAEAL,KAAMmG,GAAaW,CAEpB,KAAO,CAEN,MAAMzG,EAAO2F,EAAKE,WAAYC,GAE9BnG,KAAMmG,GAAaO,EAAOrG,EAE3B,CAIF,CAED,CAQA,MAAAiG,CAAQC,GAEP,MAAMlG,KAAEA,EAAIT,KAAEA,GAASI,KACjBgH,OAAoB3B,IAATkB,GAAsC,iBAATA,EAEzCS,IAEJT,EAAO,CACNU,SAAU,CAAC,EACXC,OAAQ,CAAC,EACTR,MAAO,CAAC,IAOV,IAAIS,EAAOZ,EAAKG,MAAOrG,GAyBvB,SAAS+G,EAAkBC,GAE1B,MAAMrD,EAAS,GAEf,IAAM,MAAMsD,KAAOD,EAAQ,CAE1B,MAAMF,EAAOE,EAAOC,UACbH,EAAKI,SACZvD,EAAOD,KAAMoD,EAEd,CAEA,OAAOnD,CAER,CAEA,QAvCcqB,IAAT8B,IAEJA,EAAO,CACN9G,OACAT,OACA2G,OACAgB,SAAU,CACThH,QAAS,IACTX,KAAM,OACN4H,UAAW,iBAIG,IAAXR,IAAkBT,EAAKG,MAAOS,EAAK9G,MAAS8G,GAEjDnH,KAAK+F,UAAWoB,UAETA,EAAKZ,MAsBRS,EAAS,CAEb,MAAMC,EAAWG,EAAkBb,EAAKU,UAClCC,EAASE,EAAkBb,EAAKW,QAChCR,EAAQU,EAAkBb,EAAKG,OAEhCO,EAAS9B,OAAS,IAAIgC,EAAKF,SAAWA,GACtCC,EAAO/B,OAAS,IAAIgC,EAAKD,OAASA,GAClCR,EAAMvB,OAAS,IAAIgC,EAAKT,MAAQA,EAEtC,CAEA,OAAOS,CAER,iBAIcxH","ignoreList":[]}