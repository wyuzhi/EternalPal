import NodeUniform from"./NodeUniform.js";import NodeAttribute from"./NodeAttribute.js";import NodeVarying from"./NodeVarying.js";import NodeVar from"./NodeVar.js";import NodeCode from"./NodeCode.js";import NodeCache from"./NodeCache.js";import ParameterNode from"./ParameterNode.js";import StructType from"./StructType.js";import FunctionNode from"../code/FunctionNode.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{getTypeFromLength}from"./NodeUtils.js";import{NodeUpdateType,defaultBuildStages,shaderStages}from"./constants.js";import{NumberNodeUniform,Vector2NodeUniform,Vector3NodeUniform,Vector4NodeUniform,ColorNodeUniform,Matrix2NodeUniform,Matrix3NodeUniform,Matrix4NodeUniform}from"../../renderers/common/nodes/NodeUniform.js";import{stack}from"./StackNode.js";import{getCurrentStack,setCurrentStack}from"../tsl/TSLBase.js";import CubeRenderTarget from"../../renderers/common/CubeRenderTarget.js";import ChainMap from"../../renderers/common/ChainMap.js";import BindGroup from"../../renderers/common/BindGroup.js";import{REVISION,IntType,UnsignedIntType,LinearFilter,LinearMipmapNearestFilter,NearestMipmapLinearFilter,LinearMipmapLinearFilter}from"../../constants.js";import{RenderTarget}from"../../core/RenderTarget.js";import{Color}from"../../math/Color.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";import{Float16BufferAttribute}from"../../core/BufferAttribute.js";const rendererCache=new WeakMap,typeFromArray=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),toFloat=t=>/e/g.test(t)?String(t).replace(/\+/g,""):(t=Number(t))+(t%1?"":".0");class NodeBuilder{constructor(t,e,r){this.object=t,this.material=t&&t.material||null,this.geometry=t&&t.geometry||null,this.renderer=e,this.parser=r,this.scene=null,this.camera=null,this.nodes=[],this.sequentialNodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.observer=null,this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.declarations={},this.flow={code:""},this.chaining=[],this.stack=stack(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={material:this.material},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null,this.subBuildLayers=[],this.currentStack=null,this.subBuildFn=null}getBindGroupsCache(){let t=rendererCache.get(this.renderer);return void 0===t&&(t=new ChainMap,rendererCache.set(this.renderer,t)),t}createRenderTarget(t,e,r){return new RenderTarget(t,e,r)}createCubeRenderTarget(t,e){return new CubeRenderTarget(t,e)}includes(t){return this.nodes.includes(t)}getOutputStructName(){}_getBindGroup(t,e){const r=this.getBindGroupsCache(),i=[];let o,s=!0;for(const t of e)i.push(t),s=s&&!0!==t.groupNode.shared;return s?(o=r.get(i),void 0===o&&(o=new BindGroup(t,i,this.bindingsIndexes[t].group,i),r.set(i,o))):o=new BindGroup(t,i,this.bindingsIndexes[t].group,i),o}getBindGroupArray(t,e){const r=this.bindings[e];let i=r[t];return void 0===i&&(void 0===this.bindingsIndexes[t]&&(this.bindingsIndexes[t]={binding:0,group:Object.keys(this.bindingsIndexes).length}),r[t]=i=[]),i}getBindings(){let t=this.bindGroups;if(null===t){const e={},r=this.bindings;for(const t of shaderStages)for(const i in r[t]){const o=r[t][i];(e[i]||(e[i]=[])).push(...o)}t=[];for(const r in e){const i=e[r],o=this._getBindGroup(r,i);t.push(o)}this.bindGroups=t}return t}sortBindingGroups(){const t=this.getBindings();t.sort(((t,e)=>t.bindings[0].groupNode.order-e.bindings[0].groupNode.order));for(let e=0;e<t.length;e++){const r=t[e];this.bindingsIndexes[r.name].group=e,r.index=e}}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){!1===this.nodes.includes(t)&&(this.nodes.push(t),this.setHashNode(t,t.getHash(this)))}addSequentialNode(t){!1===this.sequentialNodes.includes(t)&&this.sequentialNodes.push(t)}buildUpdateNodes(){for(const t of this.nodes){t.getUpdateType()!==NodeUpdateType.NONE&&this.updateNodes.push(t.getSelf())}for(const t of this.sequentialNodes){const e=t.getUpdateBeforeType(),r=t.getUpdateAfterType();e!==NodeUpdateType.NONE&&this.updateBeforeNodes.push(t.getSelf()),r!==NodeUpdateType.NONE&&this.updateAfterNodes.push(t.getSelf())}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(t){return t.magFilter===LinearFilter||t.magFilter===LinearMipmapNearestFilter||t.magFilter===NearestMipmapLinearFilter||t.magFilter===LinearMipmapLinearFilter||t.minFilter===LinearFilter||t.minFilter===LinearMipmapNearestFilter||t.minFilter===NearestMipmapLinearFilter||t.minFilter===LinearMipmapLinearFilter}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}getSharedContext(){return delete{...this.context}.material,this.context}setCache(t){this.cache=t}getCache(){return this.cache}getCacheFromNode(t,e=!0){const r=this.getDataFromNode(t);return void 0===r.cache&&(r.cache=new NodeCache(e?this.getCache():null)),r.cache}isAvailable(){return!1}getVertexIndex(){console.warn("Abstract function.")}getInstanceIndex(){console.warn("Abstract function.")}getDrawIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}increaseUsage(t){const e=this.getDataFromNode(t);return e.usageCount=void 0===e.usageCount?1:e.usageCount+1,e.usageCount}generateTexture(){console.warn("Abstract function.")}generateTextureLod(){console.warn("Abstract function.")}generateArrayDeclaration(t,e){return this.getType(t)+"[ "+e+" ]"}generateArray(t,e,r=null){let i=this.generateArrayDeclaration(t,e)+"( ";for(let o=0;o<e;o++){const s=r?r[o]:null;i+=null!==s?s.build(this,t):this.generateConst(t),o<e-1&&(i+=", ")}return i+=" )",i}generateStruct(t,e,r=null){const i=[];for(const t of e){const{name:e,type:o}=t;r&&r[e]&&r[e].isNode?i.push(r[e].build(this,o)):i.push(this.generateConst(o))}return t+"( "+i.join(", ")+" )"}generateConst(t,e=null){if(null===e&&("float"===t||"int"===t||"uint"===t?e=0:"bool"===t?e=!1:"color"===t?e=new Color:"vec2"===t?e=new Vector2:"vec3"===t?e=new Vector3:"vec4"===t&&(e=new Vector4)),"float"===t)return toFloat(e);if("int"===t)return`${Math.round(e)}`;if("uint"===t)return e>=0?`${Math.round(e)}u`:"0u";if("bool"===t)return e?"true":"false";if("color"===t)return`${this.getType("vec3")}( ${toFloat(e.r)}, ${toFloat(e.g)}, ${toFloat(e.b)} )`;const r=this.getTypeLength(t),i=this.getComponentType(t),o=t=>this.generateConst(i,t);if(2===r)return`${this.getType(t)}( ${o(e.x)}, ${o(e.y)} )`;if(3===r)return`${this.getType(t)}( ${o(e.x)}, ${o(e.y)}, ${o(e.z)} )`;if(4===r&&"mat2"!==t)return`${this.getType(t)}( ${o(e.x)}, ${o(e.y)}, ${o(e.z)}, ${o(e.w)} )`;if(r>=4&&e&&(e.isMatrix2||e.isMatrix3||e.isMatrix4))return`${this.getType(t)}( ${e.elements.map(o).join(", ")} )`;if(r>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return"color"===t?"vec3":t}hasGeometryAttribute(t){return this.geometry&&void 0!==this.geometry.getAttribute(t)}getAttribute(t,e){const r=this.attributes;for(const e of r)if(e.name===t)return e;const i=new NodeAttribute(t,e);return this.registerDeclaration(i),r.push(i),i}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return"void"===t||"property"===t||"sampler"===t||"samplerComparison"===t||"texture"===t||"cubeTexture"===t||"storageTexture"===t||"depthTexture"===t||"texture3D"===t}needsToWorkingColorSpace(){return!1}getComponentTypeFromTexture(t){const e=t.type;if(t.isDataTexture){if(e===IntType)return"int";if(e===UnsignedIntType)return"uint"}return"float"}getElementType(t){return"mat2"===t?"vec2":"mat3"===t?"vec3":"mat4"===t?"vec4":this.getComponentType(t)}getComponentType(t){if("float"===(t=this.getVectorType(t))||"bool"===t||"int"===t||"uint"===t)return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return null===e?null:"b"===e[1]?"bool":"i"===e[1]?"int":"u"===e[1]?"uint":"float"}getVectorType(t){return"color"===t?"vec3":"texture"===t||"cubeTexture"===t||"storageTexture"===t||"texture3D"===t?"vec4":t}getTypeFromLength(t,e="float"){if(1===t)return e;let r=getTypeFromLength(t);const i="float"===e?"":e[0];return!0===/mat2/.test(e)&&(r=r.replace("vec","mat")),i+r}getTypeFromArray(t){return typeFromArray.get(t.constructor)}isInteger(t){return/int|uint|(i|u)vec/.test(t)}getTypeFromAttribute(t){let e=t;t.isInterleavedBufferAttribute&&(e=t.data);const r=e.array,i=t.itemSize,o=t.normalized;let s;return t instanceof Float16BufferAttribute||!0===o||(s=this.getTypeFromArray(r)),this.getTypeFromLength(i,s)}getTypeLength(t){const e=this.getVectorType(t),r=/vec([2-4])/.exec(e);return null!==r?Number(r[1]):"float"===e||"bool"===e||"int"===e||"uint"===e?1:!0===/mat2/.test(t)?4:!0===/mat3/.test(t)?9:!0===/mat4/.test(t)?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return"int"===e||"uint"===e?t:this.changeComponentType(t,"int")}addStack(){return this.stack=stack(this.stack),this.stacks.push(getCurrentStack()||this.stack),setCurrentStack(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,setCurrentStack(this.stacks.pop()),t}getDataFromNode(t,e=this.shaderStage,r=null){let i=(r=null===r?t.isGlobal(this)?this.globalCache:this.cache:r).getData(t);void 0===i&&(i={},r.setData(t,i)),void 0===i[e]&&(i[e]={});let o=i[e];const s=i.any?i.any.subBuilds:null,n=this.getClosestSubBuild(s);return n&&(void 0===o.subBuildsCache&&(o.subBuildsCache={}),o=o.subBuildsCache[n]||(o.subBuildsCache[n]={}),o.subBuilds=s),o}getNodeProperties(t,e="any"){const r=this.getDataFromNode(t,e);return r.properties||(r.properties={outputNode:null})}getBufferAttributeFromNode(t,e){const r=this.getDataFromNode(t);let i=r.bufferAttribute;if(void 0===i){const o=this.uniforms.index++;i=new NodeAttribute("nodeAttribute"+o,e,t),this.bufferAttributes.push(i),r.bufferAttribute=i}return i}getStructTypeFromNode(t,e,r=null,i=this.shaderStage){const o=this.getDataFromNode(t,i,this.globalCache);let s=o.structType;if(void 0===s){const t=this.structs.index++;null===r&&(r="StructType"+t),s=new StructType(r,e),this.structs[i].push(s),o.structType=s}return s}getOutputStructTypeFromNode(t,e){const r=this.getStructTypeFromNode(t,e,"OutputType","fragment");return r.output=!0,r}getUniformFromNode(t,e,r=this.shaderStage,i=null){const o=this.getDataFromNode(t,r,this.globalCache);let s=o.uniform;if(void 0===s){const n=this.uniforms.index++;s=new NodeUniform(i||"nodeUniform"+n,e,t),this.uniforms[r].push(s),this.registerDeclaration(s),o.uniform=s}return s}getVarFromNode(t,e=null,r=t.getNodeType(this),i=this.shaderStage,o=!1){const s=this.getDataFromNode(t,i),n=this.getSubBuildProperty("variable",s.subBuilds);let a=s[n];if(void 0===a){const u=o?"_const":"_var",d=this.vars[i]||(this.vars[i]=[]),l=this.vars[u]||(this.vars[u]=0);null===e&&(e=(o?"nodeConst":"nodeVar")+l,this.vars[u]++),"variable"!==n&&(e=this.getSubBuildProperty(e,s.subBuilds));const h=t.getArrayCount(this);a=new NodeVar(e,r,o,h),o||d.push(a),this.registerDeclaration(a),s[n]=a}return a}isDeterministic(t){if(t.isMathNode)return this.isDeterministic(t.aNode)&&(!t.bNode||this.isDeterministic(t.bNode))&&(!t.cNode||this.isDeterministic(t.cNode));if(t.isOperatorNode)return this.isDeterministic(t.aNode)&&(!t.bNode||this.isDeterministic(t.bNode));if(t.isArrayNode){if(null!==t.values)for(const e of t.values)if(!this.isDeterministic(e))return!1;return!0}return!!t.isConstNode}getVaryingFromNode(t,e=null,r=t.getNodeType(this),i=null,o=null){const s=this.getDataFromNode(t,"any"),n=this.getSubBuildProperty("varying",s.subBuilds);let a=s[n];if(void 0===a){const t=this.varyings,u=t.length;null===e&&(e="nodeVarying"+u),"varying"!==n&&(e=this.getSubBuildProperty(e,s.subBuilds)),a=new NodeVarying(e,r,i,o),t.push(a),this.registerDeclaration(a),s[n]=a}return a}registerDeclaration(t){const e=this.shaderStage,r=this.declarations[e]||(this.declarations[e]={}),i=this.getPropertyName(t);let o=1,s=i;for(;void 0!==r[s];)s=i+"_"+o++;o>1&&(t.name=s,console.warn(`THREE.TSL: Declaration name '${i}' of '${t.type}' already in use. Renamed to '${s}'.`)),r[s]=t}getCodeFromNode(t,e,r=this.shaderStage){const i=this.getDataFromNode(t);let o=i.code;if(void 0===o){const t=this.codes[r]||(this.codes[r]=[]),s=t.length;o=new NodeCode("nodeCode"+s,e),t.push(o),i.code=o}return o}addFlowCodeHierarchy(t,e){const{flowCodes:r,flowCodeBlock:i}=this.getDataFromNode(t);let o=!0,s=e;for(;s;){if(!0===i.get(s)){o=!1;break}s=this.getDataFromNode(s).parentNodeBlock}if(o)for(const t of r)this.addLineFlowCode(t)}addLineFlowCodeBlock(t,e,r){const i=this.getDataFromNode(t),o=i.flowCodes||(i.flowCodes=[]),s=i.flowCodeBlock||(i.flowCodeBlock=new WeakMap);o.push(e),s.set(r,!0)}addLineFlowCode(t,e=null){return""===t||(null!==e&&this.context.nodeBlock&&this.addLineFlowCodeBlock(e,t,this.context.nodeBlock),t=this.tab+t,/;\s*$/.test(t)||(t+=";\n"),this.flow.code+=t),this}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),r=this.flowChildNode(t,e);return this.flowsData.set(t,r),r}addInclude(t){null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(t)}buildFunctionNode(t){const e=new FunctionNode,r=this.currentFunctionNode;return this.currentFunctionNode=e,e.code=this.buildFunctionCode(t),this.currentFunctionNode=r,e}flowShaderNode(t){const e=t.layout,r={[Symbol.iterator](){let t=0;const e=Object.values(this);return{next:()=>({value:e[t],done:t++>=e.length})}}};for(const t of e.inputs)r[t.name]=new ParameterNode(t.type,t.name);t.layout=null;const i=t.call(r),o=this.flowStagesNode(i,e.type);return t.layout=e,o}flowBuildStage(t,e,r=null){const i=this.getBuildStage();this.setBuildStage(e);const o=t.build(this,r);return this.setBuildStage(i),o}flowStagesNode(t,e=null){const r=this.flow,i=this.vars,o=this.declarations,s=this.cache,n=this.buildStage,a=this.stack,u={code:""};this.flow=u,this.vars={},this.declarations={},this.cache=new NodeCache,this.stack=stack();for(const r of defaultBuildStages)this.setBuildStage(r),u.result=t.build(this,e);return u.vars=this.getVars(this.shaderStage),this.flow=r,this.vars=i,this.declarations=o,this.cache=s,this.stack=a,this.setBuildStage(n),u}getFunctionOperator(){return null}buildFunctionCode(){console.warn("Abstract function.")}flowChildNode(t,e=null){const r=this.flow,i={code:""};return this.flow=i,i.result=t.build(this,e),this.flow=r,i}flowNodeFromShaderStage(t,e,r=null,i=null){const o=this.tab,s=this.cache,n=this.shaderStage,a=this.context;this.setShaderStage(t);const u={...this.context};delete u.nodeBlock,this.cache=this.globalCache,this.tab="\t",this.context=u;let d=null;if("generate"===this.buildStage){const o=this.flowChildNode(e,r);null!==i&&(o.code+=`${this.tab+i} = ${o.result};\n`),this.flowCode[t]=this.flowCode[t]+o.code,d=o}else d=e.build(this);return this.setShaderStage(n),this.cache=s,this.tab=o,this.context=a,d}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVar(t,e,r=null){return`${null!==r?this.generateArrayDeclaration(t,r):this.getType(t)} ${e}`}getVars(t){let e="";const r=this.vars[t];if(void 0!==r)for(const t of r)e+=`${this.getVar(t.type,t.name)}; `;return e}getUniforms(){console.warn("Abstract function.")}getCodes(t){const e=this.codes[t];let r="";if(void 0!==e)for(const t of e)r+=t.code+"\n";return r}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}get subBuild(){return this.subBuildLayers[this.subBuildLayers.length-1]||null}addSubBuild(t){this.subBuildLayers.push(t)}removeSubBuild(){return this.subBuildLayers.pop()}getClosestSubBuild(t){let e;if(e=t&&t.isNode?t.isShaderCallNodeInternal?t.shaderNode.subBuilds:t.isStackNode?[t.subBuild]:this.getDataFromNode(t,"any").subBuilds:t instanceof Set?[...t]:t,!e)return null;const r=this.subBuildLayers;for(let t=e.length-1;t>=0;t--){const i=e[t];if(r.includes(i))return i}return null}getSubBuildOutput(t){return this.getSubBuildProperty("outputNode",t)}getSubBuildProperty(t="",e=null){let r,i;return r=null!==e?this.getClosestSubBuild(e):this.subBuildFn,i=r?t?r+"_"+t:r:t,i}build(){const{object:t,material:e,renderer:r}=this;if(null!==e){let t=r.library.fromMaterial(e);null===t&&(console.error(`NodeMaterial: Material "${e.type}" is not compatible.`),t=new NodeMaterial),t.build(this)}else this.addFlow("compute",t);for(const t of defaultBuildStages){this.setBuildStage(t),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const e of shaderStages){this.setShaderStage(e);const r=this.flowNodes[e];for(const e of r)"generate"===t?this.flowNode(e):e.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(t,e){if("float"===e||"int"===e||"uint"===e)return new NumberNodeUniform(t);if("vec2"===e||"ivec2"===e||"uvec2"===e)return new Vector2NodeUniform(t);if("vec3"===e||"ivec3"===e||"uvec3"===e)return new Vector3NodeUniform(t);if("vec4"===e||"ivec4"===e||"uvec4"===e)return new Vector4NodeUniform(t);if("color"===e)return new ColorNodeUniform(t);if("mat2"===e)return new Matrix2NodeUniform(t);if("mat3"===e)return new Matrix3NodeUniform(t);if("mat4"===e)return new Matrix4NodeUniform(t);throw new Error(`Uniform "${e}" not declared.`)}format(t,e,r){if((e=this.getVectorType(e))===(r=this.getVectorType(r))||null===r||this.isReference(r))return t;const i=this.getTypeLength(e),o=this.getTypeLength(r);return 16===i&&9===o?`${this.getType(r)}( ${t}[ 0 ].xyz, ${t}[ 1 ].xyz, ${t}[ 2 ].xyz )`:9===i&&4===o?`${this.getType(r)}( ${t}[ 0 ].xy, ${t}[ 1 ].xy )`:i>4||o>4||0===o?t:i===o?`${this.getType(r)}( ${t} )`:i>o?(t="bool"===r?`all( ${t} )`:`${t}.${"xyz".slice(0,o)}`,this.format(t,this.getTypeFromLength(o,this.getComponentType(e)),r)):4===o&&i>1?`${this.getType(r)}( ${this.format(t,e,"vec3")}, 1.0 )`:2===i?`${this.getType(r)}( ${this.format(t,e,"vec2")}, 0.0 )`:(1===i&&o>1&&e!==this.getComponentType(r)&&(t=`${this.getType(this.getComponentType(r))}( ${t} )`),`${this.getType(r)}( ${t} )`)}getSignature(){return`// Three.js r${REVISION} - Node System\n`}*[Symbol.iterator](){}}export default NodeBuilder;
//# sourceMappingURL=NodeBuilder.js.map