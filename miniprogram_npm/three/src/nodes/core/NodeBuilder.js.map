{"version":3,"file":"node_modules/three/src/nodes/core/NodeBuilder.js","names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeCache","ParameterNode","StructType","FunctionNode","NodeMaterial","getTypeFromLength","NodeUpdateType","defaultBuildStages","shaderStages","NumberNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix2NodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","stack","getCurrentStack","setCurrentStack","CubeRenderTarget","ChainMap","BindGroup","REVISION","IntType","UnsignedIntType","LinearFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","RenderTarget","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","rendererCache","WeakMap","typeFromArray","Map","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","toFloat","value","test","String","replace","Number","NodeBuilder","constructor","object","renderer","parser","this","material","geometry","scene","camera","nodes","sequentialNodes","updateNodes","updateBeforeNodes","updateAfterNodes","hashNodes","observer","lightsNode","environmentNode","fogNode","clippingContext","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","bindings","bindingsIndexes","bindGroups","attributes","bufferAttributes","varyings","codes","vars","declarations","flow","code","chaining","stacks","tab","currentFunctionNode","context","cache","globalCache","flowsData","shaderStage","buildStage","subBuildLayers","currentStack","subBuildFn","getBindGroupsCache","bindGroupsCache","get","undefined","set","createRenderTarget","width","height","options","createCubeRenderTarget","size","includes","node","getOutputStructName","_getBindGroup","groupName","bindingsArray","bindGroup","sharedGroup","binding","push","groupNode","shared","group","getBindGroupArray","Object","keys","length","getBindings","bindingsGroups","groups","bindingsGroup","sortBindingGroups","sort","a","b","order","i","bindingGroup","name","setHashNode","hash","addNode","getHash","addSequentialNode","buildUpdateNodes","getUpdateType","NONE","getSelf","updateBeforeType","getUpdateBeforeType","updateAfterType","getUpdateAfterType","currentNode","isFilteredTexture","texture","magFilter","minFilter","addChain","removeChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","getSharedContext","setCache","getCache","getCacheFromNode","parent","data","getDataFromNode","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getDrawIndex","getFrontFacing","getFragCoord","isFlipY","increaseUsage","nodeData","usageCount","generateTexture","generateTextureLod","generateArrayDeclaration","type","count","getType","generateArray","values","snippet","build","generateConst","generateStruct","membersLayout","snippets","member","isNode","join","Math","round","r","g","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix2","isMatrix3","isMatrix4","elements","map","hasGeometryAttribute","getAttribute","attribute","registerDeclaration","getPropertyName","isVector","isMatrix","isReference","needsToWorkingColorSpace","getComponentTypeFromTexture","isDataTexture","getElementType","getVectorType","exec","baseType","prefix","getTypeFromArray","array","isInteger","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","itemSize","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","lastStack","isGlobal","getData","setData","subBuilds","any","subBuild","getClosestSubBuild","subBuildsCache","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","structType","getOutputStructTypeFromNode","output","getUniformFromNode","nodeUniform","uniform","getVarFromNode","getNodeType","readOnly","subBuildVariable","getSubBuildProperty","nodeVar","idNS","id","getArrayCount","isDeterministic","isMathNode","aNode","bNode","cNode","isOperatorNode","isArrayNode","n","isConstNode","getVaryingFromNode","interpolationType","interpolationSampling","subBuildVarying","nodeVarying","property","getCodeFromNode","nodeCode","addFlowCodeHierarchy","nodeBlock","flowCodes","flowCodeBlock","needsFlowCode","nodeBlockHierarchy","parentNodeBlock","addLineFlowCode","addLineFlowCodeBlock","codeBlock","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","flowData","flowChildNode","addInclude","buildFunctionNode","shaderNode","fn","previous","buildFunctionCode","flowShaderNode","layout","inputs","Symbol","iterator","next","done","input","callNode","call","flowStagesNode","flowBuildStage","previousBuildStage","getBuildStage","setBuildStage","result","previousFlow","previousVars","previousDeclarations","previousCache","previousStack","getVars","getFunctionOperator","flowNodeFromShaderStage","propertyName","previousTab","previousShaderStage","previousContext","setShaderStage","getAttributesArray","concat","getAttributes","getVaryings","getVar","variable","getUniforms","getCodes","getShaderStage","buildCode","addSubBuild","removeSubBuild","isShaderCallNodeInternal","isStackNode","Set","getSubBuildOutput","nodeMaterial","library","fromMaterial","error","getNodeUniform","uniformNode","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["node_modules/three/src/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport StructType from './StructType.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport NodeMaterial from '../../materials/nodes/NodeMaterial.js';\nimport { getTypeFromLength } from './NodeUtils.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tNumberNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix2NodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\n\nimport BindGroup from '../../renderers/common/BindGroup.js';\n\nimport { REVISION, IntType, UnsignedIntType, LinearFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, LinearMipmapLinearFilter } from '../../constants.js';\nimport { RenderTarget } from '../../core/RenderTarget.js';\nimport { Color } from '../../math/Color.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Float16BufferAttribute } from '../../core/BufferAttribute.js';\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\n/**\n * Base class for builders which generate a shader program based\n * on a 3D object and its node material definition.\n */\nclass NodeBuilder {\n\n\t/**\n\t * Constructs a new node builder.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The current renderer.\n\t * @param {NodeParser} parser - A reference to a node parser.\n\t */\n\tconstructor( object, renderer, parser ) {\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The material of the 3D object.\n\t\t *\n\t\t * @type {?Material}\n\t\t */\n\t\tthis.material = ( object && object.material ) || null;\n\n\t\t/**\n\t\t * The geometry of the 3D object.\n\t\t *\n\t\t * @type {?BufferGeometry}\n\t\t */\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\n\t\t/**\n\t\t * The current renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A reference to a node parser.\n\t\t *\n\t\t * @type {NodeParser}\n\t\t */\n\t\tthis.parser = parser;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t\t/**\n\t\t * The camera the 3D object is rendered with.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A list of all nodes the builder is processing\n\t\t * for this 3D object.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * A list of all sequential nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.sequentialNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#update} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateBefore} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateAfter} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = [];\n\n\t\t/**\n\t\t * A dictionary that assigns each node to a unique hash.\n\t\t *\n\t\t * @type {Object<number,Node>}\n\t\t */\n\t\tthis.hashNodes = {};\n\n\t\t/**\n\t\t * A reference to a node material observer.\n\t\t *\n\t\t * @type {?NodeMaterialObserver}\n\t\t * @default null\n\t\t */\n\t\tthis.observer = null;\n\n\t\t/**\n\t\t * A reference to the current lights node.\n\t\t *\n\t\t * @type {?LightsNode}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * A reference to the current environment node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.environmentNode = null;\n\n\t\t/**\n\t\t * A reference to the current fog node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.fogNode = null;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {?ClippingContext}\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * The generated vertex shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.vertexShader = null;\n\n\t\t/**\n\t\t * The generated fragment shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.fragmentShader = null;\n\n\t\t/**\n\t\t * The generated compute shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.computeShader = null;\n\n\t\t/**\n\t\t * Nodes used in the primary flow of code generation.\n\t\t *\n\t\t * @type {Object<string,Array<Node>>}\n\t\t */\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Nodes code from `.flowNodes`.\n\t\t *\n\t\t * @type {Object<string,string>}\n\t\t */\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\n\t\t/**\n\t\t * This dictionary holds the node uniforms of the builder.\n\t\t * The uniforms are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the output structs of the builder.\n\t\t * The structs are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the bindings for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t/**\n\t\t * This dictionary maintains the binding indices per bind group.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindingsIndexes = {};\n\n\t\t/**\n\t\t * Reference to the array of bind groups.\n\t\t *\n\t\t * @type {?Array<BindGroup>}\n\t\t */\n\t\tthis.bindGroups = null;\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link AttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.attributes = [];\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link BufferAttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.bufferAttributes = [];\n\n\t\t/**\n\t\t * This array holds the node varyings of this builder.\n\t\t *\n\t\t * @type {Array<NodeVarying>}\n\t\t */\n\t\tthis.varyings = [];\n\n\t\t/**\n\t\t * This dictionary holds the (native) node codes of this builder.\n\t\t * The codes are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<string,Array<NodeCode>>}\n\t\t */\n\t\tthis.codes = {};\n\n\t\t/**\n\t\t * This dictionary holds the node variables of this builder.\n\t\t * The variables are maintained in an array for each shader stage.\n\t\t * This dictionary is also used to count the number of variables\n\t\t * according to their type (const, vars).\n\t\t *\n\t\t * @type {Object<string,Array<NodeVar>|number>}\n\t\t */\n\t\tthis.vars = {};\n\n\t\t/**\n\t\t * This dictionary holds the declarations for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.declarations = {};\n\n\t\t/**\n\t\t * Current code flow.\n\t\t * All code generated in this stack will be stored in `.flow`.\n\t\t *\n\t\t * @type {{code: string}}\n\t\t */\n\t\tthis.flow = { code: '' };\n\n\t\t/**\n\t\t * A chain of nodes.\n\t\t * Used to check recursive calls in node-graph.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.chaining = [];\n\n\t\t/**\n\t\t * The current stack.\n\t\t * This reflects the current process in the code block hierarchy,\n\t\t * it is useful to know if the current process is inside a conditional for example.\n\t\t *\n\t\t * @type {StackNode}\n\t\t */\n\t\tthis.stack = stack();\n\n\t\t/**\n\t\t * List of stack nodes.\n\t\t * The current stack hierarchy is stored in an array.\n\t\t *\n\t\t * @type {Array<StackNode>}\n\t\t */\n\t\tthis.stacks = [];\n\n\t\t/**\n\t\t * A tab value. Used for shader string generation.\n\t\t *\n\t\t * @type {string}\n\t\t * @default '\\t'\n\t\t */\n\t\tthis.tab = '\\t';\n\n\t\t/**\n\t\t * Reference to the current function node.\n\t\t *\n\t\t * @type {?FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.currentFunctionNode = null;\n\n\t\t/**\n\t\t * The builder's context.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\t/**\n\t\t * The builder's cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t */\n\t\tthis.cache = new NodeCache();\n\n\t\t/**\n\t\t * Since the {@link NodeBuilder#cache} might be temporarily\n\t\t * overwritten by other caches, this member retains the reference\n\t\t * to the builder's own cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t * @default this.cache\n\t\t */\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\t/**\n\t\t * The current shader stage.\n\t\t *\n\t\t * @type {?('vertex'|'fragment'|'compute'|'any')}\n\t\t */\n\t\tthis.shaderStage = null;\n\n\t\t/**\n\t\t * The current build stage.\n\t\t *\n\t\t * @type {?('setup'|'analyze'|'generate')}\n\t\t */\n\t\tthis.buildStage = null;\n\n\t\t/**\n\t\t * The sub-build layers.\n\t\t *\n\t\t * @type {Array<SubBuildNode>}\n\t\t * @default []\n\t\t */\n\t\tthis.subBuildLayers = [];\n\n\t\t/**\n\t\t * The current stack of nodes.\n\t\t *\n\t\t * @type {?StackNode}\n\t\t * @default null\n\t\t */\n\t\tthis.currentStack = null;\n\n\t\t/**\n\t\t * The current sub-build TSL function(Fn).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.subBuildFn = null;\n\n\t}\n\n\t/**\n\t * Returns the bind groups of the current renderer.\n\t *\n\t * @return {ChainMap} The cache.\n\t */\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link RenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {number} width - The width of the render target.\n\t * @param {number} height - The height of the render target.\n\t * @param {Object} options - The options of the render target.\n\t * @return {RenderTarget} The render target.\n\t */\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link CubeRenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {number} size - The size of the cube render target.\n\t * @param {Object} options - The options of the cube render target.\n\t * @return {CubeRenderTarget} The cube render target.\n\t */\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\t/**\n\t * Whether the given node is included in the internal array of nodes or not.\n\t *\n\t * @param {Node} node - The node to test.\n\t * @return {boolean} Whether the given node is included in the internal array of nodes or not.\n\t */\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name which is required by\n\t * {@link OutputStructNode}.\n\t *\n\t * @abstract\n\t * @return {string} The name of the output struct.\n\t */\n\tgetOutputStructName() {}\n\n\t/**\n\t * Returns a bind group for the given group name and binding.\n\t *\n\t * @private\n\t * @param {string} groupName - The group name.\n\t * @param {Array<NodeUniformsGroup>} bindings - List of bindings.\n\t * @return {BindGroup} The bind group\n\t */\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns an array of node uniform groups for the given group name and shader stage.\n\t *\n\t * @param {string} groupName - The group name.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Array<NodeUniformsGroup>} The array of node uniform groups.\n\t */\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns a list bindings of all shader stages separated by groups.\n\t *\n\t * @return {Array<BindGroup>} The list of bindings.\n\t */\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\t/**\n\t * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.\n\t */\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The builder maintains each node in a hash-based dictionary.\n\t * This method sets the given node (value) with the given hash (key) into this dictionary.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {number} hash - The hash of the node.\n\t */\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\t/**\n\t * Adds a node to this builder.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * It is used to add Nodes that will be used as FRAME and RENDER events,\n\t * and need to follow a certain sequence in the calls to work correctly.\n\t * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks the update types of nodes\n\t */\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * A reference the current node which is the\n\t * last node in the chain of nodes.\n\t *\n\t * @type {Node}\n\t */\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\t/**\n\t * Whether the given texture is filtered or not.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture is filtered or not.\n\t */\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\t/**\n\t * Adds the given node to the internal node chain.\n\t * This is used to check recursive calls in node-graph.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\t/**\n\t * Removes the given node from the internal node chain.\n\t *\n\t * @param {Node} node - The node to remove.\n\t */\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name. E.g.\n\t * the method name `textureDimensions` matches the WGSL name but must be\n\t * resolved to `textureSize` in GLSL.\n\t *\n\t * @abstract\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\t/**\n\t * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.\n\t *\n\t * @param {number} hash - The hash of the node.\n\t * @return {Node} The found node.\n\t */\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\t/**\n\t * Adds the Node to a target flow so that it can generate code in the 'generate' process.\n\t *\n\t * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to add.\n\t * @return {Node} The node.\n\t */\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Sets builder's context.\n\t *\n\t * @param {Object} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\t/**\n\t * Returns the builder's current context.\n\t *\n\t * @return {Object} The builder's current context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Gets a context used in shader construction that can be shared across different materials.\n\t * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.\n\t *\n\t * @return {Object} The builder's current context without material.\n\t */\n\tgetSharedContext() {\n\n\t\tconst context = { ...this.context };\n\n\t\tdelete context.material;\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Sets builder's cache.\n\t *\n\t * @param {NodeCache} cache - The cache to set.\n\t */\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\t/**\n\t * Returns the builder's current cache.\n\t *\n\t * @return {NodeCache} The builder's current cache.\n\t */\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\t/**\n\t * Returns a cache for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t * @return {NodeCache} The cache.\n\t */\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @abstract\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the vertexIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The instanceIndex shader string.\n\t */\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the instanceIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The instanceIndex shader string.\n\t */\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the drawIndex input variable as a native shader string.\n\t * Only relevant for WebGL and its `WEBGL_multi_draw` extension.\n\t *\n\t * @abstract\n\t * @return {?string} The drawIndex shader string.\n\t */\n\tgetDrawIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the frontFacing input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The frontFacing shader string.\n\t */\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the fragCoord input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The fragCoord shader string.\n\t */\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not. WebGL needs\n\t * this method evaluate to `true`, WebGPU to `false`.\n\t *\n\t * @abstract\n\t * @return {boolean} Whether to flip texture data along its vertical axis or not.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Calling this method increases the usage count for the given node by one.\n\t *\n\t * @param {Node} node - The node to increase the usage count for.\n\t * @return {number} The updated usage count.\n\t */\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\t/**\n\t * Generates a texture sample shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The texture property name.\n\t * @param {string} uvSnippet - Snippet defining the texture coordinates.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a texture LOD shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The texture property name.\n\t * @param {string} uvSnippet - Snippet defining the texture coordinates.\n\t * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.\n\t * @param {string} levelSnippet - Snippet defining the mip level.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn this.getType( type ) + '[ ' + count + ' ]';\n\n\t}\n\n\t/**\n\t * Generates the array shader string for the given type and value.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @param {?Array<Node>} [values=null] - The default values.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArray( type, count, values = null ) {\n\n\t\tlet snippet = this.generateArrayDeclaration( type, count ) + '( ';\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst value = values ? values[ i ] : null;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tsnippet += value.build( this, type );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet += this.generateConst( type );\n\n\t\t\t}\n\n\t\t\tif ( i < count - 1 ) snippet += ', ';\n\n\t\t}\n\n\t\tsnippet += ' )';\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the struct shader string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {Array<Object>} [membersLayout] - The count.\n\t * @param {?Array<Node>} [values=null] - The default values.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateStruct( type, membersLayout, values = null ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of membersLayout ) {\n\n\t\t\tconst { name, type } = member;\n\n\t\t\tif ( values && values[ name ] && values[ name ].isNode ) {\n\n\t\t\t\tsnippets.push( values[ name ].build( this, type ) );\n\n\t\t\t} else {\n\n\t\t\t\tsnippets.push( this.generateConst( type ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn type + '( ' + snippets.join( ', ' ) + ' )';\n\n\t}\n\n\n\t/**\n\t * Generates the shader string for the given type and value.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?any} [value=null] - The value.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 && type !== 'mat2' ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength >= 4 && value && ( value.isMatrix2 || value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\t/**\n\t * It might be necessary to convert certain data types to different ones\n\t * so this method can be used to hide the conversion.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The updated type.\n\t */\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Whether the given attribute name is defined in the geometry or not.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {boolean} Whether the given attribute name is defined in the geometry.\n\t */\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\t/**\n\t * Returns a node attribute for the given name and type.\n\t *\n\t * @param {string} name - The attribute's name.\n\t * @param {string} type - The attribute's type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tthis.registerDeclaration( attribute );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Returns for the given node and shader stage the property name for the shader.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\t/**\n\t * Whether the given type is a vector type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a vector type or not.\n\t */\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a matrix type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a matrix type or not.\n\t */\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a reference type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a reference type or not.\n\t */\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'samplerComparison' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the component type of a given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The component type.\n\t */\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the element type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The element type.\n\t */\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\t/**\n\t * Returns the component type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The component type.\n\t */\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The vector type.\n\t */\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Returns the data type for the given the length and component type.\n\t *\n\t * @param {number} length - The length.\n\t * @param {string} [componentType='float'] - The component type.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tlet baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\t// fix edge case for mat2x2 being same size as vec4\n\t\tif ( /mat2/.test( componentType ) === true ) {\n\n\t\t\tbaseType = baseType.replace( 'vec', 'mat' );\n\n\t\t}\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\t/**\n\t * Returns the type for a given typed array.\n\t *\n\t * @param {TypedArray} array - The typed array.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\t/**\n\t * Returns the type is an integer type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {boolean} Whether the type is an integer type or not.\n\t */\n\tisInteger( type ) {\n\n\t\treturn /int|uint|(i|u)vec/.test( type );\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\t/**\n\t * Returns the length for the given data type.\n\t *\n\t * @param {string} type - The data type.\n\t * @return {number} The length.\n\t */\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given matrix type.\n\t *\n\t * @param {string} type - The matrix type.\n\t * @return {string} The vector type.\n\t */\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\t/**\n\t * For a given type this method changes the component type to the\n\t * given value. E.g. `vec4` should be changed to the new component type\n\t * `uint` which results in `uvec4`.\n\t *\n\t * @param {string} type - The type.\n\t * @param {string} newComponentType - The new component type.\n\t * @return {string} The new type.\n\t */\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\t/**\n\t * Returns the integer type pendant for the given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The integer type.\n\t */\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\t/**\n\t * Adds a stack node to the internal stack.\n\t *\n\t * @return {StackNode} The added stack node.\n\t */\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\t/**\n\t * Removes the last stack node from the internal stack.\n\t *\n\t * @return {StackNode} The removed stack node.\n\t */\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\t/**\n\t * The builder maintains (cached) data for each node during the building process. This method\n\t * can be used to get these data for a specific shader stage and cache.\n\t *\n\t * @param {Node} node - The node to get the data for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {?NodeCache} cache - An optional cache.\n\t * @return {Object} The node data.\n\t */\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\t//\n\n\t\tlet data = nodeData[ shaderStage ];\n\n\t\tconst subBuilds = nodeData.any ? nodeData.any.subBuilds : null;\n\t\tconst subBuild = this.getClosestSubBuild( subBuilds );\n\n\t\tif ( subBuild ) {\n\n\t\t\tif ( data.subBuildsCache === undefined ) data.subBuildsCache = {};\n\n\t\t\tdata = data.subBuildsCache[ subBuild ] || ( data.subBuildsCache[ subBuild ] = {} );\n\t\t\tdata.subBuilds = subBuilds;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns the properties for the given node and shader stage.\n\t *\n\t * @param {Node} node - The node to get the properties for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.\n\t * @return {Object} The node properties.\n\t */\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.\n\t *\n\t * @param {BufferAttributeNode} node - The buffer attribute node.\n\t * @param {string} type - The node type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @param {?string} [name=null] - The name of the struct.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetStructTypeFromNode( node, membersLayout, name = null, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet structType = nodeData.structType;\n\n\t\tif ( structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tif ( name === null ) name = 'StructType' + index;\n\n\t\t\tstructType = new StructType( name, membersLayout );\n\n\t\t\tthis.structs[ shaderStage ].push( structType );\n\n\t\t\tnodeData.structType = structType;\n\n\t\t}\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetOutputStructTypeFromNode( node, membersLayout ) {\n\n\t\tconst structType = this.getStructTypeFromNode( node, membersLayout, 'OutputType', 'fragment' );\n\t\tstructType.output = true;\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeUniform} for the given uniform node.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The uniform type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {?string} name - The name of the uniform.\n\t * @return {NodeUniform} The node uniform.\n\t */\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tthis.registerDeclaration( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVar} for the given variable node.\n\t *\n\t * @param {VarNode} node - The variable node.\n\t * @param {?string} name - The variable's name.\n\t * @param {string} [type=node.getNodeType( this )] - The variable's type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.\n\t *\n\t * @return {NodeVar} The node variable.\n\t */\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage, readOnly = false ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\t\tconst subBuildVariable = this.getSubBuildProperty( 'variable', nodeData.subBuilds );\n\n\t\tlet nodeVar = nodeData[ subBuildVariable ];\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst idNS = readOnly ? '_const' : '_var';\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\t\t\tconst id = this.vars[ idNS ] || ( this.vars[ idNS ] = 0 );\n\n\t\t\tif ( name === null ) {\n\n\t\t\t\tname = ( readOnly ? 'nodeConst' : 'nodeVar' ) + id;\n\n\t\t\t\tthis.vars[ idNS ] ++;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( subBuildVariable !== 'variable' ) {\n\n\t\t\t\tname = this.getSubBuildProperty( name, nodeData.subBuilds );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst count = node.getArrayCount( this );\n\n\t\t\tnodeVar = new NodeVar( name, type, readOnly, count );\n\n\t\t\tif ( ! readOnly ) {\n\n\t\t\t\tvars.push( nodeVar );\n\n\t\t\t}\n\n\t\t\tthis.registerDeclaration( nodeVar );\n\n\t\t\tnodeData[ subBuildVariable ] = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\t/**\n\t * Returns whether a Node or its flow is deterministic, useful for use in `const`.\n\t *\n\t * @param {Node} node - The varying node.\n\t * @return {boolean} Returns true if deterministic.\n\t */\n\tisDeterministic( node ) {\n\n\t\tif ( node.isMathNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true ) &&\n\t\t\t\t( node.cNode ? this.isDeterministic( node.cNode ) : true );\n\n\t\t} else if ( node.isOperatorNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true );\n\n\t\t} else if ( node.isArrayNode ) {\n\n\t\t\tif ( node.values !== null ) {\n\n\t\t\t\tfor ( const n of node.values ) {\n\n\t\t\t\t\tif ( ! this.isDeterministic( n ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if ( node.isConstNode ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVarying} for the given varying node.\n\t *\n\t * @param {(VaryingNode|PropertyNode)} node - The varying node.\n\t * @param {?string} name - The varying's name.\n\t * @param {string} [type=node.getNodeType( this )] - The varying's type.\n\t * @param {?string} interpolationType - The interpolation type of the varying.\n\t * @param {?string} interpolationSampling - The interpolation sampling type of the varying.\n\t * @return {NodeVar} The node varying.\n\t */\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ), interpolationType = null, interpolationSampling = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\t\tconst subBuildVarying = this.getSubBuildProperty( 'varying', nodeData.subBuilds );\n\n\t\tlet nodeVarying = nodeData[ subBuildVarying ];\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\t//\n\n\t\t\tif ( subBuildVarying !== 'varying' ) {\n\n\t\t\t\tname = this.getSubBuildProperty( name, nodeData.subBuilds );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tnodeVarying = new NodeVarying( name, type, interpolationType, interpolationSampling );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tthis.registerDeclaration( nodeVarying );\n\n\t\t\tnodeData[ subBuildVarying ] = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\t/**\n\t * Registers a node declaration in the current shader stage.\n\t *\n\t * @param {Object} node - The node to be registered.\n\t */\n\tregisterDeclaration( node ) {\n\n\t\tconst shaderStage = this.shaderStage;\n\t\tconst declarations = this.declarations[ shaderStage ] || ( this.declarations[ shaderStage ] = {} );\n\n\t\tconst property = this.getPropertyName( node );\n\n\t\tlet index = 1;\n\t\tlet name = property;\n\n\t\t// Automatically renames the property if the name is already in use.\n\n\t\twhile ( declarations[ name ] !== undefined ) {\n\n\t\t\tname = property + '_' + index ++;\n\n\t\t}\n\n\t\tif ( index > 1 ) {\n\n\t\t\tnode.name = name;\n\n\t\t\tconsole.warn( `THREE.TSL: Declaration name '${ property }' of '${ node.type }' already in use. Renamed to '${ name }'.` );\n\n\t\t}\n\n\t\tdeclarations[ name ] = node;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeCode} for the given code node.\n\t *\n\t * @param {CodeNode} node - The code node.\n\t * @param {string} type - The node type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {NodeCode} The node code.\n\t */\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\t/**\n\t * Adds a code flow based on the code-block hierarchy.\n\n\t * This is used so that code-blocks like If,Else create their variables locally if the Node\n\t * is only used inside one of these conditionals in the current shader stage.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.\n\t */\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow code-block.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {string} code - The code to add.\n\t * @param {Node} nodeBlock - Current ConditionalNode\n\t */\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow.\n\t *\n\t * @param {string} code - The code to add.\n\t * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a code to the current code flow.\n\t *\n\t * @param {string} code - Shader code.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Add tab in the code that will be generated so that other snippets respect the current tabulation.\n\t * Typically used in codes with If,Else.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a tab.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current flow data based on a Node.\n\t *\n\t * @param {Node} node - Node that the flow was started.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Object} The flow data.\n\t */\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\t/**\n\t * Executes the node flow based on a root node to generate the final shader code.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @return {Object} The code flow.\n\t */\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Includes a node in the current function node.\n\t *\n\t * @param {Node} node - The node to include.\n\t * @returns {void}\n\t */\n\taddInclude( node ) {\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.\n\t * @return {FunctionNode} The build function node.\n\t */\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a TSL function: Fn().\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.\n\t * @return {Object}\n\t */\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Executes the node in a specific build stage.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {string} buildStage - The build stage to execute the node in.\n\t * @param {Node|string|null} output - Expected output type. For example 'vec3'.\n\t * @return {Node|string|null} The result of the node build.\n\t */\n\tflowBuildStage( node, buildStage, output = null ) {\n\n\t\tconst previousBuildStage = this.getBuildStage();\n\n\t\tthis.setBuildStage( buildStage );\n\n\t\tconst result = node.build( this, output );\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @return {Object}\n\t */\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousDeclarations = this.declarations;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.declarations = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.declarations = previousDeclarations;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @abstract\n\t * @param {string} op - The operator name to resolve.\n\t * @return {?string} The resolved operator name.\n\t */\n\tgetFunctionOperator( /* op */ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @abstract\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The function code.\n\t */\n\tbuildFunctionCode( /* shaderNode */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a child Node.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @return {Object} The code flow.\n\t */\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Executes a flow of code in a different stage.\n\t *\n\t * Some nodes like `varying()` have the ability to compute code in vertex-stage and\n\t * return the value in fragment-stage even if it is being executed in an input fragment.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @param {?string} propertyName - The property name to assign the result.\n\t * @return {Object|Node|null} The code flow or node.build() result.\n\t */\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousTab = this.tab;\n\t\tconst previousCache = this.cache;\n\t\tconst previousShaderStage = this.shaderStage;\n\t\tconst previousContext = this.context;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst context = { ...this.context };\n\t\tdelete context.nodeBlock;\n\n\t\tthis.cache = this.globalCache;\n\t\tthis.tab = '\\t';\n\t\tthis.context = context;\n\n\t\tlet result = null;\n\n\t\tif ( this.buildStage === 'generate' ) {\n\n\t\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\t\tif ( propertyName !== null ) {\n\n\t\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t\t}\n\n\t\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\t\tresult = flowData;\n\n\t\t} else {\n\n\t\t\tresult = node.build( this );\n\n\t\t}\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\tthis.cache = previousCache;\n\t\tthis.tab = previousTab;\n\t\tthis.context = previousContext;\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns an array holding all node attributes of this node builder.\n\t *\n\t * @return {Array<NodeAttribute>} The node attributes of this builder.\n\t */\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\t/**\n\t * Returns the attribute definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The attribute code section.\n\t */\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the varying definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The varying code section.\n\t */\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns a single variable definition as a shader string for the given variable type and name.\n\t *\n\t * @param {string} type - The variable's type.\n\t * @param {string} name - The variable's name.\n\t * @param {?number} [count=null] - The array length.\n\t * @return {string} The shader string.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\treturn `${ count !== null ? this.generateArrayDeclaration( type, count ) : this.getType( type ) } ${ name }`;\n\n\t}\n\n\t/**\n\t * Returns the variable definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The variable code section.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the uniform definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The uniform code section.\n\t */\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the native code definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The native code section.\n\t */\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the hash of this node builder.\n\t *\n\t * @return {string} The hash.\n\t */\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\t/**\n\t * Sets the current shader stage.\n\t *\n\t * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.\n\t */\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\t/**\n\t * Returns the current shader stage.\n\t *\n\t * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.\n\t */\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\t/**\n\t * Sets the current build stage.\n\t *\n\t * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.\n\t */\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\t/**\n\t * Returns the current build stage.\n\t *\n\t * @return {?('setup'|'analyze'|'generate')} The current build stage.\n\t */\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t *\n\t * @abstract\n\t */\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the current sub-build layer.\n\t *\n\t * @return {SubBuildNode} The current sub-build layers.\n\t */\n\tget subBuild() {\n\n\t\treturn this.subBuildLayers[ this.subBuildLayers.length - 1 ] || null;\n\n\t}\n\n\t/**\n\t * Adds a sub-build layer to the node builder.\n\t *\n\t * @param {SubBuildNode} subBuild - The sub-build layer to add.\n\t */\n\taddSubBuild( subBuild ) {\n\n\t\tthis.subBuildLayers.push( subBuild );\n\n\t}\n\n\t/**\n\t * Removes the last sub-build layer from the node builder.\n\t *\n\t * @return {SubBuildNode} The removed sub-build layer.\n\t */\n\tremoveSubBuild() {\n\n\t\treturn this.subBuildLayers.pop();\n\n\t}\n\n\t/**\n\t * Returns the closest sub-build layer for the given data.\n\t *\n\t * @param {Node|Set|Array} data - The data to get the closest sub-build layer from.\n\t * @return {?string} The closest sub-build name or null if none found.\n\t */\n\tgetClosestSubBuild( data ) {\n\n\t\tlet subBuilds;\n\n\t\tif ( data && data.isNode ) {\n\n\t\t\tif ( data.isShaderCallNodeInternal ) {\n\n\t\t\t\tsubBuilds = data.shaderNode.subBuilds;\n\n\t\t\t} else if ( data.isStackNode ) {\n\n\t\t\t\tsubBuilds = [ data.subBuild ];\n\n\t\t\t} else {\n\n\t\t\t\tsubBuilds = this.getDataFromNode( data, 'any' ).subBuilds;\n\n\t\t\t}\n\n\t\t} else if ( data instanceof Set ) {\n\n\t\t\tsubBuilds = [ ...data ];\n\n\t\t} else {\n\n\t\t\tsubBuilds = data;\n\n\t\t}\n\n\t\tif ( ! subBuilds ) return null;\n\n\t\tconst subBuildLayers = this.subBuildLayers;\n\n\t\tfor ( let i = subBuilds.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst subBuild = subBuilds[ i ];\n\n\t\t\tif ( subBuildLayers.includes( subBuild ) ) {\n\n\t\t\t\treturn subBuild;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\n\t/**\n\t * Returns the output node of a sub-build layer.\n\t *\n\t * @param {Node} node - The node to get the output from.\n\t * @return {string} The output node name.\n\t */\n\tgetSubBuildOutput( node ) {\n\n\t\treturn this.getSubBuildProperty( 'outputNode', node );\n\n\t}\n\n\t/**\n\t * Returns the sub-build property name for the given property and node.\n\t *\n\t * @param {string} [property=''] - The property name.\n\t * @param {?Node} [node=null] - The node to get the sub-build from.\n\t * @return {string} The sub-build property name.\n\t */\n\tgetSubBuildProperty( property = '', node = null ) {\n\n\t\tlet subBuild;\n\n\t\tif ( node !== null ) {\n\n\t\t\tsubBuild = this.getClosestSubBuild( node );\n\n\t\t} else {\n\n\t\t\tsubBuild = this.subBuildFn;\n\n\t\t}\n\n\t\tlet result;\n\n\t\tif ( subBuild ) {\n\n\t\t\tresult = property ? ( subBuild + '_' + property ) : subBuild;\n\n\t\t} else {\n\n\t\t\tresult = property;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Central build method which controls the build for the given object.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\tconsole.error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and/or return an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a uniform representation which is later used for UBO generation and rendering.\n\t *\n\t * @param {NodeUniform} uniformNode - The uniform node.\n\t * @param {string} type - The requested type.\n\t * @return {Uniform} The uniform.\n\t */\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat2' ) return new Matrix2NodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\t/**\n\t * Formats the given shader snippet from a given type into another one. E.g.\n\t * this method might be used to convert a simple float string `\"1.0\"` into a\n\t * `vec3` representation: `\"vec3<f32>( 1.0 )\"`.\n\t *\n\t * @param {string} snippet - The shader snippet.\n\t * @param {string} fromType - The source type.\n\t * @param {string} toType - The target type.\n\t * @return {string} The updated shader string.\n\t */\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet }[ 0 ].xyz, ${ snippet }[ 1 ].xyz, ${ snippet }[ 2 ].xyz )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet }[ 0 ].xy, ${ snippet }[ 1 ].xy )`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\tsnippet = toType === 'bool' ? `all( ${ snippet } )` : `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`;\n\n\t\t\treturn this.format( snippet, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\t/**\n\t * Returns a signature with the engine's current revision.\n\t *\n\t * @return {string} The signature.\n\t */\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n\t/**\n\t * Prevents the node builder from being used as an iterable in TSL.Fn(), avoiding potential runtime errors.\n\t */\n\t*[ Symbol.iterator ]() { }\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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","ignoreList":[]}