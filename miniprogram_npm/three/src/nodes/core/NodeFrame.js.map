{"version":3,"file":"node_modules/three/src/nodes/core/NodeFrame.js","names":["NodeUpdateType","NodeFrame","constructor","this","time","deltaTime","frameId","renderId","updateMap","WeakMap","updateBeforeMap","updateAfterMap","renderer","material","camera","object","scene","_getMaps","referenceMap","nodeRef","maps","get","undefined","renderMap","frameMap","set","updateBeforeNode","node","updateType","getUpdateBeforeType","reference","updateReference","FRAME","updateBefore","RENDER","OBJECT","updateAfterNode","getUpdateAfterType","updateAfter","updateNode","getUpdateType","update","lastTime","performance","now"],"sources":["node_modules/three/src/nodes/core/NodeFrame.js"],"sourcesContent":["import { NodeUpdateType } from './constants.js';\n\n/**\n * Management class for updating nodes. The module tracks metrics like\n * the elapsed time, delta time, the render and frame ID to correctly\n * call the node update methods {@link Node#updateBefore}, {@link Node#update}\n * and {@link Node#updateAfter} depending on the node's configuration.\n */\nclass NodeFrame {\n\n\t/**\n\t * Constructs a new node fame.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The elapsed time in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.time = 0;\n\n\t\t/**\n\t\t * The delta time in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.deltaTime = 0;\n\n\t\t/**\n\t\t * The frame ID.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.frameId = 0;\n\n\t\t/**\n\t\t * The render ID.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t\t/**\n\t\t * Used to control the {@link Node#update} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateBefore} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateBeforeMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateAfter} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the current renderer.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the current material.\n\t\t *\n\t\t * @type {?Material}\n\t\t * @default null\n\t\t */\n\t\tthis.material = null;\n\n\t\t/**\n\t\t * A reference to the current camera.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A reference to the current 3D object.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.object = null;\n\n\t\t/**\n\t\t * A reference to the current scene.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t}\n\n\t/**\n\t * Returns a dictionary for a given node and update map which\n\t * is used to correctly call node update methods per frame or render.\n\t *\n\t * @private\n\t * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.\n\t * @param {Node} nodeRef - The reference to the current node.\n\t * @return {Object<string,WeakMap>} The dictionary.\n\t */\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderMap: new WeakMap(),\n\t\t\t\tframeMap: new WeakMap()\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateBefore} for the given node.\n\t * It makes sure {@link Node#updateBeforeType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateAfter} for the given node.\n\t * It makes sure {@link Node#updateAfterType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#update} for the given node.\n\t * It makes sure {@link Node#updateType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the internal state of the node frame. This method is\n\t * called by the renderer in its internal animation loop.\n\t */\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\nexport default NodeFrame;\n"],"mappings":"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","ignoreList":[]}