import{Color}from"../../math/Color.js";import{Matrix2}from"../../math/Matrix2.js";import{Matrix3}from"../../math/Matrix3.js";import{Matrix4}from"../../math/Matrix4.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";function cyrb53(t,e=0){let r=3735928559^e,o=1103547991^e;if(t instanceof Array)for(let e,n=0;n<t.length;n++)e=t[n],r=Math.imul(r^e,2654435761),o=Math.imul(o^e,1597334677);else for(let e,n=0;n<t.length;n++)e=t.charCodeAt(n),r=Math.imul(r^e,2654435761),o=Math.imul(o^e,1597334677);return r=Math.imul(r^r>>>16,2246822507),r^=Math.imul(o^o>>>13,3266489909),o=Math.imul(o^o>>>16,2246822507),o^=Math.imul(r^r>>>13,3266489909),4294967296*(2097151&o)+(r>>>0)}export const hashString=t=>cyrb53(t);export const hashArray=t=>cyrb53(t);export const hash=(...t)=>cyrb53(t);export function getCacheKey(t,e=!1){const r=[];!0===t.isNode&&(r.push(t.id),t=t.getSelf());for(const{property:o,childNode:n}of getNodeChildren(t))r.push(cyrb53(o.slice(0,-4)),n.getCacheKey(e));return cyrb53(r)}export function*getNodeChildren(t,e=!1){for(const r in t){if(!0===r.startsWith("_"))continue;const o=t[r];if(!0===Array.isArray(o))for(let t=0;t<o.length;t++){const n=o[t];n&&(!0===n.isNode||e&&"function"==typeof n.toJSON)&&(yield{property:r,index:t,childNode:n})}else if(o&&!0===o.isNode)yield{property:r,childNode:o};else if(o&&Object.getPrototypeOf(o)===Object.prototype)for(const t in o){if(!0===t.startsWith("_"))continue;const n=o[t];n&&(!0===n.isNode||e&&"function"==typeof n.toJSON)&&(yield{property:r,index:t,childNode:n})}}}const typeFromLength=new Map([[1,"float"],[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),dataFromObject=new WeakMap;export function getTypeFromLength(t){return typeFromLength.get(t)}export function getTypedArrayFromType(t){if(/[iu]?vec\d/.test(t))return t.startsWith("ivec")?Int32Array:t.startsWith("uvec")?Uint32Array:Float32Array;if(/mat\d/.test(t))return Float32Array;if(/float/.test(t))return Float32Array;if(/uint/.test(t))return Uint32Array;if(/int/.test(t))return Int32Array;throw new Error(`THREE.NodeUtils: Unsupported type: ${t}`)}export function getLengthFromType(t){return/float|int|uint/.test(t)?1:/vec2/.test(t)?2:/vec3/.test(t)?3:/vec4/.test(t)||/mat2/.test(t)?4:/mat3/.test(t)?9:/mat4/.test(t)?16:void console.error("THREE.TSL: Unsupported type:",t)}export function getMemoryLengthFromType(t){return/float|int|uint/.test(t)?1:/vec2/.test(t)?2:/vec3/.test(t)?3:/vec4/.test(t)||/mat2/.test(t)?4:/mat3/.test(t)?12:/mat4/.test(t)?16:void console.error("THREE.TSL: Unsupported type:",t)}export function getByteBoundaryFromType(t){return/float|int|uint/.test(t)?4:/vec2/.test(t)?8:/vec3/.test(t)||/vec4/.test(t)?16:/mat2/.test(t)?8:/mat3/.test(t)?48:/mat4/.test(t)?64:void console.error("THREE.TSL: Unsupported type:",t)}export function getValueType(t){if(null==t)return null;const e=typeof t;return!0===t.isNode?"node":"number"===e?"float":"boolean"===e?"bool":"string"===e?"string":"function"===e?"shader":!0===t.isVector2?"vec2":!0===t.isVector3?"vec3":!0===t.isVector4?"vec4":!0===t.isMatrix2?"mat2":!0===t.isMatrix3?"mat3":!0===t.isMatrix4?"mat4":!0===t.isColor?"color":t instanceof ArrayBuffer?"ArrayBuffer":null}export function getValueFromType(t,...e){const r=t?t.slice(-4):void 0;return 1===e.length&&("vec2"===r?e=[e[0],e[0]]:"vec3"===r?e=[e[0],e[0],e[0]]:"vec4"===r&&(e=[e[0],e[0],e[0],e[0]])),"color"===t?new Color(...e):"vec2"===r?new Vector2(...e):"vec3"===r?new Vector3(...e):"vec4"===r?new Vector4(...e):"mat2"===r?new Matrix2(...e):"mat3"===r?new Matrix3(...e):"mat4"===r?new Matrix4(...e):"bool"===t?e[0]||!1:"float"===t||"int"===t||"uint"===t?e[0]||0:"string"===t?e[0]||"":"ArrayBuffer"===t?base64ToArrayBuffer(e[0]):null}export function getDataFromObject(t){let e=dataFromObject.get(t);return void 0===e&&(e={},dataFromObject.set(t,e)),e}export function arrayBufferToBase64(t){let e="";const r=new Uint8Array(t);for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return btoa(e)}export function base64ToArrayBuffer(t){return Uint8Array.from(atob(t),(t=>t.charCodeAt(0))).buffer}
//# sourceMappingURL=NodeUtils.js.map