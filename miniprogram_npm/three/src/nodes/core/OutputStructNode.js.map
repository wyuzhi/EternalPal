{"version":3,"file":"node_modules/three/src/nodes/core/OutputStructNode.js","names":["Node","nodeProxy","OutputStructNode","type","constructor","members","super","this","isOutputStructNode","getNodeType","builder","properties","getNodeProperties","undefined","membersLayout","i","length","name","push","index","structType","getOutputStructTypeFromNode","generate","propertyName","getOutputStructName","structPrefix","snippet","build","addLineFlowCode","outputStruct"],"sources":["node_modules/three/src/nodes/core/OutputStructNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\n\n/**\n * This node can be used to define multiple outputs in a shader programs.\n *\n * @augments Node\n */\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node. The constructor can be invoked with an\n\t * arbitrary number of nodes representing the members.\n\t *\n\t * @param {...Node} members - A parameter list of nodes.\n\t */\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * An array of nodes which defines the output.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.members = members;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.membersLayout === undefined ) {\n\n\t\t\tconst members = this.members;\n\t\t\tconst membersLayout = [];\n\n\t\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\t\tconst name = 'm' + i;\n\t\t\t\tconst type = members[ i ].getNodeType( builder );\n\n\t\t\t\tmembersLayout.push( { name, type, index: i } );\n\n\t\t\t}\n\n\t\t\tproperties.membersLayout = membersLayout;\n\t\t\tproperties.structType = builder.getOutputStructTypeFromNode( this, properties.membersLayout );\n\n\t\t}\n\n\t\treturn properties.structType.name;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nexport default OutputStructNode;\n\n/**\n * TSL function for creating an output struct node.\n *\n * @tsl\n * @function\n * @param {...Node} members - A parameter list of nodes.\n * @returns {OutputStructNode}\n */\nexport const outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n"],"mappings":"OAAOA,SAAU,mBACRC,cAAiB,oBAO1B,MAAMC,yBAAyBF,KAE9B,eAAWG,GAEV,MAAO,kBAER,CAQA,WAAAC,IAAgBC,GAEfC,QAOAC,KAAKF,QAAUA,EASfE,KAAKC,oBAAqB,CAE3B,CAEA,WAAAC,CAAaC,GAEZ,MAAMC,EAAaD,EAAQE,kBAAmBL,MAE9C,QAAkCM,IAA7BF,EAAWG,cAA8B,CAE7C,MAAMT,EAAUE,KAAKF,QACfS,EAAgB,GAEtB,IAAM,IAAIC,EAAI,EAAGA,EAAIV,EAAQW,OAAQD,IAAO,CAE3C,MAAME,EAAO,IAAMF,EACbZ,EAAOE,EAASU,GAAIN,YAAaC,GAEvCI,EAAcI,KAAM,CAAED,OAAMd,OAAMgB,MAAOJ,GAE1C,CAEAJ,EAAWG,cAAgBA,EAC3BH,EAAWS,WAAaV,EAAQW,4BAA6Bd,KAAMI,EAAWG,cAE/E,CAEA,OAAOH,EAAWS,WAAWH,IAE9B,CAEA,QAAAK,CAAUZ,GAET,MAAMa,EAAeb,EAAQc,sBACvBnB,EAAUE,KAAKF,QAEfoB,EAAgC,KAAjBF,EAAsBA,EAAe,IAAM,GAEhE,IAAM,IAAIR,EAAI,EAAGA,EAAIV,EAAQW,OAAQD,IAAO,CAE3C,MAAMW,EAAUrB,EAASU,GAAIY,MAAOjB,GAEpCA,EAAQkB,gBAAiB,GAAIH,KAAkBV,OAASW,IAAYnB,KAErE,CAEA,OAAOgB,CAER,iBAIcrB,wBAUR,MAAM2B,aAA6B5B,UAAWC","ignoreList":[]}