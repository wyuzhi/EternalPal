{"version":3,"file":"node_modules/three/src/nodes/core/PropertyNode.js","names":["Node","nodeImmutable","nodeObject","PropertyNode","type","constructor","nodeType","name","varying","super","this","isPropertyNode","global","getHash","builder","generate","nodeVar","getVaryingFromNode","needsInterpolation","getVarFromNode","getPropertyName","property","varyingProperty","diffuseColor","emissive","roughness","metalness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","iridescence","iridescenceIOR","iridescenceThickness","alphaT","anisotropy","anisotropyT","anisotropyB","specularColor","specularF90","shininess","output","dashSize","gapSize","pointWidth","ior","transmission","thickness","attenuationDistance","attenuationColor","dispersion"],"sources":["node_modules/three/src/nodes/core/PropertyNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { nodeImmutable, nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\t/**\n\t * Constructs a new property node.\n\t *\n\t * @param {string} nodeType - The type of the node.\n\t * @param {?string} [name=null] - The name of the property in the shader.\n\t * @param {boolean} [varying=false] - Whether this property is a varying or not.\n\t */\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The name of the property in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this property is a varying or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.varying = varying;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPropertyNode = true;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\nexport default PropertyNode;\n\n/**\n * TSL function for creating a property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nexport const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\n\n/**\n * TSL function for creating a varying property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nexport const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nexport const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nexport const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nexport const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nexport const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n"],"mappings":"OAAOA,SAAU,mBACRC,cAAeC,eAAkB,oBAc1C,MAAMC,qBAAqBH,KAE1B,eAAWI,GAEV,MAAO,cAER,CASA,WAAAC,CAAaC,EAAUC,EAAO,KAAMC,GAAU,GAE7CC,MAAOH,GASPI,KAAKH,KAAOA,EAQZG,KAAKF,QAAUA,EASfE,KAAKC,gBAAiB,EAQtBD,KAAKE,QAAS,CAEf,CAEA,OAAAC,CAASC,GAER,OAAOJ,KAAKH,MAAQE,MAAMI,QAASC,EAEpC,CAEA,QAAAC,CAAUD,GAET,IAAIE,EAaJ,OAXsB,IAAjBN,KAAKF,SAETQ,EAAUF,EAAQG,mBAAoBP,KAAMA,KAAKH,MACjDS,EAAQE,oBAAqB,GAI7BF,EAAUF,EAAQK,eAAgBT,KAAMA,KAAKH,MAIvCO,EAAQM,gBAAiBJ,EAEjC,iBAIcb,oBAWR,MAAMkB,SAAW,CAAEjB,EAAMG,IAAUL,WAAY,IAAIC,aAAcC,EAAMG,WAWvE,MAAMe,gBAAkB,CAAElB,EAAMG,IAAUL,WAAY,IAAIC,aAAcC,EAAMG,GAAM,WAQpF,MAAMgB,aAA6BtB,cAAeE,aAAc,OAAQ,uBAQxE,MAAMqB,SAAyBvB,cAAeE,aAAc,OAAQ,wBAQpE,MAAMsB,UAA0BxB,cAAeE,aAAc,QAAS,oBAQtE,MAAMuB,UAA0BzB,cAAeE,aAAc,QAAS,oBAQtE,MAAMwB,UAA0B1B,cAAeE,aAAc,QAAS,oBAQtE,MAAMyB,mBAAmC3B,cAAeE,aAAc,QAAS,6BAQ/E,MAAM0B,MAAsB5B,cAAeE,aAAc,OAAQ,gBAQjE,MAAM2B,eAA+B7B,cAAeE,aAAc,QAAS,yBAQ3E,MAAM4B,YAA4B9B,cAAeE,aAAc,QAAS,sBAQxE,MAAM6B,eAA+B/B,cAAeE,aAAc,QAAS,yBAQ3E,MAAM8B,qBAAqChC,cAAeE,aAAc,QAAS,+BAQjF,MAAM+B,OAAuBjC,cAAeE,aAAc,QAAS,iBAQnE,MAAMgC,WAA2BlC,cAAeE,aAAc,QAAS,qBAQvE,MAAMiC,YAA4BnC,cAAeE,aAAc,OAAQ,sBAQvE,MAAMkC,YAA4BpC,cAAeE,aAAc,OAAQ,sBAQvE,MAAMmC,cAA8BrC,cAAeE,aAAc,QAAS,wBAQ1E,MAAMoC,YAA4BtC,cAAeE,aAAc,QAAS,sBAQxE,MAAMqC,UAA0BvC,cAAeE,aAAc,QAAS,oBAQtE,MAAMsC,OAAuBxC,cAAeE,aAAc,OAAQ,iBAQlE,MAAMuC,SAAyBzC,cAAeE,aAAc,QAAS,mBAQrE,MAAMwC,QAAwB1C,cAAeE,aAAc,QAAS,kBAQpE,MAAMyC,WAA2B3C,cAAeE,aAAc,QAAS,qBAQvE,MAAM0C,IAAoB5C,cAAeE,aAAc,QAAS,cAQhE,MAAM2C,aAA6B7C,cAAeE,aAAc,QAAS,uBAQzE,MAAM4C,UAA0B9C,cAAeE,aAAc,QAAS,oBAQtE,MAAM6C,oBAAoC/C,cAAeE,aAAc,QAAS,8BAQhF,MAAM8C,iBAAiChD,cAAeE,aAAc,QAAS,2BAQ7E,MAAM+C,WAA2BjD,cAAeE,aAAc,QAAS","ignoreList":[]}