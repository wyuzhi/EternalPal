{"version":3,"file":"node_modules/three/src/nodes/core/StackNode.js","names":["Node","select","ShaderNode","nodeProxy","getCurrentStack","setCurrentStack","nodeObject","StackNode","type","constructor","parent","super","this","nodes","outputNode","_currentCond","_expressionNode","isStackNode","getNodeType","builder","getMemberType","name","add","node","push","If","boolNode","method","methodNode","ElseIf","ifNode","elseNode","Else","Switch","expression","Case","params","caseNodes","length","Error","i","equal","caseNode","or","condNode","Default","setup","nodeProperties","getNodeProperties","index","childNode","getChildren","isVarNode","intent","assign","build","previousBuildStack","currentStack","previousStack","buildStage","stages","getDataFromNode","parents","shaderStage","result","stack","setParameterLength"],"sources":["node_modules/three/src/nodes/core/StackNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { select } from '../math/ConditionalNode.js';\nimport { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, nodeObject } from '../tsl/TSLBase.js';\n\n/**\n * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.\n * They are usually needed in cases like `If`, `Else`.\n *\n * @augments Node\n */\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\t/**\n\t * Constructs a new stack node.\n\t *\n\t * @param {?StackNode} [parent=null] - The parent stack node.\n\t */\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * List of nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * The parent stack node.\n\t\t *\n\t\t * @type {?StackNode}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The current conditional node.\n\t\t *\n\t\t * @private\n\t\t * @type {ConditionalNode}\n\t\t * @default null\n\t\t */\n\t\tthis._currentCond = null;\n\n\t\t/**\n\t\t * The expression node. Only\n\t\t * relevant for Switch/Case.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._expressionNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.outputNode ? this.outputNode.getMemberType( builder, name ) : 'void';\n\n\t}\n\n\t/**\n\t * Adds a node to this stack.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `if` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\t/**\n\t * Represent an `elseif` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `else` statement in TSL.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represents a `switch` statement in TSL.\n\t *\n\t * @param {any} expression - Represents the expression.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tSwitch( expression ) {\n\n\t\tthis._expressionNode = nodeObject( expression );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.\n\t * The last parameter must be the callback method that should be executed in the `true` case.\n\t *\n\t * @param {...any} params - The values of the `Case()` statement as well as the callback method.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tCase( ...params ) {\n\n\t\tconst caseNodes = [];\n\n\t\t// extract case nodes from the parameter list\n\n\t\tif ( params.length >= 2 ) {\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tcaseNodes.push( this._expressionNode.equal( nodeObject( params[ i ] ) ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'TSL: Invalid parameter length. Case() requires at least two parameters.' );\n\n\t\t}\n\n\t\t// extract method\n\n\t\tconst method = params[ params.length - 1 ];\n\t\tconst methodNode = new ShaderNode( method );\n\n\t\t// chain multiple cases when using Case( 1, 2, 3, () => {} )\n\n\t\tlet caseNode = caseNodes[ 0 ];\n\n\t\tfor ( let i = 1; i < caseNodes.length; i ++ ) {\n\n\t\t\tcaseNode = caseNode.or( caseNodes[ i ] );\n\n\t\t}\n\n\t\t// build condition\n\n\t\tconst condNode = select( caseNode, methodNode );\n\n\t\tif ( this._currentCond === null ) {\n\n\t\t\tthis._currentCond = condNode;\n\n\t\t\treturn this.add( this._currentCond );\n\n\t\t} else {\n\n\t\t\tthis._currentCond.elseNode = condNode;\n\t\t\tthis._currentCond = condNode;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the default code block of a Switch/Case statement.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tDefault( method ) {\n\n\t\tthis.Else( method );\n\n\t\treturn this;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tif ( childNode.isVarNode && childNode.intent === true ) {\n\n\t\t\t\tconst properties = builder.getNodeProperties( childNode );\n\n\t\t\t\tif ( properties.assign !== true ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousBuildStack = builder.currentStack;\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tbuilder.currentStack = this;\n\n\t\tconst buildStage = builder.buildStage;\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tif ( node.isVarNode && node.intent === true ) {\n\n\t\t\t\tconst properties = builder.getNodeProperties( node );\n\n\t\t\t\tif ( properties.assign !== true ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( buildStage === 'setup' ) {\n\n\t\t\t\tnode.build( builder );\n\n\t\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\t\tnode.build( builder, this );\n\n\t\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\t\tconst stages = builder.getDataFromNode( node, 'any' ).stages;\n\t\t\t\tconst parents = stages && stages[ builder.shaderStage ];\n\n\t\t\t\tif ( node.isVarNode && parents && parents.length === 1 && parents[ 0 ] && parents[ 0 ].isStackNode ) {\n\n\t\t\t\t\tcontinue; // skip var nodes that are only used in .toVarying()\n\n\t\t\t\t}\n\n\t\t\t\tnode.build( builder, 'void' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst result = this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t\tsetCurrentStack( previousStack );\n\n\t\tbuilder.currentStack = previousBuildStack;\n\n\t\treturn result;\n\n\t}\n\n}\n\nexport default StackNode;\n\n/**\n * TSL function for creating a stack node.\n *\n * @tsl\n * @function\n * @param {?StackNode} [parent=null] - The parent stack node.\n * @returns {StackNode}\n */\nexport const stack = /*@__PURE__*/ nodeProxy( StackNode ).setParameterLength( 0, 1 );\n"],"mappings":"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","ignoreList":[]}