{"version":3,"file":"node_modules/three/src/nodes/core/StructTypeNode.js","names":["Node","getByteBoundaryFromType","getMemoryLengthFromType","getMembersLayout","members","Object","entries","map","name","value","type","atomic","StructTypeNode","constructor","membersLayout","super","this","isStructLayoutNode","getLength","BYTES_PER_ELEMENT","Float32Array","offset","member","itemSize","chunkOffset","chunkPadding","chunkStart","Math","ceil","getMemberType","builder","find","m","getNodeType","getStructTypeFromNode","setup","addInclude","generate"],"sources":["node_modules/three/src/nodes/core/StructTypeNode.js"],"sourcesContent":["\nimport Node from './Node.js';\nimport { getByteBoundaryFromType, getMemoryLengthFromType } from './NodeUtils.js';\n\n/**\n * Generates a layout for struct members.\n * This function takes an object representing struct members and returns an array of member layouts.\n * Each member layout includes the member's name, type, and whether it is atomic.\n *\n * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.\n * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.\n */\nfunction getMembersLayout( members ) {\n\n\treturn Object.entries( members ).map( ( [ name, value ] ) => {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\treturn { name, type: value, atomic: false };\n\n\t\t}\n\n\t\treturn { name, type: value.type, atomic: value.atomic || false };\n\n\t} );\n\n}\n\n/**\n * Represents a struct type node in the node-based system.\n * This class is used to define and manage the layout and types of struct members.\n * It extends the base Node class and provides methods to get the length of the struct,\n * retrieve member types, and generate the struct type for a builder.\n *\n * @augments Node\n */\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\t/**\n\t * Creates an instance of StructTypeNode.\n\t *\n\t * @param {Object} membersLayout - The layout of the members for the struct.\n\t * @param {?string} [name=null] - The optional name of the struct.\n\t */\n\tconstructor( membersLayout, name = null ) {\n\n\t\tsuper( 'struct' );\n\n\t\t/**\n\t\t * The layout of the members for the struct\n\t\t *\n\t\t * @type {Array.<{name: string, type: string, atomic: boolean}>}\n\t\t */\n\t\tthis.membersLayout = getMembersLayout( membersLayout );\n\n\t\t/**\n\t\t * The name of the struct.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStructLayoutNode = true;\n\n\t}\n\n\t/**\n\t * Returns the length of the struct.\n\t * The length is calculated by summing the lengths of the struct's members.\n\t *\n\t * @returns {number} The length of the struct.\n\t */\n\tgetLength() {\n\n\t\tconst GPU_CHUNK_BYTES = 8;\n\t\tconst BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( const member of this.membersLayout ) {\n\n\t\t\tconst type = member.type;\n\n\t\t\tconst itemSize = getMemoryLengthFromType( type ) * BYTES_PER_ELEMENT;\n\t\t\tconst boundary = getByteBoundaryFromType( type );\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk\n\t\t\tconst chunkPadding = chunkOffset % boundary; // required padding to match boundary\n\t\t\tconst chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data\n\n\t\t\toffset += chunkPadding;\n\n\t\t\t// Check for chunk overflow\n\t\t\tif ( chunkStart !== 0 && ( GPU_CHUNK_BYTES - chunkStart ) < itemSize ) {\n\n\t\t\t\t// Add padding to the end of the chunk\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkStart );\n\n\t\t\t}\n\n\t\t\toffset += itemSize;\n\n\t\t}\n\n\t\treturn ( Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES ) / BYTES_PER_ELEMENT;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tconst member = this.membersLayout.find( m => m.name === name );\n\n\t\treturn member ? member.type : 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst structType = builder.getStructTypeFromNode( this, this.membersLayout, this.name );\n\n\t\treturn structType.name;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.addInclude( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n}\n\nexport default StructTypeNode;\n"],"mappings":"OACOA,SAAU,mBACRC,wBAAyBC,4BAA+B,iBAUjE,SAASC,iBAAkBC,GAE1B,OAAOC,OAAOC,QAASF,GAAUG,KAAK,EAAIC,EAAMC,KAEzB,iBAAVA,EAEJ,CAAED,OAAME,KAAMD,EAAOE,QAAQ,GAI9B,CAAEH,OAAME,KAAMD,EAAMC,KAAMC,OAAQF,EAAME,SAAU,IAI3D,CAUA,MAAMC,uBAAuBZ,KAE5B,eAAWU,GAEV,MAAO,gBAER,CAQA,WAAAG,CAAaC,EAAeN,EAAO,MAElCO,MAAO,UAOPC,KAAKF,cAAgBX,iBAAkBW,GAQvCE,KAAKR,KAAOA,EASZQ,KAAKC,oBAAqB,CAE3B,CAQA,SAAAC,GAEC,MACMC,EAAoBC,aAAaD,kBAEvC,IAAIE,EAAS,EAEb,IAAM,MAAMC,KAAUN,KAAKF,cAAgB,CAE1C,MAAMJ,EAAOY,EAAOZ,KAEda,EAAWrB,wBAAyBQ,GAASS,EAG7CK,EAAcH,EAZG,EAajBI,EAAeD,EAHJvB,wBAAyBS,GAIpCgB,EAAaF,EAAcC,EAEjCJ,GAAUI,EAGU,IAAfC,GAnBkB,EAmBsBA,EAAeH,IAG3DF,GAtBsB,EAsBQK,GAI/BL,GAAUE,CAEX,CAEA,OA9BwB,EA8BfI,KAAKC,KAAMP,EA9BI,GA8B6CF,CAEtE,CAEA,aAAAU,CAAeC,EAAStB,GAEvB,MAAMc,EAASN,KAAKF,cAAciB,MAAMC,GAAKA,EAAExB,OAASA,IAExD,OAAOc,EAASA,EAAOZ,KAAO,MAE/B,CAEA,WAAAuB,CAAaH,GAIZ,OAFmBA,EAAQI,sBAAuBlB,KAAMA,KAAKF,cAAeE,KAAKR,MAE/DA,IAEnB,CAEA,KAAA2B,CAAOL,GAENA,EAAQM,WAAYpB,KAErB,CAEA,QAAAqB,CAAUP,GAET,OAAOd,KAAKiB,YAAaH,EAE1B,iBAIclB","ignoreList":[]}