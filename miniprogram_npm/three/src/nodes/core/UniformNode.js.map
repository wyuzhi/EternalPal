{"version":3,"file":"node_modules/three/src/nodes/core/UniformNode.js","names":["InputNode","objectGroup","nodeObject","getConstNodeType","UniformNode","type","constructor","value","nodeType","super","this","isUniformNode","name","groupNode","setName","label","console","warn","setGroup","group","getGroup","getUniformHash","builder","getHash","onUpdate","callback","updateType","self","getSelf","bind","frame","undefined","getInputType","generate","output","getNodeType","hash","sharedNode","getNodeFromHash","setHashNode","sharedNodeType","nodeUniform","getUniformFromNode","shaderStage","context","nodeName","uniformName","getPropertyName","snippet","nodeData","getDataFromNode","propertyName","nodeVar","getVarFromNode","format","addLineFlowCode","uniform","arg1","arg2","isNode","node"],"sources":["node_modules/three/src/nodes/core/UniformNode.js"],"sourcesContent":["import InputNode from './InputNode.js';\nimport { objectGroup } from './UniformGroupNode.js';\nimport { nodeObject, getConstNodeType } from '../tsl/TSLCore.js';\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform node.\n\t *\n\t * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformNode = true;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The uniform group of this uniform. By default, uniforms are\n\t\t * managed per object but they might belong to a shared group\n\t\t * which is updated per frame or render call.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tconsole.warn( 'THREE.TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#groupNode} property.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the {@link UniformNode#groupNode}.\n\t *\n\t * @return {UniformGroupNode} The uniform group.\n\t */\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\t/**\n\t * By default, this method returns the result of {@link Node#getHash} but derived\n\t * classes might overwrite this method with a different implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The uniform hash.\n\t */\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tconst self = this.getSelf();\n\n\t\tcallback = callback.bind( self );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, self );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tlet type = super.getInputType( builder );\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\ttype = 'uint';\n\n\t\t}\n\n\t\treturn type;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName );\n\t\tconst uniformName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.nodeName !== undefined ) delete builder.context.nodeName;\n\n\t\t//\n\n\t\tlet snippet = uniformName;\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\t// cache to variable\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, 'bool' );\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\tsnippet = builder.format( uniformName, sharedNodeType, type );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t}\n\n\t\t\tsnippet = propertyName;\n\n\t\t}\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default UniformNode;\n\n/**\n * TSL function for creating a uniform node.\n *\n * @tsl\n * @function\n * @param {any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {string} [arg2] - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nexport const uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n"],"mappings":"OAAOA,cAAe,wBACbC,gBAAmB,+BACnBC,WAAYC,qBAAwB,oBAO7C,MAAMC,oBAAoBJ,UAEzB,eAAWK,GAEV,MAAO,aAER,CAQA,WAAAC,CAAaC,EAAOC,EAAW,MAE9BC,MAAOF,EAAOC,GASdE,KAAKC,eAAgB,EAQrBD,KAAKE,KAAO,GASZF,KAAKG,UAAYZ,WAElB,CAQA,OAAAa,CAASF,GAIR,OAFAF,KAAKE,KAAOA,EAELF,IAER,CASA,KAAAK,CAAOH,GAIN,OAFAI,QAAQC,KAAM,sEAEPP,KAAKI,QAASF,EAEtB,CAQA,QAAAM,CAAUC,GAIT,OAFAT,KAAKG,UAAYM,EAEVT,IAER,CAOA,QAAAU,GAEC,OAAOV,KAAKG,SAEb,CASA,cAAAQ,CAAgBC,GAEf,OAAOZ,KAAKa,QAASD,EAEtB,CAEA,QAAAE,CAAUC,EAAUC,GAEnB,MAAMC,EAAOjB,KAAKkB,UAIlB,OAFAH,EAAWA,EAASI,KAAMF,GAEnBlB,MAAMe,UAAYM,IAExB,MAAMvB,EAAQkB,EAAUK,EAAOH,QAEhBI,IAAVxB,IAEJG,KAAKH,MAAQA,EAEd,GAEGmB,EAEL,CAEA,YAAAM,CAAcV,GAEb,IAAIjB,EAAOI,MAAMuB,aAAcV,GAQ/B,MANc,SAATjB,IAEJA,EAAO,QAIDA,CAER,CAEA,QAAA4B,CAAUX,EAASY,GAElB,MAAM7B,EAAOK,KAAKyB,YAAab,GAEzBc,EAAO1B,KAAKW,eAAgBC,GAElC,IAAIe,EAAaf,EAAQgB,gBAAiBF,QAEtBL,IAAfM,IAEJf,EAAQiB,YAAa7B,KAAM0B,GAE3BC,EAAa3B,MAId,MAAM8B,EAAiBH,EAAWL,aAAcV,GAE1CmB,EAAcnB,EAAQoB,mBAAoBL,EAAYG,EAAgBlB,EAAQqB,YAAajC,KAAKE,MAAQU,EAAQsB,QAAQC,UACxHC,EAAcxB,EAAQyB,gBAAiBN,QAEXV,IAA7BT,EAAQsB,QAAQC,iBAAgCvB,EAAQsB,QAAQC,SAIrE,IAAIG,EAAUF,EAEd,GAAc,SAATzC,EAAkB,CAItB,MAAM4C,EAAW3B,EAAQ4B,gBAAiBxC,MAE1C,IAAIyC,EAAeF,EAASE,aAE5B,QAAsBpB,IAAjBoB,EAA6B,CAEjC,MAAMC,EAAU9B,EAAQ+B,eAAgB3C,KAAM,KAAM,QACpDyC,EAAe7B,EAAQyB,gBAAiBK,GAExCH,EAASE,aAAeA,EAExBH,EAAU1B,EAAQgC,OAAQR,EAAaN,EAAgBnC,GAEvDiB,EAAQiC,gBAAiB,GAAIJ,OAAoBH,IAAYtC,KAE9D,CAEAsC,EAAUG,CAEX,CAEA,OAAO7B,EAAQgC,OAAQN,EAAS3C,EAAM6B,EAEvC,iBAIc9B,mBAWR,MAAMoD,QAAU,CAAEC,EAAMC,KAE9B,MAAMlD,EAAWL,iBAAkBuD,GAAQD,GAGrClD,EAAUkD,IAAwB,IAAhBA,EAAKE,OAAsBF,EAAKG,MAAQH,EAAKG,KAAKrD,OAAWkD,EAAKlD,MAAQkD,EAElG,OAAOvD,WAAY,IAAIE,YAAaG,EAAOC,GAAY","ignoreList":[]}