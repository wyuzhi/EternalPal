{"version":3,"file":"node_modules/three/src/nodes/core/VarNode.js","names":["Node","addMethodChaining","getCurrentStack","nodeProxy","VarNode","type","constructor","node","name","readOnly","super","this","global","isVarNode","parents","intent","setIntent","value","getIntent","getMemberType","builder","getElementType","getNodeType","getArrayCount","build","params","getNodeProperties","assign","generate","renderer","isWebGPUBackend","backend","isDeterministic","shouldTreatAsReadOnly","vectorType","getVectorType","snippet","nodeVar","getVarFromNode","undefined","propertyName","getPropertyName","declarationPrefix","count","getVar","addLineFlowCode","createVar","Var","toStack","Const","VarIntent","temp","console","warn"],"sources":["node_modules/three/src/nodes/core/VarNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { addMethodChaining, getCurrentStack, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\t/**\n\t * Constructs a new variable node.\n\t *\n\t * @param {Node} node - The node for which a variable should be created.\n\t * @param {?string} [name=null] - The name of the variable in the shader.\n\t * @param {boolean} [readOnly=false] - The read-only flag.\n\t */\n\tconstructor( node, name = null, readOnly = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a variable should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the variable in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * `VarNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVarNode = true;\n\n\t\t/**\n\t\t *\n\t\t * The read-only flag.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t\t/**\n\t\t *\n\t\t * Add this flag to the node system to indicate that this node require parents.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parents = true;\n\n\t\t/**\n\t\t * This flag is used to indicate that this node is used for intent.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.intent = false;\n\n\t}\n\n\t/**\n\t * Sets the intent flag for this node.\n\t *\n\t * This flag is used to indicate that this node is used for intent\n\t * and should not be built directly. Instead, it is used to indicate that\n\t * the node should be treated as a variable intent.\n\t *\n\t * It's useful for assigning variables without needing creating a new variable node.\n\t *\n\t * @param {boolean} value - The value to set for the intent flag.\n\t * @returns {VarNode} This node.\n\t */\n\tsetIntent( value ) {\n\n\t\tthis.intent = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the intent flag of this node.\n\t *\n\t * @return {boolean} The intent flag.\n\t */\n\tgetIntent() {\n\n\t\treturn this.intent;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetArrayCount( builder ) {\n\n\t\treturn this.node.getArrayCount( builder );\n\n\t}\n\n\tbuild( ...params ) {\n\n\t\tif ( this.intent === true ) {\n\n\t\t\tconst builder = params[ 0 ];\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.assign !== true ) {\n\n\t\t\t\treturn this.node.build( ...params );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( ...params );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name, readOnly } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst isWebGPUBackend = renderer.backend.isWebGPUBackend === true;\n\n\t\tlet isDeterministic = false;\n\t\tlet shouldTreatAsReadOnly = false;\n\n\t\tif ( readOnly ) {\n\n\t\t\tisDeterministic = builder.isDeterministic( node );\n\n\t\t\tshouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;\n\n\t\t}\n\n\t\tconst vectorType = builder.getVectorType( this.getNodeType( builder ) );\n\t\tconst snippet = node.build( builder, vectorType );\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, vectorType, undefined, shouldTreatAsReadOnly );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tlet declarationPrefix = propertyName;\n\n\t\tif ( shouldTreatAsReadOnly ) {\n\n\t\t\tif ( isWebGPUBackend ) {\n\n\t\t\t\tdeclarationPrefix = isDeterministic\n\t\t\t\t\t? `const ${ propertyName }`\n\t\t\t\t\t: `let ${ propertyName }`;\n\n\t\t\t} else {\n\n\t\t\t\tconst count = node.getArrayCount( builder );\n\n\t\t\t\tdeclarationPrefix = `const ${ builder.getVar( nodeVar.type, propertyName, count ) }`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.addLineFlowCode( `${ declarationPrefix } = ${ snippet }`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nexport default VarNode;\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nexport const Var = ( node, name = null ) => createVar( node, name ).toStack();\n\n/**\n * TSL function for creating a const node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a constant should be created.\n * @param {?string} name - The name of the constant in the shader.\n * @returns {VarNode}\n */\nexport const Const = ( node, name = null ) => createVar( node, name, true ).toStack();\n\n//\n//\n\n/**\n * TSL function for creating a var intent node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nexport const VarIntent = ( node ) => {\n\n\tif ( getCurrentStack() === null ) {\n\n\t\treturn node;\n\n\t}\n\n\treturn createVar( node ).setIntent( true ).toStack();\n\n};\n\n// Method chaining\n\naddMethodChaining( 'toVar', Var );\naddMethodChaining( 'toConst', Const );\naddMethodChaining( 'toVarIntent', VarIntent );\n\n// Deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r170. Use `Var( node )` or `node.toVar()` instead.\n *\n * @param {any} node\n * @returns {VarNode}\n */\nexport const temp = ( node ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: \"temp( node )\" is deprecated. Use \"Var( node )\" or \"node.toVar()\" instead.' );\n\n\treturn createVar( node );\n\n};\n\naddMethodChaining( 'temp', temp );\n\n"],"mappings":"OAAOA,SAAU,mBACRC,kBAAmBC,gBAAiBC,cAAiB,oBAY9D,MAAMC,gBAAgBJ,KAErB,eAAWK,GAEV,MAAO,SAER,CASA,WAAAC,CAAaC,EAAMC,EAAO,KAAMC,GAAW,GAE1CC,QAOAC,KAAKJ,KAAOA,EASZI,KAAKH,KAAOA,EAQZG,KAAKC,QAAS,EASdD,KAAKE,WAAY,EASjBF,KAAKF,SAAWA,EAShBE,KAAKG,SAAU,EAQfH,KAAKI,QAAS,CAEf,CAcA,SAAAC,CAAWC,GAIV,OAFAN,KAAKI,OAASE,EAEPN,IAER,CAOA,SAAAO,GAEC,OAAOP,KAAKI,MAEb,CAEA,aAAAI,CAAeC,EAASZ,GAEvB,OAAOG,KAAKJ,KAAKY,cAAeC,EAASZ,EAE1C,CAEA,cAAAa,CAAgBD,GAEf,OAAOT,KAAKJ,KAAKc,eAAgBD,EAElC,CAEA,WAAAE,CAAaF,GAEZ,OAAOT,KAAKJ,KAAKe,YAAaF,EAE/B,CAEA,aAAAG,CAAeH,GAEd,OAAOT,KAAKJ,KAAKgB,cAAeH,EAEjC,CAEA,KAAAI,IAAUC,GAET,IAAqB,IAAhBd,KAAKI,OAAkB,CAK3B,IAA2B,IAHXU,EAAQ,GACGC,kBAAmBf,MAE9BgB,OAEf,OAAOhB,KAAKJ,KAAKiB,SAAUC,EAI7B,CAEA,OAAOf,MAAMc,SAAUC,EAExB,CAEA,QAAAG,CAAUR,GAET,MAAMb,KAAEA,EAAIC,KAAEA,EAAIC,SAAEA,GAAaE,MAC3BkB,SAAEA,GAAaT,EAEfU,GAAuD,IAArCD,EAASE,QAAQD,gBAEzC,IAAIE,GAAkB,EAClBC,GAAwB,EAEvBxB,IAEJuB,EAAkBZ,EAAQY,gBAAiBzB,GAE3C0B,EAAwBH,EAAkBrB,EAAWuB,GAItD,MAAME,EAAad,EAAQe,cAAexB,KAAKW,YAAaF,IACtDgB,EAAU7B,EAAKiB,MAAOJ,EAASc,GAE/BG,EAAUjB,EAAQkB,eAAgB3B,KAAMH,EAAM0B,OAAYK,EAAWN,GAErEO,EAAepB,EAAQqB,gBAAiBJ,GAE9C,IAAIK,EAAoBF,EAExB,GAAKP,EAEJ,GAAKH,EAEJY,EAAoBV,EACjB,SAAUQ,IACV,OAAQA,QAEL,CAEN,MAAMG,EAAQpC,EAAKgB,cAAeH,GAElCsB,EAAoB,SAAUtB,EAAQwB,OAAQP,EAAQhC,KAAMmC,EAAcG,IAE3E,CAMD,OAFAvB,EAAQyB,gBAAiB,GAAIH,OAAyBN,IAAYzB,MAE3D6B,CAER,iBAIcpC,QAWf,MAAM0C,UAA0B3C,UAAWC,gBAWpC,MAAM2C,IAAM,CAAExC,EAAMC,EAAO,OAAUsC,UAAWvC,EAAMC,GAAOwC,iBAW7D,MAAMC,MAAQ,CAAE1C,EAAMC,EAAO,OAAUsC,UAAWvC,EAAMC,GAAM,GAAOwC,iBAcrE,MAAME,UAAc3C,GAEC,OAAtBL,kBAEGK,EAIDuC,UAAWvC,GAAOS,WAAW,GAAOgC,UAM5C/C,kBAAmB,QAAS8C,KAC5B9C,kBAAmB,UAAWgD,OAC9BhD,kBAAmB,cAAeiD,kBAY3B,MAAMC,KAAS5C,IAErB6C,QAAQC,KAAM,mFAEPP,UAAWvC,IAInBN,kBAAmB,OAAQkD","ignoreList":[]}