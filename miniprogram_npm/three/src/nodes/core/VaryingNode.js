import Node from"./Node.js";import{NodeShaderStage}from"./constants.js";import{addMethodChaining,nodeProxy}from"../tsl/TSLCore.js";import{subBuild}from"./SubBuildNode.js";class VaryingNode extends Node{static get type(){return"VaryingNode"}constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0,this.interpolationType=null,this.interpolationSampling=null,this.global=!0}setInterpolation(e,t=null){return this.interpolationType=e,this.interpolationSampling=t,this}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}setupVarying(e){const t=e.getNodeProperties(this);let o=t.varying;if(void 0===o){const r=this.name,n=this.getNodeType(e),a=this.interpolationType,i=this.interpolationSampling;t.varying=o=e.getVaryingFromNode(this,r,n,a,i),t.node=subBuild(this.node,"VERTEX")}return o.needsInterpolation||(o.needsInterpolation="fragment"===e.shaderStage),o}setup(e){this.setupVarying(e),e.flowNodeFromShaderStage(NodeShaderStage.VERTEX,this.node)}analyze(e){this.setupVarying(e),e.flowNodeFromShaderStage(NodeShaderStage.VERTEX,this.node)}generate(e){const t=e.getSubBuildProperty("property",e.currentStack),o=e.getNodeProperties(this),r=this.setupVarying(e);if(void 0===o[t]){const n=this.getNodeType(e),a=e.getPropertyName(r,NodeShaderStage.VERTEX);e.flowNodeFromShaderStage(NodeShaderStage.VERTEX,o.node,n,a),o[t]=a}return e.getPropertyName(r)}}export default VaryingNode;export const varying=nodeProxy(VaryingNode).setParameterLength(1,2);export const vertexStage=e=>varying(e);addMethodChaining("toVarying",varying),addMethodChaining("toVertexStage",vertexStage),addMethodChaining("varying",((...e)=>(console.warn("THREE.TSL: .varying() has been renamed to .toVarying()."),varying(...e)))),addMethodChaining("vertexStage",((...e)=>(console.warn("THREE.TSL: .vertexStage() has been renamed to .toVertexStage()."),varying(...e))));
//# sourceMappingURL=VaryingNode.js.map