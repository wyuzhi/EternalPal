{"version":3,"file":"node_modules/three/src/nodes/core/VaryingNode.js","names":["Node","NodeShaderStage","addMethodChaining","nodeProxy","subBuild","VaryingNode","type","constructor","node","name","super","this","isVaryingNode","interpolationType","interpolationSampling","global","setInterpolation","sampling","getHash","builder","getNodeType","setupVarying","properties","getNodeProperties","varying","undefined","getVaryingFromNode","needsInterpolation","shaderStage","setup","flowNodeFromShaderStage","VERTEX","analyze","generate","propertyKey","getSubBuildProperty","currentStack","propertyName","getPropertyName","setParameterLength","vertexStage","params","console","warn"],"sources":["node_modules/three/src/nodes/core/VaryingNode.js"],"sourcesContent":["import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\nimport { subBuild } from './SubBuildNode.js';\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new varying node.\n\t *\n\t * @param {Node} node - The node for which a varying should be created.\n\t * @param {?string} name - The name of the varying in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a varying should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the varying in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVaryingNode = true;\n\n\t\t/**\n\t\t * The interpolation type of the varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationType = null;\n\n\t\t/**\n\t\t * The interpolation sampling type of varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationSampling = null;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Defines the interpolation type of the varying.\n\t *\n\t * @param {string} type - The interpolation type.\n\t * @param {?string} sampling - The interpolation sampling type\n\t * @return {VaryingNode} A reference to this node.\n\t */\n\tsetInterpolation( type, sampling = null ) {\n\n\t\tthis.interpolationType = type;\n\t\tthis.interpolationSampling = sampling;\n\n\t\treturn this;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method performs the setup of a varying node with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeVarying} The node varying from the node builder.\n\t */\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst interpolationType = this.interpolationType;\n\t\t\tconst interpolationSampling = this.interpolationSampling;\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type, interpolationType, interpolationSampling );\n\t\t\tproperties.node = subBuild( this.node, 'VERTEX' );\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyKey = builder.getSubBuildProperty( 'property', builder.currentStack );\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tif ( properties[ propertyKey ] === undefined ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, properties.node, type, propertyName );\n\n\t\t\tproperties[ propertyKey ] = propertyName;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\nexport default VaryingNode;\n\n/**\n * TSL function for creating a varying node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {?string} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nexport const varying = /*@__PURE__*/ nodeProxy( VaryingNode ).setParameterLength( 1, 2 );\n\n/**\n * Computes a node in the vertex stage.\n *\n * @tsl\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nexport const vertexStage = ( node ) => varying( node );\n\naddMethodChaining( 'toVarying', varying );\naddMethodChaining( 'toVertexStage', vertexStage );\n\n// Deprecated\n\naddMethodChaining( 'varying', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'THREE.TSL: .varying() has been renamed to .toVarying().' );\n\treturn varying( ...params );\n\n} );\n\naddMethodChaining( 'vertexStage', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'THREE.TSL: .vertexStage() has been renamed to .toVertexStage().' );\n\treturn varying( ...params );\n\n} );\n"],"mappings":"OAAOA,SAAU,mBACRC,oBAAuB,wBACvBC,kBAAmBC,cAAiB,2BACpCC,aAAgB,oBAYzB,MAAMC,oBAAoBL,KAEzB,eAAWM,GAEV,MAAO,aAER,CAQA,WAAAC,CAAaC,EAAMC,EAAO,MAEzBC,QAOAC,KAAKH,KAAOA,EASZG,KAAKF,KAAOA,EASZE,KAAKC,eAAgB,EAQrBD,KAAKE,kBAAoB,KAQzBF,KAAKG,sBAAwB,KAQ7BH,KAAKI,QAAS,CAEf,CASA,gBAAAC,CAAkBV,EAAMW,EAAW,MAKlC,OAHAN,KAAKE,kBAAoBP,EACzBK,KAAKG,sBAAwBG,EAEtBN,IAER,CAEA,OAAAO,CAASC,GAER,OAAOR,KAAKF,MAAQC,MAAMQ,QAASC,EAEpC,CAEA,WAAAC,CAAaD,GAIZ,OAAOR,KAAKH,KAAKY,YAAaD,EAE/B,CAQA,YAAAE,CAAcF,GAEb,MAAMG,EAAaH,EAAQI,kBAAmBZ,MAE9C,IAAIa,EAAUF,EAAWE,QAEzB,QAAiBC,IAAZD,EAAwB,CAE5B,MAAMf,EAAOE,KAAKF,KACZH,EAAOK,KAAKS,YAAaD,GACzBN,EAAoBF,KAAKE,kBACzBC,EAAwBH,KAAKG,sBAEnCQ,EAAWE,QAAUA,EAAUL,EAAQO,mBAAoBf,KAAMF,EAAMH,EAAMO,EAAmBC,GAChGQ,EAAWd,KAAOJ,SAAUO,KAAKH,KAAM,SAExC,CAKA,OAFAgB,EAAQG,qBAAwBH,EAAQG,mBAA+C,aAAxBR,EAAQS,aAEhEJ,CAER,CAEA,KAAAK,CAAOV,GAENR,KAAKU,aAAcF,GAEnBA,EAAQW,wBAAyB7B,gBAAgB8B,OAAQpB,KAAKH,KAE/D,CAEA,OAAAwB,CAASb,GAERR,KAAKU,aAAcF,GAEnBA,EAAQW,wBAAyB7B,gBAAgB8B,OAAQpB,KAAKH,KAE/D,CAEA,QAAAyB,CAAUd,GAET,MAAMe,EAAcf,EAAQgB,oBAAqB,WAAYhB,EAAQiB,cAC/Dd,EAAaH,EAAQI,kBAAmBZ,MACxCa,EAAUb,KAAKU,aAAcF,GAEnC,QAAmCM,IAA9BH,EAAYY,GAA8B,CAE9C,MAAM5B,EAAOK,KAAKS,YAAaD,GACzBkB,EAAelB,EAAQmB,gBAAiBd,EAASvB,gBAAgB8B,QAGvEZ,EAAQW,wBAAyB7B,gBAAgB8B,OAAQT,EAAWd,KAAMF,EAAM+B,GAEhFf,EAAYY,GAAgBG,CAE7B,CAEA,OAAOlB,EAAQmB,gBAAiBd,EAEjC,iBAIcnB,mBAWR,MAAMmB,QAAwBrB,UAAWE,aAAckC,mBAAoB,EAAG,UAU9E,MAAMC,YAAgBhC,GAAUgB,QAAShB,GAEhDN,kBAAmB,YAAasB,SAChCtB,kBAAmB,gBAAiBsC,aAIpCtC,kBAAmB,WAAW,IAAKuC,KAElCC,QAAQC,KAAM,2DACPnB,WAAYiB,MAIpBvC,kBAAmB,eAAe,IAAKuC,KAEtCC,QAAQC,KAAM,mEACPnB,WAAYiB","ignoreList":[]}