import TempNode from"../core/TempNode.js";import{addMethodChaining,mat3,nodeObject,vec4}from"../tsl/TSLCore.js";import{SRGBTransfer}from"../../constants.js";import{ColorManagement}from"../../math/ColorManagement.js";import{sRGBTransferEOTF,sRGBTransferOETF}from"./ColorSpaceFunctions.js";import{Matrix3}from"../../math/Matrix3.js";const WORKING_COLOR_SPACE="WorkingColorSpace",OUTPUT_COLOR_SPACE="OutputColorSpace";class ColorSpaceNode extends TempNode{static get type(){return"ColorSpaceNode"}constructor(o,e,r){super("vec4"),this.colorNode=o,this.source=e,this.target=r}resolveColorSpace(o,e){return"WorkingColorSpace"===e?ColorManagement.workingColorSpace:"OutputColorSpace"===e?o.context.outputColorSpace||o.renderer.outputColorSpace:e}setup(o){const{colorNode:e}=this,r=this.resolveColorSpace(o,this.source),t=this.resolveColorSpace(o,this.target);let a=e;return!1!==ColorManagement.enabled&&r!==t&&r&&t?(ColorManagement.getTransfer(r)===SRGBTransfer&&(a=vec4(sRGBTransferEOTF(a.rgb),a.a)),ColorManagement.getPrimaries(r)!==ColorManagement.getPrimaries(t)&&(a=vec4(mat3(ColorManagement._getMatrix(new Matrix3,r,t)).mul(a.rgb),a.a)),ColorManagement.getTransfer(t)===SRGBTransfer&&(a=vec4(sRGBTransferOETF(a.rgb),a.a)),a):a}}export default ColorSpaceNode;export const workingToColorSpace=(o,e)=>nodeObject(new ColorSpaceNode(nodeObject(o),"WorkingColorSpace",e));export const colorSpaceToWorking=(o,e)=>nodeObject(new ColorSpaceNode(nodeObject(o),e,"WorkingColorSpace"));export const convertColorSpace=(o,e,r)=>nodeObject(new ColorSpaceNode(nodeObject(o),e,r));addMethodChaining("workingToColorSpace",workingToColorSpace),addMethodChaining("colorSpaceToWorking",colorSpaceToWorking);
//# sourceMappingURL=ColorSpaceNode.js.map