{"version":3,"file":"node_modules/three/src/nodes/display/FrontFacingNode.js","names":["Node","nodeImmutable","float","Fn","BackSide","DoubleSide","WebGLCoordinateSystem","FrontFacingNode","type","constructor","super","this","isFrontFacingNode","generate","builder","shaderStage","renderer","material","coordinateSystem","side","getFrontFacing","frontFacing","faceDirection","mul","sub","directionToFaceDirection","direction"],"sources":["node_modules/three/src/nodes/display/FrontFacingNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { nodeImmutable, float, Fn } from '../tsl/TSLBase.js';\n\nimport { BackSide, DoubleSide, WebGLCoordinateSystem } from '../../constants.js';\n\n/**\n * This node can be used to evaluate whether a primitive is front or back facing.\n *\n * @augments Node\n */\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new front facing node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( builder.shaderStage !== 'fragment' ) return 'true';\n\n\t\t//\n\n\t\tconst { renderer, material } = builder;\n\n\t\tif ( renderer.coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\treturn 'false';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\nexport default FrontFacingNode;\n\n/**\n * TSL object that represents whether a primitive is front or back facing\n *\n * @tsl\n * @type {FrontFacingNode<bool>}\n */\nexport const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\n\n/**\n * TSL object that represents the front facing status as a number instead of a bool.\n * `1` means front facing, `-1` means back facing.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\n/**\n * Converts a direction vector to a face direction vector based on the material's side.\n *\n * If the material is set to `BackSide`, the direction is inverted.\n * If the material is set to `DoubleSide`, the direction is multiplied by `faceDirection`.\n *\n * @tsl\n * @param {Node<vec3>} direction - The direction vector to convert.\n * @returns {Node<vec3>} The converted direction vector.\n */\nexport const directionToFaceDirection = /*@__PURE__*/ Fn( ( [ direction ], { material } ) => {\n\n\tconst side = material.side;\n\n\tif ( side === BackSide ) {\n\n\t\tdirection = direction.mul( - 1.0 );\n\n\t} else if ( side === DoubleSide ) {\n\n\t\tdirection = direction.mul( faceDirection );\n\n\t}\n\n\treturn direction;\n\n} );\n"],"mappings":"OAAOA,SAAU,yBACRC,cAAeC,MAAOC,OAAU,2BAEhCC,SAAUC,WAAYC,0BAA6B,qBAO5D,MAAMC,wBAAwBP,KAE7B,eAAWQ,GAEV,MAAO,iBAER,CAKA,WAAAC,GAECC,MAAO,QASPC,KAAKC,mBAAoB,CAE1B,CAEA,QAAAC,CAAUC,GAET,GAA6B,aAAxBA,EAAQC,YAA6B,MAAO,OAIjD,MAAMC,SAAEA,EAAQC,SAAEA,GAAaH,EAE/B,OAAKE,EAASE,mBAAqBZ,uBAE7BW,EAASE,OAASf,SAEf,QAMFU,EAAQM,gBAEhB,iBAIcb,uBAQR,MAAMc,YAA4BpB,cAAeM,wBASjD,MAAMe,cAA8BpB,MAAOmB,aAAcE,IAAK,GAAMC,IAAK,UAYzE,MAAMC,yBAAyCtB,IAAI,EAAIuB,IAAeT,eAE5E,MAAME,EAAOF,EAASE,KAYtB,OAVKA,IAASf,SAEbsB,EAAYA,EAAUH,KAAO,GAElBJ,IAASd,aAEpBqB,EAAYA,EAAUH,IAAKD,gBAIrBI,CAAS","ignoreList":[]}