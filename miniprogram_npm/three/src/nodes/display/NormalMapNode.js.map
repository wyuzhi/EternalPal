{"version":3,"file":"node_modules/three/src/nodes/display/NormalMapNode.js","names":["TempNode","normalView","transformNormalToView","TBNViewMatrix","nodeProxy","vec3","TangentSpaceNormalMap","ObjectSpaceNormalMap","directionToFaceDirection","NormalMapNode","type","constructor","node","scaleNode","super","this","normalMapType","setup","material","normalMap","mul","sub","scale","flatShading","xy","z","output","normalize","console","error","setParameterLength"],"sources":["node_modules/three/src/nodes/display/NormalMapNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\n\nimport { normalView, transformNormalToView } from '../accessors/Normal.js';\nimport { TBNViewMatrix } from '../accessors/AccessorsUtils.js';\nimport { nodeProxy, vec3 } from '../tsl/TSLBase.js';\n\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from '../../constants.js';\nimport { directionToFaceDirection } from './FrontFacingNode.js';\n\n/**\n * This class can be used for applying normals maps to materials.\n *\n * ```js\n * material.normalNode = normalMap( texture( normalTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new normal map node.\n\t *\n\t * @param {Node<vec3>} node - Represents the normal map data.\n\t * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.\n\t */\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the normal map data.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Controls the intensity of the effect.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * The normal map type.\n\t\t *\n\t\t * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}\n\t\t * @default TangentSpaceNormalMap\n\t\t */\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( { material } ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tlet scale = scaleNode;\n\n\t\t\tif ( material.flatShading === true ) {\n\n\t\t\t\tscale = directionToFaceDirection( scale );\n\n\t\t\t}\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scale ), normalMap.z );\n\n\t\t}\n\n\t\tlet output = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutput = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\toutput = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t} else {\n\n\t\t\tconsole.error( `THREE.NodeMaterial: Unsupported normal map type: ${ normalMapType }` );\n\n\t\t\toutput = normalView; // Fallback to default normal view\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default NormalMapNode;\n\n/**\n * TSL function for creating a normal map node.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} node - Represents the normal map data.\n * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.\n * @returns {NormalMapNode}\n */\nexport const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode ).setParameterLength( 1, 2 );\n"],"mappings":"OAAOA,aAAc,6BAEZC,WAAYC,0BAA6B,gCACzCC,kBAAqB,wCACrBC,UAAWC,SAAY,2BAEvBC,sBAAuBC,yBAA4B,4BACnDC,6BAAgC,uBAWzC,MAAMC,sBAAsBT,SAE3B,eAAWU,GAEV,MAAO,eAER,CAQA,WAAAC,CAAaC,EAAMC,EAAY,MAE9BC,MAAO,QAOPC,KAAKH,KAAOA,EAQZG,KAAKF,UAAYA,EAQjBE,KAAKC,cAAgBV,qBAEtB,CAEA,KAAAW,EAAOC,SAAEA,IAER,MAAMF,cAAEA,EAAaH,UAAEA,GAAcE,KAErC,IAAII,EAAYJ,KAAKH,KAAKQ,IAAK,GAAMC,IAAK,GAE1C,GAAmB,OAAdR,EAAqB,CAEzB,IAAIS,EAAQT,GAEkB,IAAzBK,EAASK,cAEbD,EAAQd,yBAA0Bc,IAInCH,EAAYd,KAAMc,EAAUK,GAAGJ,IAAKE,GAASH,EAAUM,EAExD,CAEA,IAAIC,EAAS,KAkBb,OAhBKV,IAAkBT,qBAEtBmB,EAASxB,sBAAuBiB,GAErBH,IAAkBV,sBAE7BoB,EAASvB,cAAciB,IAAKD,GAAYQ,aAIxCC,QAAQC,MAAO,oDAAqDb,KAEpEU,EAASzB,YAIHyB,CAER,iBAIcjB,qBAWR,MAAMU,UAA0Bf,UAAWK,eAAgBqB,mBAAoB,EAAG","ignoreList":[]}