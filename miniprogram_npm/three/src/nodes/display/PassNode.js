import TempNode from"../core/TempNode.js";import{default as TextureNode}from"../accessors/TextureNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeObject}from"../tsl/TSLBase.js";import{uniform}from"../core/UniformNode.js";import{viewZToOrthographicDepth,perspectiveDepthToViewZ}from"./ViewportDepthNode.js";import{HalfFloatType}from"../../constants.js";import{Vector2}from"../../math/Vector2.js";import{Vector4}from"../../math/Vector4.js";import{DepthTexture}from"../../textures/DepthTexture.js";import{RenderTarget}from"../../core/RenderTarget.js";const _size=new Vector2;class PassTextureNode extends TextureNode{static get type(){return"PassTextureNode"}constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class PassMultipleTextureNode extends PassTextureNode{static get type(){return"PassMultipleTextureNode"}constructor(e,t,s=!1){super(e,null),this.textureName=t,this.previousTexture=s}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(e){return this.updateTexture(),super.setup(e)}clone(){const e=new this.constructor(this.passNode,this.textureName,this.previousTexture);return e.uvNode=this.uvNode,e.levelNode=this.levelNode,e.biasNode=this.biasNode,e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e}}class PassNode extends TempNode{static get type(){return"PassNode"}constructor(e,t,s,r={}){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this.options=r,this._pixelRatio=1,this._width=1,this._height=1;const i=new DepthTexture;i.isRenderTargetTexture=!0,i.name="depth";const o=new RenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:HalfFloatType,...r});o.texture.name="output",o.depthTexture=i,this.renderTarget=o,this._textures={output:o.texture,depth:i},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=uniform(0),this._cameraFar=uniform(0),this._mrt=null,this._layers=null,this._resolution=1,this._viewport=null,this._scissor=null,this.isPassNode=!0,this.updateBeforeType=NodeUpdateType.FRAME,this.global=!0}setResolution(e){return this._resolution=e,this}getResolution(){return this._resolution}setLayers(e){return this._layers=e,this}getLayers(){return this._layers}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}getTexture(e){let t=this._textures[e];if(void 0===t){t=this.renderTarget.texture.clone(),t.name=e,this._textures[e]=t,this.renderTarget.textures.push(t)}return t}getPreviousTexture(e){let t=this._previousTextures[e];return void 0===t&&(t=this.getTexture(e).clone(),this._previousTextures[e]=t),t}toggleTexture(e){const t=this._previousTextures[e];if(void 0!==t){const s=this._textures[e],r=this.renderTarget.textures.indexOf(s);this.renderTarget.textures[r]=t,this._textures[e]=t,this._previousTextures[e]=s,this._textureNodes[e].updateTexture(),this._previousTextureNodes[e].updateTexture()}}getTextureNode(e="output"){let t=this._textureNodes[e];return void 0===t&&(t=nodeObject(new PassMultipleTextureNode(this,e)),t.updateTexture(),this._textureNodes[e]=t),t}getPreviousTextureNode(e="output"){let t=this._previousTextureNodes[e];return void 0===t&&(void 0===this._textureNodes[e]&&this.getTextureNode(e),t=nodeObject(new PassMultipleTextureNode(this,e,!0)),t.updateTexture(),this._previousTextureNodes[e]=t),t}getViewZNode(e="depth"){let t=this._viewZNodes[e];if(void 0===t){const s=this._cameraNear,r=this._cameraFar;this._viewZNodes[e]=t=perspectiveDepthToViewZ(this.getTextureNode(e),s,r)}return t}getLinearDepthNode(e="depth"){let t=this._linearDepthNodes[e];if(void 0===t){const s=this._cameraNear,r=this._cameraFar,i=this.getViewZNode(e);this._linearDepthNodes[e]=t=viewZToOrthographicDepth(i,s,r)}return t}async compileAsync(e){const t=e.getRenderTarget(),s=e.getMRT();e.setRenderTarget(this.renderTarget),e.setMRT(this._mrt),await e.compileAsync(this.scene,this.camera),e.setRenderTarget(t),e.setMRT(s)}setup({renderer:e}){return this.renderTarget.samples=void 0===this.options.samples?e.samples:this.options.samples,this.renderTarget.texture.type=e.getColorBufferType(),this.scope===PassNode.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s}=this;let r,i;const o=t.getOutputRenderTarget();o&&!0===o.isXRRenderTarget?(i=1,r=t.xr.getCamera(),t.xr.updateCamera(r),_size.set(o.width,o.height)):(r=this.camera,i=t.getPixelRatio(),t.getSize(_size)),this._pixelRatio=i,this.setSize(_size.width,_size.height);const h=t.getRenderTarget(),a=t.getMRT(),u=r.layers.mask;this._cameraNear.value=r.near,this._cameraFar.value=r.far,null!==this._layers&&(r.layers.mask=this._layers.mask);for(const e in this._previousTextures)this.toggleTexture(e);t.setRenderTarget(this.renderTarget),t.setMRT(this._mrt),t.render(s,r),t.setRenderTarget(h),t.setMRT(a),r.layers.mask=u}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio*this._resolution,r=this._height*this._pixelRatio*this._resolution;this.renderTarget.setSize(s,r),null!==this._scissor&&this.renderTarget.scissor.copy(this._scissor),null!==this._viewport&&this.renderTarget.viewport.copy(this._viewport)}setScissor(e,t,s,r){null===e?this._scissor=null:(null===this._scissor&&(this._scissor=new Vector4),e.isVector4?this._scissor.copy(e):this._scissor.set(e,t,s,r),this._scissor.multiplyScalar(this._pixelRatio*this._resolution).floor())}setViewport(e,t,s,r){null===e?this._viewport=null:(null===this._viewport&&(this._viewport=new Vector4),e.isVector4?this._viewport.copy(e):this._viewport.set(e,t,s,r),this._viewport.multiplyScalar(this._pixelRatio*this._resolution).floor())}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}PassNode.COLOR="color",PassNode.DEPTH="depth";export default PassNode;export const pass=(e,t,s)=>nodeObject(new PassNode(PassNode.COLOR,e,t,s));export const passTexture=(e,t)=>nodeObject(new PassTextureNode(e,t));export const depthPass=(e,t,s)=>nodeObject(new PassNode(PassNode.DEPTH,e,t,s));
//# sourceMappingURL=PassNode.js.map