{"version":3,"file":"node_modules/three/src/nodes/display/PassNode.js","names":["TempNode","TextureNode","NodeUpdateType","nodeObject","uniform","viewZToOrthographicDepth","perspectiveDepthToViewZ","HalfFloatType","Vector2","Vector4","DepthTexture","RenderTarget","_size","PassTextureNode","type","constructor","passNode","texture","super","this","setUpdateMatrix","setup","builder","build","clone","value","PassMultipleTextureNode","textureName","previousTexture","updateTexture","getPreviousTexture","getTexture","newNode","uvNode","levelNode","biasNode","sampler","depthNode","compareNode","gradNode","PassNode","scope","scene","camera","options","_pixelRatio","_width","_height","depthTexture","isRenderTargetTexture","name","renderTarget","_textures","output","depth","_textureNodes","_linearDepthNodes","_viewZNodes","_previousTextures","_previousTextureNodes","_cameraNear","_cameraFar","_mrt","_layers","_resolution","_viewport","_scissor","isPassNode","updateBeforeType","FRAME","global","setResolution","resolution","getResolution","setLayers","layers","getLayers","setMRT","mrt","getMRT","undefined","textures","push","toggleTexture","prevTexture","index","indexOf","getTextureNode","textureNode","getPreviousTextureNode","getViewZNode","viewZNode","cameraNear","cameraFar","getLinearDepthNode","linearDepthNode","compileAsync","renderer","currentRenderTarget","getRenderTarget","currentMRT","setRenderTarget","samples","getColorBufferType","COLOR","updateBefore","frame","pixelRatio","outputRenderTarget","getOutputRenderTarget","isXRRenderTarget","xr","getCamera","updateCamera","set","width","height","getPixelRatio","getSize","setSize","currentMask","mask","near","far","render","effectiveWidth","effectiveHeight","scissor","copy","viewport","setScissor","x","y","isVector4","multiplyScalar","floor","setViewport","setPixelRatio","dispose","DEPTH","pass","passTexture","depthPass"],"sources":["node_modules/three/src/nodes/display/PassNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { default as TextureNode/*, texture*/ } from '../accessors/TextureNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { viewZToOrthographicDepth, perspectiveDepthToViewZ } from './ViewportDepthNode.js';\n\nimport { HalfFloatType/*, FloatType*/ } from '../../constants.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport { RenderTarget } from '../../core/RenderTarget.js';\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * Represents the texture of a pass node.\n *\n * @augments TextureNode\n */\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {Texture} texture - The output texture.\n\t */\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\t/**\n\t\t * A reference to the pass node.\n\t\t *\n\t\t * @type {PassNode}\n\t\t */\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\n/**\n * An extension of `PassTextureNode` which allows to manage more than one\n * internal texture. Relevant for the `getPreviousTexture()` related API.\n *\n * @augments PassTextureNode\n */\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {string} textureName - The output texture name.\n\t * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.\n\t */\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\t// null is passed to the super call since this class does not\n\t\t// use an external texture for rendering pass data into. Instead\n\t\t// the texture is managed by the pass node itself\n\n\t\tsuper( passNode, null );\n\n\t\t/**\n\t\t * The output texture name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.textureName = textureName;\n\n\t\t/**\n\t\t * Whether previous frame data should be used or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\t/**\n\t * Updates the texture reference of this node.\n\t */\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\t\tnewNode.uvNode = this.uvNode;\n\t\tnewNode.levelNode = this.levelNode;\n\t\tnewNode.biasNode = this.biasNode;\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * Represents a render pass (sometimes called beauty pass) in context of post processing.\n * This pass produces a render for the given scene and camera and can provide multiple outputs\n * via MRT for further processing.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * @augments TempNode\n */\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass node.\n\t *\n\t * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Object} options - Options for the internal render target.\n\t */\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The scope of the pass. The scope determines whether the node outputs color or depth.\n\t\t *\n\t\t * @type {('color'|'depth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * A reference to the camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Options for the internal render target.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.options = options;\n\n\t\t/**\n\t\t * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._width = 1;\n\n\t\t/**\n\t\t * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\t/**\n\t\t * The pass's render target.\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * A dictionary holding the internal result textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, Texture>}\n\t\t */\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\t/**\n\t\t * A dictionary holding the internal texture nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, TextureNode>}\n\t\t */\n\t\tthis._textureNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal depth nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._linearDepthNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal viewZ nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._viewZNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture data of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, Texture>}\n\t\t */\n\t\tthis._previousTextures = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture nodes of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, TextureNode>}\n\t\t */\n\t\tthis._previousTextureNodes = {};\n\n\t\t/**\n\t\t * The `near` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraNear = uniform( 0 );\n\n\t\t/**\n\t\t * The `far` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\t/**\n\t\t * A MRT node configuring the MRT settings.\n\t\t *\n\t\t * @private\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * Layer object for configuring the camera that is used\n\t\t * to produce the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?Layers}\n\t\t * @default null\n\t\t */\n\t\tthis._layers = null;\n\n\t\t/**\n\t\t * Scales the resolution of the internal render target.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._resolution = 1;\n\n\t\t/**\n\t\t * Custom viewport definition.\n\t\t *\n\t\t * @private\n\t\t * @type {?Vector4}\n\t\t * @default null\n\t\t */\n\t\tthis._viewport = null;\n\n\t\t/**\n\t\t * Custom scissor definition.\n\t\t *\n\t\t * @private\n\t\t * @type {?Vector4}\n\t\t * @default null\n\t\t */\n\t\tthis._scissor = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPassNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link PassNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Sets the resolution for the pass.\n\t * The resolution is a factor that is multiplied with the renderer's width and height.\n\t *\n\t * @param {number} resolution - The resolution to set. A value of `1` means full resolution.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetResolution( resolution ) {\n\n\t\tthis._resolution = resolution;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current resolution of the pass.\n\t *\n\t * @return {number} The current resolution. A value of `1` means full resolution.\n\t */\n\tgetResolution() {\n\n\t\treturn this._resolution;\n\n\t}\n\n\t/**\n\t * Sets the layer configuration that should be used when rendering the pass.\n\t *\n\t * @param {Layers} layers - The layers object to set.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetLayers( layers ) {\n\n\t\tthis._layers = layers;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current layer configuration of the pass.\n\t *\n\t * @return {?Layers} .\n\t */\n\tgetLayers() {\n\n\t\treturn this._layers;\n\n\t}\n\n\t/**\n\t * Sets the given MRT node to setup MRT for this pass.\n\t *\n\t * @param {MRTNode} mrt - The MRT object.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the current MRT node.\n\t *\n\t * @return {MRTNode} The current MRT node.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Returns the texture for the given output name.\n\t *\n\t * @param {string} name - The output name to get the texture for.\n\t * @return {Texture} The texture.\n\t */\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Returns the texture holding the data of the previous frame for the given output name.\n\t *\n\t * @param {string} name - The output name to get the texture for.\n\t * @return {Texture} The texture holding the data of the previous frame.\n\t */\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Switches current and previous textures for the given output name.\n\t *\n\t * @param {string} name - The output name.\n\t */\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the texture node for the given output name.\n\t *\n\t * @param {string} [name='output'] - The output name to get the texture node for.\n\t * @return {TextureNode} The texture node.\n\t */\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns the previous texture node for the given output name.\n\t *\n\t * @param {string} [name='output'] - The output name to get the previous texture node for.\n\t * @return {TextureNode} The previous texture node.\n\t */\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns a viewZ node of this pass.\n\t *\n\t * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The viewZ node.\n\t */\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\t/**\n\t * Returns a linear depth node of this pass.\n\t *\n\t * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The linear depth node.\n\t */\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\t/**\n\t * Precompiles the pass.\n\t *\n\t * Note that this method must be called after the pass configuartion is complete.\n\t * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the compile has been finished.\n\t * @see {@link Renderer#compileAsync}\n\t */\n\tasync compileAsync( renderer ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\tawait renderer.compileAsync( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\tthis.renderTarget.texture.type = renderer.getColorBufferType();\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene } = this;\n\n\t\tlet camera;\n\t\tlet pixelRatio;\n\n\t\tconst outputRenderTarget = renderer.getOutputRenderTarget();\n\n\t\tif ( outputRenderTarget && outputRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\tpixelRatio = 1;\n\t\t\tcamera = renderer.xr.getCamera();\n\n\t\t\trenderer.xr.updateCamera( camera );\n\n\t\t\t_size.set( outputRenderTarget.width, outputRenderTarget.height );\n\n\t\t} else {\n\n\t\t\tcamera = this.camera;\n\t\t\tpixelRatio = renderer.getPixelRatio();\n\n\t\t\trenderer.getSize( _size );\n\n\t\t}\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( _size.width, _size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentMask = camera.layers.mask;\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tif ( this._layers !== null ) {\n\n\t\t\tcamera.layers.mask = this._layers.mask;\n\n\t\t}\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\trenderer.render( scene, camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t\tcamera.layers.mask = currentMask;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass's render target. Honors the pixel ratio.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio * this._resolution;\n\t\tconst effectiveHeight = this._height * this._pixelRatio * this._resolution;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tif ( this._scissor !== null ) this.renderTarget.scissor.copy( this._scissor );\n\t\tif ( this._viewport !== null ) this.renderTarget.viewport.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept\n\t * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method\n\t * with `null` as the single argument.\n\t *\n\t * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {number} width - The width of the scissor box in logical pixel unit.\n\t * @param {number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tif ( x === null ) {\n\n\t\t\tthis._scissor = null;\n\n\t\t} else {\n\n\t\t\tif ( this._scissor === null ) this._scissor = new Vector4();\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\tthis._scissor.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\tthis._scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tthis._scissor.multiplyScalar( this._pixelRatio * this._resolution ).floor();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method allows to define the pass's viewport. By default, the viewport is kept in sync\n\t * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method\n\t * with `null` as the single argument.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t */\n\tsetViewport( x, y, width, height ) {\n\n\t\tif ( x === null ) {\n\n\t\t\tthis._viewport = null;\n\n\t\t} else {\n\n\t\t\tif ( this._viewport === null ) this._viewport = new Vector4();\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\tthis._viewport.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\tthis._viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tthis._viewport.multiplyScalar( this._pixelRatio * this._resolution ).floor();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio the pass's render target and updates the size.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\n/**\n * @static\n * @type {'color'}\n * @default 'color'\n */\nPassNode.COLOR = 'color';\n\n/**\n * @static\n * @type {'depth'}\n * @default 'depth'\n */\nPassNode.DEPTH = 'depth';\n\nexport default PassNode;\n\n/**\n * TSL function for creating a pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nexport const pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\n\n/**\n * TSL function for creating a pass texture node.\n *\n * @tsl\n * @function\n * @param {PassNode} pass - The pass node.\n * @param {Texture} texture - The output texture.\n * @returns {PassTextureNode}\n */\nexport const passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\n\n/**\n * TSL function for creating a depth pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nexport const depthPass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera, options ) );\n"],"mappings":"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","ignoreList":[]}