import{float,nodeObject,normalize,vec4}from"../tsl/TSLBase.js";import{Color}from"../../math/Color.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{cameraProjectionMatrix}from"../../nodes/accessors/Camera.js";import{modelViewMatrix}from"../../nodes/accessors/ModelNode.js";import{positionLocal}from"../../nodes/accessors/Position.js";import{normalLocal}from"../../nodes/accessors/Normal.js";import{BackSide}from"../../constants.js";import PassNode from"./PassNode.js";class ToonOutlinePassNode extends PassNode{static get type(){return"ToonOutlinePassNode"}constructor(e,o,t,s,a){super(PassNode.COLOR,e,o),this.colorNode=t,this.thicknessNode=s,this.alphaNode=a,this._materialCache=new WeakMap}updateBefore(e){const{renderer:o}=e,t=o.getRenderObjectFunction();o.setRenderObjectFunction(((e,t,s,a,r,i,n,c)=>{if((r.isMeshToonMaterial||r.isMeshToonNodeMaterial)&&!1===r.wireframe){const l=this._getOutlineMaterial(r);o.renderObject(e,t,s,a,l,i,n,c)}o.renderObject(e,t,s,a,r,i,n,c)})),super.updateBefore(e),o.setRenderObjectFunction(t)}_createMaterial(){const e=new NodeMaterial;e.isMeshToonOutlineMaterial=!0,e.name="Toon_Outline",e.side=BackSide;const o=normalLocal.negate(),t=cameraProjectionMatrix.mul(modelViewMatrix),s=float(1),a=t.mul(vec4(positionLocal,1)),r=t.mul(vec4(positionLocal.add(o),1)),i=normalize(a.sub(r));return e.vertexNode=a.add(i.mul(this.thicknessNode).mul(a.w).mul(s)),e.colorNode=vec4(this.colorNode,this.alphaNode),e}_getOutlineMaterial(e){let o=this._materialCache.get(e);return void 0===o&&(o=this._createMaterial(),this._materialCache.set(e,o)),o}}export default ToonOutlinePassNode;export const toonOutlinePass=(e,o,t=new Color(0,0,0),s=.003,a=1)=>nodeObject(new ToonOutlinePassNode(e,o,nodeObject(t),nodeObject(s),nodeObject(a)));
//# sourceMappingURL=ToonOutlinePassNode.js.map