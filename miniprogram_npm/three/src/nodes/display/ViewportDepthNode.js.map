{"version":3,"file":"node_modules/three/src/nodes/display/ViewportDepthNode.js","names":["Node","float","log","log2","nodeImmutable","nodeProxy","cameraNear","cameraFar","positionView","viewportDepthTexture","ViewportDepthNode","type","constructor","scope","valueNode","super","this","isViewportDepthNode","generate","builder","DEPTH_BASE","getFragDepth","setup","camera","value","node","depthBase","assign","DEPTH","isPerspectiveCamera","viewZToPerspectiveDepth","z","viewZToOrthographicDepth","LINEAR_DEPTH","viewZ","perspectiveDepthToViewZ","near","far","add","div","sub","orthographicDepthToViewZ","depth","mul","viewZToLogarithmicDepth","max","toVar","numerator","negate","denominator","logarithmicDepthToViewZ","exponent","Math","E","pow","linearDepth","setParameterLength","viewportLinearDepth"],"sources":["node_modules/three/src/nodes/display/ViewportDepthNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { float, log, log2, nodeImmutable, nodeProxy } from '../tsl/TSLBase.js';\nimport { cameraNear, cameraFar } from '../accessors/Camera.js';\nimport { positionView } from '../accessors/Position.js';\nimport { viewportDepthTexture } from './ViewportDepthTextureNode.js';\n\n/**\n * This node offers a collection of features in context of the depth logic in the fragment shader.\n * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current\n * fragment or for depth evaluation purposes.\n *\n * @augments Node\n */\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth node.\n\t *\n\t * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.\n\t * @param {?Node} [valueNode=null] - The value node.\n\t */\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The node behaves differently depending on which scope is selected.\n\t\t *\n\t\t * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.\n\t\t * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).\n\t\t * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.\n\t\t * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.\n\t\t *\n\t\t * @type {('depth'|'depthBase'|'linearDepth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * Can be used to define a custom depth value.\n\t\t * The property is ignored in the `ViewportDepthNode.DEPTH` scope.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\nexport default ViewportDepthNode;\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n/**\n * TSL function for converting a viewZ value to an orthographic depth value.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n/**\n * TSL function for converting an orthographic depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The orthographic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n/**\n * TSL function for converting a viewZ value to a perspective depth value.\n *\n * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n/**\n * TSL function for converting a perspective depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The perspective depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n/**\n * TSL function for converting a viewZ value to a logarithmic depth value.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesnâ€™t use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n/**\n * TSL function for converting a logarithmic depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The logarithmic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nexport const logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\n/**\n * TSL function for defining a value for the current fragment's depth.\n *\n * @tsl\n * @function\n * @param {Node<float>} value - The depth value to set.\n * @returns {ViewportDepthNode<float>}\n */\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\n/**\n * TSL object that represents the depth value for the current fragment.\n *\n * @tsl\n * @type {ViewportDepthNode}\n */\nexport const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\n\n/**\n * TSL function for converting a perspective depth value to linear depth.\n *\n * @tsl\n * @function\n * @param {?Node<float>} [value=null] - The perspective depth. If `null` is provided, the current fragment's depth is used.\n * @returns {ViewportDepthNode<float>}\n */\nexport const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH ).setParameterLength( 0, 1 );\n\n/**\n * TSL object that represents the linear (orthographic) depth value of the current fragment\n *\n * @tsl\n * @type {ViewportDepthNode}\n */\nexport const viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n"],"mappings":"OAAOA,SAAU,yBACRC,MAAOC,IAAKC,KAAMC,cAAeC,cAAiB,2BAClDC,WAAYC,cAAiB,gCAC7BC,iBAAoB,kCACpBC,yBAA4B,gCASrC,MAAMC,0BAA0BV,KAE/B,eAAWW,GAEV,MAAO,mBAER,CAQA,WAAAC,CAAaC,EAAOC,EAAY,MAE/BC,MAAO,SAYPC,KAAKH,MAAQA,EASbG,KAAKF,UAAYA,EASjBE,KAAKC,qBAAsB,CAE5B,CAEA,QAAAC,CAAUC,GAET,MAAMN,MAAEA,GAAUG,KAElB,OAAKH,IAAUH,kBAAkBU,WAEzBD,EAAQE,eAITN,MAAMG,SAAUC,EAExB,CAEA,KAAAG,EAAOC,OAAEA,IAER,MAAMV,MAAEA,GAAUG,KACZQ,EAAQR,KAAKF,UAEnB,IAAIW,EAAO,KAEX,GAAKZ,IAAUH,kBAAkBU,WAEjB,OAAVI,IAEHC,EAAOC,YAAYC,OAAQH,SAIvB,GAAKX,IAAUH,kBAAkBkB,MAItCH,EAFIF,EAAOM,oBAEJC,wBAAyBtB,aAAauB,EAAGzB,WAAYC,WAIrDyB,yBAA0BxB,aAAauB,EAAGzB,WAAYC,gBAIxD,GAAKM,IAAUH,kBAAkBuB,aAEvC,GAAe,OAAVT,EAEJ,GAAKD,EAAOM,oBAAsB,CAEjC,MAAMK,EAAQC,wBAAyBX,EAAOlB,WAAYC,WAE1DkB,EAAOO,yBAA0BE,EAAO5B,WAAYC,UAErD,MAECkB,EAAOD,OAMRC,EAAOO,yBAA0BxB,aAAauB,EAAGzB,WAAYC,WAM/D,OAAOkB,CAER,EAIDf,kBAAkBU,WAAa,YAC/BV,kBAAkBkB,MAAQ,QAC1BlB,kBAAkBuB,aAAe,6BAElBvB,yBAcR,MAAMsB,yBAA2B,CAAEE,EAAOE,EAAMC,IAASH,EAAMI,IAAKF,GAAOG,IAAKH,EAAKI,IAAKH,WAY1F,MAAMI,yBAA2B,CAAEC,EAAON,EAAMC,IAASD,EAAKI,IAAKH,GAAMM,IAAKD,GAAQF,IAAKJ,UAc3F,MAAMN,wBAA0B,CAAEI,EAAOE,EAAMC,IAASD,EAAKE,IAAKJ,GAAQS,IAAKN,GAAME,IAAKF,EAAIG,IAAKJ,GAAOO,IAAKT,WAY/G,MAAMC,wBAA0B,CAAEO,EAAON,EAAMC,IAASD,EAAKO,IAAKN,GAAME,IAAKF,EAAIG,IAAKJ,GAAOO,IAAKD,GAAQF,IAAKH,WAY/G,MAAMO,wBAA0B,CAAEV,EAAOE,EAAMC,KA4BrDD,EAAOA,EAAKS,IAAK,MAAOC,QACxB,MAAMC,EAAY5C,KAAM+B,EAAMc,SAAST,IAAKH,IACtCa,EAAc9C,KAAMkC,EAAIE,IAAKH,IACnC,OAAOW,EAAUR,IAAKU,EAAa,SAc7B,MAAMC,wBAA0B,CAAER,EAAON,EAAMC,KAKrD,MAAMc,EAAWT,EAAMC,IAAKzC,IAAKmC,EAAIE,IAAKH,KAC1C,OAAOnC,MAAOmD,KAAKC,GAAIC,IAAKH,GAAWR,IAAKP,GAAOY,QAAQ,EAY5D,MAAMtB,UAA0BrB,UAAWK,kBAAmBA,kBAAkBU,mBAQzE,MAAMsB,MAAsBtC,cAAeM,kBAAmBA,kBAAkBkB,cAUhF,MAAM2B,YAA4BlD,UAAWK,kBAAmBA,kBAAkBuB,cAAeuB,mBAAoB,EAAG,UAQxH,MAAMC,oBAAoCF,YAAa9C,wBAE9DiC,MAAMf,OAAWH,GAAWE,UAAWF","ignoreList":[]}