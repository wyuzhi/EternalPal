import TextureNode from"../accessors/TextureNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeProxy}from"../tsl/TSLBase.js";import{screenUV}from"./ScreenNode.js";import{Vector2}from"../../math/Vector2.js";import{FramebufferTexture}from"../../textures/FramebufferTexture.js";import{LinearMipmapLinearFilter}from"../../constants.js";const _size=new Vector2;class ViewportTextureNode extends TextureNode{static get type(){return"ViewportTextureNode"}constructor(e=screenUV,t=null,r=null){let s=null;null===r?(s=new FramebufferTexture,s.minFilter=LinearMipmapLinearFilter,r=s):s=r,super(r,e,t),this.generateMipmaps=!1,this.defaultFramebuffer=s,this.isOutputTextureNode=!0,this.updateBeforeType=NodeUpdateType.RENDER,this._textures=new WeakMap}getFrameBufferTexture(e=null){const t=this.referenceNode?this.referenceNode.defaultFramebuffer:this.defaultFramebuffer;if(null===e)return t;if(!1===this._textures.has(e)){const r=t.clone();this._textures.set(e,r)}return this._textures.get(e)}updateBefore(e){const t=e.renderer,r=t.getRenderTarget();null===r?t.getDrawingBufferSize(_size):_size.set(r.width,r.height);const s=this.getFrameBufferTexture(r);s.image.width===_size.width&&s.image.height===_size.height||(s.image.width=_size.width,s.image.height=_size.height,s.needsUpdate=!0);const i=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=i,this.value=s}clone(){const e=new this.constructor(this.uvNode,this.levelNode,this.value);return e.generateMipmaps=this.generateMipmaps,e}}export default ViewportTextureNode;export const viewportTexture=nodeProxy(ViewportTextureNode).setParameterLength(0,3);export const viewportMipTexture=nodeProxy(ViewportTextureNode,null,null,{generateMipmaps:!0}).setParameterLength(0,3);
//# sourceMappingURL=ViewportTextureNode.js.map