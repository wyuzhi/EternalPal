{"version":3,"file":"node_modules/three/src/nodes/display/ViewportTextureNode.js","names":["TextureNode","NodeUpdateType","nodeProxy","screenUV","Vector2","FramebufferTexture","LinearMipmapLinearFilter","_size","ViewportTextureNode","type","constructor","uvNode","levelNode","framebufferTexture","defaultFramebuffer","minFilter","super","this","generateMipmaps","isOutputTextureNode","updateBeforeType","RENDER","_textures","WeakMap","getFrameBufferTexture","reference","referenceNode","has","clone","set","get","updateBefore","frame","renderer","renderTarget","getRenderTarget","getDrawingBufferSize","width","height","image","needsUpdate","currentGenerateMipmaps","copyFramebufferToTexture","value","viewportTextureNode","viewportTexture","setParameterLength","viewportMipTexture"],"sources":["node_modules/three/src/nodes/display/ViewportTextureNode.js"],"sourcesContent":["import TextureNode from '../accessors/TextureNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\nimport { screenUV } from './ScreenNode.js';\n\nimport { Vector2 } from '../../math/Vector2.js';\nimport { FramebufferTexture } from '../../textures/FramebufferTexture.js';\nimport { LinearMipmapLinearFilter } from '../../constants.js';\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * A special type of texture node which represents the data of the current viewport\n * as a texture. The module extracts data from the current bound framebuffer with\n * a copy operation so no extra render pass is required to produce the texture data\n * (which is good for performance). `ViewportTextureNode` can be used as an input for a\n * variety of effects like refractive or transmissive materials.\n *\n * @augments TextureNode\n */\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {?Node} [levelNode=null] - The level node.\n\t * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tlet defaultFramebuffer = null;\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tdefaultFramebuffer = new FramebufferTexture();\n\t\t\tdefaultFramebuffer.minFilter = LinearMipmapLinearFilter;\n\n\t\t\tframebufferTexture = defaultFramebuffer;\n\n\t\t} else {\n\n\t\t\tdefaultFramebuffer = framebufferTexture;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\t/**\n\t\t * Whether to generate mipmaps or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * The reference framebuffer texture. This is used to store the framebuffer texture\n\t\t * for the current render target. If the render target changes, a new framebuffer texture\n\t\t * is created automatically.\n\t\t *\n\t\t * @type {FramebufferTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultFramebuffer = defaultFramebuffer;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputTextureNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node renders the\n\t\t * scene once per render in its {@link ViewportTextureNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * The framebuffer texture for the current renderer context.\n\t\t *\n\t\t * @type {WeakMap<RenderTarget, FramebufferTexture>}\n\t\t * @private\n\t\t */\n\t\tthis._textures = new WeakMap();\n\n\t}\n\n\tgetFrameBufferTexture( reference = null ) {\n\n\t\tconst defaultFramebuffer = this.referenceNode ? this.referenceNode.defaultFramebuffer : this.defaultFramebuffer;\n\n\t\tif ( reference === null ) {\n\n\t\t\treturn defaultFramebuffer;\n\n\t\t}\n\n\t\tif ( this._textures.has( reference ) === false ) {\n\n\t\t\tconst framebufferTexture = defaultFramebuffer.clone();\n\n\t\t\tthis._textures.set( reference, framebufferTexture );\n\n\t\t}\n\n\t\treturn this._textures.get( reference );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\trenderer.getDrawingBufferSize( _size );\n\n\t\t} else {\n\n\t\t\t_size.set( renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t//\n\n\t\tconst framebufferTexture = this.getFrameBufferTexture( renderTarget );\n\n\t\tif ( framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height ) {\n\n\t\t\tframebufferTexture.image.width = _size.width;\n\t\t\tframebufferTexture.image.height = _size.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t\tthis.value = framebufferTexture;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\nexport default ViewportTextureNode;\n\n/**\n * TSL function for creating a viewport texture node.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nexport const viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode ).setParameterLength( 0, 3 );\n\n/**\n * TSL function for creating a viewport texture node with enabled mipmap generation.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nexport const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } ).setParameterLength( 0, 3 );\n"],"mappings":"OAAOA,gBAAiB,qCACfC,mBAAsB,8BACtBC,cAAiB,2BACjBC,aAAgB,yBAEhBC,YAAe,+BACfC,uBAA0B,8CAC1BC,6BAAgC,qBAEzC,MAAMC,MAAsB,IAAIH,QAWhC,MAAMI,4BAA4BR,YAEjC,eAAWS,GAEV,MAAO,qBAER,CASA,WAAAC,CAAaC,EAASR,SAAUS,EAAY,KAAMC,EAAqB,MAEtE,IAAIC,EAAqB,KAEG,OAAvBD,GAEJC,EAAqB,IAAIT,mBACzBS,EAAmBC,UAAYT,yBAE/BO,EAAqBC,GAIrBA,EAAqBD,EAItBG,MAAOH,EAAoBF,EAAQC,GAQnCK,KAAKC,iBAAkB,EAUvBD,KAAKH,mBAAqBA,EAS1BG,KAAKE,qBAAsB,EAS3BF,KAAKG,iBAAmBnB,eAAeoB,OAQvCJ,KAAKK,UAAY,IAAIC,OAEtB,CAEA,qBAAAC,CAAuBC,EAAY,MAElC,MAAMX,EAAqBG,KAAKS,cAAgBT,KAAKS,cAAcZ,mBAAqBG,KAAKH,mBAE7F,GAAmB,OAAdW,EAEJ,OAAOX,EAIR,IAAyC,IAApCG,KAAKK,UAAUK,IAAKF,GAAwB,CAEhD,MAAMZ,EAAqBC,EAAmBc,QAE9CX,KAAKK,UAAUO,IAAKJ,EAAWZ,EAEhC,CAEA,OAAOI,KAAKK,UAAUQ,IAAKL,EAE5B,CAEA,YAAAM,CAAcC,GAEb,MAAMC,EAAWD,EAAMC,SACjBC,EAAeD,EAASE,kBAER,OAAjBD,EAEJD,EAASG,qBAAsB7B,OAI/BA,MAAMsB,IAAKK,EAAaG,MAAOH,EAAaI,QAM7C,MAAMzB,EAAqBI,KAAKO,sBAAuBU,GAElDrB,EAAmB0B,MAAMF,QAAU9B,MAAM8B,OAASxB,EAAmB0B,MAAMD,SAAW/B,MAAM+B,SAEhGzB,EAAmB0B,MAAMF,MAAQ9B,MAAM8B,MACvCxB,EAAmB0B,MAAMD,OAAS/B,MAAM+B,OACxCzB,EAAmB2B,aAAc,GAMlC,MAAMC,EAAyB5B,EAAmBK,gBAClDL,EAAmBK,gBAAkBD,KAAKC,gBAE1Ce,EAASS,yBAA0B7B,GAEnCA,EAAmBK,gBAAkBuB,EAErCxB,KAAK0B,MAAQ9B,CAEd,CAEA,KAAAe,GAEC,MAAMgB,EAAsB,IAAI3B,KAAKP,YAAaO,KAAKN,OAAQM,KAAKL,UAAWK,KAAK0B,OAGpF,OAFAC,EAAoB1B,gBAAkBD,KAAKC,gBAEpC0B,CAER,iBAIcpC,2BAYR,MAAMqC,gBAAgC3C,UAAWM,qBAAsBsC,mBAAoB,EAAG,UAY9F,MAAMC,mBAAmC7C,UAAWM,oBAAqB,KAAM,KAAM,CAAEU,iBAAiB,IAAS4B,mBAAoB,EAAG","ignoreList":[]}