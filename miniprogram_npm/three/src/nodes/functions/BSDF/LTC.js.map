{"version":3,"file":"node_modules/three/src/nodes/functions/BSDF/LTC.js","names":["Fn","If","mat3","vec2","vec3","max","LTC_Uv","N","V","roughness","dotNV","dot","saturate","uv","oneMinus","sqrt","assign","mul","add","setLayout","name","type","inputs","LTC_ClippedSphereFormFactor","f","l","length","z","div","LTC_EdgeVectorFormFactor","v1","v2","x","y","abs","toVar","a","b","v","theta_sintheta","greaterThan","select","inverseSqrt","sub","cross","LTC_Evaluate","P","mInv","p0","p1","p2","p3","lightNormal","result","greaterThanEqual","T1","normalize","T2","negate","mat","transpose","coords0","coords1","coords2","coords3","vectorFormFactor","addAssign","LTC_Evaluate_Volume"],"sources":["node_modules/three/src/nodes/functions/BSDF/LTC.js"],"sourcesContent":["import { Fn, If, mat3, vec2, vec3 } from '../../tsl/TSLBase.js';\nimport { max } from '../../math/MathNode.js';\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate_Volume = /*@__PURE__*/ Fn( ( { P, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = p0.sub( P ).normalize().toVar();\n\t\tconst coords1 = p1.sub( P ).normalize().toVar();\n\t\tconst coords2 = p2.sub( P ).normalize().toVar();\n\t\tconst coords3 = p3.sub( P ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor.abs() } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\nexport { LTC_Evaluate, LTC_Evaluate_Volume, LTC_Uv };\n"],"mappings":"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","ignoreList":[]}