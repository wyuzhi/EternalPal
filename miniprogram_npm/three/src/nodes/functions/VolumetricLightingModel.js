import LightingModel from"../core/LightingModel.js";import{property}from"../core/PropertyNode.js";import{float,If,uniform,vec3,vec4}from"../tsl/TSLBase.js";import{positionWorld}from"../accessors/Position.js";import{cameraFar,cameraNear,cameraPosition,cameraViewMatrix}from"../accessors/Camera.js";import{Loop}from"../utils/LoopNode.js";import{linearDepth,viewZToPerspectiveDepth}from"../display/ViewportDepthNode.js";import{modelRadius}from"../accessors/ModelNode.js";import{LTC_Evaluate_Volume}from"./BSDF/LTC.js";const scatteringDensity=property("vec3"),linearDepthRay=property("vec3"),outgoingRayLight=property("vec3");class VolumetricLightingModel extends LightingModel{constructor(){super()}start(t){const{material:e,context:o}=t,i=property("vec3"),s=property("vec3");If(cameraPosition.sub(positionWorld).length().greaterThan(modelRadius.mul(2)),(()=>{i.assign(cameraPosition),s.assign(positionWorld)})).Else((()=>{i.assign(positionWorld),s.assign(cameraPosition)}));const r=s.sub(i),a=uniform("int").onRenderUpdate((({material:t})=>t.steps)),n=r.length().div(a).toVar(),d=r.normalize().toVar(),c=float(0).toVar(),g=vec3(1).toVar();e.offsetNode&&c.addAssign(e.offsetNode.mul(n)),Loop(a,(()=>{const s=i.add(d.mul(c)),r=cameraViewMatrix.mul(vec4(s,1)).xyz;let a;null!==e.depthNode&&(linearDepthRay.assign(linearDepth(viewZToPerspectiveDepth(r.z,cameraNear,cameraFar))),o.sceneDepthNode=linearDepth(e.depthNode).toVar()),o.positionWorld=s,o.shadowPositionWorld=s,o.positionView=r,scatteringDensity.assign(0),e.scatteringNode&&(a=e.scatteringNode({positionRay:s})),super.start(t),a&&scatteringDensity.mulAssign(a);const l=scatteringDensity.mul(.01).negate().mul(n).exp();g.mulAssign(l),c.addAssign(n)})),outgoingRayLight.addAssign(g.saturate().oneMinus())}scatteringLight(t,e){const o=e.context.sceneDepthNode;o?If(o.greaterThanEqual(linearDepthRay),(()=>{scatteringDensity.addAssign(t)})):scatteringDensity.addAssign(t)}direct({lightNode:t,lightColor:e},o){if(void 0===t.light.distance)return;const i=e.xyz.toVar();i.mulAssign(t.shadowNode),this.scatteringLight(i,o)}directRectArea({lightColor:t,lightPosition:e,halfWidth:o,halfHeight:i},s){const r=e.add(o).sub(i),a=e.sub(o).sub(i),n=e.sub(o).add(i),d=e.add(o).add(i),c=s.context.positionView,g=t.xyz.mul(LTC_Evaluate_Volume({P:c,p0:r,p1:a,p2:n,p3:d})).pow(1.5);this.scatteringLight(g,s)}finish(t){t.context.outgoingLight.assign(outgoingRayLight)}}export default VolumetricLightingModel;
//# sourceMappingURL=VolumetricLightingModel.js.map