{"version":3,"file":"node_modules/three/src/nodes/functions/VolumetricLightingModel.js","names":["LightingModel","property","float","If","uniform","vec3","vec4","positionWorld","cameraFar","cameraNear","cameraPosition","cameraViewMatrix","Loop","linearDepth","viewZToPerspectiveDepth","modelRadius","LTC_Evaluate_Volume","scatteringDensity","linearDepthRay","outgoingRayLight","VolumetricLightingModel","constructor","super","start","builder","material","context","startPos","endPos","sub","length","greaterThan","mul","assign","Else","viewVector","steps","onRenderUpdate","stepSize","div","toVar","rayDir","normalize","distTravelled","transmittance","offsetNode","addAssign","positionRay","add","positionViewRay","xyz","scatteringNode","depthNode","z","sceneDepthNode","shadowPositionWorld","positionView","mulAssign","falloff","negate","exp","saturate","oneMinus","scatteringLight","lightColor","greaterThanEqual","direct","lightNode","undefined","light","distance","directLight","shadowNode","this","directRectArea","lightPosition","halfWidth","halfHeight","p0","p1","p2","p3","P","pow","finish","outgoingLight"],"sources":["node_modules/three/src/nodes/functions/VolumetricLightingModel.js"],"sourcesContent":["import LightingModel from '../core/LightingModel.js';\nimport { property } from '../core/PropertyNode.js';\nimport { float, If, uniform, vec3, vec4 } from '../tsl/TSLBase.js';\nimport { positionWorld } from '../accessors/Position.js';\nimport { cameraFar, cameraNear, cameraPosition, cameraViewMatrix } from '../accessors/Camera.js';\nimport { Loop } from '../utils/LoopNode.js';\nimport { linearDepth, viewZToPerspectiveDepth } from '../display/ViewportDepthNode.js';\nimport { modelRadius } from '../accessors/ModelNode.js';\nimport { LTC_Evaluate_Volume } from './BSDF/LTC.js';\n\nconst scatteringDensity = property( 'vec3' );\nconst linearDepthRay = property( 'vec3' );\nconst outgoingRayLight = property( 'vec3' );\n\n/**\n * VolumetricLightingModel class extends the LightingModel to implement volumetric lighting effects.\n * This model calculates the scattering and transmittance of light through a volumetric medium.\n * It dynamically adjusts the direction of the ray based on the camera and object positions.\n * The model supports custom scattering and depth nodes to enhance the lighting effects.\n *\n * @augments LightingModel\n */\nclass VolumetricLightingModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tstart( builder ) {\n\n\t\tconst { material, context } = builder;\n\n\t\tconst startPos = property( 'vec3' );\n\t\tconst endPos = property( 'vec3' );\n\n\t\t// This approach dynamically changes the direction of the ray,\n\t\t// prioritizing the ray from the camera to the object if it is inside the mesh, and from the object to the camera if it is far away.\n\n\t\tIf( cameraPosition.sub( positionWorld ).length().greaterThan( modelRadius.mul( 2 ) ), () => {\n\n\t\t\tstartPos.assign( cameraPosition );\n\t\t\tendPos.assign( positionWorld );\n\n\t\t} ).Else( () => {\n\n\t\t\tstartPos.assign( positionWorld );\n\t\t\tendPos.assign( cameraPosition );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst viewVector = endPos.sub( startPos );\n\n\t\tconst steps = uniform( 'int' ).onRenderUpdate( ( { material } ) => material.steps );\n\t\tconst stepSize = viewVector.length().div( steps ).toVar();\n\n\t\tconst rayDir = viewVector.normalize().toVar(); // TODO: toVar() should be automatic here ( in loop )\n\n\t\tconst distTravelled = float( 0.0 ).toVar();\n\t\tconst transmittance = vec3( 1 ).toVar();\n\n\t\tif ( material.offsetNode ) {\n\n\t\t\t// reduce banding\n\n\t\t\tdistTravelled.addAssign( material.offsetNode.mul( stepSize ) );\n\n\t\t}\n\n\t\tLoop( steps, () => {\n\n\t\t\tconst positionRay = startPos.add( rayDir.mul( distTravelled ) );\n\t\t\tconst positionViewRay = cameraViewMatrix.mul( vec4( positionRay, 1 ) ).xyz;\n\n\t\t\tif ( material.depthNode !== null ) {\n\n\t\t\t\tlinearDepthRay.assign( linearDepth( viewZToPerspectiveDepth( positionViewRay.z, cameraNear, cameraFar ) ) );\n\n\t\t\t\tcontext.sceneDepthNode = linearDepth( material.depthNode ).toVar();\n\n\t\t\t}\n\n\t\t\tcontext.positionWorld = positionRay;\n\t\t\tcontext.shadowPositionWorld = positionRay;\n\t\t\tcontext.positionView = positionViewRay;\n\n\t\t\tscatteringDensity.assign( 0 );\n\n\t\t\tlet scatteringNode;\n\n\t\t\tif ( material.scatteringNode ) {\n\n\t\t\t\tscatteringNode = material.scatteringNode( {\n\t\t\t\t\tpositionRay\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tsuper.start( builder );\n\n\t\t\tif ( scatteringNode ) {\n\n\t\t\t\tscatteringDensity.mulAssign( scatteringNode );\n\n\t\t\t}\n\n\t\t\t// beer's law\n\n\t\t\tconst falloff = scatteringDensity.mul( .01 ).negate().mul( stepSize ).exp();\n\t\t\ttransmittance.mulAssign( falloff );\n\n\t\t\t// move along the ray\n\n\t\t\tdistTravelled.addAssign( stepSize );\n\n\t\t} );\n\n\t\toutgoingRayLight.addAssign( transmittance.saturate().oneMinus() );\n\n\t}\n\n\tscatteringLight( lightColor, builder ) {\n\n\t\tconst sceneDepthNode = builder.context.sceneDepthNode;\n\n\t\tif ( sceneDepthNode ) {\n\n\t\t\tIf( sceneDepthNode.greaterThanEqual( linearDepthRay ), () => {\n\n\t\t\t\tscatteringDensity.addAssign( lightColor );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tscatteringDensity.addAssign( lightColor );\n\n\t\t}\n\n\t}\n\n\tdirect( { lightNode, lightColor }, builder ) {\n\n\t\t// Ignore lights with infinite distance\n\n\t\tif ( lightNode.light.distance === undefined ) return;\n\n\t\t// TODO: We need a viewportOpaque*() ( output, depth ) to fit with modern rendering approaches\n\n\t\tconst directLight = lightColor.xyz.toVar();\n\t\tdirectLight.mulAssign( lightNode.shadowNode ); // it no should be necessary if used in the same render pass\n\n\t\tthis.scatteringLight( directLight, builder );\n\n\t}\n\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight }, builder ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst P = builder.context.positionView;\n\n\t\tconst directLight = lightColor.xyz.mul( LTC_Evaluate_Volume( { P, p0, p1, p2, p3 } ) ).pow( 1.5 );\n\n\t\tthis.scatteringLight( directLight, builder );\n\n\t}\n\n\tfinish( builder ) {\n\n\t\tbuilder.context.outgoingLight.assign( outgoingRayLight );\n\n\t}\n\n}\n\nexport default VolumetricLightingModel;\n"],"mappings":"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","ignoreList":[]}