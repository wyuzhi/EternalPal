import Node from"../core/Node.js";import{getValueType}from"../core/NodeUtils.js";import{buffer}from"../accessors/BufferNode.js";import{instancedBufferAttribute}from"../accessors/BufferAttributeNode.js";import{instanceIndex}from"../core/IndexNode.js";import{nodeProxy,float}from"../tsl/TSLBase.js";import{Vector4}from"../../math/Vector4.js";import{MathUtils}from"../../math/MathUtils.js";import{InstancedBufferAttribute}from"../../core/InstancedBufferAttribute.js";let min=null,max=null;class RangeNode extends Node{static get type(){return"RangeNode"}constructor(e=float(),t=float()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(getValueType(this.minNode.value)),o=e.getTypeLength(getValueType(this.maxNode.value));return t>o?t:o}getNodeType(e){return e.object.count>1?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let o=null;if(t.count>1){const r=this.minNode.value,n=this.maxNode.value,s=e.getTypeLength(getValueType(r)),a=e.getTypeLength(getValueType(n));min=min||new Vector4,max=max||new Vector4,min.setScalar(0),max.setScalar(0),1===s?min.setScalar(r):r.isColor?min.set(r.r,r.g,r.b,1):min.set(r.x,r.y,r.z||0,r.w||0),1===a?max.setScalar(n):n.isColor?max.set(n.r,n.g,n.b,1):max.set(n.x,n.y,n.z||0,n.w||0);const i=4,m=i*t.count,c=new Float32Array(m);for(let e=0;e<m;e++){const t=e%i,o=min.getComponent(t),r=max.getComponent(t);c[e]=MathUtils.lerp(o,r,Math.random())}const l=this.getNodeType(e);if(t.count<=4096)o=buffer(c,"vec4",t.count).element(instanceIndex).convert(l);else{const t=new InstancedBufferAttribute(c,4);e.geometry.setAttribute("__range"+this.id,t),o=instancedBufferAttribute(t).convert(l)}}else o=float(0);return o}}export default RangeNode;export const range=nodeProxy(RangeNode).setParameterLength(2);
//# sourceMappingURL=RangeNode.js.map