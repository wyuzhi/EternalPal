{"version":3,"file":"node_modules/three/src/nodes/geometry/RangeNode.js","names":["Node","getValueType","buffer","instancedBufferAttribute","instanceIndex","nodeProxy","float","Vector4","MathUtils","InstancedBufferAttribute","min","max","RangeNode","type","constructor","minNode","maxNode","super","this","getVectorLength","builder","minLength","getTypeLength","value","maxLength","getNodeType","object","count","getTypeFromLength","setup","output","minValue","maxValue","setScalar","isColor","set","r","g","b","x","y","z","w","stride","length","array","Float32Array","i","index","minElementValue","getComponent","maxElementValue","lerp","Math","random","nodeType","element","convert","bufferAttribute","geometry","setAttribute","id","range","setParameterLength"],"sources":["node_modules/three/src/nodes/geometry/RangeNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { getValueType } from '../core/NodeUtils.js';\nimport { buffer } from '../accessors/BufferNode.js';\nimport { instancedBufferAttribute } from '../accessors/BufferAttributeNode.js';\nimport { instanceIndex } from '../core/IndexNode.js';\nimport { nodeProxy, float } from '../tsl/TSLBase.js';\n\nimport { Vector4 } from '../../math/Vector4.js';\nimport { MathUtils } from '../../math/MathUtils.js';\nimport { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';\n\nlet min = null;\nlet max = null;\n\n/**\n * `RangeNode` generates random instanced attribute data in a defined range.\n * An exemplary use case for this utility node is to generate random per-instance\n * colors:\n * ```js\n * const material = new MeshBasicNodeMaterial();\n * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );\n * const mesh = new InstancedMesh( geometry, material, count );\n * ```\n * @augments Node\n */\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new range node.\n\t *\n\t * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n\t * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n\t */\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t *  A node defining the lower bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.minNode = minNode;\n\n\t\t/**\n\t\t *  A node defining the upper bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {number} The vector length.\n\t */\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b, 1 );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b, 1 );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default RangeNode;\n\n/**\n * TSL function for creating a range node.\n *\n * @tsl\n * @function\n * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n * @returns {RangeNode}\n */\nexport const range = /*@__PURE__*/ nodeProxy( RangeNode ).setParameterLength( 2 );\n"],"mappings":"OAAOA,SAAU,yBACRC,iBAAoB,8BACpBC,WAAc,oCACdC,6BAAgC,6CAChCC,kBAAqB,8BACrBC,UAAWC,UAAa,2BAExBC,YAAe,+BACfC,cAAiB,iCACjBC,6BAAgC,yCAEzC,IAAIC,IAAM,KACNC,IAAM,KAaV,MAAMC,kBAAkBZ,KAEvB,eAAWa,GAEV,MAAO,WAER,CAQA,WAAAC,CAAaC,EAAUT,QAASU,EAAUV,SAEzCW,QAQAC,KAAKH,QAAUA,EAQfG,KAAKF,QAAUA,CAEhB,CAQA,eAAAG,CAAiBC,GAEhB,MAAMC,EAAYD,EAAQE,cAAerB,aAAciB,KAAKH,QAAQQ,QAC9DC,EAAYJ,EAAQE,cAAerB,aAAciB,KAAKF,QAAQO,QAEpE,OAAOF,EAAYG,EAAYH,EAAYG,CAE5C,CAQA,WAAAC,CAAaL,GAEZ,OAAOA,EAAQM,OAAOC,MAAQ,EAAIP,EAAQQ,kBAAmBV,KAAKC,gBAAiBC,IAAc,OAElG,CAEA,KAAAS,CAAOT,GAEN,MAAMM,EAASN,EAAQM,OAEvB,IAAII,EAAS,KAEb,GAAKJ,EAAOC,MAAQ,EAAI,CAEvB,MAAMI,EAAWb,KAAKH,QAAQQ,MACxBS,EAAWd,KAAKF,QAAQO,MAExBF,EAAYD,EAAQE,cAAerB,aAAc8B,IACjDP,EAAYJ,EAAQE,cAAerB,aAAc+B,IAEvDtB,IAAMA,KAAO,IAAIH,QACjBI,IAAMA,KAAO,IAAIJ,QAEjBG,IAAIuB,UAAW,GACftB,IAAIsB,UAAW,GAEI,IAAdZ,EAAkBX,IAAIuB,UAAWF,GAC5BA,EAASG,QAAUxB,IAAIyB,IAAKJ,EAASK,EAAGL,EAASM,EAAGN,EAASO,EAAG,GACrE5B,IAAIyB,IAAKJ,EAASQ,EAAGR,EAASS,EAAGT,EAASU,GAAK,EAAGV,EAASW,GAAK,GAElD,IAAdlB,EAAkBb,IAAIsB,UAAWD,GAC5BA,EAASE,QAAUvB,IAAIwB,IAAKH,EAASI,EAAGJ,EAASK,EAAGL,EAASM,EAAG,GACrE3B,IAAIwB,IAAKH,EAASO,EAAGP,EAASQ,EAAGR,EAASS,GAAK,EAAGT,EAASU,GAAK,GAErE,MAAMC,EAAS,EAETC,EAASD,EAASjB,EAAOC,MACzBkB,EAAQ,IAAIC,aAAcF,GAEhC,IAAM,IAAIG,EAAI,EAAGA,EAAIH,EAAQG,IAAO,CAEnC,MAAMC,EAAQD,EAAIJ,EAEZM,EAAkBvC,IAAIwC,aAAcF,GACpCG,EAAkBxC,IAAIuC,aAAcF,GAE1CH,EAAOE,GAAMvC,UAAU4C,KAAMH,EAAiBE,EAAiBE,KAAKC,SAErE,CAEA,MAAMC,EAAWrC,KAAKO,YAAaL,GAEnC,GAAKM,EAAOC,OAAS,KAEpBG,EAAS5B,OAAQ2C,EAAO,OAAQnB,EAAOC,OAAQ6B,QAASpD,eAAgBqD,QAASF,OAE3E,CAGN,MAAMG,EAAkB,IAAIjD,yBAA0BoC,EAAO,GAC7DzB,EAAQuC,SAASC,aAAc,UAAY1C,KAAK2C,GAAIH,GAEpD5B,EAAS3B,yBAA0BuD,GAAkBD,QAASF,EAE/D,CAED,MAECzB,EAASxB,MAAO,GAIjB,OAAOwB,CAER,iBAIclB,iBAWR,MAAMkD,MAAsBzD,UAAWO,WAAYmD,mBAAoB","ignoreList":[]}