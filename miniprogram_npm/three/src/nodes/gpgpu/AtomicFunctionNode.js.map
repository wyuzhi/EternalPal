{"version":3,"file":"node_modules/three/src/nodes/gpgpu/AtomicFunctionNode.js","names":["Node","expression","nodeProxy","AtomicFunctionNode","type","constructor","method","pointerNode","valueNode","super","this","parents","getInputType","builder","getNodeType","generate","properties","getNodeProperties","inputType","a","b","params","push","build","methodSnippet","getMethod","join","length","isStackNode","undefined","constNode","toConst","addLineFlowCode","ATOMIC_LOAD","ATOMIC_STORE","ATOMIC_ADD","ATOMIC_SUB","ATOMIC_MAX","ATOMIC_MIN","ATOMIC_AND","ATOMIC_OR","ATOMIC_XOR","atomicNode","atomicFunc","toStack","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor"],"sources":["node_modules/three/src/nodes/gpgpu/AtomicFunctionNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * `AtomicFunctionNode` represents any function that can operate on atomic variable types\n * within a shader. In an atomic function, any modification to an atomic variable will\n * occur as an indivisible step with a defined order relative to other modifications.\n * Accordingly, even if multiple atomic functions are modifying an atomic variable at once\n * atomic operations will not interfere with each other.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass AtomicFunctionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new atomic function node.\n\t *\n\t * @param {string} method - The signature of the atomic function to construct.\n\t * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n\t * @param {Node} valueNode - The value that mutates the atomic variable.\n\t */\n\tconstructor( method, pointerNode, valueNode ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The signature of the atomic function to construct.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * An atomic variable or element of an atomic buffer.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.pointerNode = pointerNode;\n\n\t\t/**\n\t\t * A value that modifies the atomic variable.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * Creates a list of the parents for this node for detecting if the node needs to return a value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parents = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return the type of\n\t * the pointer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the input type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst parents = properties.parents;\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\n\t\tif ( b !== null ) {\n\n\t\t\tparams.push( b.build( builder, inputType ) );\n\n\n\t\t}\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${ params.join( ', ' ) } )`;\n\t\tconst isVoid = parents ? ( parents.length === 1 && parents[ 0 ].isStackNode === true ) : false;\n\n\t\tif ( isVoid ) {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t} else {\n\n\t\t\tif ( properties.constNode === undefined ) {\n\n\t\t\t\tproperties.constNode = expression( methodSnippet, type ).toConst();\n\n\t\t\t}\n\n\t\t\treturn properties.constNode.build( builder );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\nexport default AtomicFunctionNode;\n\n/**\n * TSL function for creating an atomic function node.\n *\n * @tsl\n * @function\n * @param {string} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\n/**\n * TSL function for appending an atomic function call into the programmatic flow of a compute shader.\n *\n * @tsl\n * @function\n * @param {string} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicFunc = ( method, pointerNode, valueNode ) => {\n\n\treturn atomicNode( method, pointerNode, valueNode ).toStack();\n\n};\n\n/**\n * Loads the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicLoad = ( pointerNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null );\n\n/**\n * Stores a value in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicStore = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode );\n\n/**\n * Increments the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicAdd = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode );\n\n/**\n * Decrements the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicSub = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the maximum between its current value and a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicMax = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the minimum between its current value and a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicMin = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise AND of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicAnd = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise OR of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicOr = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise XOR of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nexport const atomicXor = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode );\n"],"mappings":"OAAOA,SAAU,yBACRC,eAAkB,mCAClBC,cAAiB,oBAa1B,MAAMC,2BAA2BH,KAEhC,eAAWI,GAEV,MAAO,oBAER,CASA,WAAAC,CAAaC,EAAQC,EAAaC,GAEjCC,MAAO,QAOPC,KAAKJ,OAASA,EAOdI,KAAKH,YAAcA,EAOnBG,KAAKF,UAAYA,EAQjBE,KAAKC,SAAU,CAEhB,CASA,YAAAC,CAAcC,GAEb,OAAOH,KAAKH,YAAYO,YAAaD,EAEtC,CAQA,WAAAC,CAAaD,GAEZ,OAAOH,KAAKE,aAAcC,EAE3B,CAEA,QAAAE,CAAUF,GAET,MAAMG,EAAaH,EAAQI,kBAAmBP,MACxCC,EAAUK,EAAWL,QAErBL,EAASI,KAAKJ,OAEdF,EAAOM,KAAKI,YAAaD,GACzBK,EAAYR,KAAKE,aAAcC,GAE/BM,EAAIT,KAAKH,YACTa,EAAIV,KAAKF,UAETa,EAAS,GAEfA,EAAOC,KAAM,IAAKH,EAAEI,MAAOV,EAASK,MAEzB,OAANE,GAEJC,EAAOC,KAAMF,EAAEG,MAAOV,EAASK,IAKhC,MAAMM,EAAgB,GAAIX,EAAQY,UAAWnB,EAAQF,OAAaiB,EAAOK,KAAM,UAG/E,OAFef,IAA+B,IAAnBA,EAAQgB,SAA6C,IAA7BhB,EAAS,GAAIiB,cAc/D,YAN8BC,IAAzBb,EAAWc,YAEfd,EAAWc,UAAY7B,WAAYuB,EAAepB,GAAO2B,WAInDf,EAAWc,UAAUP,MAAOV,GAVnCA,EAAQmB,gBAAiBR,EAAed,KAc1C,EAIDP,mBAAmB8B,YAAc,aACjC9B,mBAAmB+B,aAAe,cAClC/B,mBAAmBgC,WAAa,YAChChC,mBAAmBiC,WAAa,YAChCjC,mBAAmBkC,WAAa,YAChClC,mBAAmBmC,WAAa,YAChCnC,mBAAmBoC,WAAa,YAChCpC,mBAAmBqC,UAAY,WAC/BrC,mBAAmBsC,WAAa,2BAEjBtC,mBAYf,MAAMuC,WAAaxC,UAAWC,2BAYvB,MAAMwC,WAAa,CAAErC,EAAQC,EAAaC,IAEzCkC,WAAYpC,EAAQC,EAAaC,GAAYoC,iBAY9C,MAAMC,WAAetC,GAAiBoC,WAAYxC,mBAAmB8B,YAAa1B,EAAa,aAW/F,MAAMuC,YAAc,CAAEvC,EAAaC,IAAemC,WAAYxC,mBAAmB+B,aAAc3B,EAAaC,UAW5G,MAAMuC,UAAY,CAAExC,EAAaC,IAAemC,WAAYxC,mBAAmBgC,WAAY5B,EAAaC,UAWxG,MAAMwC,UAAY,CAAEzC,EAAaC,IAAemC,WAAYxC,mBAAmBiC,WAAY7B,EAAaC,UAWxG,MAAMyC,UAAY,CAAE1C,EAAaC,IAAemC,WAAYxC,mBAAmBkC,WAAY9B,EAAaC,UAWxG,MAAM0C,UAAY,CAAE3C,EAAaC,IAAemC,WAAYxC,mBAAmBmC,WAAY/B,EAAaC,UAWxG,MAAM2C,UAAY,CAAE5C,EAAaC,IAAemC,WAAYxC,mBAAmBoC,WAAYhC,EAAaC,UAWxG,MAAM4C,SAAW,CAAE7C,EAAaC,IAAemC,WAAYxC,mBAAmBqC,UAAWjC,EAAaC,UAWtG,MAAM6C,UAAY,CAAE9C,EAAaC,IAAemC,WAAYxC,mBAAmBsC,WAAYlC,EAAaC","ignoreList":[]}