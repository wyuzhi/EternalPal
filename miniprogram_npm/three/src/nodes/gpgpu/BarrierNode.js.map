{"version":3,"file":"node_modules/three/src/nodes/gpgpu/BarrierNode.js","names":["Node","nodeProxy","BarrierNode","constructor","scope","super","this","generate","builder","renderer","backend","isWebGLBackend","addFlowCode","addLineFlowCode","barrier","workgroupBarrier","toStack","storageBarrier","textureBarrier"],"sources":["node_modules/three/src/nodes/gpgpu/BarrierNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * Represents a GPU control barrier that synchronizes compute operations within a given scope.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass BarrierNode extends Node {\n\n\t/**\n\t * Constructs a new barrier node.\n\t *\n\t * @param {string} scope - The scope defines the behavior of the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\nexport default BarrierNode;\n\n/**\n * TSL function for creating a barrier node.\n *\n * @tsl\n * @function\n * @param {string} scope - The scope defines the behavior of the node..\n * @returns {BarrierNode}\n */\nconst barrier = nodeProxy( BarrierNode );\n\n/**\n * TSL function for creating a workgroup barrier. All compute shader\n * invocations must wait for each invocation within a workgroup to\n * complete before the barrier can be surpassed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nexport const workgroupBarrier = () => barrier( 'workgroup' ).toStack();\n\n/**\n * TSL function for creating a storage barrier. All invocations must\n * wait for each access to variables within the 'storage' address space\n * to complete before the barrier can be passed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nexport const storageBarrier = () => barrier( 'storage' ).toStack();\n\n/**\n * TSL function for creating a texture barrier. All invocations must\n * wait for each access to variables within the 'texture' address space\n * to complete before the barrier can be passed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nexport const textureBarrier = () => barrier( 'texture' ).toStack();\n\n"],"mappings":"OAAOA,SAAU,yBACRC,cAAiB,oBAS1B,MAAMC,oBAAoBF,KAOzB,WAAAG,CAAaC,GAEZC,QAEAC,KAAKF,MAAQA,CAEd,CAEA,QAAAG,CAAUC,GAET,MAAMJ,MAAEA,GAAUE,MACZG,SAAEA,GAAaD,GAEoB,IAApCC,EAASC,QAAQC,eAErBH,EAAQI,YAAa,QAAQR,eAI7BI,EAAQK,gBAAiB,GAAGT,aAAkBE,KAIhD,iBAIcJ,YAUf,MAAMY,QAAUb,UAAWC,oBAWpB,MAAMa,iBAAmB,IAAMD,QAAS,aAAcE,iBAWtD,MAAMC,eAAiB,IAAMH,QAAS,WAAYE,iBAWlD,MAAME,eAAiB,IAAMJ,QAAS,WAAYE","ignoreList":[]}