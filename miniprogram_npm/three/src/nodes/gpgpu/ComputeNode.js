import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{addMethodChaining,nodeObject}from"../tsl/TSLCore.js";class ComputeNode extends Node{static get type(){return"ComputeNode"}constructor(e,t){super("void"),this.isComputeNode=!0,this.computeNode=e,this.workgroupSize=t,this.count=null,this.version=1,this.name="",this.updateBeforeType=NodeUpdateType.OBJECT,this.onInitFunction=null}setCount(e){return this.count=e,this}getCount(){return this.count}dispose(){this.dispatchEvent({type:"dispose"})}setName(e){return this.name=e,this}label(e){return console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'),this.setName(e)}onInit(e){return this.onInitFunction=e,this}updateBefore({renderer:e}){e.compute(this)}setup(e){const t=this.computeNode.build(e);if(t){e.getNodeProperties(this).outputComputeNode=t.outputNode,t.outputNode=null}return t}generate(e,t){const{shaderStage:o}=e;if("compute"===o){const t=this.computeNode.build(e,"void");""!==t&&e.addLineFlowCode(t,this)}else{const o=e.getNodeProperties(this).outputComputeNode;if(o)return o.build(e,t)}}}export default ComputeNode;export const computeKernel=(e,t=[64])=>{(0===t.length||t.length>3)&&console.error("THREE.TSL: compute() workgroupSize must have 1, 2, or 3 elements");for(let e=0;e<t.length;e++){const o=t[e];("number"!=typeof o||o<=0||!Number.isInteger(o))&&console.error(`THREE.TSL: compute() workgroupSize element at index [ ${e} ] must be a positive integer`)}for(;t.length<3;)t.push(1);return nodeObject(new ComputeNode(nodeObject(e),t))};export const compute=(e,t,o)=>computeKernel(e,o).setCount(t);addMethodChaining("compute",compute),addMethodChaining("computeKernel",computeKernel);
//# sourceMappingURL=ComputeNode.js.map