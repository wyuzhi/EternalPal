import LightingNode from"./LightingNode.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{Color}from"../../math/Color.js";import{renderGroup}from"../core/UniformGroupNode.js";import{shadow}from"./ShadowNode.js";import{nodeObject}from"../tsl/TSLCore.js";import{lightViewPosition}from"../accessors/Lights.js";import{positionView}from"../accessors/Position.js";class AnalyticLightNode extends LightingNode{static get type(){return"AnalyticLightNode"}constructor(o=null){super(),this.light=o,this.color=new Color,this.colorNode=o&&o.colorNode||uniform(this.color).setGroup(renderGroup),this.baseColorNode=null,this.shadowNode=null,this.shadowColorNode=null,this.isAnalyticLightNode=!0,this.updateType=NodeUpdateType.FRAME}getHash(){return this.light.uuid}getLightVector(o){return lightViewPosition(this.light).sub(o.context.positionView||positionView)}setupDirect(){}setupDirectRectArea(){}setupShadowNode(){return shadow(this.light)}setupShadow(o){const{renderer:t}=o;if(!1===t.shadowMap.enabled)return;let e=this.shadowColorNode;if(null===e){const o=this.light.shadow.shadowNode;let t;t=void 0!==o?nodeObject(o):this.setupShadowNode(),this.shadowNode=t,this.shadowColorNode=e=this.colorNode.mul(t),this.baseColorNode=this.colorNode}this.colorNode=e}setup(o){this.colorNode=this.baseColorNode||this.colorNode,this.light.castShadow?o.object.receiveShadow&&this.setupShadow(o):null!==this.shadowNode&&(this.shadowNode.dispose(),this.shadowNode=null,this.shadowColorNode=null);const t=this.setupDirect(o),e=this.setupDirectRectArea(o);t&&o.lightsNode.setupDirectLight(o,this,t),e&&o.lightsNode.setupDirectRectAreaLight(o,this,e)}update(){const{light:o}=this;this.color.copy(o.color).multiplyScalar(o.intensity)}}export default AnalyticLightNode;
//# sourceMappingURL=AnalyticLightNode.js.map