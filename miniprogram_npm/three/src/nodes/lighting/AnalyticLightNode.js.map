{"version":3,"file":"node_modules/three/src/nodes/lighting/AnalyticLightNode.js","names":["LightingNode","NodeUpdateType","uniform","Color","renderGroup","shadow","nodeObject","lightViewPosition","positionView","AnalyticLightNode","type","constructor","light","super","this","color","colorNode","setGroup","baseColorNode","shadowNode","shadowColorNode","isAnalyticLightNode","updateType","FRAME","getHash","uuid","getLightVector","builder","sub","context","setupDirect","setupDirectRectArea","setupShadowNode","setupShadow","renderer","shadowMap","enabled","customShadowNode","undefined","mul","setup","castShadow","object","receiveShadow","dispose","directLightData","directRectAreaLightData","lightsNode","setupDirectLight","setupDirectRectAreaLight","update","copy","multiplyScalar","intensity"],"sources":["node_modules/three/src/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Color } from '../../math/Color.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\nimport { shadow } from './ShadowNode.js';\nimport { nodeObject } from '../tsl/TSLCore.js';\nimport { lightViewPosition } from '../accessors/Lights.js';\nimport { positionView } from '../accessors/Position.js';\n\n/**\n * Base class for analytic light nodes.\n *\n * @augments LightingNode\n */\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new analytic light node.\n\t *\n\t * @param {?Light} [light=null] - The light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light source.\n\t\t *\n\t\t * @type {?Light}\n\t\t * @default null\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * The light's color value.\n\t\t *\n\t\t * @type {Color}\n\t\t */\n\t\tthis.color = new Color();\n\n\t\t/**\n\t\t * The light's color node. Points to `colorNode` of the light source, if set. Otherwise\n\t\t * it creates a uniform node based on {@link AnalyticLightNode#color}.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.\n\t\t * The final color node is represented by a different node when using shadows.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.baseColorNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow.\n\t\t *\n\t\t * @type {?ShadowNode}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow color.\n\t\t *\n\t\t * @type {?Node}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowColorNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAnalyticLightNode = true;\n\n\t\t/**\n\t\t * Overwritten since analytic light nodes are updated\n\t\t * once per frame.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\t/**\n\t * Returns a node representing a direction vector which points from the current\n\t * position in view space to the light's position in view space.\n\t *\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Node<vec3>} The light vector node.\n\t */\n\tgetLightVector( builder ) {\n\n\t\treturn lightViewPosition( this.light ).sub( builder.context.positionView || positionView );\n\n\t}\n\n\t/**\n\t * Sets up the direct lighting for the analytic light node.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Object|undefined} The direct light data (color and direction).\n\t */\n\tsetupDirect( /*builder*/ ) { }\n\n\t/**\n\t * Sets up the direct rect area lighting for the analytic light node.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Object|undefined} The direct rect area light data.\n\t */\n\tsetupDirectRectArea( /*builder*/ ) { }\n\n\t/**\n\t * Setups the shadow node for this light. The method exists so concrete light classes\n\t * can setup different types of shadow nodes.\n\t *\n\t * @return {ShadowNode} The created shadow node.\n\t */\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\t/**\n\t * Setups the shadow for this light. This method is only executed if the light\n\t * cast shadows and the current build object receives shadows. It incorporates\n\t * shadows into the lighting computation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode();\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\t/**\n\t * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.\n\t * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or\n\t * invocate the respective interface methods.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t\tconst directLightData = this.setupDirect( builder );\n\t\tconst directRectAreaLightData = this.setupDirectRectArea( builder );\n\n\t\tif ( directLightData ) {\n\n\t\t\tbuilder.lightsNode.setupDirectLight( builder, this, directLightData );\n\n\t\t}\n\n\t\tif ( directRectAreaLightData ) {\n\n\t\t\tbuilder.lightsNode.setupDirectRectAreaLight( builder, this, directRectAreaLightData );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The update method is used to update light uniforms per frame.\n\t * Potentially overwritten in concrete light nodes to update light\n\t * specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n"],"mappings":"OAAOA,iBAAkB,2BAChBC,mBAAsB,8BACtBC,YAAe,gCACfC,UAAa,6BACbC,gBAAmB,qCACnBC,WAAc,yBACdC,eAAkB,2BAClBC,sBAAyB,gCACzBC,iBAAoB,2BAO7B,MAAMC,0BAA0BT,aAE/B,eAAWU,GAEV,MAAO,mBAER,CAOA,WAAAC,CAAaC,EAAQ,MAEpBC,QAQAC,KAAKF,MAAQA,EAObE,KAAKC,MAAQ,IAAIZ,MAQjBW,KAAKE,UAAcJ,GAASA,EAAMI,WAAed,QAASY,KAAKC,OAAQE,SAAUb,aASjFU,KAAKI,cAAgB,KAQrBJ,KAAKK,WAAa,KAQlBL,KAAKM,gBAAkB,KASvBN,KAAKO,qBAAsB,EAS3BP,KAAKQ,WAAarB,eAAesB,KAElC,CAEA,OAAAC,GAEC,OAAOV,KAAKF,MAAMa,IAEnB,CASA,cAAAC,CAAgBC,GAEf,OAAOpB,kBAAmBO,KAAKF,OAAQgB,IAAKD,EAAQE,QAAQrB,cAAgBA,aAE7E,CASA,WAAAsB,GAA6B,CAS7B,mBAAAC,GAAqC,CAQrC,eAAAC,GAEC,OAAO3B,OAAQS,KAAKF,MAErB,CASA,WAAAqB,CAAaN,GAEZ,MAAMO,SAAEA,GAAaP,EAErB,IAAoC,IAA/BO,EAASC,UAAUC,QAAoB,OAE5C,IAAIhB,EAAkBN,KAAKM,gBAE3B,GAAyB,OAApBA,EAA2B,CAE/B,MAAMiB,EAAmBvB,KAAKF,MAAMP,OAAOc,WAE3C,IAAIA,EAIHA,OAFyBmB,IAArBD,EAES/B,WAAY+B,GAIZvB,KAAKkB,kBAInBlB,KAAKK,WAAaA,EAElBL,KAAKM,gBAAkBA,EAAkBN,KAAKE,UAAUuB,IAAKpB,GAE7DL,KAAKI,cAAgBJ,KAAKE,SAE3B,CAIAF,KAAKE,UAAYI,CAElB,CASA,KAAAoB,CAAOb,GAENb,KAAKE,UAAYF,KAAKI,eAAiBJ,KAAKE,UAEvCF,KAAKF,MAAM6B,WAEVd,EAAQe,OAAOC,eAEnB7B,KAAKmB,YAAaN,GAIY,OAApBb,KAAKK,aAEhBL,KAAKK,WAAWyB,UAChB9B,KAAKK,WAAa,KAClBL,KAAKM,gBAAkB,MAIxB,MAAMyB,EAAkB/B,KAAKgB,YAAaH,GACpCmB,EAA0BhC,KAAKiB,oBAAqBJ,GAErDkB,GAEJlB,EAAQoB,WAAWC,iBAAkBrB,EAASb,KAAM+B,GAIhDC,GAEJnB,EAAQoB,WAAWE,yBAA0BtB,EAASb,KAAMgC,EAI9D,CASA,MAAAI,GAEC,MAAMtC,MAAEA,GAAUE,KAElBA,KAAKC,MAAMoC,KAAMvC,EAAMG,OAAQqC,eAAgBxC,EAAMyC,UAEtD,iBAIc5C","ignoreList":[]}