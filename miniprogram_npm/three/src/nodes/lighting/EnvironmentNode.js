import LightingNode from"./LightingNode.js";import{cache}from"../core/CacheNode.js";import{roughness,clearcoatRoughness}from"../core/PropertyNode.js";import{cameraViewMatrix}from"../accessors/Camera.js";import{normalView,clearcoatNormalView,normalWorld}from"../accessors/Normal.js";import{positionViewDirection}from"../accessors/Position.js";import{float}from"../tsl/TSLBase.js";import{bentNormalView}from"../accessors/AccessorsUtils.js";import{pmremTexture}from"../pmrem/PMREMNode.js";import{materialEnvIntensity}from"../accessors/MaterialProperties.js";const _envNodeCache=new WeakMap;class EnvironmentNode extends LightingNode{static get type(){return"EnvironmentNode"}constructor(e=null){super(),this.envNode=e}setup(e){const{material:t}=e;let o=this.envNode;if(o.isTextureNode||o.isMaterialReferenceNode){const e=o.isTextureNode?o.value:t[o.property];let r=_envNodeCache.get(e);void 0===r&&(r=pmremTexture(e),_envNodeCache.set(e,r)),o=r}const r=!0===t.useAnisotropy||t.anisotropy>0?bentNormalView:normalView,a=o.context(createRadianceContext(roughness,r)).mul(materialEnvIntensity),n=o.context(createIrradianceContext(normalWorld)).mul(Math.PI).mul(materialEnvIntensity),i=cache(a),s=cache(n);e.context.radiance.addAssign(i),e.context.iblIrradiance.addAssign(s);const c=e.context.lightingModel.clearcoatRadiance;if(c){const e=o.context(createRadianceContext(clearcoatRoughness,clearcoatNormalView)).mul(materialEnvIntensity),t=cache(e);c.addAssign(t)}}}export default EnvironmentNode;const createRadianceContext=(e,t)=>{let o=null;return{getUV:()=>(null===o&&(o=positionViewDirection.negate().reflect(t),o=e.mul(e).mix(o,t).normalize(),o=o.transformDirection(cameraViewMatrix)),o),getTextureLevel:()=>e}},createIrradianceContext=e=>({getUV:()=>e,getTextureLevel:()=>float(1)});
//# sourceMappingURL=EnvironmentNode.js.map