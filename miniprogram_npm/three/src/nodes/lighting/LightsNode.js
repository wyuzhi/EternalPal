import Node from"../core/Node.js";import{nodeObject,property,vec3}from"../tsl/TSLBase.js";import{hashArray}from"../core/NodeUtils.js";const sortLights=t=>t.sort(((t,e)=>t.id-e.id)),getLightNodeById=(t,e)=>{for(const s of e)if(s.isAnalyticLightNode&&s.light.id===t)return s;return null},_lightsNodeRef=new WeakMap,_hashData=[];class LightsNode extends Node{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=property("vec3","totalDiffuse"),this.totalSpecularNode=property("vec3","totalSpecular"),this.outgoingLightNode=property("vec3","outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}customCacheKey(){const t=this._lights;for(let e=0;e<t.length;e++){const s=t[e];if(_hashData.push(s.id),_hashData.push(s.castShadow?1:0),!0===s.isSpotLight){const t=null!==s.map?s.map.id:-1,e=s.colorNode?s.colorNode.getCacheKey():-1;_hashData.push(t,e)}}const e=hashArray(_hashData);return _hashData.length=0,e}getHash(t){if(null===this._lightNodesHash){null===this._lightNodes&&this.setupLightsNode(t);const e=[];for(const t of this._lightNodes)e.push(t.getSelf().getHash());this._lightNodesHash="lights-"+e.join(",")}return this._lightNodesHash}analyze(t){const e=t.getNodeProperties(this);for(const s of e.nodes)s.build(t);e.outputNode.build(t)}setupLightsNode(t){const e=[],s=this._lightNodes,i=sortLights(this._lights),o=t.renderer.library;for(const t of i)if(t.isNode)e.push(nodeObject(t));else{let i=null;if(null!==s&&(i=getLightNodeById(t.id,s)),null===i){const s=o.getLightNodeClass(t.constructor);if(null===s){console.warn(`LightsNode.setupNodeLights: Light node not found for ${t.constructor.name}`);continue}let i=null;_lightsNodeRef.has(t)?i=_lightsNodeRef.get(t):(i=nodeObject(new s(t)),_lightsNodeRef.set(t,i)),e.push(i)}}this._lightNodes=e}setupDirectLight(t,e,s){const{lightingModel:i,reflectedLight:o}=t.context;i.direct({...s,lightNode:e,reflectedLight:o},t)}setupDirectRectAreaLight(t,e,s){const{lightingModel:i,reflectedLight:o}=t.context;i.directRectArea({...s,lightNode:e,reflectedLight:o},t)}setupLights(t,e){for(const s of e)s.build(t)}getLightNodes(t){return null===this._lightNodes&&this.setupLightsNode(t),this._lightNodes}setup(t){const e=t.lightsNode;t.lightsNode=this;let s=this.outgoingLightNode;const i=t.context,o=i.lightingModel,h=t.getNodeProperties(this);if(o){const{totalDiffuseNode:e,totalSpecularNode:l}=this;i.outgoingLight=s;const d=t.addStack();h.nodes=d.nodes,o.start(t);const{backdrop:g,backdropAlpha:r}=i,{directDiffuse:n,directSpecular:a,indirectDiffuse:c,indirectSpecular:u}=i.reflectedLight;let N=n.add(c);null!==g&&(N=vec3(null!==r?r.mix(N,g):g),i.material.transparent=!0),e.assign(N),l.assign(a.add(u)),s.assign(e.add(l)),o.finish(t),s=s.bypass(t.removeStack())}else h.nodes=[];return t.lightsNode=e,s}setLights(t){return this._lights=t,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}export default LightsNode;export const lights=(t=[])=>nodeObject(new LightsNode).setLights(t);
//# sourceMappingURL=LightsNode.js.map