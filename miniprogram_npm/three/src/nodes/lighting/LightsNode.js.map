{"version":3,"file":"node_modules/three/src/nodes/lighting/LightsNode.js","names":["Node","nodeObject","property","vec3","hashArray","sortLights","lights","sort","a","b","id","getLightNodeById","lightNodes","lightNode","isAnalyticLightNode","light","_lightsNodeRef","WeakMap","_hashData","LightsNode","type","constructor","super","this","totalDiffuseNode","totalSpecularNode","outgoingLightNode","_lights","_lightNodes","_lightNodesHash","global","customCacheKey","i","length","push","castShadow","isSpotLight","hashMap","map","hashColorNode","colorNode","getCacheKey","cacheKey","getHash","builder","setupLightsNode","hash","getSelf","join","analyze","properties","getNodeProperties","node","nodes","build","outputNode","previousLightNodes","nodeLibrary","renderer","library","isNode","lightNodeClass","getLightNodeClass","console","warn","name","has","get","set","setupDirectLight","lightData","lightingModel","reflectedLight","context","direct","setupDirectRectAreaLight","directRectArea","setupLights","getLightNodes","setup","currentLightsNode","lightsNode","outgoingLight","stack","addStack","start","backdrop","backdropAlpha","directDiffuse","directSpecular","indirectDiffuse","indirectSpecular","totalDiffuse","add","mix","material","transparent","assign","finish","bypass","removeStack","setLights","getLights","hasLights"],"sources":["node_modules/three/src/nodes/lighting/LightsNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { nodeObject, property, vec3 } from '../tsl/TSLBase.js';\nimport { hashArray } from '../core/NodeUtils.js';\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\nconst _hashData = [];\n\n/**\n * This node represents the scene's lighting and manages the lighting model's life cycle\n * for the current build 3D object. It is responsible for computing the total outgoing\n * light in a given lighting context.\n *\n * @augments Node\n */\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lights node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * A node representing the total diffuse light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalDiffuseNode = property( 'vec3', 'totalDiffuse' );\n\n\t\t/**\n\t\t * A node representing the total specular light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalSpecularNode = property( 'vec3', 'totalSpecular' );\n\n\t\t/**\n\t\t * A node representing the outgoing light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.outgoingLightNode = property( 'vec3', 'outgoingLight' );\n\n\t\t/**\n\t\t * An array representing the lights in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis._lights = [];\n\n\t\t/**\n\t\t * For each light in the scene, this node will create a\n\t\t * corresponding light node.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<LightingNode>}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodes = null;\n\n\t\t/**\n\t\t * A hash for identifying the current light nodes setup.\n\t\t *\n\t\t * @private\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodesHash = null;\n\n\t\t/**\n\t\t * `LightsNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including\n\t * light data into the cache key.\n\t *\n\t * @return {number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\tconst lights = this._lights;\n\n\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\t_hashData.push( light.id );\n\t\t\t_hashData.push( light.castShadow ? 1 : 0 );\n\n\t\t\tif ( light.isSpotLight === true ) {\n\n\t\t\t\tconst hashMap = ( light.map !== null ) ? light.map.id : - 1;\n\t\t\t\tconst hashColorNode = ( light.colorNode ) ? light.colorNode.getCacheKey() : - 1;\n\n\t\t\t\t_hashData.push( hashMap, hashColorNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst cacheKey = hashArray( _hashData );\n\n\t\t_hashData.length = 0;\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Computes a hash value for identifying the current light nodes setup.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {string} The computed hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getSelf().getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t\tproperties.outputNode.build( builder );\n\n\t}\n\n\t/**\n\t * Creates lighting nodes for each scene light. This makes it possible to further\n\t * process lights in the node system.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t */\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\t// find the corresponding node type for a given light\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\tconsole.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\t/**\n\t * Sets up a direct light in the lighting model.\n\t *\n\t * @param {Object} builder - The builder object containing the context and stack.\n\t * @param {Object} lightNode - The light node.\n\t * @param {Object} lightData - The light object containing color and direction properties.\n\t */\n\tsetupDirectLight( builder, lightNode, lightData ) {\n\n\t\tconst { lightingModel, reflectedLight } = builder.context;\n\n\t\tlightingModel.direct( {\n\t\t\t...lightData,\n\t\t\tlightNode,\n\t\t\treflectedLight\n\t\t}, builder );\n\n\t}\n\n\tsetupDirectRectAreaLight( builder, lightNode, lightData ) {\n\n\t\tconst { lightingModel, reflectedLight } = builder.context;\n\n\t\tlightingModel.directRectArea( {\n\t\t\t...lightData,\n\t\t\tlightNode,\n\t\t\treflectedLight\n\t\t}, builder );\n\n\t}\n\n\t/**\n\t * Setups the internal lights by building all respective\n\t * light nodes.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.\n\t */\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tgetLightNodes( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\treturn this._lightNodes;\n\n\t}\n\n\t/**\n\t * The implementation makes sure that for each light in the scene\n\t * there is a corresponding light node. By building the light nodes\n\t * and evaluating the lighting model the outgoing light is computed.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} A node representing the outgoing light.\n\t */\n\tsetup( builder ) {\n\n\t\tconst currentLightsNode = builder.lightsNode;\n\n\t\tbuilder.lightsNode = this;\n\n\t\t//\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.material.transparent = true;\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t} else {\n\n\t\t\tproperties.nodes = [];\n\n\t\t}\n\n\t\t//\n\n\t\tbuilder.lightsNode = currentLightsNode;\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Configures this node with an array of lights.\n\t *\n\t * @param {Array<Light>} lights - An array of lights.\n\t * @return {LightsNode} A reference to this node.\n\t */\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an array of the scene's lights.\n\t *\n\t * @return {Array<Light>} The scene's lights.\n\t */\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\t/**\n\t * Whether the scene has lights or not.\n\t *\n\t * @type {boolean}\n\t */\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\nexport default LightsNode;\n\n/**\n * TSL function for creating an instance of `LightsNode` and configuring\n * it with the given array of lights.\n *\n * @tsl\n * @function\n * @param {Array<Light>} lights - An array of lights.\n * @return {LightsNode} The created lights node.\n */\nexport const lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n"],"mappings":"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","ignoreList":[]}