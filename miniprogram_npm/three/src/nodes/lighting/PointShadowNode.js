import ShadowNode from"./ShadowNode.js";import{uniform}from"../core/UniformNode.js";import{float,vec2,If,Fn,nodeObject}from"../tsl/TSLBase.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{max,abs,sign}from"../math/MathNode.js";import{sub,div}from"../math/OperatorNode.js";import{renderGroup}from"../core/UniformGroupNode.js";import{Vector2}from"../../math/Vector2.js";import{Vector4}from"../../math/Vector4.js";import{Color}from"../../math/Color.js";import{BasicShadowMap}from"../../constants.js";const _clearColor=new Color;export const cubeToUV=Fn((([e,o])=>{const r=e.toVar(),t=abs(r),a=div(1,max(t.x,max(t.y,t.z)));t.mulAssign(a),r.mulAssign(a.mul(o.mul(2).oneMinus()));const d=vec2(r.xy).toVar(),s=o.mul(1.5).oneMinus();return If(t.z.greaterThanEqual(s),(()=>{If(r.z.greaterThan(0),(()=>{d.x.assign(sub(4,r.x))}))})).ElseIf(t.x.greaterThanEqual(s),(()=>{const e=sign(r.x);d.x.assign(r.z.mul(e).add(e.mul(2)))})).ElseIf(t.y.greaterThanEqual(s),(()=>{const e=sign(r.y);d.x.assign(r.x.add(e.mul(2)).add(2)),d.y.assign(r.z.mul(e).sub(2))})),vec2(.125,.25).mul(d).add(vec2(.375,.75)).flipY()})).setLayout({name:"cubeToUV",type:"vec2",inputs:[{name:"pos",type:"vec3"},{name:"texelSizeY",type:"float"}]});export const BasicPointShadowFilter=Fn((({depthTexture:e,bd3D:o,dp:r,texelSize:t})=>texture(e,cubeToUV(o,t.y)).compare(r)));export const PointShadowFilter=Fn((({depthTexture:e,bd3D:o,dp:r,texelSize:t,shadow:a})=>{const d=reference("radius","float",a).setGroup(renderGroup),s=vec2(-1,1).mul(d).mul(t.y);return texture(e,cubeToUV(o.add(s.xyy),t.y)).compare(r).add(texture(e,cubeToUV(o.add(s.yyy),t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.xyx),t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.yyx),t.y)).compare(r)).add(texture(e,cubeToUV(o,t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.xxy),t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.yxy),t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.xxx),t.y)).compare(r)).add(texture(e,cubeToUV(o.add(s.yxx),t.y)).compare(r)).mul(1/9)}));const pointShadowFilter=Fn((({filterFn:e,depthTexture:o,shadowCoord:r,shadow:t})=>{const a=r.xyz.toVar(),d=a.length(),s=uniform("float").setGroup(renderGroup).onRenderUpdate((()=>t.camera.near)),n=uniform("float").setGroup(renderGroup).onRenderUpdate((()=>t.camera.far)),i=reference("bias","float",t).setGroup(renderGroup),u=uniform(t.mapSize).setGroup(renderGroup),p=float(1).toVar();return If(d.sub(n).lessThanEqual(0).and(d.sub(s).greaterThanEqual(0)),(()=>{const r=d.sub(s).div(n.sub(s)).toVar();r.addAssign(i);const c=a.normalize(),l=vec2(1).div(u.mul(vec2(4,2)));p.assign(e({depthTexture:o,bd3D:c,dp:r,texelSize:l,shadow:t}))})),p})),_viewport=new Vector4,_viewportSize=new Vector2,_shadowMapSize=new Vector2;class PointShadowNode extends ShadowNode{static get type(){return"PointShadowNode"}constructor(e,o=null){super(e,o)}getShadowFilterFn(e){return e===BasicShadowMap?BasicPointShadowFilter:PointShadowFilter}setupShadowCoord(e,o){return o}setupShadowFilter(e,{filterFn:o,shadowTexture:r,depthTexture:t,shadowCoord:a,shadow:d}){return pointShadowFilter({filterFn:o,shadowTexture:r,depthTexture:t,shadowCoord:a,shadow:d})}renderShadow(e){const{shadow:o,shadowMap:r,light:t}=this,{renderer:a,scene:d}=e,s=o.getFrameExtents();_shadowMapSize.copy(o.mapSize),_shadowMapSize.multiply(s),r.setSize(_shadowMapSize.width,_shadowMapSize.height),_viewportSize.copy(o.mapSize);const n=a.autoClear,i=a.getClearColor(_clearColor),u=a.getClearAlpha();a.autoClear=!1,a.setClearColor(o.clearColor,o.clearAlpha),a.clear();const p=o.getViewportCount();for(let e=0;e<p;e++){const s=o.getViewport(e),n=_viewportSize.x*s.x,i=_shadowMapSize.y-_viewportSize.y-_viewportSize.y*s.y;_viewport.set(n,i,_viewportSize.x*s.z,_viewportSize.y*s.w),r.viewport.copy(_viewport),o.updateMatrices(t,e),a.render(d,o.camera)}a.autoClear=n,a.setClearColor(i,u)}}export default PointShadowNode;export const pointShadow=(e,o)=>nodeObject(new PointShadowNode(e,o));
//# sourceMappingURL=PointShadowNode.js.map