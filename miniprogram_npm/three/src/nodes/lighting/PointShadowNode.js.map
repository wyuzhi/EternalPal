{"version":3,"file":"node_modules/three/src/nodes/lighting/PointShadowNode.js","names":["ShadowNode","uniform","float","vec2","If","Fn","nodeObject","reference","texture","max","abs","sign","sub","div","renderGroup","Vector2","Vector4","Color","BasicShadowMap","_clearColor","cubeToUV","pos","texelSizeY","v","toVar","absV","scaleToCube","x","y","z","mulAssign","mul","oneMinus","planar","xy","almostOne","greaterThanEqual","greaterThan","assign","ElseIf","signX","add","signY","flipY","setLayout","name","type","inputs","BasicPointShadowFilter","depthTexture","bd3D","dp","texelSize","compare","PointShadowFilter","shadow","radius","setGroup","offset","xyy","yyy","xyx","yyx","xxy","yxy","xxx","yxx","pointShadowFilter","filterFn","shadowCoord","lightToPosition","xyz","lightToPositionLength","length","cameraNearLocal","onRenderUpdate","camera","near","cameraFarLocal","far","bias","mapSize","result","lessThanEqual","and","addAssign","normalize","_viewport","_viewportSize","_shadowMapSize","PointShadowNode","constructor","light","super","getShadowFilterFn","setupShadowCoord","builder","shadowPosition","setupShadowFilter","shadowTexture","renderShadow","frame","shadowMap","this","renderer","scene","shadowFrameExtents","getFrameExtents","copy","multiply","setSize","width","height","previousAutoClear","autoClear","previousClearColor","getClearColor","previousClearAlpha","getClearAlpha","setClearColor","clearColor","clearAlpha","clear","viewportCount","getViewportCount","vp","viewport","getViewport","set","w","updateMatrices","render","pointShadow"],"sources":["node_modules/three/src/nodes/lighting/PointShadowNode.js"],"sourcesContent":["import ShadowNode from './ShadowNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { float, vec2, If, Fn, nodeObject } from '../tsl/TSLBase.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { max, abs, sign } from '../math/MathNode.js';\nimport { sub, div } from '../math/OperatorNode.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Color } from '../../math/Color.js';\nimport { BasicShadowMap } from '../../constants.js';\n\nconst _clearColor = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nexport const cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max( absV.x, max( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nexport const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nexport const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n\n/**\n * Represents the shadow implementation for point light nodes.\n *\n * @augments ShadowNode\n */\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point shadow node.\n\t *\n\t * @param {PointLight} light - The shadow casting point light.\n\t * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return point light shadow specific\n\t * filtering functions.\n\t *\n\t * @param {number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation so the unaltered shadow position is used.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to only use point light specific\n\t * shadow filter functions.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation with point light specific\n\t * rendering code.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\nexport default PointShadowNode;\n\n/**\n * TSL function for creating an instance of `PointShadowNode`.\n *\n * @tsl\n * @function\n * @param {PointLight} light - The shadow casting point light.\n * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.\n * @return {PointShadowNode} The created point shadow node.\n */\nexport const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n"],"mappings":"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","ignoreList":[]}