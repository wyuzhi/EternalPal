import{float,vec2,vec4,If,Fn}from"../tsl/TSLBase.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{mix,fract,step,max,clamp}from"../math/MathNode.js";import{add,sub}from"../math/OperatorNode.js";import{renderGroup}from"../core/UniformGroupNode.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{objectPosition}from"../accessors/Object3DNode.js";import{positionWorld}from"../accessors/Position.js";const shadowMaterialLib=new WeakMap;export const BasicShadowFilter=Fn((({depthTexture:e,shadowCoord:r,depthLayer:a})=>{let t=texture(e,r.xy).setName("t_basic");return e.isArrayTexture&&(t=t.depth(a)),t.compare(r.z)}));export const PCFShadowFilter=Fn((({depthTexture:e,shadowCoord:r,shadow:a,depthLayer:t})=>{const d=(r,a)=>{let d=texture(e,r);return e.isArrayTexture&&(d=d.depth(t)),d.compare(a)},o=reference("mapSize","vec2",a).setGroup(renderGroup),s=reference("radius","float",a).setGroup(renderGroup),c=vec2(1).div(o),i=c.x.negate().mul(s),n=c.y.negate().mul(s),u=c.x.mul(s),m=c.y.mul(s),l=i.div(2),x=n.div(2),p=u.div(2),v=m.div(2);return add(d(r.xy.add(vec2(i,n)),r.z),d(r.xy.add(vec2(0,n)),r.z),d(r.xy.add(vec2(u,n)),r.z),d(r.xy.add(vec2(l,x)),r.z),d(r.xy.add(vec2(0,x)),r.z),d(r.xy.add(vec2(p,x)),r.z),d(r.xy.add(vec2(i,0)),r.z),d(r.xy.add(vec2(l,0)),r.z),d(r.xy,r.z),d(r.xy.add(vec2(p,0)),r.z),d(r.xy.add(vec2(u,0)),r.z),d(r.xy.add(vec2(l,v)),r.z),d(r.xy.add(vec2(0,v)),r.z),d(r.xy.add(vec2(p,v)),r.z),d(r.xy.add(vec2(i,m)),r.z),d(r.xy.add(vec2(0,m)),r.z),d(r.xy.add(vec2(u,m)),r.z)).mul(1/17)}));export const PCFSoftShadowFilter=Fn((({depthTexture:e,shadowCoord:r,shadow:a,depthLayer:t})=>{const d=(r,a)=>{let d=texture(e,r);return e.isArrayTexture&&(d=d.depth(t)),d.compare(a)},o=reference("mapSize","vec2",a).setGroup(renderGroup),s=vec2(1).div(o),c=s.x,i=s.y,n=r.xy,u=fract(n.mul(o).add(.5));return n.subAssign(u.mul(s)),add(d(n,r.z),d(n.add(vec2(c,0)),r.z),d(n.add(vec2(0,i)),r.z),d(n.add(s),r.z),mix(d(n.add(vec2(c.negate(),0)),r.z),d(n.add(vec2(c.mul(2),0)),r.z),u.x),mix(d(n.add(vec2(c.negate(),i)),r.z),d(n.add(vec2(c.mul(2),i)),r.z),u.x),mix(d(n.add(vec2(0,i.negate())),r.z),d(n.add(vec2(0,i.mul(2))),r.z),u.y),mix(d(n.add(vec2(c,i.negate())),r.z),d(n.add(vec2(c,i.mul(2))),r.z),u.y),mix(mix(d(n.add(vec2(c.negate(),i.negate())),r.z),d(n.add(vec2(c.mul(2),i.negate())),r.z),u.x),mix(d(n.add(vec2(c.negate(),i.mul(2))),r.z),d(n.add(vec2(c.mul(2),i.mul(2))),r.z),u.x),u.y)).mul(1/9)}));export const VSMShadowFilter=Fn((({depthTexture:e,shadowCoord:r,depthLayer:a})=>{const t=float(1).toVar();let d=texture(e).sample(r.xy);e.isArrayTexture&&(d=d.depth(a)),d=d.rg;const o=step(r.z,d.x);return If(o.notEqual(float(1)),(()=>{const e=r.z.sub(d.x),a=max(0,d.y.mul(d.y));let s=a.div(a.add(e.mul(e)));s=clamp(sub(s,.3).div(.95-.3)),t.assign(clamp(max(o,s)))})),t}));const linearDistance=Fn((([e,r,a])=>{let t=positionWorld.sub(e).length();return t=t.sub(r).div(a.sub(r)),t=t.saturate(),t})),linearShadowDistance=e=>{const r=e.shadow.camera,a=reference("near","float",r).setGroup(renderGroup),t=reference("far","float",r).setGroup(renderGroup),d=objectPosition(e);return linearDistance(d,a,t)};export const getShadowMaterial=e=>{let r=shadowMaterialLib.get(e);if(void 0===r){const a=e.isPointLight?linearShadowDistance(e):null;r=new NodeMaterial,r.colorNode=vec4(0,0,0,1),r.depthNode=a,r.isShadowPassMaterial=!0,r.name="ShadowMaterial",r.fog=!1,shadowMaterialLib.set(e,r)}return r};
//# sourceMappingURL=ShadowFilterNode.js.map