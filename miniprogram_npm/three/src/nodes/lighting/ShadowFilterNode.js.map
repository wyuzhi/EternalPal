{"version":3,"file":"node_modules/three/src/nodes/lighting/ShadowFilterNode.js","names":["float","vec2","vec4","If","Fn","reference","texture","mix","fract","step","max","clamp","add","sub","renderGroup","NodeMaterial","objectPosition","positionWorld","shadowMaterialLib","WeakMap","BasicShadowFilter","depthTexture","shadowCoord","depthLayer","basic","xy","setName","isArrayTexture","depth","compare","z","PCFShadowFilter","shadow","depthCompare","uv","mapSize","setGroup","radius","texelSize","div","dx0","x","negate","mul","dy0","y","dx1","dy1","dx2","dy2","dx3","dy3","PCFSoftShadowFilter","dx","dy","f","subAssign","VSMShadowFilter","occlusion","toVar","distribution","sample","rg","hardShadow","notEqual","distance","variance","softnessProbability","assign","linearDistance","position","cameraNear","cameraFar","dist","length","saturate","linearShadowDistance","light","camera","nearDistance","farDistance","referencePosition","getShadowMaterial","material","get","undefined","depthNode","isPointLight","colorNode","isShadowPassMaterial","name","fog","set"],"sources":["node_modules/three/src/nodes/lighting/ShadowFilterNode.js"],"sourcesContent":["import { float, vec2, vec4, If, Fn } from '../tsl/TSLBase.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { mix, fract, step, max, clamp } from '../math/MathNode.js';\nimport { add, sub } from '../math/OperatorNode.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\nimport NodeMaterial from '../../materials/nodes/NodeMaterial.js';\nimport { objectPosition } from '../accessors/Object3DNode.js';\nimport { positionWorld } from '../accessors/Position.js';\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\n\n/**\n * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map\n * with a binary `[0,1]` result.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nexport const BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {\n\n\tlet basic = texture( depthTexture, shadowCoord.xy ).setName( 't_basic' );\n\n\tif ( depthTexture.isArrayTexture ) {\n\n\t\tbasic = basic.depth( depthLayer );\n\n\t}\n\n\treturn basic.compare( shadowCoord.z );\n\n} );\n\n/**\n * A shadow filtering function performing PCF filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nexport const PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {\n\n\tconst depthCompare = ( uv, compare ) => {\n\n\t\tlet depth = texture( depthTexture, uv );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\treturn depth.compare( compare );\n\n\t};\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\n/**\n * A shadow filtering function performing PCF soft filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nexport const PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {\n\n\tconst depthCompare = ( uv, compare ) => {\n\n\t\tlet depth = texture( depthTexture, uv );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\treturn depth.compare( compare );\n\n\t};\n\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n/**\n * A shadow filtering function performing VSM filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nexport const VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tlet distribution = texture( depthTexture ).sample( shadowCoord.xy );\n\n\tif ( depthTexture.isArrayTexture ) {\n\n\t\tdistribution = distribution.depth( depthLayer );\n\n\t}\n\n\tdistribution = distribution.rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\n//\n\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\n/**\n * Retrieves or creates a shadow material for the given light source.\n *\n * This function checks if a shadow material already exists for the provided light.\n * If not, it creates a new `NodeMaterial` configured for shadow rendering and stores it\n * in the `shadowMaterialLib` for future use.\n *\n * @param {Light} light - The light source for which the shadow material is needed.\n *                         If the light is a point light, a depth node is calculated\n *                         using the linear shadow distance.\n * @returns {NodeMaterial} The shadow material associated with the given light.\n */\nexport const getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowPassMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.name = 'ShadowMaterial';\n\t\tmaterial.fog = false;\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n"],"mappings":"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","ignoreList":[]}