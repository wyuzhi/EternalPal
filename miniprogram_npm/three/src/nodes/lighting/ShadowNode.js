import ShadowBaseNode,{shadowPositionWorld}from"./ShadowBaseNode.js";import{float,vec2,vec3,int,Fn,nodeObject}from"../tsl/TSLBase.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{normalWorld}from"../accessors/Normal.js";import{mix,sqrt}from"../math/MathNode.js";import{add}from"../math/OperatorNode.js";import{DepthTexture}from"../../textures/DepthTexture.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import QuadMesh from"../../renderers/common/QuadMesh.js";import{Loop}from"../utils/LoopNode.js";import{screenCoordinate}from"../display/ScreenNode.js";import{HalfFloatType,LessCompare,RGFormat,VSMShadowMap,WebGPUCoordinateSystem}from"../../constants.js";import{renderGroup}from"../core/UniformGroupNode.js";import{viewZToLogarithmicDepth}from"../display/ViewportDepthNode.js";import{lightShadowMatrix}from"../accessors/Lights.js";import{resetRendererAndSceneState,restoreRendererAndSceneState}from"../../renderers/common/RendererUtils.js";import{getDataFromObject}from"../core/NodeUtils.js";import{getShadowMaterial,BasicShadowFilter,PCFShadowFilter,PCFSoftShadowFilter,VSMShadowFilter}from"./ShadowFilterNode.js";import ChainMap from"../../renderers/common/ChainMap.js";const _shadowRenderObjectLibrary=new ChainMap,_shadowRenderObjectKeys=[];export const getShadowRenderObjectFunction=(e,t,a,r)=>{_shadowRenderObjectKeys[0]=e,_shadowRenderObjectKeys[1]=t;let o=_shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);return void 0!==o&&o.shadowType===a&&o.useVelocity===r||(o=(o,s,d,i,h,n,...l)=>{(!0===o.castShadow||o.receiveShadow&&a===VSMShadowMap)&&(r&&(getDataFromObject(o).useVelocity=!0),o.onBeforeShadow(e,o,d,t.camera,i,s.overrideMaterial,n),e.renderObject(o,s,d,i,h,n,...l),o.onAfterShadow(e,o,d,t.camera,i,s.overrideMaterial,n))},o.shadowType=a,o.useVelocity=r,_shadowRenderObjectLibrary.set(_shadowRenderObjectKeys,o)),_shadowRenderObjectKeys[0]=null,_shadowRenderObjectKeys[1]=null,o};const VSMPassVertical=Fn((({samples:e,radius:t,size:a,shadowPass:r,depthLayer:o})=>{const s=float(0).toVar("meanVertical"),d=float(0).toVar("squareMeanVertical"),i=e.lessThanEqual(float(1)).select(float(0),float(2).div(e.sub(1))),h=e.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(e),type:"int",condition:"<"},(({i:e})=>{const n=h.add(float(e).mul(i));let l=r.sample(add(screenCoordinate.xy,vec2(0,n).mul(t)).div(a));r.value.isArrayTexture&&(l=l.depth(o)),l=l.x,s.addAssign(l),d.addAssign(l.mul(l))})),s.divAssign(e),d.divAssign(e);const n=sqrt(d.sub(s.mul(s)));return vec2(s,n)})),VSMPassHorizontal=Fn((({samples:e,radius:t,size:a,shadowPass:r,depthLayer:o})=>{const s=float(0).toVar("meanHorizontal"),d=float(0).toVar("squareMeanHorizontal"),i=e.lessThanEqual(float(1)).select(float(0),float(2).div(e.sub(1))),h=e.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(e),type:"int",condition:"<"},(({i:e})=>{const n=h.add(float(e).mul(i));let l=r.sample(add(screenCoordinate.xy,vec2(n,0).mul(t)).div(a));r.value.isArrayTexture&&(l=l.depth(o)),s.addAssign(l.x),d.addAssign(add(l.y.mul(l.y),l.x.mul(l.x)))})),s.divAssign(e),d.divAssign(e);const n=sqrt(d.sub(s.mul(s)));return vec2(s,n)})),_shadowFilterLib=[BasicShadowFilter,PCFShadowFilter,PCFSoftShadowFilter,VSMShadowFilter];let _rendererState;const _quadMesh=new QuadMesh;class ShadowNode extends ShadowBaseNode{static get type(){return"ShadowNode"}constructor(e,t=null){super(e),this.shadow=t||e.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this._node=null,this._cameraFrameId=new WeakMap,this.isShadowNode=!0,this.depthLayer=0}setupShadowFilter(e,{filterFn:t,depthTexture:a,shadowCoord:r,shadow:o,depthLayer:s}){const d=r.x.greaterThanEqual(0).and(r.x.lessThanEqual(1)).and(r.y.greaterThanEqual(0)).and(r.y.lessThanEqual(1)).and(r.z.lessThanEqual(1)),i=t({depthTexture:a,shadowCoord:r,shadow:o,depthLayer:s});return d.select(i,float(1))}setupShadowCoord(e,t){const{shadow:a}=this,{renderer:r}=e,o=reference("bias","float",a).setGroup(renderGroup);let s,d=t;if(a.camera.isOrthographicCamera||!0!==r.logarithmicDepthBuffer)d=d.xyz.div(d.w),s=d.z,r.coordinateSystem===WebGPUCoordinateSystem&&(s=s.mul(2).sub(1));else{const e=d.w;d=d.xy.div(e);const t=reference("near","float",a.camera).setGroup(renderGroup),r=reference("far","float",a.camera).setGroup(renderGroup);s=viewZToLogarithmicDepth(e.negate(),t,r)}return d=vec3(d.x,d.y.oneMinus(),s.add(o)),d}getShadowFilterFn(e){return _shadowFilterLib[e]}setupRenderTarget(e,t){const a=new DepthTexture(e.mapSize.width,e.mapSize.height);a.name="ShadowDepthTexture",a.compareFunction=LessCompare;const r=t.createRenderTarget(e.mapSize.width,e.mapSize.height);return r.texture.name="ShadowMap",r.texture.type=e.mapType,r.depthTexture=a,{shadowMap:r,depthTexture:a}}setupShadow(e){const{renderer:t}=e,{light:a,shadow:r}=this,o=t.shadowMap.type,{depthTexture:s,shadowMap:d}=this.setupRenderTarget(r,e);if(r.camera.updateProjectionMatrix(),o===VSMShadowMap&&!0!==r.isPointLightShadow){s.compareFunction=null,d.depth>1?(d._vsmShadowMapVertical||(d._vsmShadowMapVertical=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:RGFormat,type:HalfFloatType,depth:d.depth,depthBuffer:!1}),d._vsmShadowMapVertical.texture.name="VSMVertical"),this.vsmShadowMapVertical=d._vsmShadowMapVertical,d._vsmShadowMapHorizontal||(d._vsmShadowMapHorizontal=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:RGFormat,type:HalfFloatType,depth:d.depth,depthBuffer:!1}),d._vsmShadowMapHorizontal.texture.name="VSMHorizontal"),this.vsmShadowMapHorizontal=d._vsmShadowMapHorizontal):(this.vsmShadowMapVertical=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:RGFormat,type:HalfFloatType,depthBuffer:!1}),this.vsmShadowMapHorizontal=e.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:RGFormat,type:HalfFloatType,depthBuffer:!1}));let t=texture(s);s.isArrayTexture&&(t=t.depth(this.depthLayer));let a=texture(this.vsmShadowMapVertical.texture);s.isArrayTexture&&(a=a.depth(this.depthLayer));const o=reference("blurSamples","float",r).setGroup(renderGroup),i=reference("radius","float",r).setGroup(renderGroup),h=reference("mapSize","vec2",r).setGroup(renderGroup);let n=this.vsmMaterialVertical||(this.vsmMaterialVertical=new NodeMaterial);n.fragmentNode=VSMPassVertical({samples:o,radius:i,size:h,shadowPass:t,depthLayer:this.depthLayer}).context(e.getSharedContext()),n.name="VSMVertical",n=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new NodeMaterial),n.fragmentNode=VSMPassHorizontal({samples:o,radius:i,size:h,shadowPass:a,depthLayer:this.depthLayer}).context(e.getSharedContext()),n.name="VSMHorizontal"}const i=reference("intensity","float",r).setGroup(renderGroup),h=reference("normalBias","float",r).setGroup(renderGroup),n=lightShadowMatrix(a).mul(shadowPositionWorld.add(normalWorld.mul(h))),l=this.setupShadowCoord(e,n),p=r.filterNode||this.getShadowFilterFn(t.shadowMap.type)||null;if(null===p)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const m=o===VSMShadowMap&&!0!==r.isPointLightShadow?this.vsmShadowMapHorizontal.texture:s,c=this.setupShadowFilter(e,{filterFn:p,shadowTexture:d.texture,depthTexture:m,shadowCoord:l,shadow:r,depthLayer:this.depthLayer});let u=texture(d.texture,l);s.isArrayTexture&&(u=u.depth(this.depthLayer));const w=mix(1,c.rgb.mix(u,1),i.mul(u.a)).toVar();return this.shadowMap=d,this.shadow.map=d,w}setup(e){if(!1!==e.renderer.shadowMap.enabled)return Fn((()=>{let t=this._node;return this.setupShadowPosition(e),null===t&&(this._node=t=this.setupShadow(e)),e.material.shadowNode&&console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'),e.material.receivedShadowNode&&(t=e.material.receivedShadowNode(t)),t}))()}renderShadow(e){const{shadow:t,shadowMap:a,light:r}=this,{renderer:o,scene:s}=e;t.updateMatrices(r),a.setSize(t.mapSize.width,t.mapSize.height,a.depth),o.render(s,t.camera)}updateShadow(e){const{shadowMap:t,light:a,shadow:r}=this,{renderer:o,scene:s,camera:d}=e,i=o.shadowMap.type,h=t.depthTexture.version;this._depthVersionCached=h;const n=r.camera.layers.mask;0==(4294967294&r.camera.layers.mask)&&(r.camera.layers.mask=d.layers.mask);const l=o.getRenderObjectFunction(),p=o.getMRT(),m=!!p&&p.has("velocity");_rendererState=resetRendererAndSceneState(o,s,_rendererState),s.overrideMaterial=getShadowMaterial(a),o.setRenderObjectFunction(getShadowRenderObjectFunction(o,r,i,m)),o.setClearColor(0,0),o.setRenderTarget(t),this.renderShadow(e),o.setRenderObjectFunction(l),i===VSMShadowMap&&!0!==r.isPointLightShadow&&this.vsmPass(o),r.camera.layers.mask=n,restoreRendererAndSceneState(o,s,_rendererState)}vsmPass(e){const{shadow:t}=this,a=this.shadowMap.depth;this.vsmShadowMapVertical.setSize(t.mapSize.width,t.mapSize.height,a),this.vsmShadowMapHorizontal.setSize(t.mapSize.width,t.mapSize.height,a),e.setRenderTarget(this.vsmShadowMapVertical),_quadMesh.material=this.vsmMaterialVertical,_quadMesh.render(e),e.setRenderTarget(this.vsmShadowMapHorizontal),_quadMesh.material=this.vsmMaterialHorizontal,_quadMesh.render(e)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,null!==this.vsmShadowMapVertical&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),null!==this.vsmShadowMapHorizontal&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),super.dispose()}updateBefore(e){const{shadow:t}=this;let a=t.needsUpdate||t.autoUpdate;a&&(this._cameraFrameId[e.camera]===e.frameId&&(a=!1),this._cameraFrameId[e.camera]=e.frameId),a&&(this.updateShadow(e),this.shadowMap.depthTexture.version===this._depthVersionCached&&(t.needsUpdate=!1))}}export default ShadowNode;export const shadow=(e,t)=>nodeObject(new ShadowNode(e,t));
//# sourceMappingURL=ShadowNode.js.map