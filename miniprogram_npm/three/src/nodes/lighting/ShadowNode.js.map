{"version":3,"file":"node_modules/three/src/nodes/lighting/ShadowNode.js","names":["ShadowBaseNode","shadowPositionWorld","float","vec2","vec3","int","Fn","nodeObject","reference","texture","normalWorld","mix","sqrt","add","DepthTexture","NodeMaterial","QuadMesh","Loop","screenCoordinate","HalfFloatType","LessCompare","RGFormat","VSMShadowMap","WebGPUCoordinateSystem","renderGroup","viewZToLogarithmicDepth","lightShadowMatrix","resetRendererAndSceneState","restoreRendererAndSceneState","getDataFromObject","getShadowMaterial","BasicShadowFilter","PCFShadowFilter","PCFSoftShadowFilter","VSMShadowFilter","ChainMap","_shadowRenderObjectLibrary","_shadowRenderObjectKeys","getShadowRenderObjectFunction","renderer","shadow","shadowType","useVelocity","renderObjectFunction","get","undefined","object","scene","_camera","geometry","material","group","params","castShadow","receiveShadow","onBeforeShadow","camera","overrideMaterial","renderObject","onAfterShadow","set","VSMPassVertical","samples","radius","size","shadowPass","depthLayer","mean","toVar","squaredMean","uvStride","lessThanEqual","select","div","sub","uvStart","start","end","type","condition","i","uvOffset","mul","depth","sample","xy","value","isArrayTexture","x","addAssign","divAssign","std_dev","VSMPassHorizontal","distribution","y","_shadowFilterLib","_rendererState","_quadMesh","ShadowNode","constructor","light","super","this","shadowMap","vsmShadowMapVertical","vsmShadowMapHorizontal","vsmMaterialVertical","vsmMaterialHorizontal","_node","_cameraFrameId","WeakMap","isShadowNode","setupShadowFilter","builder","filterFn","depthTexture","shadowCoord","frustumTest","greaterThanEqual","and","z","shadowNode","setupShadowCoord","shadowPosition","bias","setGroup","coordZ","isOrthographicCamera","logarithmicDepthBuffer","xyz","w","coordinateSystem","cameraNearLocal","cameraFarLocal","negate","oneMinus","getShadowFilterFn","setupRenderTarget","mapSize","width","height","name","compareFunction","createRenderTarget","mapType","setupShadow","shadowMapType","updateProjectionMatrix","isPointLightShadow","_vsmShadowMapVertical","format","depthBuffer","_vsmShadowMapHorizontal","shadowPassVertical","shadowPassHorizontal","fragmentNode","context","getSharedContext","shadowIntensity","normalBias","filterNode","Error","shadowDepthTexture","shadowTexture","shadowColor","shadowOutput","rgb","a","map","setup","enabled","node","setupShadowPosition","console","warn","receivedShadowNode","renderShadow","frame","updateMatrices","setSize","render","updateShadow","depthVersion","version","_depthVersionCached","_shadowCameraLayer","layers","mask","currentRenderObjectFunction","getRenderObjectFunction","currentMRT","getMRT","has","setRenderObjectFunction","setClearColor","setRenderTarget","vsmPass","dispose","updateBefore","needsUpdate","autoUpdate","frameId"],"sources":["node_modules/three/src/nodes/lighting/ShadowNode.js"],"sourcesContent":["import ShadowBaseNode, { shadowPositionWorld } from './ShadowBaseNode.js';\nimport { float, vec2, vec3, int, Fn, nodeObject } from '../tsl/TSLBase.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { normalWorld } from '../accessors/Normal.js';\nimport { mix, sqrt } from '../math/MathNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport NodeMaterial from '../../materials/nodes/NodeMaterial.js';\nimport QuadMesh from '../../renderers/common/QuadMesh.js';\nimport { Loop } from '../utils/LoopNode.js';\nimport { screenCoordinate } from '../display/ScreenNode.js';\nimport { HalfFloatType, LessCompare, RGFormat, VSMShadowMap, WebGPUCoordinateSystem } from '../../constants.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\nimport { viewZToLogarithmicDepth } from '../display/ViewportDepthNode.js';\nimport { lightShadowMatrix } from '../accessors/Lights.js';\nimport { resetRendererAndSceneState, restoreRendererAndSceneState } from '../../renderers/common/RendererUtils.js';\nimport { getDataFromObject } from '../core/NodeUtils.js';\nimport { getShadowMaterial, BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter } from './ShadowFilterNode.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\n\n//\n\nconst _shadowRenderObjectLibrary = /*@__PURE__*/ new ChainMap();\nconst _shadowRenderObjectKeys = [];\n\n/**\n * Creates a function to render shadow objects in a scene.\n *\n * @param {Renderer} renderer - The renderer.\n * @param {LightShadow} shadow - The light shadow object containing shadow properties.\n * @param {number} shadowType - The type of shadow map (e.g., BasicShadowMap).\n * @param {boolean} useVelocity - Whether to use velocity data for rendering.\n * @return {Function} A function that renders shadow objects.\n *\n * The returned function has the following parameters:\n * @param {Object3D} object - The 3D object to render.\n * @param {Scene} scene - The scene containing the object.\n * @param {Camera} _camera - The camera used for rendering.\n * @param {BufferGeometry} geometry - The geometry of the object.\n * @param {Material} material - The material of the object.\n * @param {Group} group - The group the object belongs to.\n * @param {...any} params - Additional parameters for rendering.\n */\nexport const getShadowRenderObjectFunction = ( renderer, shadow, shadowType, useVelocity ) => {\n\n\t_shadowRenderObjectKeys[ 0 ] = renderer;\n\t_shadowRenderObjectKeys[ 1 ] = shadow;\n\n\tlet renderObjectFunction = _shadowRenderObjectLibrary.get( _shadowRenderObjectKeys );\n\n\tif ( renderObjectFunction === undefined || ( renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity ) ) {\n\n\t\trenderObjectFunction = ( object, scene, _camera, geometry, material, group, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\tif ( useVelocity ) {\n\n\t\t\t\t\tgetDataFromObject( object ).useVelocity = true;\n\n\t\t\t\t}\n\n\t\t\t\tobject.onBeforeShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t\trenderer.renderObject( object, scene, _camera, geometry, material, group, ...params );\n\n\t\t\t\tobject.onAfterShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t}\n\n\t\t};\n\n\t\trenderObjectFunction.shadowType = shadowType;\n\t\trenderObjectFunction.useVelocity = useVelocity;\n\n\t\t_shadowRenderObjectLibrary.set( _shadowRenderObjectKeys, renderObjectFunction );\n\n\t}\n\n\t_shadowRenderObjectKeys[ 0 ] = null;\n\t_shadowRenderObjectKeys[ 1 ] = null;\n\n\treturn renderObjectFunction;\n\n};\n\n/**\n * Represents the shader code for the first VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {\n\n\tconst mean = float( 0 ).toVar( 'meanVertical' );\n\tconst squaredMean = float( 0 ).toVar( 'squareMeanVertical' );\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tlet depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) );\n\n\t\tif ( shadowPass.value.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\tdepth = depth.x;\n\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\n/**\n * Represents the shader code for the second VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {\n\n\tconst mean = float( 0 ).toVar( 'meanHorizontal' );\n\tconst squaredMean = float( 0 ).toVar( 'squareMeanHorizontal' );\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tlet distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\n\t\tif ( shadowPass.value.isArrayTexture ) {\n\n\t\t\tdistribution = distribution.depth( depthLayer );\n\n\t\t}\n\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nlet _rendererState;\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\n/**\n * Represents the default shadow implementation for lighting nodes.\n *\n * @augments ShadowBaseNode\n */\nclass ShadowNode extends ShadowBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t * @param {?LightShadow} [shadow=null] - An optional light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * The light shadow which defines the properties light's\n\t\t * shadow.\n\t\t *\n\t\t * @type {?LightShadow}\n\t\t * @default null\n\t\t */\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\t/**\n\t\t * A reference to the shadow map which is a render target.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowMap = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * first VSM render pass.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * second VSM render pass.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the first VSM pass.\n\t\t *\n\t\t * @type {?NodeMaterial}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the second VSM pass.\n\t\t *\n\t\t * @type {?NodeMaterial}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t/**\n\t\t * A reference to the output node which defines the\n\t\t * final result of this shadow node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._node = null;\n\n\t\tthis._cameraFrameId = new WeakMap();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNode = true;\n\n\t\t/**\n\t\t * This index can be used when overriding setupRenderTarget with a RenderTarget Array to specify the depth layer.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.depthLayer = 0;\n\n\t}\n\n\t/**\n\t * Setups the shadow filtering.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow, depthLayer } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow, depthLayer } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\t/**\n\t * Setups the shadow coordinates.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\t/**\n\t * Returns the shadow filtering function for the given shadow type.\n\t *\n\t * @param {number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\n\tsetupRenderTarget( shadow, builder ) {\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.name = 'ShadowDepthTexture';\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.texture.name = 'ShadowMap';\n\t\tshadowMap.texture.type = shadow.mapType;\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\treturn { shadowMap, depthTexture };\n\n\t}\n\n\t/**\n\t * Setups the shadow output node.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} The shadow output node.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst { depthTexture, shadowMap } = this.setupRenderTarget( shadow, builder );\n\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tif ( shadowMap.depth > 1 ) {\n\n\t\t\t\tif ( ! shadowMap._vsmShadowMapVertical ) {\n\n\t\t\t\t\tshadowMap._vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );\n\t\t\t\t\tshadowMap._vsmShadowMapVertical.texture.name = 'VSMVertical';\n\n\t\t\t\t}\n\n\t\t\t\tthis.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;\n\n\t\t\t\tif ( ! shadowMap._vsmShadowMapHorizontal ) {\n\n\t\t\t\t\tshadowMap._vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );\n\t\t\t\t\tshadowMap._vsmShadowMapHorizontal.texture.name = 'VSMHorizontal';\n\n\t\t\t\t}\n\n\t\t\t\tthis.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;\n\n\t\t\t} else {\n\n\t\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );\n\t\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );\n\n\t\t\t}\n\n\n\t\t\tlet shadowPassVertical = texture( depthTexture );\n\n\t\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\t\tshadowPassVertical = shadowPassVertical.depth( this.depthLayer );\n\n\t\t\t}\n\n\t\t\tlet shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\t\tshadowPassHorizontal = shadowPassHorizontal.depth( this.depthLayer );\n\n\t\t\t}\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowPositionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow, depthLayer: this.depthLayer } );\n\n\t\tlet shadowColor = texture( shadowMap.texture, shadowCoord );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tshadowColor = shadowColor.depth( this.depthLayer );\n\n\t\t}\n\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\treturn shadowOutput;\n\n\t}\n\n\t/**\n\t * The implementation performs the setup of the output node. An output is only\n\t * produces if shadow mapping is globally enabled in the renderer.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {ShaderCallNodeInternal} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( () => {\n\n\t\t\tlet node = this._node;\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Renders the shadow. The logic of this function could be included\n\t * into {@link ShadowNode#updateShadow} however more specialized shadow\n\t * nodes might require a custom shadow map rendering. By having a\n\t * dedicated method, it's easier to overwrite the default behavior.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadow.updateMatrices( light );\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height, shadowMap.depth );\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t}\n\n\t/**\n\t * Updates the shadow.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tconst _shadowCameraLayer = shadow.camera.layers.mask;\n\n\t\tif ( ( shadow.camera.layers.mask & 0xFFFFFFFE ) === 0 ) {\n\n\t\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\t}\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;\n\n\t\t_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\trenderer.setRenderObjectFunction( getShadowRenderObjectFunction( renderer, shadow, shadowType, useVelocity ) );\n\n\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( shadowType === VSMShadowMap && shadow.isPointLightShadow !== true ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\tshadow.camera.layers.mask = _shadowCameraLayer;\n\n\t\trestoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * For VSM additional render passes are required.\n\t *\n\t * @param {Renderer} renderer - A reference to the current renderer.\n\t */\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst depth = this.shadowMap.depth;\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh.material = this.vsmMaterialVertical;\n\t\t_quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh.render( renderer );\n\n\t}\n\n\t/**\n\t * Frees the internal resources of this shadow node.\n\t */\n\tdispose() {\n\n\t\tthis.shadowMap.dispose();\n\t\tthis.shadowMap = null;\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n\t/**\n\t * The implementation performs the update of the shadow map if necessary.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tlet needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tif ( this._cameraFrameId[ frame.camera ] === frame.frameId ) {\n\n\t\t\t\tneedsUpdate = false;\n\n\t\t\t}\n\n\t\t\tthis._cameraFrameId[ frame.camera ] = frame.frameId;\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default ShadowNode;\n\n/**\n * TSL function for creating an instance of `ShadowNode`.\n *\n * @tsl\n * @function\n * @param {Light} light - The shadow casting light.\n * @param {?LightShadow} [shadow] - The light shadow.\n * @return {ShadowNode} The created shadow node.\n */\nexport const shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n"],"mappings":"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","ignoreList":[]}