import AnalyticLightNode from"./AnalyticLightNode.js";import{getDistanceAttenuation}from"./LightUtils.js";import{uniform}from"../core/UniformNode.js";import{smoothstep}from"../math/MathNode.js";import{renderGroup}from"../core/UniformGroupNode.js";import{lightTargetDirection,lightProjectionUV}from"../accessors/Lights.js";import{texture}from"../accessors/TextureNode.js";class SpotLightNode extends AnalyticLightNode{static get type(){return"SpotLightNode"}constructor(t=null){super(t),this.coneCosNode=uniform(0).setGroup(renderGroup),this.penumbraCosNode=uniform(0).setGroup(renderGroup),this.cutoffDistanceNode=uniform(0).setGroup(renderGroup),this.decayExponentNode=uniform(0).setGroup(renderGroup),this.colorNode=uniform(this.color).setGroup(renderGroup)}update(t){super.update(t);const{light:o}=this;this.coneCosNode.value=Math.cos(o.angle),this.penumbraCosNode.value=Math.cos(o.angle*(1-o.penumbra)),this.cutoffDistanceNode.value=o.distance,this.decayExponentNode.value=o.decay}getSpotAttenuation(t,o){const{coneCosNode:e,penumbraCosNode:r}=this;return smoothstep(e,r,o)}getLightCoord(t){const o=t.getNodeProperties(this);let e=o.projectionUV;return void 0===e&&(e=lightProjectionUV(this.light,t.context.positionWorld),o.projectionUV=e),e}setupDirect(t){const{colorNode:o,cutoffDistanceNode:e,decayExponentNode:r,light:i}=this,s=this.getLightVector(t),n=s.normalize(),c=n.dot(lightTargetDirection(i)),u=this.getSpotAttenuation(t,c),a=s.length(),d=getDistanceAttenuation({lightDistance:a,cutoffDistance:e,decayExponent:r});let h,p,l=o.mul(u).mul(d);if(i.colorNode?(p=this.getLightCoord(t),h=i.colorNode(p)):i.map&&(p=this.getLightCoord(t),h=texture(i.map,p.xy).onRenderUpdate((()=>i.map))),h){l=p.mul(2).sub(1).abs().lessThan(1).all().select(l.mul(h),l)}return{lightColor:l,lightDirection:n}}}export default SpotLightNode;
//# sourceMappingURL=SpotLightNode.js.map