import{int,float,vec3,If,Fn}from"../../tsl/TSLBase.js";import{add}from"../../math/OperatorNode.js";import{floor,trunc,max,min}from"../../math/MathNode.js";export const mx_hsvtorgb=Fn((([s])=>{const a=s.y,t=s.z,e=vec3().toVar();return If(a.lessThan(1e-4),(()=>{e.assign(vec3(t,t,t))})).Else((()=>{let n=s.x;n=n.sub(floor(n)).mul(6).toVar();const o=int(trunc(n)),l=n.sub(float(o)),r=t.mul(a.oneMinus()),i=t.mul(a.mul(l).oneMinus()),u=t.mul(a.mul(l.oneMinus()).oneMinus());If(o.equal(int(0)),(()=>{e.assign(vec3(t,u,r))})).ElseIf(o.equal(int(1)),(()=>{e.assign(vec3(i,t,r))})).ElseIf(o.equal(int(2)),(()=>{e.assign(vec3(r,t,u))})).ElseIf(o.equal(int(3)),(()=>{e.assign(vec3(r,i,t))})).ElseIf(o.equal(int(4)),(()=>{e.assign(vec3(u,r,t))})).Else((()=>{e.assign(vec3(t,r,i))}))})),e})).setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]});export const mx_rgbtohsv=Fn((([s])=>{const a=vec3(s).toVar(),t=float(a.x).toVar(),e=float(a.y).toVar(),n=float(a.z).toVar(),o=float(min(t,min(e,n))).toVar(),l=float(max(t,max(e,n))).toVar(),r=float(l.sub(o)).toVar(),i=float().toVar(),u=float().toVar(),m=float().toVar();return m.assign(l),If(l.greaterThan(0),(()=>{u.assign(r.div(l))})).Else((()=>{u.assign(0)})),If(u.lessThanEqual(0),(()=>{i.assign(0)})).Else((()=>{If(t.greaterThanEqual(l),(()=>{i.assign(e.sub(n).div(r))})).ElseIf(e.greaterThanEqual(l),(()=>{i.assign(add(2,n.sub(t).div(r)))})).Else((()=>{i.assign(add(4,t.sub(e).div(r)))})),i.mulAssign(1/6),If(i.lessThan(0),(()=>{i.addAssign(1)}))})),vec3(i,u,m)})).setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]});
//# sourceMappingURL=mx_hsv.js.map