{"version":3,"file":"node_modules/three/src/nodes/math/ConditionalNode.js","names":["Node","property","addMethodChaining","nodeProxy","ConditionalNode","type","constructor","condNode","ifNode","elseNode","super","this","getNodeType","builder","getNodeProperties","undefined","flowBuildStage","ifType","elseType","getTypeLength","setup","cache","currentNodeBlock","context","nodeBlock","getDataFromNode","parentNodeBlock","properties","generate","output","nodeData","nodeProperty","functionNode","currentFunctionNode","needsOutput","build","nodeSnippet","addFlowCode","tab","addFlowTab","ifSnippet","console","warn","removeFlowTab","elseSnippet","format","select","setParameterLength"],"sources":["node_modules/three/src/nodes/math/ConditionalNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { property } from '../core/PropertyNode.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional node.\n\t *\n\t * @param {Node} condNode - The node that defines the condition.\n\t * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n\t * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n\t */\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that defines the condition.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.condNode = condNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `true`.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.ifNode = ifNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `false`.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the if/else\n\t * nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tif ( ifNode === undefined ) {\n\n\t\t\t// fallback setup\n\n\t\t\tbuilder.flowBuildStage( this, 'setup' );\n\n\t\t\treturn this.getNodeType( builder );\n\n\t\t}\n\n\t\tconst ifType = ifNode.getNodeType( builder );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tconst elseType = elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst functionNode = builder.currentFunctionNode;\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\tifSnippet = '// ' + ifSnippet;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\t\telseSnippet = '// ' + elseSnippet;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\nexport default ConditionalNode;\n\n/**\n * TSL function for creating a conditional node.\n *\n * @tsl\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nexport const select = /*@__PURE__*/ nodeProxy( ConditionalNode ).setParameterLength( 2, 3 );\n\naddMethodChaining( 'select', select );\n"],"mappings":"OAAOA,SAAU,yBACRC,aAAgB,iCAChBC,kBAAmBC,cAAiB,oBAe7C,MAAMC,wBAAwBJ,KAE7B,eAAWK,GAEV,MAAO,iBAER,CASA,WAAAC,CAAaC,EAAUC,EAAQC,EAAW,MAEzCC,QAOAC,KAAKJ,SAAWA,EAOhBI,KAAKH,OAASA,EAQdG,KAAKF,SAAWA,CAEjB,CASA,WAAAG,CAAaC,GAEZ,MAAML,OAAEA,EAAMC,SAAEA,GAAaI,EAAQC,kBAAmBH,MAExD,QAAgBI,IAAXP,EAMJ,OAFAK,EAAQG,eAAgBL,KAAM,SAEvBA,KAAKC,YAAaC,GAI1B,MAAMI,EAAST,EAAOI,YAAaC,GAEnC,GAAkB,OAAbJ,EAAoB,CAExB,MAAMS,EAAWT,EAASG,YAAaC,GAEvC,GAAKA,EAAQM,cAAeD,GAAaL,EAAQM,cAAeF,GAE/D,OAAOC,CAIT,CAEA,OAAOD,CAER,CAEA,KAAAG,CAAOP,GAEN,MAAMN,EAAWI,KAAKJ,SAASc,QACzBb,EAASG,KAAKH,OAAOa,QACrBZ,EAAWE,KAAKF,SAAWE,KAAKF,SAASY,QAAU,KAInDC,EAAmBT,EAAQU,QAAQC,UAEzCX,EAAQY,gBAAiBjB,GAASkB,gBAAkBJ,EAClC,OAAbb,IAAoBI,EAAQY,gBAAiBhB,GAAWiB,gBAAkBJ,GAI/E,MAAMK,EAAad,EAAQC,kBAAmBH,MAC9CgB,EAAWpB,SAAWA,EACtBoB,EAAWnB,OAASA,EAAOe,QAAS,CAAEC,UAAWhB,IACjDmB,EAAWlB,SAAWA,EAAWA,EAASc,QAAS,CAAEC,UAAWf,IAAe,IAEhF,CAEA,QAAAmB,CAAUf,EAASgB,GAElB,MAAMxB,EAAOM,KAAKC,YAAaC,GAEzBiB,EAAWjB,EAAQY,gBAAiBd,MAE1C,QAA+BI,IAA1Be,EAASC,aAEb,OAAOD,EAASC,aAIjB,MAAMxB,SAAEA,EAAQC,OAAEA,EAAMC,SAAEA,GAAaI,EAAQC,kBAAmBH,MAE5DqB,EAAenB,EAAQoB,oBACvBC,EAAyB,SAAXL,EACdE,EAAeG,EAAcjC,SAAUI,GAAO8B,MAAOtB,GAAY,GAEvEiB,EAASC,aAAeA,EAExB,MAAMK,EAAc7B,EAAS4B,MAAOtB,EAAS,QAE7CA,EAAQwB,YAAa,KAAMxB,EAAQyB,WAAaF,aAAyBG,aAEzE,IAAIC,EAAYhC,EAAO2B,MAAOtB,EAASR,GA0BvC,GAxBKmC,IAECN,EAEJM,EAAYT,EAAe,MAAQS,EAAY,KAI/CA,EAAY,UAAYA,EAAY,IAEd,OAAjBR,IAEJS,QAAQC,KAAM,wGAEdF,EAAY,MAAQA,KAQvB3B,EAAQ8B,gBAAgBN,YAAaxB,EAAQyB,IAAM,KAAOE,EAAY,OAAS3B,EAAQyB,IAAM,KAE3E,OAAb7B,EAAoB,CAExBI,EAAQwB,YAAa,eAAgBE,aAErC,IAAIK,EAAcnC,EAAS0B,MAAOtB,EAASR,GAEtCuC,IAECV,EAEJU,EAAcb,EAAe,MAAQa,EAAc,KAInDA,EAAc,UAAYA,EAAc,IAElB,OAAjBZ,IAEJS,QAAQC,KAAM,wGAEdE,EAAc,MAAQA,KAQzB/B,EAAQ8B,gBAAgBN,YAAaxB,EAAQyB,IAAM,KAAOM,EAAc,OAAS/B,EAAQyB,IAAM,QAEhG,MAECzB,EAAQwB,YAAa,QAItB,OAAOxB,EAAQgC,OAAQd,EAAc1B,EAAMwB,EAE5C,iBAIczB,uBAYR,MAAM0C,OAAuB3C,UAAWC,iBAAkB2C,mBAAoB,EAAG,GAExF7C,kBAAmB,SAAU4C","ignoreList":[]}