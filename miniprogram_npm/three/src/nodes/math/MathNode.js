import TempNode from"../core/TempNode.js";import{sub,mul,div,mod,equal}from"./OperatorNode.js";import{addMethodChaining,nodeObject,nodeProxyIntent,float,vec2,vec3,vec4,Fn}from"../tsl/TSLCore.js";import{WebGLCoordinateSystem,WebGPUCoordinateSystem}from"../../constants.js";class MathNode extends TempNode{static get type(){return"MathNode"}constructor(e,t,o=null,a=null){if(super(),(e===MathNode.MAX||e===MathNode.MIN)&&arguments.length>3){let n=new MathNode(e,t,o);for(let t=2;t<arguments.length-1;t++)n=new MathNode(e,n,arguments[t]);t=n,o=arguments[arguments.length-1],a=null}this.method=e,this.aNode=t,this.bNode=o,this.cNode=a,this.isMathNode=!0}getInputType(e){const t=this.aNode.getNodeType(e),o=this.bNode?this.bNode.getNodeType(e):null,a=this.cNode?this.cNode.getNodeType(e):null,n=e.isMatrix(t)?0:e.getTypeLength(t),d=e.isMatrix(o)?0:e.getTypeLength(o),h=e.isMatrix(a)?0:e.getTypeLength(a);return n>d&&n>h?t:d>h?o:h>n?a:t}getNodeType(e){const t=this.method;return t===MathNode.LENGTH||t===MathNode.DISTANCE||t===MathNode.DOT?"float":t===MathNode.CROSS?"vec3":t===MathNode.ALL||t===MathNode.ANY?"bool":t===MathNode.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):this.getInputType(e)}setup(e){const{aNode:t,bNode:o,method:a}=this;let n=null;if(a===MathNode.ONE_MINUS)n=sub(1,t);else if(a===MathNode.RECIPROCAL)n=div(1,t);else if(a===MathNode.DIFFERENCE)n=abs(sub(t,o));else if(a===MathNode.TRANSFORM_DIRECTION){let a=t,d=o;e.isMatrix(a.getNodeType(e))?d=vec4(vec3(d),0):a=vec4(vec3(a),0);const h=mul(a,d).xyz;n=normalize(h)}return null!==n?n:super.setup(e)}generate(e,t){if(e.getNodeProperties(this).outputNode)return super.generate(e,t);let o=this.method;const a=this.getNodeType(e),n=this.getInputType(e),d=this.aNode,h=this.bNode,r=this.cNode,s=e.renderer.coordinateSystem;if(o===MathNode.NEGATE)return e.format("( - "+d.build(e,n)+" )",a,t);{const i=[];return o===MathNode.CROSS?i.push(d.build(e,a),h.build(e,a)):s===WebGLCoordinateSystem&&o===MathNode.STEP?i.push(d.build(e,1===e.getTypeLength(d.getNodeType(e))?"float":n),h.build(e,n)):s!==WebGLCoordinateSystem||o!==MathNode.MIN&&o!==MathNode.MAX?o===MathNode.REFRACT?i.push(d.build(e,n),h.build(e,n),r.build(e,"float")):o===MathNode.MIX?i.push(d.build(e,n),h.build(e,n),r.build(e,1===e.getTypeLength(r.getNodeType(e))?"float":n)):(s===WebGPUCoordinateSystem&&o===MathNode.ATAN&&null!==h&&(o="atan2"),"fragment"===e.shaderStage||o!==MathNode.DFDX&&o!==MathNode.DFDY||(console.warn(`THREE.TSL: '${o}' is not supported in the ${e.shaderStage} stage.`),o="/*"+o+"*/"),i.push(d.build(e,n)),null!==h&&i.push(h.build(e,n)),null!==r&&i.push(r.build(e,n))):i.push(d.build(e,n),h.build(e,1===e.getTypeLength(h.getNodeType(e))?"float":n)),e.format(`${e.getMethod(o,a)}( ${i.join(", ")} )`,a,t)}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}MathNode.ALL="all",MathNode.ANY="any",MathNode.RADIANS="radians",MathNode.DEGREES="degrees",MathNode.EXP="exp",MathNode.EXP2="exp2",MathNode.LOG="log",MathNode.LOG2="log2",MathNode.SQRT="sqrt",MathNode.INVERSE_SQRT="inversesqrt",MathNode.FLOOR="floor",MathNode.CEIL="ceil",MathNode.NORMALIZE="normalize",MathNode.FRACT="fract",MathNode.SIN="sin",MathNode.COS="cos",MathNode.TAN="tan",MathNode.ASIN="asin",MathNode.ACOS="acos",MathNode.ATAN="atan",MathNode.ABS="abs",MathNode.SIGN="sign",MathNode.LENGTH="length",MathNode.NEGATE="negate",MathNode.ONE_MINUS="oneMinus",MathNode.DFDX="dFdx",MathNode.DFDY="dFdy",MathNode.ROUND="round",MathNode.RECIPROCAL="reciprocal",MathNode.TRUNC="trunc",MathNode.FWIDTH="fwidth",MathNode.TRANSPOSE="transpose",MathNode.DETERMINANT="determinant",MathNode.INVERSE="inverse",MathNode.BITCAST="bitcast",MathNode.EQUALS="equals",MathNode.MIN="min",MathNode.MAX="max",MathNode.STEP="step",MathNode.REFLECT="reflect",MathNode.DISTANCE="distance",MathNode.DIFFERENCE="difference",MathNode.DOT="dot",MathNode.CROSS="cross",MathNode.POW="pow",MathNode.TRANSFORM_DIRECTION="transformDirection",MathNode.MIX="mix",MathNode.CLAMP="clamp",MathNode.REFRACT="refract",MathNode.SMOOTHSTEP="smoothstep",MathNode.FACEFORWARD="faceforward";export default MathNode;export const EPSILON=float(1e-6);export const INFINITY=float(1e6);export const PI=float(Math.PI);export const PI2=float(2*Math.PI);export const all=nodeProxyIntent(MathNode,MathNode.ALL).setParameterLength(1);export const any=nodeProxyIntent(MathNode,MathNode.ANY).setParameterLength(1);export const radians=nodeProxyIntent(MathNode,MathNode.RADIANS).setParameterLength(1);export const degrees=nodeProxyIntent(MathNode,MathNode.DEGREES).setParameterLength(1);export const exp=nodeProxyIntent(MathNode,MathNode.EXP).setParameterLength(1);export const exp2=nodeProxyIntent(MathNode,MathNode.EXP2).setParameterLength(1);export const log=nodeProxyIntent(MathNode,MathNode.LOG).setParameterLength(1);export const log2=nodeProxyIntent(MathNode,MathNode.LOG2).setParameterLength(1);export const sqrt=nodeProxyIntent(MathNode,MathNode.SQRT).setParameterLength(1);export const inverseSqrt=nodeProxyIntent(MathNode,MathNode.INVERSE_SQRT).setParameterLength(1);export const floor=nodeProxyIntent(MathNode,MathNode.FLOOR).setParameterLength(1);export const ceil=nodeProxyIntent(MathNode,MathNode.CEIL).setParameterLength(1);export const normalize=nodeProxyIntent(MathNode,MathNode.NORMALIZE).setParameterLength(1);export const fract=nodeProxyIntent(MathNode,MathNode.FRACT).setParameterLength(1);export const sin=nodeProxyIntent(MathNode,MathNode.SIN).setParameterLength(1);export const cos=nodeProxyIntent(MathNode,MathNode.COS).setParameterLength(1);export const tan=nodeProxyIntent(MathNode,MathNode.TAN).setParameterLength(1);export const asin=nodeProxyIntent(MathNode,MathNode.ASIN).setParameterLength(1);export const acos=nodeProxyIntent(MathNode,MathNode.ACOS).setParameterLength(1);export const atan=nodeProxyIntent(MathNode,MathNode.ATAN).setParameterLength(1,2);export const abs=nodeProxyIntent(MathNode,MathNode.ABS).setParameterLength(1);export const sign=nodeProxyIntent(MathNode,MathNode.SIGN).setParameterLength(1);export const length=nodeProxyIntent(MathNode,MathNode.LENGTH).setParameterLength(1);export const negate=nodeProxyIntent(MathNode,MathNode.NEGATE).setParameterLength(1);export const oneMinus=nodeProxyIntent(MathNode,MathNode.ONE_MINUS).setParameterLength(1);export const dFdx=nodeProxyIntent(MathNode,MathNode.DFDX).setParameterLength(1);export const dFdy=nodeProxyIntent(MathNode,MathNode.DFDY).setParameterLength(1);export const round=nodeProxyIntent(MathNode,MathNode.ROUND).setParameterLength(1);export const reciprocal=nodeProxyIntent(MathNode,MathNode.RECIPROCAL).setParameterLength(1);export const trunc=nodeProxyIntent(MathNode,MathNode.TRUNC).setParameterLength(1);export const fwidth=nodeProxyIntent(MathNode,MathNode.FWIDTH).setParameterLength(1);export const transpose=nodeProxyIntent(MathNode,MathNode.TRANSPOSE).setParameterLength(1);export const determinant=nodeProxyIntent(MathNode,MathNode.DETERMINANT).setParameterLength(1);export const inverse=nodeProxyIntent(MathNode,MathNode.INVERSE).setParameterLength(1);export const bitcast=nodeProxyIntent(MathNode,MathNode.BITCAST).setParameterLength(2);export const equals=(e,t)=>(console.warn('THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"'),equal(e,t));export const min=nodeProxyIntent(MathNode,MathNode.MIN).setParameterLength(2,1/0);export const max=nodeProxyIntent(MathNode,MathNode.MAX).setParameterLength(2,1/0);export const step=nodeProxyIntent(MathNode,MathNode.STEP).setParameterLength(2);export const reflect=nodeProxyIntent(MathNode,MathNode.REFLECT).setParameterLength(2);export const distance=nodeProxyIntent(MathNode,MathNode.DISTANCE).setParameterLength(2);export const difference=nodeProxyIntent(MathNode,MathNode.DIFFERENCE).setParameterLength(2);export const dot=nodeProxyIntent(MathNode,MathNode.DOT).setParameterLength(2);export const cross=nodeProxyIntent(MathNode,MathNode.CROSS).setParameterLength(2);export const pow=nodeProxyIntent(MathNode,MathNode.POW).setParameterLength(2);export const pow2=nodeProxyIntent(MathNode,MathNode.POW,2).setParameterLength(1);export const pow3=nodeProxyIntent(MathNode,MathNode.POW,3).setParameterLength(1);export const pow4=nodeProxyIntent(MathNode,MathNode.POW,4).setParameterLength(1);export const transformDirection=nodeProxyIntent(MathNode,MathNode.TRANSFORM_DIRECTION).setParameterLength(2);export const cbrt=e=>mul(sign(e),pow(abs(e),1/3));export const lengthSq=e=>dot(e,e);export const mix=nodeProxyIntent(MathNode,MathNode.MIX).setParameterLength(3);export const clamp=(e,t=0,o=1)=>nodeObject(new MathNode(MathNode.CLAMP,nodeObject(e),nodeObject(t),nodeObject(o)));export const saturate=e=>clamp(e);export const refract=nodeProxyIntent(MathNode,MathNode.REFRACT).setParameterLength(3);export const smoothstep=nodeProxyIntent(MathNode,MathNode.SMOOTHSTEP).setParameterLength(3);export const faceForward=nodeProxyIntent(MathNode,MathNode.FACEFORWARD).setParameterLength(3);export const rand=Fn((([e])=>{const t=dot(e.xy,vec2(12.9898,78.233)),o=mod(t,PI);return fract(sin(o).mul(43758.5453))}));export const mixElement=(e,t,o)=>mix(t,o,e);export const smoothstepElement=(e,t,o)=>smoothstep(t,o,e);export const stepElement=(e,t)=>step(t,e);export const atan2=(e,t)=>(console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'),atan(e,t));export const faceforward=faceForward;export const inversesqrt=inverseSqrt;addMethodChaining("all",all),addMethodChaining("any",any),addMethodChaining("equals",equals),addMethodChaining("radians",radians),addMethodChaining("degrees",degrees),addMethodChaining("exp",exp),addMethodChaining("exp2",exp2),addMethodChaining("log",log),addMethodChaining("log2",log2),addMethodChaining("sqrt",sqrt),addMethodChaining("inverseSqrt",inverseSqrt),addMethodChaining("floor",floor),addMethodChaining("ceil",ceil),addMethodChaining("normalize",normalize),addMethodChaining("fract",fract),addMethodChaining("sin",sin),addMethodChaining("cos",cos),addMethodChaining("tan",tan),addMethodChaining("asin",asin),addMethodChaining("acos",acos),addMethodChaining("atan",atan),addMethodChaining("abs",abs),addMethodChaining("sign",sign),addMethodChaining("length",length),addMethodChaining("lengthSq",lengthSq),addMethodChaining("negate",negate),addMethodChaining("oneMinus",oneMinus),addMethodChaining("dFdx",dFdx),addMethodChaining("dFdy",dFdy),addMethodChaining("round",round),addMethodChaining("reciprocal",reciprocal),addMethodChaining("trunc",trunc),addMethodChaining("fwidth",fwidth),addMethodChaining("atan2",atan2),addMethodChaining("min",min),addMethodChaining("max",max),addMethodChaining("step",stepElement),addMethodChaining("reflect",reflect),addMethodChaining("distance",distance),addMethodChaining("dot",dot),addMethodChaining("cross",cross),addMethodChaining("pow",pow),addMethodChaining("pow2",pow2),addMethodChaining("pow3",pow3),addMethodChaining("pow4",pow4),addMethodChaining("transformDirection",transformDirection),addMethodChaining("mix",mixElement),addMethodChaining("clamp",clamp),addMethodChaining("refract",refract),addMethodChaining("smoothstep",smoothstepElement),addMethodChaining("faceForward",faceForward),addMethodChaining("difference",difference),addMethodChaining("saturate",saturate),addMethodChaining("cbrt",cbrt),addMethodChaining("transpose",transpose),addMethodChaining("determinant",determinant),addMethodChaining("inverse",inverse),addMethodChaining("rand",rand);
//# sourceMappingURL=MathNode.js.map