{"version":3,"file":"node_modules/three/src/nodes/math/MathNode.js","names":["TempNode","sub","mul","div","mod","equal","addMethodChaining","nodeObject","nodeProxyIntent","float","vec2","vec3","vec4","Fn","WebGLCoordinateSystem","WebGPUCoordinateSystem","MathNode","type","constructor","method","aNode","bNode","cNode","super","MAX","MIN","arguments","length","finalOp","i","this","isMathNode","getInputType","builder","aType","getNodeType","bType","cType","aLen","isMatrix","getTypeLength","bLen","cLen","LENGTH","DISTANCE","DOT","CROSS","ALL","ANY","EQUALS","changeComponentType","setup","outputNode","ONE_MINUS","RECIPROCAL","DIFFERENCE","abs","TRANSFORM_DIRECTION","tA","tB","mulNode","xyz","normalize","generate","output","getNodeProperties","inputType","a","b","c","coordinateSystem","renderer","NEGATE","format","build","params","push","STEP","REFRACT","MIX","ATAN","shaderStage","DFDX","DFDY","console","warn","getMethod","join","serialize","data","deserialize","RADIANS","DEGREES","EXP","EXP2","LOG","LOG2","SQRT","INVERSE_SQRT","FLOOR","CEIL","NORMALIZE","FRACT","SIN","COS","TAN","ASIN","ACOS","ABS","SIGN","ROUND","TRUNC","FWIDTH","TRANSPOSE","DETERMINANT","INVERSE","BITCAST","REFLECT","POW","CLAMP","SMOOTHSTEP","FACEFORWARD","EPSILON","INFINITY","PI","Math","PI2","all","setParameterLength","any","radians","degrees","exp","exp2","log","log2","sqrt","inverseSqrt","floor","ceil","fract","sin","cos","tan","asin","acos","atan","sign","negate","oneMinus","dFdx","dFdy","round","reciprocal","trunc","fwidth","transpose","determinant","inverse","bitcast","equals","x","y","min","Infinity","max","step","reflect","distance","difference","dot","cross","pow","pow2","pow3","pow4","transformDirection","cbrt","lengthSq","mix","clamp","value","low","high","saturate","refract","smoothstep","faceForward","rand","uv","dt","xy","sn","mixElement","t","e1","e2","smoothstepElement","stepElement","edge","atan2","faceforward","inversesqrt"],"sources":["node_modules/three/src/nodes/math/MathNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { sub, mul, div, mod, equal } from './OperatorNode.js';\nimport { addMethodChaining, nodeObject, nodeProxyIntent, float, vec2, vec3, vec4, Fn } from '../tsl/TSLCore.js';\nimport { WebGLCoordinateSystem, WebGPUCoordinateSystem } from '../../constants.js';\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\t/**\n\t * Constructs a new math node.\n\t *\n\t * @param {string} method - The method name.\n\t * @param {Node} aNode - The first input.\n\t * @param {?Node} [bNode=null] - The second input.\n\t * @param {?Node} [cNode=null] - The third input.\n\t */\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\t// Allow the max() and min() functions to take an arbitrary number of arguments.\n\n\t\tif ( ( method === MathNode.MAX || method === MathNode.MIN ) && arguments.length > 3 ) {\n\n\t\t\tlet finalOp = new MathNode( method, aNode, bNode );\n\n\t\t\tfor ( let i = 2; i < arguments.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new MathNode( method, finalOp, arguments[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = arguments[ arguments.length - 1 ];\n\t\t\tcNode = null;\n\n\t\t}\n\n\t\t/**\n\t\t * The method name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * The third input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.cNode = cNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMathNode = true;\n\n\t}\n\n\t/**\n\t * The input type is inferred from the node types of the input nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\t/**\n\t * The selected method as well as the input type determine the node type of this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL || method === MathNode.ANY ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { aNode, bNode, method } = this;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === MathNode.ONE_MINUS ) {\n\n\t\t\toutputNode = sub( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\toutputNode = div( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\toutputNode = abs( sub( aNode, bNode ) );\n\n\t\t} else if ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = aNode;\n\t\t\tlet tB = bNode;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\toutputNode = normalize( mulNode );\n\n\t\t}\n\n\t\tif ( outputNode !== null ) {\n\n\t\t\treturn outputNode;\n\n\t\t} else {\n\n\t\t\treturn super.setup( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode ) {\n\n\t\t\treturn super.generate( builder, output );\n\n\t\t}\n\n\t\tlet method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst coordinateSystem = builder.renderer.coordinateSystem;\n\n\t\tif ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {\n\n\t\t\t\t\tmethod = 'atan2';\n\n\t\t\t\t}\n\n\t\t\t\tif ( builder.shaderStage !== 'fragment' && ( method === MathNode.DFDX || method === MathNode.DFDY ) ) {\n\n\t\t\t\t\tconsole.warn( `THREE.TSL: '${ method }' is not supported in the ${ builder.shaderStage } stage.` );\n\n\t\t\t\t\tmethod = '/*' + method + '*/';\n\n\t\t\t\t}\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\nMathNode.DETERMINANT = 'determinant';\nMathNode.INVERSE = 'inverse';\n\n// 2 inputs\n\nMathNode.BITCAST = 'bitcast';\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\nexport default MathNode;\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const EPSILON = /*@__PURE__*/ float( 1e-6 );\n\n/**\n * Represents infinity.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const INFINITY = /*@__PURE__*/ float( 1e6 );\n\n/**\n * Represents PI.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const PI = /*@__PURE__*/ float( Math.PI );\n\n/**\n * Represents PI * 2.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nexport const all = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ALL ).setParameterLength( 1 );\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nexport const any = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ANY ).setParameterLength( 1 );\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in degrees.\n * @returns {Node}\n */\nexport const radians = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RADIANS ).setParameterLength( 1 );\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in radians.\n * @returns {Node}\n */\nexport const degrees = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DEGREES ).setParameterLength( 1 );\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const exp = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP ).setParameterLength( 1 );\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const exp2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP2 ).setParameterLength( 1 );\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const log = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG ).setParameterLength( 1 );\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const log2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG2 ).setParameterLength( 1 );\n\n/**\n * Returns the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SQRT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const inverseSqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE_SQRT ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const floor = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FLOOR ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const ceil = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CEIL ).setParameterLength( 1 );\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nexport const normalize = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NORMALIZE ).setParameterLength( 1 );\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const fract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FRACT ).setParameterLength( 1 );\n\n/**\n * Returns the sine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIN ).setParameterLength( 1 );\n\n/**\n * Returns the cosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const cos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.COS ).setParameterLength( 1 );\n\n/**\n * Returns the tangent of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const tan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TAN ).setParameterLength( 1 );\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const asin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ASIN ).setParameterLength( 1 );\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const acos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ACOS ).setParameterLength( 1 );\n\n/**\n * Returns the arc-tangent of the parameter.\n * If two parameters are provided, the result is `atan2(y/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} y - The y parameter.\n * @param {?(Node | number)} x - The x parameter.\n * @returns {Node}\n */\nexport const atan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ATAN ).setParameterLength( 1, 2 );\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const abs = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ABS ).setParameterLength( 1 );\n\n/**\n * Extracts the sign of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sign = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIGN ).setParameterLength( 1 );\n\n/**\n * Calculates the length of a vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nexport const length = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LENGTH ).setParameterLength( 1 );\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const negate = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NEGATE ).setParameterLength( 1 );\n\n/**\n * Return `1` minus the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const oneMinus = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ONE_MINUS ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const dFdx = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDX ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const dFdy = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDY ).setParameterLength( 1 );\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const round = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ROUND ).setParameterLength( 1 );\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const reciprocal = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RECIPROCAL ).setParameterLength( 1 );\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const trunc = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRUNC ).setParameterLength( 1 );\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const fwidth = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FWIDTH ).setParameterLength( 1 );\n\n/**\n * Returns the transpose of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nexport const transpose = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSPOSE ).setParameterLength( 1 );\n\n/**\n * Returns the determinant of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<float>}\n */\nexport const determinant = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DETERMINANT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<mat2|mat3|mat4>}\n */\nexport const inverse = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE ).setParameterLength( 1 );\n\n// 2 inputs\n\n/**\n * Reinterpret the bit representation of a value in one type as a value in another type.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @param {string} y - The new type.\n * @returns {Node}\n */\nexport const bitcast = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.BITCAST ).setParameterLength( 2 );\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @deprecated since r175. Use {@link equal} instead.\n * @returns {Node<bool>}\n */\nexport const equals = ( x, y ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"equals\" is deprecated. Use \"equal\" inside a vector instead, like: \"bvec*( equal( ... ) )\"' );\n\treturn equal( x, y );\n\n};\n\n/**\n * Returns the least of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nexport const min = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIN ).setParameterLength( 2, Infinity );\n\n/**\n * Returns the greatest of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nexport const max = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MAX ).setParameterLength( 2, Infinity );\n\n/**\n * Generate a step function by comparing two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The y parameter.\n * @param {Node | number} y - The x parameter.\n * @returns {Node}\n */\nexport const step = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.STEP ).setParameterLength( 2 );\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const reflect = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFLECT ).setParameterLength( 2 );\n\n/**\n * Calculates the distance between two points.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nexport const distance = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DISTANCE ).setParameterLength( 2 );\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nexport const difference = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DIFFERENCE ).setParameterLength( 2 );\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nexport const dot = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DOT ).setParameterLength( 2 );\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3>} x - The first vector.\n * @param {Node<vec2|vec3>} y - The second vector.\n * @returns {Node<float|vec3>}\n */\nexport const cross = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CROSS ).setParameterLength( 2 );\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nexport const pow = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW ).setParameterLength( 2 );\n\n/**\n * Returns the square of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW, 2 ).setParameterLength( 1 );\n\n/**\n * Returns the cube of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow3 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW, 3 ).setParameterLength( 1 );\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow4 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW, 4 ).setParameterLength( 1 );\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nexport const transformDirection = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSFORM_DIRECTION ).setParameterLength( 2 );\n\n/**\n * Returns the cube root of a number.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @returns {Node}\n */\nexport const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\n\n/**\n * Calculate the squared length of a vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nexport const lengthSq = ( a ) => dot( a, a );\n\n/**\n * Linearly interpolates between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @param {Node | number} b - The second parameter.\n * @param {Node | number} t - The interpolation value.\n * @returns {Node}\n */\nexport const mix = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIX ).setParameterLength( 3 );\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @param {Node | number} [low=0] - The lower bound.\n * @param {Node | number} [high=1] - The upper bound.\n * @returns {Node}\n */\nexport const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @returns {Node}\n */\nexport const saturate = ( value ) => clamp( value );\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const refract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFRACT ).setParameterLength( 3 );\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @param {Node | number} x - The source value for interpolation.\n * @returns {Node}\n */\nexport const smoothstep = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SMOOTHSTEP ).setParameterLength( 3 );\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const faceForward = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FACEFORWARD ).setParameterLength( 3 );\n\n/**\n * Returns a random value for the given uv.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nexport const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} t - The interpolation value.\n * @param {Node | number} e1 - The first parameter.\n * @param {Node | number} e2 - The second parameter.\n * @returns {Node}\n */\nexport const mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nexport const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\n/**\n * Alias for `step()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} edge - The edge value.\n * @returns {Node}\n */\nexport const stepElement = ( x, edge ) => step( edge, x );\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @tsl\n * @function\n * @deprecated since r172. Use {@link atan} instead.\n *\n * @param {Node | number} y - The y parameter.\n * @param {Node | number} x - The x parameter.\n * @returns {Node}\n */\nexport const atan2 = ( y, x ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"atan2\" is overloaded. Use \"atan\" instead.' );\n\treturn atan( y, x );\n\n};\n\n// GLSL alias function\n\nexport const faceforward = faceForward;\nexport const inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min );\naddMethodChaining( 'max', max );\naddMethodChaining( 'step', stepElement );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'determinant', determinant );\naddMethodChaining( 'inverse', inverse );\naddMethodChaining( 'rand', rand );\n"],"mappings":"OAAOA,aAAc,6BACZC,IAAKC,IAAKC,IAAKC,IAAKC,UAAa,2BACjCC,kBAAmBC,WAAYC,gBAAiBC,MAAOC,KAAMC,KAAMC,KAAMC,OAAU,2BACnFC,sBAAuBC,2BAA8B,qBAY9D,MAAMC,iBAAiBhB,SAEtB,eAAWiB,GAEV,MAAO,UAER,CAUA,WAAAC,CAAaC,EAAQC,EAAOC,EAAQ,KAAMC,EAAQ,MAMjD,GAJAC,SAIOJ,IAAWH,SAASQ,KAAOL,IAAWH,SAASS,MAASC,UAAUC,OAAS,EAAI,CAErF,IAAIC,EAAU,IAAIZ,SAAUG,EAAQC,EAAOC,GAE3C,IAAM,IAAIQ,EAAI,EAAGA,EAAIH,UAAUC,OAAS,EAAGE,IAE1CD,EAAU,IAAIZ,SAAUG,EAAQS,EAASF,UAAWG,IAIrDT,EAAQQ,EACRP,EAAQK,UAAWA,UAAUC,OAAS,GACtCL,EAAQ,IAET,CAOAQ,KAAKX,OAASA,EAOdW,KAAKV,MAAQA,EAQbU,KAAKT,MAAQA,EAQbS,KAAKR,MAAQA,EASbQ,KAAKC,YAAa,CAEnB,CAQA,YAAAC,CAAcC,GAEb,MAAMC,EAAQJ,KAAKV,MAAMe,YAAaF,GAChCG,EAAQN,KAAKT,MAAQS,KAAKT,MAAMc,YAAaF,GAAY,KACzDI,EAAQP,KAAKR,MAAQQ,KAAKR,MAAMa,YAAaF,GAAY,KAEzDK,EAAOL,EAAQM,SAAUL,GAAU,EAAID,EAAQO,cAAeN,GAC9DO,EAAOR,EAAQM,SAAUH,GAAU,EAAIH,EAAQO,cAAeJ,GAC9DM,EAAOT,EAAQM,SAAUF,GAAU,EAAIJ,EAAQO,cAAeH,GAEpE,OAAKC,EAAOG,GAAQH,EAAOI,EAEnBR,EAEIO,EAAOC,EAEXN,EAEIM,EAAOJ,EAEXD,EAIDH,CAER,CAQA,WAAAC,CAAaF,GAEZ,MAAMd,EAASW,KAAKX,OAEpB,OAAKA,IAAWH,SAAS2B,QAAUxB,IAAWH,SAAS4B,UAAYzB,IAAWH,SAAS6B,IAE/E,QAEI1B,IAAWH,SAAS8B,MAExB,OAEI3B,IAAWH,SAAS+B,KAAO5B,IAAWH,SAASgC,IAEnD,OAEI7B,IAAWH,SAASiC,OAExBhB,EAAQiB,oBAAqBpB,KAAKV,MAAMe,YAAaF,GAAW,QAIhEH,KAAKE,aAAcC,EAI5B,CAEA,KAAAkB,CAAOlB,GAEN,MAAMb,MAAEA,EAAKC,MAAEA,EAAKF,OAAEA,GAAWW,KAEjC,IAAIsB,EAAa,KAEjB,GAAKjC,IAAWH,SAASqC,UAExBD,EAAanD,IAAK,EAAKmB,QAEjB,GAAKD,IAAWH,SAASsC,WAE/BF,EAAajD,IAAK,EAAKiB,QAEjB,GAAKD,IAAWH,SAASuC,WAE/BH,EAAaI,IAAKvD,IAAKmB,EAAOC,SAExB,GAAKF,IAAWH,SAASyC,oBAAsB,CAKrD,IAAIC,EAAKtC,EACLuC,EAAKtC,EAEJY,EAAQM,SAAUmB,EAAGvB,YAAaF,IAEtC0B,EAAK/C,KAAMD,KAAMgD,GAAM,GAIvBD,EAAK9C,KAAMD,KAAM+C,GAAM,GAIxB,MAAME,EAAU1D,IAAKwD,EAAIC,GAAKE,IAE9BT,EAAaU,UAAWF,EAEzB,CAEA,OAAoB,OAAfR,EAEGA,EAIA7B,MAAM4B,MAAOlB,EAItB,CAEA,QAAA8B,CAAU9B,EAAS+B,GAIlB,GAFmB/B,EAAQgC,kBAAmBnC,MAE9BsB,WAEf,OAAO7B,MAAMwC,SAAU9B,EAAS+B,GAIjC,IAAI7C,EAASW,KAAKX,OAElB,MAAMF,EAAOa,KAAKK,YAAaF,GACzBiC,EAAYpC,KAAKE,aAAcC,GAE/BkC,EAAIrC,KAAKV,MACTgD,EAAItC,KAAKT,MACTgD,EAAIvC,KAAKR,MAETgD,EAAmBrC,EAAQsC,SAASD,iBAE1C,GAAKnD,IAAWH,SAASwD,OAExB,OAAOvC,EAAQwC,OAAQ,OAASN,EAAEO,MAAOzC,EAASiC,GAAc,KAAMjD,EAAM+C,GAEtE,CAEN,MAAMW,EAAS,GA6Df,OA3DKxD,IAAWH,SAAS8B,MAExB6B,EAAOC,KACNT,EAAEO,MAAOzC,EAAShB,GAClBmD,EAAEM,MAAOzC,EAAShB,IAGRqD,IAAqBxD,uBAAyBK,IAAWH,SAAS6D,KAE7EF,EAAOC,KACNT,EAAEO,MAAOzC,EAA+D,IAAtDA,EAAQO,cAAe2B,EAAEhC,YAAaF,IAAoB,QAAUiC,GACtFE,EAAEM,MAAOzC,EAASiC,IAGRI,IAAqBxD,uBAA2BK,IAAWH,SAASS,KAAON,IAAWH,SAASQ,IAO/FL,IAAWH,SAAS8D,QAE/BH,EAAOC,KACNT,EAAEO,MAAOzC,EAASiC,GAClBE,EAAEM,MAAOzC,EAASiC,GAClBG,EAAEK,MAAOzC,EAAS,UAGRd,IAAWH,SAAS+D,IAE/BJ,EAAOC,KACNT,EAAEO,MAAOzC,EAASiC,GAClBE,EAAEM,MAAOzC,EAASiC,GAClBG,EAAEK,MAAOzC,EAA+D,IAAtDA,EAAQO,cAAe6B,EAAElC,YAAaF,IAAoB,QAAUiC,KAKlFI,IAAqBvD,wBAA0BI,IAAWH,SAASgE,MAAc,OAANZ,IAE/EjD,EAAS,SAImB,aAAxBc,EAAQgD,aAAgC9D,IAAWH,SAASkE,MAAQ/D,IAAWH,SAASmE,OAE5FC,QAAQC,KAAM,eAAgBlE,8BAAqCc,EAAQgD,sBAE3E9D,EAAS,KAAOA,EAAS,MAI1BwD,EAAOC,KAAMT,EAAEO,MAAOzC,EAASiC,IACpB,OAANE,GAAaO,EAAOC,KAAMR,EAAEM,MAAOzC,EAASiC,IACtC,OAANG,GAAaM,EAAOC,KAAMP,EAAEK,MAAOzC,EAASiC,KAvCjDS,EAAOC,KACNT,EAAEO,MAAOzC,EAASiC,GAClBE,EAAEM,MAAOzC,EAA+D,IAAtDA,EAAQO,cAAe4B,EAAEjC,YAAaF,IAAoB,QAAUiC,IAyCjFjC,EAAQwC,OAAQ,GAAIxC,EAAQqD,UAAWnE,EAAQF,OAAY0D,EAAOY,KAAM,UAAYtE,EAAM+C,EAElG,CAED,CAEA,SAAAwB,CAAWC,GAEVlE,MAAMiE,UAAWC,GAEjBA,EAAKtE,OAASW,KAAKX,MAEpB,CAEA,WAAAuE,CAAaD,GAEZlE,MAAMmE,YAAaD,GAEnB3D,KAAKX,OAASsE,EAAKtE,MAEpB,EAMDH,SAAS+B,IAAM,MACf/B,SAASgC,IAAM,MAEfhC,SAAS2E,QAAU,UACnB3E,SAAS4E,QAAU,UACnB5E,SAAS6E,IAAM,MACf7E,SAAS8E,KAAO,OAChB9E,SAAS+E,IAAM,MACf/E,SAASgF,KAAO,OAChBhF,SAASiF,KAAO,OAChBjF,SAASkF,aAAe,cACxBlF,SAASmF,MAAQ,QACjBnF,SAASoF,KAAO,OAChBpF,SAASqF,UAAY,YACrBrF,SAASsF,MAAQ,QACjBtF,SAASuF,IAAM,MACfvF,SAASwF,IAAM,MACfxF,SAASyF,IAAM,MACfzF,SAAS0F,KAAO,OAChB1F,SAAS2F,KAAO,OAChB3F,SAASgE,KAAO,OAChBhE,SAAS4F,IAAM,MACf5F,SAAS6F,KAAO,OAChB7F,SAAS2B,OAAS,SAClB3B,SAASwD,OAAS,SAClBxD,SAASqC,UAAY,WACrBrC,SAASkE,KAAO,OAChBlE,SAASmE,KAAO,OAChBnE,SAAS8F,MAAQ,QACjB9F,SAASsC,WAAa,aACtBtC,SAAS+F,MAAQ,QACjB/F,SAASgG,OAAS,SAClBhG,SAASiG,UAAY,YACrBjG,SAASkG,YAAc,cACvBlG,SAASmG,QAAU,UAInBnG,SAASoG,QAAU,UACnBpG,SAASiC,OAAS,SAClBjC,SAASS,IAAM,MACfT,SAASQ,IAAM,MACfR,SAAS6D,KAAO,OAChB7D,SAASqG,QAAU,UACnBrG,SAAS4B,SAAW,WACpB5B,SAASuC,WAAa,aACtBvC,SAAS6B,IAAM,MACf7B,SAAS8B,MAAQ,QACjB9B,SAASsG,IAAM,MACftG,SAASyC,oBAAsB,qBAI/BzC,SAAS+D,IAAM,MACf/D,SAASuG,MAAQ,QACjBvG,SAAS8D,QAAU,UACnB9D,SAASwG,WAAa,aACtBxG,SAASyG,YAAc,6BAERzG,gBAUR,MAAM0G,QAAwBjH,MAAO,aAQrC,MAAMkH,SAAyBlH,MAAO,YAQtC,MAAMmH,GAAmBnH,MAAOoH,KAAKD,WAQrC,MAAME,IAAoBrH,MAAiB,EAAVoH,KAAKD,WAUtC,MAAMG,IAAoBvH,gBAAiBQ,SAAUA,SAAS+B,KAAMiF,mBAAoB,UAUxF,MAAMC,IAAoBzH,gBAAiBQ,SAAUA,SAASgC,KAAMgF,mBAAoB,UAUxF,MAAME,QAAwB1H,gBAAiBQ,SAAUA,SAAS2E,SAAUqC,mBAAoB,UAUhG,MAAMG,QAAwB3H,gBAAiBQ,SAAUA,SAAS4E,SAAUoC,mBAAoB,UAUhG,MAAMI,IAAoB5H,gBAAiBQ,SAAUA,SAAS6E,KAAMmC,mBAAoB,UAUxF,MAAMK,KAAqB7H,gBAAiBQ,SAAUA,SAAS8E,MAAOkC,mBAAoB,UAU1F,MAAMM,IAAoB9H,gBAAiBQ,SAAUA,SAAS+E,KAAMiC,mBAAoB,UAUxF,MAAMO,KAAqB/H,gBAAiBQ,SAAUA,SAASgF,MAAOgC,mBAAoB,UAU1F,MAAMQ,KAAqBhI,gBAAiBQ,SAAUA,SAASiF,MAAO+B,mBAAoB,UAU1F,MAAMS,YAA4BjI,gBAAiBQ,SAAUA,SAASkF,cAAe8B,mBAAoB,UAUzG,MAAMU,MAAsBlI,gBAAiBQ,SAAUA,SAASmF,OAAQ6B,mBAAoB,UAU5F,MAAMW,KAAqBnI,gBAAiBQ,SAAUA,SAASoF,MAAO4B,mBAAoB,UAU1F,MAAMlE,UAA0BtD,gBAAiBQ,SAAUA,SAASqF,WAAY2B,mBAAoB,UAUpG,MAAMY,MAAsBpI,gBAAiBQ,SAAUA,SAASsF,OAAQ0B,mBAAoB,UAU5F,MAAMa,IAAoBrI,gBAAiBQ,SAAUA,SAASuF,KAAMyB,mBAAoB,UAUxF,MAAMc,IAAoBtI,gBAAiBQ,SAAUA,SAASwF,KAAMwB,mBAAoB,UAUxF,MAAMe,IAAoBvI,gBAAiBQ,SAAUA,SAASyF,KAAMuB,mBAAoB,UAUxF,MAAMgB,KAAqBxI,gBAAiBQ,SAAUA,SAAS0F,MAAOsB,mBAAoB,UAU1F,MAAMiB,KAAqBzI,gBAAiBQ,SAAUA,SAAS2F,MAAOqB,mBAAoB,UAY1F,MAAMkB,KAAqB1I,gBAAiBQ,SAAUA,SAASgE,MAAOgD,mBAAoB,EAAG,UAU7F,MAAMxE,IAAoBhD,gBAAiBQ,SAAUA,SAAS4F,KAAMoB,mBAAoB,UAUxF,MAAMmB,KAAqB3I,gBAAiBQ,SAAUA,SAAS6F,MAAOmB,mBAAoB,UAU1F,MAAMrG,OAAuBnB,gBAAiBQ,SAAUA,SAAS2B,QAASqF,mBAAoB,UAU9F,MAAMoB,OAAuB5I,gBAAiBQ,SAAUA,SAASwD,QAASwD,mBAAoB,UAU9F,MAAMqB,SAAyB7I,gBAAiBQ,SAAUA,SAASqC,WAAY2E,mBAAoB,UAUnG,MAAMsB,KAAqB9I,gBAAiBQ,SAAUA,SAASkE,MAAO8C,mBAAoB,UAU1F,MAAMuB,KAAqB/I,gBAAiBQ,SAAUA,SAASmE,MAAO6C,mBAAoB,UAU1F,MAAMwB,MAAsBhJ,gBAAiBQ,SAAUA,SAAS8F,OAAQkB,mBAAoB,UAU5F,MAAMyB,WAA2BjJ,gBAAiBQ,SAAUA,SAASsC,YAAa0E,mBAAoB,UAUtG,MAAM0B,MAAsBlJ,gBAAiBQ,SAAUA,SAAS+F,OAAQiB,mBAAoB,UAU5F,MAAM2B,OAAuBnJ,gBAAiBQ,SAAUA,SAASgG,QAASgB,mBAAoB,UAU9F,MAAM4B,UAA0BpJ,gBAAiBQ,SAAUA,SAASiG,WAAYe,mBAAoB,UAUpG,MAAM6B,YAA4BrJ,gBAAiBQ,SAAUA,SAASkG,aAAcc,mBAAoB,UAUxG,MAAM8B,QAAwBtJ,gBAAiBQ,SAAUA,SAASmG,SAAUa,mBAAoB,UAahG,MAAM+B,QAAwBvJ,gBAAiBQ,SAAUA,SAASoG,SAAUY,mBAAoB,UAYhG,MAAMgC,OAAS,CAAEC,EAAGC,KAE1B9E,QAAQC,KAAM,yGACPhF,MAAO4J,EAAGC,WAYX,MAAMC,IAAoB3J,gBAAiBQ,SAAUA,SAASS,KAAMuG,mBAAoB,EAAGoC,YAU3F,MAAMC,IAAoB7J,gBAAiBQ,SAAUA,SAASQ,KAAMwG,mBAAoB,EAAGoC,YAW3F,MAAME,KAAqB9J,gBAAiBQ,SAAUA,SAAS6D,MAAOmD,mBAAoB,UAW1F,MAAMuC,QAAwB/J,gBAAiBQ,SAAUA,SAASqG,SAAUW,mBAAoB,UAWhG,MAAMwC,SAAyBhK,gBAAiBQ,SAAUA,SAAS4B,UAAWoF,mBAAoB,UAWlG,MAAMyC,WAA2BjK,gBAAiBQ,SAAUA,SAASuC,YAAayE,mBAAoB,UAWtG,MAAM0C,IAAoBlK,gBAAiBQ,SAAUA,SAAS6B,KAAMmF,mBAAoB,UAWxF,MAAM2C,MAAsBnK,gBAAiBQ,SAAUA,SAAS8B,OAAQkF,mBAAoB,UAW5F,MAAM4C,IAAoBpK,gBAAiBQ,SAAUA,SAASsG,KAAMU,mBAAoB,UAUxF,MAAM6C,KAAqBrK,gBAAiBQ,SAAUA,SAASsG,IAAK,GAAIU,mBAAoB,UAU5F,MAAM8C,KAAqBtK,gBAAiBQ,SAAUA,SAASsG,IAAK,GAAIU,mBAAoB,UAU5F,MAAM+C,KAAqBvK,gBAAiBQ,SAAUA,SAASsG,IAAK,GAAIU,mBAAoB,UAW5F,MAAMgD,mBAAmCxK,gBAAiBQ,SAAUA,SAASyC,qBAAsBuE,mBAAoB,UAUvH,MAAMiD,KAAS9G,GAAOjE,IAAKiJ,KAAMhF,GAAKyG,IAAKpH,IAAKW,GAAK,EAAM,WAU3D,MAAM+G,SAAa/G,GAAOuG,IAAKvG,EAAGA,UAYlC,MAAMgH,IAAoB3K,gBAAiBQ,SAAUA,SAAS+D,KAAMiD,mBAAoB,UAYxF,MAAMoD,MAAQ,CAAEC,EAAOC,EAAM,EAAGC,EAAO,IAAOhL,WAAY,IAAIS,SAAUA,SAASuG,MAAOhH,WAAY8K,GAAS9K,WAAY+K,GAAO/K,WAAYgL,YAU5I,MAAMC,SAAaH,GAAWD,MAAOC,UAYrC,MAAMI,QAAwBjL,gBAAiBQ,SAAUA,SAAS8D,SAAUkD,mBAAoB,UAYhG,MAAM0D,WAA2BlL,gBAAiBQ,SAAUA,SAASwG,YAAaQ,mBAAoB,UAYtG,MAAM2D,YAA4BnL,gBAAiBQ,SAAUA,SAASyG,aAAcO,mBAAoB,UAUxG,MAAM4D,KAAqB/K,IAAI,EAAIgL,MAEzC,MACMC,EAAKpB,IAAKmB,EAAGE,GAAIrL,KADb,QAAa,SACgBsL,EAAK5L,IAAK0L,EAAIlE,IAErD,OAAOgB,MAAOC,IAAKmD,GAAK9L,IAHW,YAGD,WAc5B,MAAM+L,WAAa,CAAEC,EAAGC,EAAIC,IAAQjB,IAAKgB,EAAIC,EAAIF,UAYjD,MAAMG,kBAAoB,CAAEpC,EAAGqB,EAAKC,IAAUG,WAAYJ,EAAKC,EAAMtB,UAWrE,MAAMqC,YAAc,CAAErC,EAAGsC,IAAUjC,KAAMiC,EAAMtC,UAa/C,MAAMuC,MAAQ,CAAEtC,EAAGD,KAEzB7E,QAAQC,KAAM,yDACP6D,KAAMgB,EAAGD,WAMV,MAAMwC,YAAcd,mBACpB,MAAMe,YAAcjE,YAI3BnI,kBAAmB,MAAOyH,KAC1BzH,kBAAmB,MAAO2H,KAC1B3H,kBAAmB,SAAU0J,QAE7B1J,kBAAmB,UAAW4H,SAC9B5H,kBAAmB,UAAW6H,SAC9B7H,kBAAmB,MAAO8H,KAC1B9H,kBAAmB,OAAQ+H,MAC3B/H,kBAAmB,MAAOgI,KAC1BhI,kBAAmB,OAAQiI,MAC3BjI,kBAAmB,OAAQkI,MAC3BlI,kBAAmB,cAAemI,aAClCnI,kBAAmB,QAASoI,OAC5BpI,kBAAmB,OAAQqI,MAC3BrI,kBAAmB,YAAawD,WAChCxD,kBAAmB,QAASsI,OAC5BtI,kBAAmB,MAAOuI,KAC1BvI,kBAAmB,MAAOwI,KAC1BxI,kBAAmB,MAAOyI,KAC1BzI,kBAAmB,OAAQ0I,MAC3B1I,kBAAmB,OAAQ2I,MAC3B3I,kBAAmB,OAAQ4I,MAC3B5I,kBAAmB,MAAOkD,KAC1BlD,kBAAmB,OAAQ6I,MAC3B7I,kBAAmB,SAAUqB,QAC7BrB,kBAAmB,WAAY4K,UAC/B5K,kBAAmB,SAAU8I,QAC7B9I,kBAAmB,WAAY+I,UAC/B/I,kBAAmB,OAAQgJ,MAC3BhJ,kBAAmB,OAAQiJ,MAC3BjJ,kBAAmB,QAASkJ,OAC5BlJ,kBAAmB,aAAcmJ,YACjCnJ,kBAAmB,QAASoJ,OAC5BpJ,kBAAmB,SAAUqJ,QAC7BrJ,kBAAmB,QAASkM,OAC5BlM,kBAAmB,MAAO6J,KAC1B7J,kBAAmB,MAAO+J,KAC1B/J,kBAAmB,OAAQgM,aAC3BhM,kBAAmB,UAAWiK,SAC9BjK,kBAAmB,WAAYkK,UAC/BlK,kBAAmB,MAAOoK,KAC1BpK,kBAAmB,QAASqK,OAC5BrK,kBAAmB,MAAOsK,KAC1BtK,kBAAmB,OAAQuK,MAC3BvK,kBAAmB,OAAQwK,MAC3BxK,kBAAmB,OAAQyK,MAC3BzK,kBAAmB,qBAAsB0K,oBACzC1K,kBAAmB,MAAO2L,YAC1B3L,kBAAmB,QAAS8K,OAC5B9K,kBAAmB,UAAWmL,SAC9BnL,kBAAmB,aAAc+L,mBACjC/L,kBAAmB,cAAeqL,aAClCrL,kBAAmB,aAAcmK,YACjCnK,kBAAmB,WAAYkL,UAC/BlL,kBAAmB,OAAQ2K,MAC3B3K,kBAAmB,YAAasJ,WAChCtJ,kBAAmB,cAAeuJ,aAClCvJ,kBAAmB,UAAWwJ,SAC9BxJ,kBAAmB,OAAQsL","ignoreList":[]}