{"version":3,"file":"node_modules/three/src/nodes/math/OperatorNode.js","names":["WebGLCoordinateSystem","TempNode","addMethodChaining","Fn","int","nodeProxyIntent","_vectorOperators","OperatorNode","type","constructor","op","aNode","bNode","params","super","length","finalOp","i","this","isOperatorNode","getOperatorMethod","builder","output","getMethod","getNodeType","typeA","typeB","getIntegerType","typeLength","Math","max","getTypeLength","isMatrix","isVector","getVectorFromMatrix","generate","changeComponentType","isInteger","a","build","b","fnOpSnippet","getFunctionOperator","isGLSL","renderer","coordinateSystem","format","snippet","serialize","data","deserialize","add","setParameterLength","Infinity","setName","sub","mul","div","mod","equal","notEqual","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","not","xor","bitAnd","bitNot","bitOr","bitXor","shiftLeft","shiftRight","incrementBefore","addAssign","decrementBefore","subAssign","increment","temp","toConst","decrement","modInt","console","warn"],"sources":["node_modules/three/src/nodes/math/OperatorNode.js"],"sourcesContent":["import { WebGLCoordinateSystem } from '../../constants.js';\nimport TempNode from '../core/TempNode.js';\nimport { addMethodChaining, Fn, int, nodeProxyIntent } from '../tsl/TSLCore.js';\n\nconst _vectorOperators = {\n\t'==': 'equal',\n\t'!=': 'notEqual',\n\t'<': 'lessThan',\n\t'>': 'greaterThan',\n\t'<=': 'lessThanEqual',\n\t'>=': 'greaterThanEqual',\n\t'%': 'mod'\n};\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new operator node.\n\t *\n\t * @param {string} op - The operator.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node} bNode - The second input.\n\t * @param {...Node} params - Additional input parameters.\n\t */\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\t/**\n\t\t * The operator.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.op = op;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOperatorNode = true;\n\n\t}\n\n\t/**\n\t * Returns the operator method name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The output type.\n\t * @returns {string} The operator method name.\n\t */\n\tgetOperatorMethod( builder, output ) {\n\n\t\treturn builder.getMethod( _vectorOperators[ this.op ], output );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the operator\n\t * and the input node types.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\t// Handle matrix operations\n\n\t\t\tif ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\treturn typeA; // matrix * scalar = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeA ); // matrix * vector\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn typeA; // matrix * matrix\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\treturn typeB; // scalar * matrix = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeB ); // vector * matrix\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Handle non-matrix cases\n\n\t\t\tif ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst { aNode, bNode } = this;\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' || op === '!=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\ttypeA = typeB;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.isInteger( typeA ) && builder.isInteger( typeB ) ? typeB : typeA;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeA, but ensure typeB stays float\n\n\t\t\t\t\ttypeB = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\t// matrix x vector\n\t\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\t// matrix x matrix - keep both types\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeB, but ensure typeA stays float\n\n\t\t\t\t\ttypeA = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t// vector x matrix\n\n\t\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode ? bNode.build( builder, typeB ) : null;\n\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tconst isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;\n\n\t\t\tif ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( isGLSL ) {\n\n\t\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WGSL\n\n\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\tif ( builder.isInteger( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `( ${ a } % ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, type ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\t// Handle matrix operations\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `( ${ b } ${ op } ${ a } )`, type, output );\n\n\t\t\t\t} else if ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet snippet = `( ${ a } ${ op } ${ b } )`;\n\n\t\t\t\t\tif ( ! isGLSL && type === 'bool' && builder.isVector( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t\t\tsnippet = `all${ snippet }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn builder.format( snippet, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `${ b } ${ op } ${ a }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nexport default OperatorNode;\n\n/**\n * Returns the addition of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const add = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '+' ).setParameterLength( 2, Infinity ).setName( 'add' );\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const sub = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '-' ).setParameterLength( 2, Infinity ).setName( 'sub' );\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const mul = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '*' ).setParameterLength( 2, Infinity ).setName( 'mul' );\n\n/**\n * Returns the division of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const div = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '/' ).setParameterLength( 2, Infinity ).setName( 'div' );\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const mod = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '%' ).setParameterLength( 2 ).setName( 'mod' );\n\n/**\n * Checks if two nodes are equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const equal = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '==' ).setParameterLength( 2 ).setName( 'equal' );\n\n/**\n * Checks if two nodes are not equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const notEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!=' ).setParameterLength( 2 ).setName( 'notEqual' );\n\n/**\n * Checks if the first node is less than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const lessThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<' ).setParameterLength( 2 ).setName( 'lessThan' );\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const greaterThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>' ).setParameterLength( 2 ).setName( 'greaterThan' );\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const lessThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<=' ).setParameterLength( 2 ).setName( 'lessThanEqual' );\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const greaterThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>=' ).setParameterLength( 2 ).setName( 'greaterThanEqual' );\n\n/**\n * Performs a logical AND operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using AND.\n * @returns {OperatorNode}\n */\nexport const and = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&&' ).setParameterLength( 2, Infinity ).setName( 'and' );\n\n/**\n * Performs a logical OR operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using OR.\n * @returns {OperatorNode}\n */\nexport const or = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '||' ).setParameterLength( 2, Infinity ).setName( 'or' );\n\n/**\n * Performs logical NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} value - The value.\n * @returns {OperatorNode}\n */\nexport const not = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!' ).setParameterLength( 1 ).setName( 'not' );\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const xor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^^' ).setParameterLength( 2 ).setName( 'xor' );\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitAnd = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&' ).setParameterLength( 2 ).setName( 'bitAnd' );\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitNot = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '~' ).setParameterLength( 2 ).setName( 'bitNot' );\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitOr = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '|' ).setParameterLength( 2 ).setName( 'bitOr' );\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitXor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^' ).setParameterLength( 2 ).setName( 'bitXor' );\n\n/**\n * Shifts a node to the left.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nexport const shiftLeft = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<<' ).setParameterLength( 2 ).setName( 'shiftLeft' );\n\n/**\n * Shifts a node to the right.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nexport const shiftRight = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>>' ).setParameterLength( 2 ).setName( 'shiftRight' );\n\n/**\n * Increments a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nexport const incrementBefore = Fn( ( [ a ] ) => {\n\n\ta.addAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Decrements a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nexport const decrementBefore = Fn( ( [ a ] ) => {\n\n\ta.subAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Increments a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nexport const increment = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.addAssign( 1 );\n\treturn temp;\n\n} );\n\n/**\n * Decrements a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nexport const decrement = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.subAssign( 1 );\n\treturn temp;\n\n} );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\naddMethodChaining( 'incrementBefore', incrementBefore );\naddMethodChaining( 'decrementBefore', decrementBefore );\naddMethodChaining( 'increment', increment );\naddMethodChaining( 'decrement', decrement );\n\n/**\n * @tsl\n * @function\n * @deprecated since r175. Use {@link mod} instead.\n *\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const modInt = ( a, b ) => { // @deprecated, r175\n\n\tconsole.warn( 'THREE.TSL: \"modInt()\" is deprecated. Use \"mod( int( ... ) )\" instead.' );\n\treturn mod( int( a ), int( b ) );\n\n};\n\naddMethodChaining( 'modInt', modInt );\n"],"mappings":"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","ignoreList":[]}