import NodeFunction from"../core/NodeFunction.js";import NodeFunctionInput from"../core/NodeFunctionInput.js";const declarationRegexp=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,propertiesRegexp=/[a-z_0-9]+/gi,pragmaMain="#pragma main",parse=e=>{const o=(e=e.trim()).indexOf(pragmaMain),t=-1!==o?e.slice(o+12):e,n=t.match(declarationRegexp);if(null!==n&&5===n.length){const i=n[4],s=[];let r=null;for(;null!==(r=propertiesRegexp.exec(i));)s.push(r);const c=[];let p=0;for(;p<s.length;){const e="const"===s[p][0];!0===e&&p++;let o=s[p][0];"in"===o||"out"===o||"inout"===o?p++:o="";const t=s[p++][0];let n=Number.parseInt(s[p][0]);!1===Number.isNaN(n)?p++:n=null;const i=s[p++][0];c.push(new NodeFunctionInput(t,i,n,o,e))}const u=t.substring(n[0].length),d=void 0!==n[3]?n[3]:"";return{type:n[2],inputs:c,name:d,precision:void 0!==n[1]?n[1]:"",inputsCode:i,blockCode:u,headerCode:-1!==o?e.slice(0,o):""}}throw new Error("FunctionNode: Function is not a GLSL code.")};class GLSLNodeFunction extends NodeFunction{constructor(e){const{type:o,inputs:t,name:n,precision:i,inputsCode:s,blockCode:r,headerCode:c}=parse(e);super(o,t,n,i),this.inputsCode=s,this.blockCode=r,this.headerCode=c}getCode(e=this.name){let o;const t=this.blockCode;if(""!==t){const{type:n,inputsCode:i,headerCode:s,precision:r}=this;let c=`${n} ${e} ( ${i.trim()} )`;""!==r&&(c=`${r} ${c}`),o=s+c+t}else o="";return o}}export default GLSLNodeFunction;
//# sourceMappingURL=GLSLNodeFunction.js.map