{"version":3,"file":"node_modules/three/src/nodes/parsers/GLSLNodeFunction.js","names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","pragmaMain","parse","source","pragmaMainIndex","trim","indexOf","mainCode","slice","declaration","match","length","inputsCode","propsMatches","nameMatch","exec","push","inputs","i","isConst","qualifier","type","count","Number","parseInt","isNaN","name","blockCode","substring","undefined","precision","headerCode","Error","GLSLNodeFunction","constructor","super","this","getCode","code","declarationCode"],"sources":["node_modules/three/src/nodes/parsers/GLSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a GLSL node function.\n *\n * @augments NodeFunction\n */\nclass GLSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new GLSL node function.\n\t *\n\t * @param {string} source - The GLSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\t/**\n\t * This method returns the GLSL code of the node function.\n\t *\n\t * @param {string} [name=this.name] - The function's name.\n\t * @return {string} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nexport default GLSLNodeFunction;\n"],"mappings":"OAAOA,iBAAkB,iCAClBC,sBAAuB,+BAE9B,MAAMC,kBAAoB,6EACpBC,iBAAmB,eAEnBC,WAAa,eAEbC,MAAUC,IAIf,MAAMC,GAFND,EAASA,EAAOE,QAEeC,QAASL,YAElCM,GAAiC,IAAtBH,EAA0BD,EAAOK,MAAOJ,EAAkBH,IAAsBE,EAE3FM,EAAcF,EAASG,MAAOX,mBAEpC,GAAqB,OAAhBU,GAA+C,IAAvBA,EAAYE,OAAe,CAIvD,MAAMC,EAAaH,EAAa,GAC1BI,EAAe,GAErB,IAAIC,EAAY,KAEhB,KAAgE,QAAtDA,EAAYd,iBAAiBe,KAAMH,KAE5CC,EAAaG,KAAMF,GAMpB,MAAMG,EAAS,GAEf,IAAIC,EAAI,EAER,KAAQA,EAAIL,EAAaF,QAAS,CAEjC,MAAMQ,EAAqC,UAA3BN,EAAcK,GAAK,IAElB,IAAZC,GAEJD,IAID,IAAIE,EAAYP,EAAcK,GAAK,GAEhB,OAAdE,GAAoC,QAAdA,GAAqC,UAAdA,EAEjDF,IAIAE,EAAY,GAIb,MAAMC,EAAOR,EAAcK,KAAQ,GAEnC,IAAII,EAAQC,OAAOC,SAAUX,EAAcK,GAAK,KAEjB,IAA1BK,OAAOE,MAAOH,GAAoBJ,IAClCI,EAAQ,KAEb,MAAMI,EAAOb,EAAcK,KAAQ,GAEnCD,EAAOD,KAAM,IAAIlB,kBAAmBuB,EAAMK,EAAMJ,EAAOF,EAAWD,GAEnE,CAIA,MAAMQ,EAAYpB,EAASqB,UAAWnB,EAAa,GAAIE,QAEjDe,OAA4BG,IAArBpB,EAAa,GAAoBA,EAAa,GAAM,GAOjE,MAAO,CACNY,KAPYZ,EAAa,GAQzBQ,SACAS,OACAI,eARsCD,IAArBpB,EAAa,GAAoBA,EAAa,GAAM,GASrEG,aACAe,YACAI,YATwC,IAAtB3B,EAA0BD,EAAOK,MAAO,EAAGJ,GAAoB,GAYnF,CAEC,MAAM,IAAI4B,MAAO,6CAElB,EASD,MAAMC,yBAAyBpC,aAO9B,WAAAqC,CAAa/B,GAEZ,MAAMkB,KAAEA,EAAIJ,OAAEA,EAAMS,KAAEA,EAAII,UAAEA,EAASlB,WAAEA,EAAUe,UAAEA,EAASI,WAAEA,GAAe7B,MAAOC,GAEpFgC,MAAOd,EAAMJ,EAAQS,EAAMI,GAE3BM,KAAKxB,WAAaA,EAClBwB,KAAKT,UAAYA,EACjBS,KAAKL,WAAaA,CAEnB,CAQA,OAAAM,CAASX,EAAOU,KAAKV,MAEpB,IAAIY,EAEJ,MAAMX,EAAYS,KAAKT,UAEvB,GAAmB,KAAdA,EAAmB,CAEvB,MAAMN,KAAEA,EAAIT,WAAEA,EAAUmB,WAAEA,EAAUD,UAAEA,GAAcM,KAEpD,IAAIG,EAAkB,GAAIlB,KAAUK,OAAYd,EAAWP,WAExC,KAAdyB,IAEJS,EAAkB,GAAIT,KAAeS,KAItCD,EAAOP,EAAaQ,EAAkBZ,CAEvC,MAICW,EAAO,GAIR,OAAOA,CAER,iBAIcL","ignoreList":[]}