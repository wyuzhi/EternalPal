import TempNode from"../core/TempNode.js";import{texture}from"../accessors/TextureNode.js";import{textureCubeUV}from"./PMREMUtils.js";import{uniform}from"../core/UniformNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeProxy,vec3}from"../tsl/TSLBase.js";import{Texture}from"../../textures/Texture.js";import PMREMGenerator from"../../renderers/common/extras/PMREMGenerator.js";import{materialEnvRotation}from"../accessors/MaterialProperties.js";const _cache=new WeakMap;function _generateCubeUVSize(e){const t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:r,maxMip:t}}function _getPMREMFromTexture(e,t,r){const i=_getCache(t);let o=i.get(e);if((void 0!==o?o.pmremVersion:-1)!==e.pmremVersion){const t=e.image;if(e.isCubeTexture){if(!isCubeMapReady(t))return null;o=r.fromCubemap(e,o)}else{if(!isEquirectangularMapReady(t))return null;o=r.fromEquirectangular(e,o)}o.pmremVersion=e.pmremVersion,i.set(e,o)}return o.texture}function _getCache(e){let t=_cache.get(e);return void 0===t&&(t=new WeakMap,_cache.set(e,t)),t}class PMREMNode extends TempNode{static get type(){return"PMREMNode"}constructor(e,t=null,r=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=r,this._generator=null;const i=new Texture;i.isRenderTargetTexture=!0,this._texture=texture(i),this._width=uniform(0),this._height=uniform(0),this._maxMip=uniform(0),this.updateBeforeType=NodeUpdateType.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=_generateCubeUVSize(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(e){let t=this._pmrem;const r=t?t.pmremVersion:-1,i=this._value;r!==i.pmremVersion&&(t=!0===i.isPMREMTexture?i:_getPMREMFromTexture(i,e.renderer,this._generator),null!==t&&(this._pmrem=t,this.updateFromTexture(t)))}setup(e){null===this._generator&&(this._generator=new PMREMGenerator(e.renderer)),this.updateBefore(e);let t=this.uvNode;null===t&&e.context.getUV&&(t=e.context.getUV(this)),t=materialEnvRotation.mul(vec3(t.x,t.y.negate(),t.z));let r=this.levelNode;return null===r&&e.context.getTextureLevel&&(r=e.context.getTextureLevel(this)),textureCubeUV(this._texture,t,r,this._width,this._height,this._maxMip)}dispose(){super.dispose(),null!==this._generator&&this._generator.dispose()}}export default PMREMNode;function isCubeMapReady(e){if(null==e)return!1;let t=0;for(let r=0;r<6;r++)void 0!==e[r]&&t++;return 6===t}function isEquirectangularMapReady(e){return null!=e&&e.height>0}export const pmremTexture=nodeProxy(PMREMNode).setParameterLength(1,3);
//# sourceMappingURL=PMREMNode.js.map