{"version":3,"file":"node_modules/three/src/nodes/pmrem/PMREMNode.js","names":["TempNode","texture","textureCubeUV","uniform","NodeUpdateType","nodeProxy","vec3","Texture","PMREMGenerator","materialEnvRotation","_cache","WeakMap","_generateCubeUVSize","imageHeight","maxMip","Math","log2","texelHeight","texelWidth","max","pow","_getPMREMFromTexture","renderer","generator","cache","_getCache","cacheTexture","get","undefined","pmremVersion","image","isCubeTexture","isCubeMapReady","fromCubemap","isEquirectangularMapReady","fromEquirectangular","set","rendererCache","PMREMNode","type","constructor","value","uvNode","levelNode","super","this","_value","_pmrem","_generator","defaultTexture","isRenderTargetTexture","_texture","_width","_height","_maxMip","updateBeforeType","RENDER","updateFromTexture","cubeUVSize","height","updateBefore","frame","pmrem","isPMREMTexture","setup","builder","context","getUV","mul","x","y","negate","z","getTextureLevel","dispose","count","i","pmremTexture","setParameterLength"],"sources":["node_modules/three/src/nodes/pmrem/PMREMNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { textureCubeUV } from './PMREMUtils.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy, vec3 } from '../tsl/TSLBase.js';\n\nimport { Texture } from '../../textures/Texture.js';\nimport PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';\nimport { materialEnvRotation } from '../accessors/MaterialProperties.js';\n\nconst _cache = new WeakMap();\n\n/**\n * Generates the cubeUV size based on the given image height.\n *\n * @private\n * @param {number} imageHeight - The image height.\n * @return {{texelWidth: number,texelHeight: number, maxMip: number}} The result object.\n */\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\n/**\n * Generates a PMREM from the given texture.\n *\n * @private\n * @param {Texture} texture - The texture to create the PMREM for.\n * @param {Renderer} renderer - The renderer.\n * @param {PMREMGenerator} generator - The PMREM generator.\n * @return {?Texture} The PMREM.\n */\nfunction _getPMREMFromTexture( texture, renderer, generator ) {\n\n\tconst cache = _getCache( renderer );\n\n\tlet cacheTexture = cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\tcache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\n/**\n * Returns a cache that stores generated PMREMs for the respective textures.\n * A cache must be maintained per renderer since PMREMs are render target textures\n * which can't be shared across render contexts.\n *\n * @private\n * @param {Renderer} renderer - The renderer.\n * @return {WeakMap<Texture, Texture>} The PMREM cache.\n */\nfunction _getCache( renderer ) {\n\n\tlet rendererCache = _cache.get( renderer );\n\n\tif ( rendererCache === undefined ) {\n\n\t\trendererCache = new WeakMap();\n\t\t_cache.set( renderer, rendererCache );\n\n\t}\n\n\treturn rendererCache;\n\n}\n\n/**\n * This node represents a PMREM which is a special type of preprocessed\n * environment map intended for PBR materials.\n *\n * ```js\n * const material = new MeshStandardNodeMaterial();\n * material.envNode = pmremTexture( envMap );\n * ```\n *\n * @augments TempNode\n */\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Texture} value - The input texture.\n\t * @param {Node<vec2>} [uvNode=null] - The uv node.\n\t * @param {Node<float>} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Reference to the input texture.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Reference to the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture | null}\n\t\t * @default null\n\t\t */\n\t\tthis._pmrem = null;\n\n\t\t/**\n\t\t *  The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t *  The level node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Reference to a PMREM generator.\n\t\t *\n\t\t * @private\n\t\t * @type {?PMREMGenerator}\n\t\t * @default null\n\t\t */\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * The texture node holding the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._texture = texture( defaultTexture );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's width.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._width = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's height.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._height = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's max Mip.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._maxMip = uniform( 0 );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\t/**\n\t * The node's texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Uses the given PMREM texture to update internal values.\n\t *\n\t * @param {Texture} texture - The PMREM texture.\n\t */\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : - 1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture, frame.renderer, this._generator );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this._generator === null ) {\n\n\t\t\tthis._generator = new PMREMGenerator( builder.renderer );\n\n\t\t}\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tuvNode = materialEnvRotation.mul( vec3( uvNode.x, uvNode.y.negate(), uvNode.z ) );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._generator !== null ) this._generator.dispose();\n\n\t}\n\n}\n\nexport default PMREMNode;\n\n/**\n * Returns `true` if the given cube map image has been fully loaded.\n *\n * @private\n * @param {?Array<(Image|Object)>} [image] - The cube map image.\n * @return {boolean} Whether the given cube map is ready or not.\n */\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\n/**\n * Returns `true` if the given equirectangular image has been fully loaded.\n *\n * @private\n * @param {(Image|Object)} image - The equirectangular image.\n * @return {boolean} Whether the given cube map is ready or not.\n */\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * TSL function for creating a PMREM node.\n *\n * @tsl\n * @function\n * @param {Texture} value - The input texture.\n * @param {?Node<vec2>} [uvNode=null] - The uv node.\n * @param {?Node<float>} [levelNode=null] - The level node.\n * @returns {PMREMNode}\n */\nexport const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode ).setParameterLength( 1, 3 );\n"],"mappings":"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","ignoreList":[]}