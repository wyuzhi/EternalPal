import{Fn,int,float,vec2,vec3,vec4,If}from"../tsl/TSLBase.js";import{cos,sin,abs,max,exp2,log2,clamp,fract,mix,floor,normalize,cross}from"../math/MathNode.js";import{mul}from"../math/OperatorNode.js";import{select}from"../math/ConditionalNode.js";import{Loop,Break}from"../utils/LoopNode.js";const cubeUV_r0=float(1),cubeUV_m0=float(-2),cubeUV_r1=float(.8),cubeUV_m1=float(-1),cubeUV_r4=float(.4),cubeUV_m4=float(2),cubeUV_r5=float(.305),cubeUV_m5=float(3),cubeUV_r6=float(.21),cubeUV_m6=float(4),cubeUV_minMipLevel=float(4),cubeUV_minTileSize=float(16),getFace=Fn((([e])=>{const a=vec3(abs(e)).toVar(),t=float(-1).toVar();return If(a.x.greaterThan(a.z),(()=>{If(a.x.greaterThan(a.y),(()=>{t.assign(select(e.x.greaterThan(0),0,3))})).Else((()=>{t.assign(select(e.y.greaterThan(0),1,4))}))})).Else((()=>{If(a.z.greaterThan(a.y),(()=>{t.assign(select(e.z.greaterThan(0),2,5))})).Else((()=>{t.assign(select(e.y.greaterThan(0),1,4))}))})),t})).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),getUV=Fn((([e,a])=>{const t=vec2().toVar();return If(a.equal(0),(()=>{t.assign(vec2(e.z,e.y).div(abs(e.x)))})).ElseIf(a.equal(1),(()=>{t.assign(vec2(e.x.negate(),e.z.negate()).div(abs(e.y)))})).ElseIf(a.equal(2),(()=>{t.assign(vec2(e.x.negate(),e.y).div(abs(e.z)))})).ElseIf(a.equal(3),(()=>{t.assign(vec2(e.z.negate(),e.y).div(abs(e.x)))})).ElseIf(a.equal(4),(()=>{t.assign(vec2(e.x.negate(),e.z).div(abs(e.y)))})).Else((()=>{t.assign(vec2(e.x,e.y).div(abs(e.z)))})),mul(.5,t.add(1))})).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),roughnessToMip=Fn((([e])=>{const a=float(0).toVar();return If(e.greaterThanEqual(cubeUV_r1),(()=>{a.assign(cubeUV_r0.sub(e).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0))})).ElseIf(e.greaterThanEqual(cubeUV_r4),(()=>{a.assign(cubeUV_r1.sub(e).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1))})).ElseIf(e.greaterThanEqual(cubeUV_r5),(()=>{a.assign(cubeUV_r4.sub(e).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4))})).ElseIf(e.greaterThanEqual(cubeUV_r6),(()=>{a.assign(cubeUV_r5.sub(e).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5))})).Else((()=>{a.assign(float(-2).mul(log2(mul(1.16,e))))})),a})).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]});export const getDirection=Fn((([e,a])=>{const t=e.toVar();t.assign(mul(2,t).sub(1));const s=vec3(t,1).toVar();return If(a.equal(0),(()=>{s.assign(s.zyx)})).ElseIf(a.equal(1),(()=>{s.assign(s.xzy),s.xz.mulAssign(-1)})).ElseIf(a.equal(2),(()=>{s.x.mulAssign(-1)})).ElseIf(a.equal(3),(()=>{s.assign(s.zyx),s.xz.mulAssign(-1)})).ElseIf(a.equal(4),(()=>{s.assign(s.xzy),s.xy.mulAssign(-1)})).ElseIf(a.equal(5),(()=>{s.z.mulAssign(-1)})),s})).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]});export const textureCubeUV=Fn((([e,a,t,s,n,u])=>{const l=float(t),o=vec3(a),r=clamp(roughnessToMip(l),cubeUV_m0,u),i=fract(r),c=floor(r),m=vec3(bilinearCubeUV(e,o,c,s,n,u)).toVar();return If(i.notEqual(0),(()=>{const a=vec3(bilinearCubeUV(e,o,c.add(1),s,n,u)).toVar();m.assign(mix(m,a,i))})),m}));const bilinearCubeUV=Fn((([e,a,t,s,n,u])=>{const l=float(t).toVar(),o=vec3(a),r=float(getFace(o)).toVar(),i=float(max(cubeUV_minMipLevel.sub(l),0)).toVar();l.assign(max(l,cubeUV_minMipLevel));const c=float(exp2(l)).toVar(),m=vec2(getUV(o,r).mul(c.sub(2)).add(1)).toVar();return If(r.greaterThan(2),(()=>{m.y.addAssign(c),r.subAssign(3)})),m.x.addAssign(r.mul(c)),m.x.addAssign(i.mul(mul(3,cubeUV_minTileSize))),m.y.addAssign(mul(4,exp2(u).sub(c))),m.x.mulAssign(s),m.y.mulAssign(n),e.sample(m).grad(vec2(),vec2())})),getSample=Fn((({envMap:e,mipInt:a,outputDirection:t,theta:s,axis:n,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:o})=>{const r=cos(s),i=t.mul(r).add(n.cross(t).mul(sin(s))).add(n.mul(n.dot(t).mul(r.oneMinus())));return bilinearCubeUV(e,i,a,u,l,o)}));export const blur=Fn((({n:e,latitudinal:a,poleAxis:t,outputDirection:s,weights:n,samples:u,dTheta:l,mipInt:o,envMap:r,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:m})=>{const V=vec3(select(a,t,cross(t,s))).toVar();If(V.equal(vec3(0)),(()=>{V.assign(vec3(s.z,0,s.x.negate()))})),V.assign(normalize(V));const U=vec3().toVar();return U.addAssign(n.element(0).mul(getSample({theta:0,axis:V,outputDirection:s,mipInt:o,envMap:r,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:m}))),Loop({start:int(1),end:e},(({i:e})=>{If(e.greaterThanEqual(u),(()=>{Break()}));const a=float(l.mul(float(e))).toVar();U.addAssign(n.element(e).mul(getSample({theta:a.mul(-1),axis:V,outputDirection:s,mipInt:o,envMap:r,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:m}))),U.addAssign(n.element(e).mul(getSample({theta:a,axis:V,outputDirection:s,mipInt:o,envMap:r,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:m})))})),vec4(U,1)}));
//# sourceMappingURL=PMREMUtils.js.map