{"version":3,"file":"node_modules/three/src/nodes/pmrem/PMREMUtils.js","names":["Fn","int","float","vec2","vec3","vec4","If","cos","sin","abs","max","exp2","log2","clamp","fract","mix","floor","normalize","cross","mul","select","Loop","Break","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","direction","absDirection","toVar","face","x","greaterThan","z","y","assign","Else","setLayout","name","type","inputs","getUV","uv","equal","div","ElseIf","negate","add","roughnessToMip","roughness","mip","greaterThanEqual","sub","getDirection","uv_immutable","zyx","xzy","xz","mulAssign","xy","textureCubeUV","envMap","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","notEqual","color1","direction_immutable","mipInt_immutable","filterInt","faceSize","addAssign","subAssign","sample","grad","getSample","outputDirection","theta","axis","cosTheta","sampleDirection","dot","oneMinus","blur","n","latitudinal","poleAxis","weights","samples","dTheta","gl_FragColor","element","start","end","i"],"sources":["node_modules/three/src/nodes/pmrem/PMREMUtils.js"],"sourcesContent":["import { Fn, int, float, vec2, vec3, vec4, If } from '../tsl/TSLBase.js';\nimport { cos, sin, abs, max, exp2, log2, clamp, fract, mix, floor, normalize, cross } from '../math/MathNode.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { select } from '../math/ConditionalNode.js';\nimport { Loop, Break } from '../utils/LoopNode.js';\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nexport const getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nexport const textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nexport const blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( axis.equal( vec3( 0.0 ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( 0 ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n"],"mappings":"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","ignoreList":[]}