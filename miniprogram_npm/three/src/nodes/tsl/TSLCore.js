import Node from"../core/Node.js";import ArrayElementNode from"../utils/ArrayElementNode.js";import ConvertNode from"../utils/ConvertNode.js";import JoinNode from"../utils/JoinNode.js";import SplitNode from"../utils/SplitNode.js";import SetNode from"../utils/SetNode.js";import FlipNode from"../utils/FlipNode.js";import ConstNode from"../core/ConstNode.js";import MemberNode from"../utils/MemberNode.js";import{getValueFromType,getValueType}from"../core/NodeUtils.js";let currentStack=null;const NodeElements=new Map;export function addMethodChaining(e,t){if(NodeElements.has(e))console.warn(`THREE.TSL: Redefinition of method chaining '${e}'.`);else{if("function"!=typeof t)throw new Error(`THREE.TSL: Node element ${e} is not a function`);NodeElements.set(e,t)}}const parseSwizzle=e=>e.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),parseSwizzleAndSort=e=>parseSwizzle(e).split("").sort().join(""),shaderNodeHandler={setup(e,t){const n=t.shift();return e(nodeObjects(n),...t)},get(e,t,n){if("string"==typeof t&&void 0===e[t]){if(!0!==e.isStackNode&&"assign"===t)return(...e)=>(currentStack.assign(n,...e),n);if(NodeElements.has(t)){const o=NodeElements.get(t);return e.isStackNode?(...e)=>n.add(o(...e)):(...e)=>o(n,...e)}if("toVarIntent"===t)return()=>n;if("self"===t)return e;if(t.endsWith("Assign")&&NodeElements.has(t.slice(0,t.length-6))){const o=NodeElements.get(t.slice(0,t.length-6));return e.isStackNode?(...e)=>n.assign(e[0],o(...e)):(...e)=>n.assign(o(n,...e))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=parseSwizzle(t),nodeObject(new SplitNode(n,t));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(t))return t=parseSwizzleAndSort(t.slice(3).toLowerCase()),n=>nodeObject(new SetNode(e,t,nodeObject(n)));if(!0===/^flip[XYZWRGBASTPQ]{1,4}$/.test(t))return t=parseSwizzleAndSort(t.slice(4).toLowerCase()),()=>nodeObject(new FlipNode(nodeObject(e),t));if("width"===t||"height"===t||"depth"===t)return"width"===t?t="x":"height"===t?t="y":"depth"===t&&(t="z"),nodeObject(new SplitNode(e,t));if(!0===/^\d+$/.test(t))return nodeObject(new ArrayElementNode(n,new ConstNode(Number(t),"uint")));if(!0===/^get$/.test(t))return e=>nodeObject(new MemberNode(n,e))}return Reflect.get(e,t,n)},set:(e,t,n,o)=>"string"!=typeof t||void 0!==e[t]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(t)&&"width"!==t&&"height"!==t&&"depth"!==t&&!0!==/^\d+$/.test(t)?Reflect.set(e,t,n,o):(o[t].assign(n),!0)},nodeObjectsCacheMap=new WeakMap,nodeBuilderFunctionsCacheMap=new WeakMap,ShaderNodeObject=function(e,t=null){const n=getValueType(e);if("node"===n){let t=nodeObjectsCacheMap.get(e);return void 0===t&&(t=new Proxy(e,shaderNodeHandler),nodeObjectsCacheMap.set(e,t),nodeObjectsCacheMap.set(t,t)),t}return null===t&&("float"===n||"boolean"===n)||n&&"shader"!==n&&"string"!==n?nodeObject(getConstNode(e,t)):"shader"===n?e.isFn?e:Fn(e):e},ShaderNodeObjects=function(e,t=null){for(const n in e)e[n]=nodeObject(e[n],t);return e},ShaderNodeArray=function(e,t=null){const n=e.length;for(let o=0;o<n;o++)e[o]=nodeObject(e[o],t);return e},ShaderNodeProxy=function(e,t=null,n=null,o=null){function r(e){return null!==o?(e=nodeObject(Object.assign(e,o)),!0===o.intent&&(e=e.toVarIntent())):e=nodeObject(e),e}let s,d,a,c=t;function i(t){let n;return n=c?/[a-z]/i.test(c)?c+"()":c:e.type,void 0!==d&&t.length<d?(console.error(`THREE.TSL: "${n}" parameter length is less than minimum required.`),t.concat(new Array(d-t.length).fill(0))):void 0!==a&&t.length>a?(console.error(`THREE.TSL: "${n}" parameter length exceeds limit.`),t.slice(0,a)):t}return null===t?s=(...t)=>r(new e(...nodeArray(i(t)))):null!==n?(n=nodeObject(n),s=(...o)=>r(new e(t,...nodeArray(i(o)),n))):s=(...n)=>r(new e(t,...nodeArray(i(n)))),s.setParameterLength=(...e)=>(1===e.length?d=a=e[0]:2===e.length&&([d,a]=e),s),s.setName=e=>(c=e,s),s},ShaderNodeImmutable=function(e,...t){return nodeObject(new e(...nodeArray(t)))};class ShaderCallNodeInternal extends Node{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t,this.isShaderCallNodeInternal=!0}getNodeType(e){return this.shaderNode.nodeType||this.getOutputNode(e).getNodeType(e)}getMemberType(e,t){return this.getOutputNode(e).getMemberType(e,t)}call(e){const{shaderNode:t,inputNodes:n}=this,o=e.getNodeProperties(t),r=e.getClosestSubBuild(t.subBuilds)||"",s=r||"default";if(o[s])return o[s];const d=e.subBuildFn;e.subBuildFn=r;let a=null;if(t.layout){let o=nodeBuilderFunctionsCacheMap.get(e.constructor);void 0===o&&(o=new WeakMap,nodeBuilderFunctionsCacheMap.set(e.constructor,o));let r=o.get(t);void 0===r&&(r=nodeObject(e.buildFunctionNode(t)),o.set(t,r)),e.addInclude(r),a=nodeObject(r.call(n))}else{let o=n;if(Array.isArray(o)){let e=0;o=new Proxy(o,{get:(t,n,o)=>void 0===t[n]?t[e++]:Reflect.get(t,n,o)})}const r=t.jsFunc,s=null!==o||r.length>1?r(o||[],e):r(e);a=nodeObject(s)}return e.subBuildFn=d,t.once&&(o[s]=a),a}setupOutput(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}getOutputNode(e){const t=e.getNodeProperties(this),n=e.getSubBuildOutput(this);return t[n]=t[n]||this.setupOutput(e),t[n].subBuild=e.getClosestSubBuild(this),t[n]}build(e,t=null){let n=null;const o=e.getBuildStage(),r=e.getNodeProperties(this),s=e.getSubBuildOutput(this),d=this.getOutputNode(e);if("setup"===o){const t=e.getSubBuildProperty("initialized",this);if(!0!==r[t]&&(r[t]=!0,r[s]=this.getOutputNode(e),r[s].build(e),this.shaderNode.subBuilds))for(const t of e.chaining){const n=e.getDataFromNode(t,"any");n.subBuilds=n.subBuilds||new Set;for(const e of this.shaderNode.subBuilds)n.subBuilds.add(e)}n=r[s]}else"analyze"===o?d.build(e,t):"generate"===o&&(n=d.build(e,t)||"");return n}}class ShaderNodeInternal extends Node{constructor(e,t){super(t),this.jsFunc=e,this.layout=null,this.global=!0,this.once=!1}setLayout(e){return this.layout=e,this}call(e=null){return nodeObjects(e),nodeObject(new ShaderCallNodeInternal(this,e))}setup(){return this.call()}}const bools=[!1,!0],uints=[0,1,2,3],ints=[-1,-2],floats=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],boolsCacheMap=new Map;for(const e of bools)boolsCacheMap.set(e,new ConstNode(e));const uintsCacheMap=new Map;for(const t of uints)uintsCacheMap.set(t,new ConstNode(t,"uint"));const intsCacheMap=new Map([...uintsCacheMap].map((e=>new ConstNode(e.value,"int"))));for(const n of ints)intsCacheMap.set(n,new ConstNode(n,"int"));const floatsCacheMap=new Map([...intsCacheMap].map((e=>new ConstNode(e.value))));for(const o of floats)floatsCacheMap.set(o,new ConstNode(o));for(const r of floats)floatsCacheMap.set(-r,new ConstNode(-r));const cacheMaps={bool:boolsCacheMap,uint:uintsCacheMap,ints:intsCacheMap,float:floatsCacheMap},constNodesCacheMap=new Map([...boolsCacheMap,...floatsCacheMap]),getConstNode=(e,t)=>constNodesCacheMap.has(e)?constNodesCacheMap.get(e):!0===e.isNode?e:new ConstNode(e,t),ConvertType=function(e,t=null){return(...n)=>{if((0===n.length||!["bool","float","int","uint"].includes(e)&&n.every((e=>"object"!=typeof e)))&&(n=[getValueFromType(e,...n)]),1===n.length&&null!==t&&t.has(n[0]))return nodeObjectIntent(t.get(n[0]));if(1===n.length){const t=getConstNode(n[0],e);return t.nodeType===e?nodeObjectIntent(t):nodeObjectIntent(new ConvertNode(t,e))}const o=n.map((e=>getConstNode(e)));return nodeObjectIntent(new JoinNode(o,e))}};export const defined=e=>"object"==typeof e&&null!==e?e.value:e;export const getConstNodeType=e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null;export function ShaderNode(e,t){return new Proxy(new ShaderNodeInternal(e,t),shaderNodeHandler)}export const nodeObject=(e,t=null)=>ShaderNodeObject(e,t);export const nodeObjectIntent=(e,t=null)=>nodeObject(e,t).toVarIntent();export const nodeObjects=(e,t=null)=>new ShaderNodeObjects(e,t);export const nodeArray=(e,t=null)=>new ShaderNodeArray(e,t);export const nodeProxy=(e,t=null,n=null,o=null)=>new ShaderNodeProxy(e,t,n,o);export const nodeImmutable=(e,...t)=>new ShaderNodeImmutable(e,...t);export const nodeProxyIntent=(e,t=null,n=null,o={})=>new ShaderNodeProxy(e,t,n,{intent:!0,...o});let fnId=0;export const Fn=(e,t=null)=>{let n=null;null!==t&&("object"==typeof t?n=t.return:("string"==typeof t?n=t:console.error("THREE.TSL: Invalid layout type."),t=null));const o=new ShaderNode(e,n),r=(...e)=>{let t;nodeObjects(e);t=e[0]&&(e[0].isNode||Object.getPrototypeOf(e[0])!==Object.prototype)?[...e]:e[0];const r=o.call(t);return"void"===n&&r.toStack(),r.toVarIntent()};if(r.shaderNode=o,r.id=o.id,r.isFn=!0,r.getNodeType=(...e)=>o.getNodeType(...e),r.getCacheKey=(...e)=>o.getCacheKey(...e),r.setLayout=e=>(o.setLayout(e),r),r.once=(e=null)=>(o.once=!0,o.subBuilds=e,r),null!==t){if("object"!=typeof t.inputs){const e={name:"fn"+fnId++,type:n,inputs:[]};for(const n in t)"return"!==n&&e.inputs.push({name:n,type:t[n]});t=e}r.setLayout(t)}return r};export const setCurrentStack=e=>{currentStack=e};export const getCurrentStack=()=>currentStack;export const If=(...e)=>currentStack.If(...e);export const Switch=(...e)=>currentStack.Switch(...e);export function Stack(e){return currentStack&&currentStack.add(e),e}addMethodChaining("toStack",Stack);export const color=new ConvertType("color");export const float=new ConvertType("float",cacheMaps.float);export const int=new ConvertType("int",cacheMaps.ints);export const uint=new ConvertType("uint",cacheMaps.uint);export const bool=new ConvertType("bool",cacheMaps.bool);export const vec2=new ConvertType("vec2");export const ivec2=new ConvertType("ivec2");export const uvec2=new ConvertType("uvec2");export const bvec2=new ConvertType("bvec2");export const vec3=new ConvertType("vec3");export const ivec3=new ConvertType("ivec3");export const uvec3=new ConvertType("uvec3");export const bvec3=new ConvertType("bvec3");export const vec4=new ConvertType("vec4");export const ivec4=new ConvertType("ivec4");export const uvec4=new ConvertType("uvec4");export const bvec4=new ConvertType("bvec4");export const mat2=new ConvertType("mat2");export const mat3=new ConvertType("mat3");export const mat4=new ConvertType("mat4");export const string=(e="")=>nodeObject(new ConstNode(e,"string"));export const arrayBuffer=e=>nodeObject(new ConstNode(e,"ArrayBuffer"));addMethodChaining("toColor",color),addMethodChaining("toFloat",float),addMethodChaining("toInt",int),addMethodChaining("toUint",uint),addMethodChaining("toBool",bool),addMethodChaining("toVec2",vec2),addMethodChaining("toIVec2",ivec2),addMethodChaining("toUVec2",uvec2),addMethodChaining("toBVec2",bvec2),addMethodChaining("toVec3",vec3),addMethodChaining("toIVec3",ivec3),addMethodChaining("toUVec3",uvec3),addMethodChaining("toBVec3",bvec3),addMethodChaining("toVec4",vec4),addMethodChaining("toIVec4",ivec4),addMethodChaining("toUVec4",uvec4),addMethodChaining("toBVec4",bvec4),addMethodChaining("toMat2",mat2),addMethodChaining("toMat3",mat3),addMethodChaining("toMat4",mat4);export const element=nodeProxy(ArrayElementNode).setParameterLength(2);export const convert=(e,t)=>nodeObject(new ConvertNode(nodeObject(e),t));export const split=(e,t)=>nodeObject(new SplitNode(nodeObject(e),t));addMethodChaining("element",element),addMethodChaining("convert",convert);export const append=e=>(console.warn("THREE.TSL: append() has been renamed to Stack()."),Stack(e));addMethodChaining("append",(e=>(console.warn("THREE.TSL: .append() has been renamed to .toStack()."),Stack(e))));
//# sourceMappingURL=TSLCore.js.map