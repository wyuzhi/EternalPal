{"version":3,"file":"node_modules/three/src/nodes/tsl/TSLCore.js","names":["Node","ArrayElementNode","ConvertNode","JoinNode","SplitNode","SetNode","FlipNode","ConstNode","MemberNode","getValueFromType","getValueType","currentStack","NodeElements","Map","addMethodChaining","name","nodeElement","has","console","warn","Error","set","parseSwizzle","props","replace","parseSwizzleAndSort","split","sort","join","shaderNodeHandler","setup","NodeClosure","params","inputs","shift","nodeObjects","get","node","prop","nodeObj","undefined","isStackNode","assign","add","endsWith","slice","length","test","nodeObject","toLowerCase","value","Number","Reflect","nodeObjectsCacheMap","WeakMap","nodeBuilderFunctionsCacheMap","ShaderNodeObject","obj","altType","type","Proxy","getConstNode","isFn","Fn","ShaderNodeObjects","objects","ShaderNodeArray","array","len","i","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","Object","intent","toVarIntent","fn","minParams","maxParams","verifyParamsLimit","tslName","error","concat","Array","fill","nodeArray","setParameterLength","setName","ShaderNodeImmutable","ShaderCallNodeInternal","constructor","shaderNode","inputNodes","super","this","isShaderCallNodeInternal","getNodeType","builder","nodeType","getOutputNode","getMemberType","call","properties","getNodeProperties","subBuild","getClosestSubBuild","subBuilds","subBuildProperty","previousSubBuildFn","subBuildFn","result","layout","functionNodesCacheMap","functionNode","buildFunctionNode","addInclude","isArray","index","target","property","receiver","jsFunc","outputNode","once","setupOutput","addStack","stack","removeStack","subBuildOutput","getSubBuildOutput","build","output","buildStage","getBuildStage","subBuildInitialized","getSubBuildProperty","chaining","nodeData","getDataFromNode","Set","ShaderNodeInternal","global","setLayout","bools","uints","ints","floats","Math","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","isNode","ConvertType","cacheMap","includes","every","param","nodeObjectIntent","nodes","defined","v","getConstNodeType","convertTo","ShaderNode","val","nodeProxy","nodeImmutable","nodeProxyIntent","fnId","return","getPrototypeOf","prototype","fnCall","toStack","id","getCacheKey","fullLayout","push","setCurrentStack","getCurrentStack","If","Switch","Stack","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","string","arrayBuffer","element","convert","types","channels","append"],"sources":["node_modules/three/src/nodes/tsl/TSLCore.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport FlipNode from '../utils/FlipNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport MemberNode from '../utils/MemberNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\nexport function addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `THREE.TSL: Redefinition of method chaining '${ name }'.` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `THREE.TSL: Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'toVarIntent' ) {\n\n\t\t\t\treturn () => nodeObj;\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, nodeObject( value ) ) );\n\n\t\t\t} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );\n\n\t\t\t\treturn () => nodeObject( new FlipNode( nodeObject( node ), prop ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t} else if ( /^get$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties\n\n\t\t\t\treturn ( value ) => nodeObject( new MemberNode( nodeObj, value ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn obj.isFn ? obj : Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tfunction assignNode( node ) {\n\n\t\tif ( settings !== null ) {\n\n\t\t\tnode = nodeObject( Object.assign( node, settings ) );\n\n\t\t\tif ( settings.intent === true ) {\n\n\t\t\t\tnode = node.toVarIntent();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tnode = nodeObject( node );\n\n\t\t}\n\n\t\treturn node;\n\n\n\t}\n\n\tlet fn, name = scope, minParams, maxParams;\n\n\tfunction verifyParamsLimit( params ) {\n\n\t\tlet tslName;\n\n\t\tif ( name ) tslName = /[a-z]/i.test( name ) ? name + '()' : name;\n\t\telse tslName = NodeClass.type;\n\n\t\tif ( minParams !== undefined && params.length < minParams ) {\n\n\t\t\tconsole.error( `THREE.TSL: \"${ tslName }\" parameter length is less than minimum required.` );\n\n\t\t\treturn params.concat( new Array( minParams - params.length ).fill( 0 ) );\n\n\t\t} else if ( maxParams !== undefined && params.length > maxParams ) {\n\n\t\t\tconsole.error( `THREE.TSL: \"${ tslName }\" parameter length exceeds limit.` );\n\n\t\t\treturn params.slice( 0, maxParams );\n\n\t\t}\n\n\t\treturn params;\n\n\t}\n\n\tif ( scope === null ) {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t}\n\n\tfn.setParameterLength = ( ...params ) => {\n\n\t\tif ( params.length === 1 ) minParams = maxParams = params[ 0 ];\n\t\telse if ( params.length === 2 ) [ minParams, maxParams ] = params;\n\n\t\treturn fn;\n\n\t};\n\n\tfn.setName = ( value ) => {\n\n\t\tname = value;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t\tthis.isShaderCallNodeInternal = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.getOutputNode( builder ).getMemberType( builder, name );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\n\t\tconst subBuild = builder.getClosestSubBuild( shaderNode.subBuilds ) || '';\n\t\tconst subBuildProperty = subBuild || 'default';\n\n\t\tif ( properties[ subBuildProperty ] ) {\n\n\t\t\treturn properties[ subBuildProperty ];\n\n\t\t}\n\n\t\t//\n\n\t\tconst previousSubBuildFn = builder.subBuildFn;\n\n\t\tbuilder.subBuildFn = subBuild;\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tbuilder.addInclude( functionNode );\n\n\t\t\tresult = nodeObject( functionNode.call( inputNodes ) );\n\n\t\t} else {\n\n\t\t\tlet inputs = inputNodes;\n\n\t\t\tif ( Array.isArray( inputs ) ) {\n\n\t\t\t\t// If inputs is an array, we need to convert it to a Proxy\n\t\t\t\t// so we can call TSL functions using the syntax `Fn( ( { r, g, b } ) => { ... } )`\n\t\t\t\t// and call through `fn( 0, 1, 0 )` or `fn( { r: 0, g: 1, b: 0 } )`\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tinputs = new Proxy( inputs, {\n\t\t\t\t\tget: ( target, property, receiver ) => {\n\n\t\t\t\t\t\tif ( target[ property ] === undefined ) {\n\n\t\t\t\t\t\t\treturn target[ index ++ ];\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn Reflect.get( target, property, receiver );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = inputs !== null || jsFunc.length > 1 ? jsFunc( inputs || [], builder ) : jsFunc( builder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tbuilder.subBuildFn = previousSubBuildFn;\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties[ subBuildProperty ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\n\t\tproperties[ subBuildOutput ] = properties[ subBuildOutput ] || this.setupOutput( builder );\n\t\tproperties[ subBuildOutput ].subBuild = builder.getClosestSubBuild( this );\n\n\t\treturn properties[ subBuildOutput ];\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tconst subBuildInitialized = builder.getSubBuildProperty( 'initialized', this );\n\n\t\t\tif ( properties[ subBuildInitialized ] !== true ) {\n\n\t\t\t\tproperties[ subBuildInitialized ] = true;\n\n\t\t\t\tproperties[ subBuildOutput ] = this.getOutputNode( builder );\n\t\t\t\tproperties[ subBuildOutput ].build( builder );\n\n\t\t\t\t// If the shaderNode has subBuilds, add them to the chaining nodes\n\t\t\t\t// so they can be built later in the build process.\n\n\t\t\t\tif ( this.shaderNode.subBuilds ) {\n\n\t\t\t\t\tfor ( const node of builder.chaining ) {\n\n\t\t\t\t\t\tconst nodeData = builder.getDataFromNode( node, 'any' );\n\t\t\t\t\t\tnodeData.subBuilds = nodeData.subBuilds || new Set();\n\n\t\t\t\t\t\tfor ( const subBuild of this.shaderNode.subBuilds ) {\n\n\t\t\t\t\t\t\tnodeData.subBuilds.add( subBuild );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//builder.getDataFromNode( node ).subBuilds = nodeData.subBuilds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties[ subBuildOutput ];\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\toutputNode.build( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tresult = outputNode.build( builder, output ) || '';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObjectIntent( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( node.nodeType === type ) return nodeObjectIntent( node );\n\t\t\treturn nodeObjectIntent( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObjectIntent( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nexport const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nexport const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nexport function ShaderNode( jsFunc, nodeType ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );\n\n}\n\nexport const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nexport const nodeObjectIntent = ( val, altType = null ) => /* new */ nodeObject( val, altType ).toVarIntent();\nexport const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nexport const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nexport const nodeProxy = ( NodeClass, scope = null, factor = null, settings = null ) => new ShaderNodeProxy( NodeClass, scope, factor, settings );\nexport const nodeImmutable = ( NodeClass, ...params ) => new ShaderNodeImmutable( NodeClass, ...params );\nexport const nodeProxyIntent = ( NodeClass, scope = null, factor = null, settings = {} ) => new ShaderNodeProxy( NodeClass, scope, factor, { intent: true, ...settings } );\n\nlet fnId = 0;\n\nexport const Fn = ( jsFunc, layout = null ) => {\n\n\tlet nodeType = null;\n\n\tif ( layout !== null ) {\n\n\t\tif ( typeof layout === 'object' ) {\n\n\t\t\tnodeType = layout.return;\n\n\t\t} else {\n\n\t\t\tif ( typeof layout === 'string' ) {\n\n\t\t\t\tnodeType = layout;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.TSL: Invalid layout type.' );\n\n\t\t\t}\n\n\t\t\tlayout = null;\n\n\t\t}\n\n\t}\n\n\tconst shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tconst isArrayAsParameter = params[ 0 ] && ( params[ 0 ].isNode || Object.getPrototypeOf( params[ 0 ] ) !== Object.prototype );\n\n\t\tif ( isArrayAsParameter ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\tconst fnCall = shaderNode.call( inputs );\n\n\t\tif ( nodeType === 'void' ) fnCall.toStack();\n\n\t\treturn fnCall.toVarIntent();\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\tfn.id = shaderNode.id;\n\n\tfn.isFn = true;\n\n\tfn.getNodeType = ( ...params ) => shaderNode.getNodeType( ...params );\n\tfn.getCacheKey = ( ...params ) => shaderNode.getCacheKey( ...params );\n\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\tfn.once = ( subBuilds = null ) => {\n\n\t\tshaderNode.once = true;\n\t\tshaderNode.subBuilds = subBuilds;\n\n\t\treturn fn;\n\n\t};\n\n\tif ( layout !== null ) {\n\n\t\tif ( typeof layout.inputs !== 'object' ) {\n\n\t\t\tconst fullLayout = {\n\t\t\t\tname: 'fn' + fnId ++,\n\t\t\t\ttype: nodeType,\n\t\t\t\tinputs: []\n\t\t\t};\n\n\t\t\tfor ( const name in layout ) {\n\n\t\t\t\tif ( name === 'return' ) continue;\n\n\t\t\t\tfullLayout.inputs.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: layout[ name ]\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tlayout = fullLayout;\n\n\t\t}\n\n\t\tfn.setLayout( layout );\n\n\t}\n\n\treturn fn;\n\n};\n\n//\n\nexport const setCurrentStack = ( stack ) => {\n\n\tif ( currentStack === stack ) {\n\n\t\t//throw new Error( 'Stack already defined.' );\n\n\t}\n\n\tcurrentStack = stack;\n\n};\n\nexport const getCurrentStack = () => currentStack;\n\n/**\n * Represent a conditional node using if/else statements.\n *\n * ```js\n * If( condition, function )\n * \t.ElseIf( condition, function )\n * \t.Else( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nexport const If = ( ...params ) => currentStack.If( ...params );\n\n/**\n * Represent a conditional node using switch/case statements.\n *\n * ```js\n * Switch( value )\n * \t.Case( 1, function )\n * \t.Case( 2, 3, 4, function )\n * \t.Default( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nexport const Switch = ( ...params ) => currentStack.Switch( ...params );\n\n/**\n * Add the given node to the current stack.\n *\n * @param {Node} node - The node to add.\n * @returns {Node} The node that was added to the stack.\n */\nexport function Stack( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'toStack', Stack );\n\n// types\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.ints );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat2 = new ConvertType( 'mat2' );\nexport const mat3 = new ConvertType( 'mat3' );\nexport const mat4 = new ConvertType( 'mat4' );\n\nexport const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nexport const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nexport const element = /*@__PURE__*/ nodeProxy( ArrayElementNode ).setParameterLength( 2 );\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nexport const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\n// deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r176. Use {@link Stack} instead.\n *\n * @param {Node} node - The node to add.\n * @returns {Function}\n */\nexport const append = ( node ) => { // @deprecated, r176\n\n\tconsole.warn( 'THREE.TSL: append() has been renamed to Stack().' );\n\treturn Stack( node );\n\n};\n\naddMethodChaining( 'append', ( node ) => { // @deprecated, r176\n\n\tconsole.warn( 'THREE.TSL: .append() has been renamed to .toStack().' );\n\treturn Stack( node );\n\n} );\n\n"],"mappings":"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","ignoreList":[]}