{"version":3,"file":"node_modules/three/src/nodes/utils/CubeMapNode.js","names":["TempNode","NodeUpdateType","nodeProxy","CubeTexture","cubeTexture","CubeRenderTarget","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","_cache","WeakMap","CubeMapNode","type","constructor","envNode","super","this","_cubeTexture","_cubeTextureNode","defaultTexture","isRenderTargetTexture","_defaultTexture","updateBeforeType","RENDER","updateBefore","frame","renderer","material","isTextureNode","isMaterialReferenceNode","texture","value","property","isTexture","mapping","has","cubeMap","get","mapTextureMapping","image","isEquirectangularMapReady","renderTarget","height","fromEquirectangularTexture","set","addEventListener","onTextureDispose","setup","builder","event","target","removeEventListener","undefined","delete","dispose","cubeMapNode","setParameterLength"],"sources":["node_modules/three/src/nodes/utils/CubeMapNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\nimport { CubeTexture } from '../../textures/CubeTexture.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\n\nconst _cache = new WeakMap();\n\n/**\n * This node can be used to automatically convert environment maps in the\n * equirectangular format into the cube map format.\n *\n * @augments TempNode\n */\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube map node.\n\t *\n\t * @param {Node} envNode - The node representing the environment map.\n\t */\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The node representing the environment map.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t\t/**\n\t\t * A reference to the internal cube texture.\n\t\t *\n\t\t * @private\n\t\t * @type {?CubeTexture}\n\t\t * @default null\n\t\t */\n\t\tthis._cubeTexture = null;\n\n\t\t/**\n\t\t * A reference to the internal cube texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTextureNode}\n\t\t */\n\t\tthis._cubeTextureNode = cubeTexture( null );\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * A default cube texture that acts as a placeholder.\n\t\t * It is used when the conversion from equirectangular to cube\n\t\t * map has not finished yet for a given texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t */\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link CubeMapNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\nexport default CubeMapNode;\n\n/**\n * Returns true if the given equirectangular image has been fully loaded\n * and is ready for further processing.\n *\n * @private\n * @param {Image} image - The equirectangular image to check.\n * @return {boolean} Whether the image is ready or not.\n */\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * This function is executed when `dispose()` is called on the equirectangular\n * texture. In this case, the generated cube map with its render target\n * is deleted as well.\n *\n * @private\n * @param {Object} event - The event object.\n */\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\n/**\n * This function makes sure the generated cube map uses the correct\n * texture mapping that corresponds to the equirectangular original.\n *\n * @private\n * @param {Texture} texture - The cube texture.\n * @param {number} mapping - The original texture mapping.\n */\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube map node.\n *\n * @tsl\n * @function\n * @param {Node} envNode - The node representing the environment map.\n * @returns {CubeMapNode}\n */\nexport const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode ).setParameterLength( 1 );\n"],"mappings":"OAAOA,aAAc,6BACZC,mBAAsB,8BACtBC,cAAiB,2BACjBC,gBAAmB,uCACnBC,gBAAmB,yCACrBC,qBAAsB,oDACpBC,sBAAuBC,sBAAuBC,iCAAkCC,qCAAwC,qBAEjI,MAAMC,OAAS,IAAIC,QAQnB,MAAMC,oBAAoBZ,SAEzB,eAAWa,GAEV,MAAO,aAER,CAOA,WAAAC,CAAaC,GAEZC,MAAO,QAOPC,KAAKF,QAAUA,EASfE,KAAKC,aAAe,KAQpBD,KAAKE,iBAAmBf,YAAa,MAErC,MAAMgB,EAAiB,IAAIjB,YAC3BiB,EAAeC,uBAAwB,EAUvCJ,KAAKK,gBAAkBF,EASvBH,KAAKM,iBAAmBtB,eAAeuB,MAExC,CAEA,YAAAC,CAAcC,GAEb,MAAMC,SAAEA,EAAQC,SAAEA,GAAaF,EAEzBX,EAAUE,KAAKF,QAErB,GAAKA,EAAQc,eAAiBd,EAAQe,wBAA0B,CAE/D,MAAMC,EAAYhB,EAAsB,cAAIA,EAAQiB,MAAQJ,EAAUb,EAAQkB,UAE9E,GAAKF,GAAWA,EAAQG,UAAY,CAEnC,MAAMC,EAAUJ,EAAQI,QAExB,GAAKA,IAAY3B,kCAAoC2B,IAAY1B,iCAAmC,CAInG,GAAKC,OAAO0B,IAAKL,GAAY,CAE5B,MAAMM,EAAU3B,OAAO4B,IAAKP,GAE5BQ,kBAAmBF,EAASN,EAAQI,SACpClB,KAAKC,aAAemB,CAErB,KAAO,CAIN,MAAMG,EAAQT,EAAQS,MAEtB,GAAKC,0BAA2BD,GAAU,CAEzC,MAAME,EAAe,IAAIrC,iBAAkBmC,EAAMG,QACjDD,EAAaE,2BAA4BjB,EAAUI,GAEnDQ,kBAAmBG,EAAaX,QAASA,EAAQI,SACjDlB,KAAKC,aAAewB,EAAaX,QAEjCrB,OAAOmC,IAAKd,EAASW,EAAaX,SAElCA,EAAQe,iBAAkB,UAAWC,iBAEtC,MAIC9B,KAAKC,aAAeD,KAAKK,eAI3B,CAIAL,KAAKE,iBAAiBa,MAAQf,KAAKC,YAEpC,MAICD,KAAKE,iBAAmBF,KAAKF,OAI/B,CAED,CAED,CAEA,KAAAiC,CAAOC,GAIN,OAFAhC,KAAKQ,aAAcwB,GAEZhC,KAAKE,gBAEb,iBAIcP,YAUf,SAAS6B,0BAA2BD,GAEnC,OAAKA,SAEEA,EAAMG,OAAS,CAEvB,CAUA,SAASI,iBAAkBG,GAE1B,MAAMnB,EAAUmB,EAAMC,OAEtBpB,EAAQqB,oBAAqB,UAAWL,kBAExC,MAAML,EAAehC,OAAO4B,IAAKP,QAEXsB,IAAjBX,IAEJhC,OAAO4C,OAAQvB,GAEfW,EAAaa,UAIf,CAUA,SAAShB,kBAAmBR,EAASI,GAE/BA,IAAY3B,iCAEhBuB,EAAQI,QAAU7B,sBAEP6B,IAAY1B,mCAEvBsB,EAAQI,QAAU5B,sBAIpB,QAUO,MAAMiD,YAA4BtD,UAAWU,aAAc6C,mBAAoB","ignoreList":[]}