{"version":3,"file":"node_modules/three/src/nodes/utils/FlipNode.js","names":["TempNode","vectorComponents","FlipNode","type","constructor","sourceNode","components","super","this","getNodeType","builder","generate","sourceType","sourceSnippet","build","sourceCache","getVarFromNode","sourceProperty","getPropertyName","addLineFlowCode","length","getTypeLength","snippetValues","componentIndex","i","component","push","getType","join"],"sources":["node_modules/three/src/nodes/utils/FlipNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { vectorComponents } from '../core/constants.js';\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\t/**\n\t * Constructs a new flip node.\n\t *\n\t * @param {Node} sourceNode - The node which component(s) should be flipped.\n\t * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n\t */\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which component(s) should be flipped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be flipped e.g. `'x'` or `'xy'`.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the source node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default FlipNode;\n"],"mappings":"OAAOA,aAAc,6BACZC,qBAAwB,uBAiBjC,MAAMC,iBAAiBF,SAEtB,eAAWG,GAEV,MAAO,UAER,CAQA,WAAAC,CAAaC,EAAYC,GAExBC,QAOAC,KAAKH,WAAaA,EAOlBG,KAAKF,WAAaA,CAEnB,CAQA,WAAAG,CAAaC,GAEZ,OAAOF,KAAKH,WAAWI,YAAaC,EAErC,CAEA,QAAAC,CAAUD,GAET,MAAMJ,WAAEA,EAAUD,WAAEA,GAAeG,KAE7BI,EAAaJ,KAAKC,YAAaC,GAC/BG,EAAgBR,EAAWS,MAAOJ,GAElCK,EAAcL,EAAQM,eAAgBR,MACtCS,EAAiBP,EAAQQ,gBAAiBH,GAEhDL,EAAQS,gBAAiBF,EAAiB,MAAQJ,EAAeL,MAEjE,MAAMY,EAASV,EAAQW,cAAeT,GAChCU,EAAgB,GAEtB,IAAIC,EAAiB,EAErB,IAAM,IAAIC,EAAI,EAAGA,EAAIJ,EAAQI,IAAO,CAEnC,MAAMC,EAAYxB,iBAAkBuB,GAE/BC,IAAcnB,EAAYiB,IAE9BD,EAAcI,KAAM,SAAaT,EAAiB,IAAMQ,GAExDF,KAIAD,EAAcI,KAAMT,EAAiB,IAAMQ,EAI7C,CAEA,MAAO,GAAIf,EAAQiB,QAASf,OAAmBU,EAAcM,KAAM,SAEpE,iBAIc1B","ignoreList":[]}