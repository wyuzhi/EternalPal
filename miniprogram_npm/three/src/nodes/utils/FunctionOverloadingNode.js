import Node from"../core/Node.js";import{nodeProxy}from"../tsl/TSLCore.js";class FunctionOverloadingNode extends Node{static get type(){return"FunctionOverloadingNode"}constructor(e=[],...o){super(),this.functionNodes=e,this.parametersNodes=o,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const o=this.parametersNodes;let t=this._candidateFnCall;if(null===t){let n=null,r=-1;for(const t of this.functionNodes){const s=t.shaderNode.layout;if(null===s)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const d=s.inputs;if(o.length===d.length){let s=0;for(let t=0;t<o.length;t++){const n=o[t],r=d[t];n.getNodeType(e)===r.type?s++:s=0}s>r&&(n=t,r=s)}}this._candidateFnCall=t=n(...o)}return t}}export default FunctionOverloadingNode;const overloadingBaseFn=nodeProxy(FunctionOverloadingNode);export const overloadingFn=e=>(...o)=>overloadingBaseFn(e,...o);
//# sourceMappingURL=FunctionOverloadingNode.js.map