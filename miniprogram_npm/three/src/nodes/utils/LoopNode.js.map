{"version":3,"file":"node_modules/three/src/nodes/utils/LoopNode.js","names":["Node","expression","nodeObject","nodeArray","Fn","LoopNode","type","constructor","params","super","this","getVarName","index","String","fromCharCode","charCodeAt","getProperties","builder","properties","getNodeProperties","undefined","stackNode","inputs","i","l","length","param","name","isNode","stack","addStack","returnsNode","baseParam","update","updateNode","removeStack","getNodeType","setup","generate","loopSnippet","isWhile","start","end","condition","build","generateConst","Number","internalParam","startSnippet","endSnippet","updateSnippet","deltaOperator","includes","flowStagesNode","code","replace","console","error","getVar","addFlowCode","tab","addFlowTab","stackSnippet","returnsSnippet","removeFlowTab","Loop","toStack","Continue","Break"],"sources":["node_modules/three/src/nodes/utils/LoopNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { nodeObject, nodeArray, Fn } from '../tsl/TSLBase.js';\n\n/**\n * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:\n * ```js\n * Loop( count, ( { i } ) => {\n *\n * } );\n * ```\n * However, it is also possible to define a start and end ranges, data types and loop conditions:\n * ```js\n * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {\n *\n * } );\n *```\n * Nested loops can be defined in a compacted form:\n * ```js\n * Loop( 10, 5, ( { i, j } ) => {\n *\n * } );\n * ```\n * Loops that should run backwards can be defined like so:\n * ```js\n * Loop( { start: 10 }, () => {} );\n * ```\n * It is possible to execute with boolean values, similar to the `while` syntax.\n * ```js\n * const value = float( 0 ).toVar();\n *\n * Loop( value.lessThan( 10 ), () => {\n *\n * \tvalue.addAssign( 1 );\n *\n * } );\n * ```\n * The module also provides `Break()` and `Continue()` TSL expression for loop control.\n * @augments Node\n */\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\t/**\n\t * Constructs a new loop node.\n\t *\n\t * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.\n\t */\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\t/**\n\t * Returns a loop variable name based on an index. The pattern is\n\t * `0` = `i`, `1`= `j`, `2`= `k` and so on.\n\t *\n\t * @param {number} index - The index.\n\t * @return {string} The loop variable name.\n\t */\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt( 0 ) + index );\n\n\t}\n\n\t/**\n\t * Returns properties about this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Object} The node properties.\n\t */\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack(); // TODO: cache() it\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, builder );\n\t\tproperties.stackNode = stack;\n\n\t\tconst baseParam = this.params[ 0 ];\n\n\t\tif ( baseParam.isNode !== true && typeof baseParam.update === 'function' ) {\n\n\t\t\tproperties.updateNode = Fn( this.params[ 0 ].update )( inputs );\n\n\t\t}\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred based on the loop configuration.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet isWhile = false, start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\tif ( param.getNodeType( builder ) === 'bool' ) {\n\n\t\t\t\t\tisWhile = true;\n\t\t\t\t\ttype = 'bool';\n\t\t\t\t\tend = param.build( builder, type );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttype = 'int';\n\t\t\t\t\tname = this.getVarName( i );\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tend = param.build( builder, type );\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet loopSnippet;\n\n\t\t\tif ( isWhile ) {\n\n\t\t\t\tloopSnippet = `while ( ${ end } )`;\n\n\t\t\t} else {\n\n\t\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t\t//\n\n\t\t\t\tconst startSnippet = internalParam.start;\n\t\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\t\tlet updateSnippet;\n\n\t\t\t\tconst deltaOperator = () => condition.includes( '<' ) ? '+=' : '-=';\n\n\t\t\t\tif ( update !== undefined && update !== null ) {\n\n\t\t\t\t\tswitch ( typeof update ) {\n\n\t\t\t\t\t\tcase 'function':\n\n\t\t\t\t\t\t\tconst flow = builder.flowStagesNode( properties.updateNode, 'void' );\n\t\t\t\t\t\t\tconst snippet = flow.code.replace( /\\t|;/g, '' );\n\n\t\t\t\t\t\t\tupdateSnippet = snippet;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'number':\n\n\t\t\t\t\t\t\tupdateSnippet = name + ' ' + deltaOperator() + ' ' + builder.generateConst( type, update );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'string':\n\n\t\t\t\t\t\t\tupdateSnippet = name + ' ' + update;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( update.isNode ) {\n\n\t\t\t\t\t\t\t\tupdateSnippet = name + ' ' + deltaOperator() + ' ' + update.build( builder );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.TSL: \\'Loop( { update: ... } )\\' is not a function, string or number.' );\n\n\t\t\t\t\t\t\t\tupdateSnippet = 'break /* invalid update */';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\t\tupdate = condition.includes( '<' ) ? '++' : '--';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tupdate = deltaOperator() + ' 1.';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateSnippet = name + ' ' + update;\n\n\t\t\t\t}\n\n\t\t\t\tconst declarationSnippet = builder.getVar( type, name ) + ' = ' + startSnippet;\n\t\t\t\tconst conditionalSnippet = name + ' ' + condition + ' ' + endSnippet;\n\n\t\t\t\tloopSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\t}\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + loopSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\nexport default LoopNode;\n\n/**\n * TSL function for creating a loop node.\n *\n * @tsl\n * @function\n * @param {...any} params - A list of parameters.\n * @returns {LoopNode}\n */\nexport const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).toStack();\n\n/**\n * TSL function for creating a `Continue()` expression.\n *\n * @tsl\n * @function\n * @returns {ExpressionNode}\n */\nexport const Continue = () => expression( 'continue' ).toStack();\n\n/**\n * TSL function for creating a `Break()` expression.\n *\n * @tsl\n * @function\n * @returns {ExpressionNode}\n */\nexport const Break = () => expression( 'break' ).toStack();\n"],"mappings":"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","ignoreList":[]}