{"version":3,"file":"node_modules/three/src/nodes/utils/PostProcessingUtils.js","names":["abs","cross","float","Fn","normalize","ivec2","sub","vec2","vec3","vec4","textureSize","textureLoad","WebGPUCoordinateSystem","getViewPosition","screenPosition","depth","projectionMatrixInverse","builder","clipSpacePosition","renderer","coordinateSystem","x","y","oneMinus","mul","viewSpacePosition","xyz","div","w","getScreenPosition","viewPosition","projectionMatrix","sampleClipPos","sampleUv","xy","add","toVar","getNormalFromDepth","uv","depthTexture","size","p","c0","l2","l1","r1","r2","b2","b1","t1","t2","dl","dr","db","dt","ce","dpdx","lessThan","select","negate","dpdy"],"sources":["node_modules/three/src/nodes/utils/PostProcessingUtils.js"],"sourcesContent":["import { abs, cross, float, Fn, normalize, ivec2, sub, vec2, vec3, vec4 } from '../tsl/TSLBase.js';\nimport { textureSize } from '../accessors/TextureSizeNode.js';\nimport { textureLoad } from '../accessors/TextureNode.js';\nimport { WebGPUCoordinateSystem } from '../../constants.js';\n\n/**\n * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n * depth value and the camera's inverse projection matrix.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.\n * @param {Node<float>} depth - The fragment's depth value.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The fragments position in view space.\n */\nexport const getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n * Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n * and the camera's projection matrix\n *\n * @tsl\n * @function\n * @param {Node<vec3>} viewPosition - The fragments position in view space.\n * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.\n * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.\n */\nexport const getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n * Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n * target is available or if flat surface normals are required.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The texture coordinate.\n * @param {DepthTexture} depthTexture - The depth texture.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The computed normal vector.\n */\nexport const getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n"],"mappings":"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","ignoreList":[]}