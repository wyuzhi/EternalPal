{"version":3,"file":"node_modules/three/src/nodes/utils/RTTNode.js","names":["nodeObject","TextureNode","NodeUpdateType","uv","NodeMaterial","QuadMesh","RenderTarget","Vector2","HalfFloatType","_size","RTTNode","type","constructor","node","width","height","options","renderTarget","super","texture","this","isRTTNode","pixelRatio","textureNeedsUpdate","autoUpdate","_rttNode","_quadMesh","updateBeforeType","RENDER","autoResize","setup","builder","context","getSharedContext","material","name","needsUpdate","setSize","effectiveWidth","effectiveHeight","setPixelRatio","updateBefore","renderer","getPixelRatio","size","getSize","fragmentNode","currentRenderTarget","getRenderTarget","setRenderTarget","render","clone","newNode","value","uvNode","levelNode","sampler","referenceNode","rtt","params","convertToTexture","isTextureNode","isPassNode","getTextureNode"],"sources":["node_modules/three/src/nodes/utils/RTTNode.js"],"sourcesContent":["import { nodeObject } from '../tsl/TSLCore.js';\nimport TextureNode from '../accessors/TextureNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uv } from '../accessors/UV.js';\nimport NodeMaterial from '../../materials/nodes/NodeMaterial.js';\nimport QuadMesh from '../../renderers/common/QuadMesh.js';\n\nimport { RenderTarget } from '../../core/RenderTarget.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { HalfFloatType } from '../../constants.js';\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).\n * This module is especially relevant in context of post processing where certain nodes require\n * texture input for their effects. With the helper function `convertToTexture()` which is based\n * on this module, the node system can automatically ensure texture input if required.\n *\n * @augments TextureNode\n */\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new RTT node.\n\t *\n\t * @param {Node} node - The node to render a texture with.\n\t * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n\t * @param {?number} [height=null] - The height of the internal render target.\n\t * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n\t */\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv() );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRTTNode = true;\n\n\t\t/**\n\t\t * The node to render a texture with.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The width of the internal render target.\n\t\t * If not width is applied, the render target is automatically resized.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.width = width;\n\n\t\t/**\n\t\t * The height of the internal render target.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.height = height;\n\n\t\t/**\n\t\t * The pixel ratio\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.pixelRatio = 1;\n\n\t\t/**\n\t\t * The render target\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * Whether the texture requires an update or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.textureNeedsUpdate = true;\n\n\t\t/**\n\t\t * Whether the texture should automatically be updated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoUpdate = true;\n\n\t\t/**\n\t\t * The node which is used with the quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._rttNode = null;\n\n\t\t/**\n\t\t * The internal quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link RTTNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Whether the internal render target should automatically be resized or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget autoResize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Sets the size of the internal render target\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The width to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio. This will also resize the render target.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoResize === true ) {\n\n\t\t\tconst pixelRatio = renderer.getPixelRatio();\n\t\t\tconst size = renderer.getSize( _size );\n\n\t\t\tconst effectiveWidth = size.width * pixelRatio;\n\t\t\tconst effectiveHeight = size.height * pixelRatio;\n\n\t\t\tif ( effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height ) {\n\n\t\t\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\t\t\tthis.textureNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default RTTNode;\n\n/**\n * TSL function for creating a RTT node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {?number} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nexport const rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\n/**\n * TSL function for converting nodes to textures nodes.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {?number} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nexport const convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n"],"mappings":"OAASA,eAAkB,2BACpBC,gBAAiB,qCACfC,mBAAsB,8BACtBC,OAAU,4BACZC,iBAAkB,+CAClBC,aAAc,4CAEZC,iBAAoB,oCACpBC,YAAe,+BACfC,kBAAqB,qBAE9B,MAAMC,MAAsB,IAAIF,QAUhC,MAAMG,gBAAgBT,YAErB,eAAWU,GAEV,MAAO,SAER,CAUA,WAAAC,CAAaC,EAAMC,EAAQ,KAAMC,EAAS,KAAMC,EAAU,CAAEL,KAAMH,gBAEjE,MAAMS,EAAe,IAAIX,aAAcQ,EAAOC,EAAQC,GAEtDE,MAAOD,EAAaE,QAAShB,MAS7BiB,KAAKC,WAAY,EAOjBD,KAAKP,KAAOA,EASZO,KAAKN,MAAQA,EAQbM,KAAKL,OAASA,EAQdK,KAAKE,WAAa,EAOlBF,KAAKH,aAAeA,EAQpBG,KAAKG,oBAAqB,EAQ1BH,KAAKI,YAAa,EASlBJ,KAAKK,SAAW,KAQhBL,KAAKM,UAAY,IAAIrB,SAAU,IAAID,cASnCgB,KAAKO,iBAAmBzB,eAAe0B,MAExC,CASA,cAAIC,GAEH,OAAsB,OAAfT,KAAKN,KAEb,CAEA,KAAAgB,CAAOC,GAMN,OAJAX,KAAKK,SAAWL,KAAKP,KAAKmB,QAASD,EAAQE,oBAC3Cb,KAAKM,UAAUQ,SAASC,KAAO,MAC/Bf,KAAKM,UAAUQ,SAASE,aAAc,EAE/BlB,MAAMY,MAAOC,EAErB,CAQA,OAAAM,CAASvB,EAAOC,GAEfK,KAAKN,MAAQA,EACbM,KAAKL,OAASA,EAEd,MAAMuB,EAAiBxB,EAAQM,KAAKE,WAC9BiB,EAAkBxB,EAASK,KAAKE,WAEtCF,KAAKH,aAAaoB,QAASC,EAAgBC,GAE3CnB,KAAKG,oBAAqB,CAE3B,CAOA,aAAAiB,CAAelB,GAEdF,KAAKE,WAAaA,EAElBF,KAAKiB,QAASjB,KAAKN,MAAOM,KAAKL,OAEhC,CAEA,YAAA0B,EAAcC,SAAEA,IAEf,IAAiC,IAA5BtB,KAAKG,qBAAoD,IAApBH,KAAKI,WAAuB,OAMtE,GAJAJ,KAAKG,oBAAqB,GAID,IAApBH,KAAKS,WAAsB,CAE/B,MAAMP,EAAaoB,EAASC,gBACtBC,EAAOF,EAASG,QAASpC,OAEzB6B,EAAiBM,EAAK9B,MAAQQ,EAC9BiB,EAAkBK,EAAK7B,OAASO,EAEjCgB,IAAmBlB,KAAKH,aAAaH,OAASyB,IAAoBnB,KAAKH,aAAaF,SAExFK,KAAKH,aAAaoB,QAASC,EAAgBC,GAE3CnB,KAAKG,oBAAqB,EAI5B,CAIAH,KAAKM,UAAUQ,SAASY,aAAe1B,KAAKK,SAI5C,MAAMsB,EAAsBL,EAASM,kBAErCN,EAASO,gBAAiB7B,KAAKH,cAE/BG,KAAKM,UAAUwB,OAAQR,GAEvBA,EAASO,gBAAiBF,EAE3B,CAEA,KAAAI,GAEC,MAAMC,EAAU,IAAInD,YAAamB,KAAKiC,MAAOjC,KAAKkC,OAAQlC,KAAKmC,WAI/D,OAHAH,EAAQI,QAAUpC,KAAKoC,QACvBJ,EAAQK,cAAgBrC,KAEjBgC,CAER,iBAIc1C,eAaR,MAAMgD,IAAM,CAAE7C,KAAS8C,IAAY3D,WAAY,IAAIU,QAASV,WAAYa,MAAW8C,WAanF,MAAMC,iBAAmB,CAAE/C,KAAS8C,IAErC9C,EAAKgD,cAAuBhD,EAC5BA,EAAKiD,WAAoBjD,EAAKkD,iBAE5BL,IAAK7C,KAAS8C","ignoreList":[]}