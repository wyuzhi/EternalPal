import Node from"../core/Node.js";import TextureNode from"../accessors/TextureNode.js";import{nodeObject}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{screenUV}from"../display/ScreenNode.js";import{HalfFloatType,LinearMipMapLinearFilter,WebGPUCoordinateSystem}from"../../constants.js";import{Plane}from"../../math/Plane.js";import{Object3D}from"../../core/Object3D.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";import{Matrix4}from"../../math/Matrix4.js";import{RenderTarget}from"../../core/RenderTarget.js";import{DepthTexture}from"../../textures/DepthTexture.js";const _reflectorPlane=new Plane,_normal=new Vector3,_reflectorWorldPosition=new Vector3,_cameraWorldPosition=new Vector3,_rotationMatrix=new Matrix4,_lookAtPosition=new Vector3(0,0,-1),clipPlane=new Vector4,_view=new Vector3,_target=new Vector3,_q=new Vector4,_size=new Vector2,_defaultRT=new RenderTarget,_defaultUV=screenUV.flipX();_defaultRT.depthTexture=new DepthTexture(1,1);let _inReflector=!1;class ReflectorNode extends TextureNode{static get type(){return"ReflectorNode"}constructor(e={}){super(e.defaultTexture||_defaultRT.texture,_defaultUV),this._reflectorBaseNode=e.reflector||new ReflectorBaseNode(this,e),this._depthNode=null,this.setUpdateMatrix(!1)}get reflector(){return this._reflectorBaseNode}get target(){return this._reflectorBaseNode.target}getDepthNode(){if(null===this._depthNode){if(!0!==this._reflectorBaseNode.depth)throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");this._depthNode=nodeObject(new ReflectorNode({defaultTexture:_defaultRT.depthTexture,reflector:this._reflectorBaseNode}))}return this._depthNode}setup(e){return e.object.isQuadMesh||this._reflectorBaseNode.build(e),super.setup(e)}clone(){const e=new this.constructor(this.reflectorNode);return e.uvNode=this.uvNode,e.levelNode=this.levelNode,e.biasNode=this.biasNode,e.sampler=this.sampler,e.depthNode=this.depthNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e._reflectorBaseNode=this._reflectorBaseNode,e}dispose(){super.dispose(),this._reflectorBaseNode.dispose()}}class ReflectorBaseNode extends Node{static get type(){return"ReflectorBaseNode"}constructor(e,t={}){super();const{target:r=new Object3D,resolution:o=1,generateMipmaps:a=!1,bounces:i=!0,depth:s=!1}=t;this.textureNode=e,this.target=r,this.resolution=o,this.generateMipmaps=a,this.bounces=i,this.depth=s,this.updateBeforeType=i?NodeUpdateType.RENDER:NodeUpdateType.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new Map,this.forceUpdate=!1,this.hasOutput=!1}_updateResolution(e,t){const r=this.resolution;t.getDrawingBufferSize(_size),e.setSize(Math.round(_size.width*r),Math.round(_size.height*r))}setup(e){return this._updateResolution(_defaultRT,e.renderer),super.setup(e)}dispose(){super.dispose();for(const e of this.renderTargets.values())e.dispose()}getVirtualCamera(e){let t=this.virtualCameras.get(e);return void 0===t&&(t=e.clone(),this.virtualCameras.set(e,t)),t}getRenderTarget(e){let t=this.renderTargets.get(e);return void 0===t&&(t=new RenderTarget(0,0,{type:HalfFloatType}),!0===this.generateMipmaps&&(t.texture.minFilter=LinearMipMapLinearFilter,t.texture.generateMipmaps=!0),!0===this.depth&&(t.depthTexture=new DepthTexture),this.renderTargets.set(e,t)),t}updateBefore(e){if(!1===this.bounces&&_inReflector)return!1;_inReflector=!0;const{scene:t,camera:r,renderer:o,material:a}=e,{target:i}=this,s=this.getVirtualCamera(r),n=this.getRenderTarget(s);o.getDrawingBufferSize(_size),this._updateResolution(n,o),_reflectorWorldPosition.setFromMatrixPosition(i.matrixWorld),_cameraWorldPosition.setFromMatrixPosition(r.matrixWorld),_rotationMatrix.extractRotation(i.matrixWorld),_normal.set(0,0,1),_normal.applyMatrix4(_rotationMatrix),_view.subVectors(_reflectorWorldPosition,_cameraWorldPosition);let l=!1;if(!0===_view.dot(_normal)>0&&!1===this.forceUpdate){if(!1===this.hasOutput)return void(_inReflector=!1);l=!0}_view.reflect(_normal).negate(),_view.add(_reflectorWorldPosition),_rotationMatrix.extractRotation(r.matrixWorld),_lookAtPosition.set(0,0,-1),_lookAtPosition.applyMatrix4(_rotationMatrix),_lookAtPosition.add(_cameraWorldPosition),_target.subVectors(_reflectorWorldPosition,_lookAtPosition),_target.reflect(_normal).negate(),_target.add(_reflectorWorldPosition),s.coordinateSystem=r.coordinateSystem,s.position.copy(_view),s.up.set(0,1,0),s.up.applyMatrix4(_rotationMatrix),s.up.reflect(_normal),s.lookAt(_target),s.near=r.near,s.far=r.far,s.updateMatrixWorld(),s.projectionMatrix.copy(r.projectionMatrix),_reflectorPlane.setFromNormalAndCoplanarPoint(_normal,_reflectorWorldPosition),_reflectorPlane.applyMatrix4(s.matrixWorldInverse),clipPlane.set(_reflectorPlane.normal.x,_reflectorPlane.normal.y,_reflectorPlane.normal.z,_reflectorPlane.constant);const d=s.projectionMatrix;_q.x=(Math.sign(clipPlane.x)+d.elements[8])/d.elements[0],_q.y=(Math.sign(clipPlane.y)+d.elements[9])/d.elements[5],_q.z=-1,_q.w=(1+d.elements[10])/d.elements[14],clipPlane.multiplyScalar(1/clipPlane.dot(_q));d.elements[2]=clipPlane.x,d.elements[6]=clipPlane.y,d.elements[10]=o.coordinateSystem===WebGPUCoordinateSystem?clipPlane.z-0:clipPlane.z+1-0,d.elements[14]=clipPlane.w,this.textureNode.value=n.texture,!0===this.depth&&(this.textureNode.getDepthNode().value=n.depthTexture),a.visible=!1;const c=o.getRenderTarget(),p=o.getMRT(),u=o.autoClear;o.setMRT(null),o.setRenderTarget(n),o.autoClear=!0,l?(o.clear(),this.hasOutput=!1):(o.render(t,s),this.hasOutput=!0),o.setMRT(p),o.setRenderTarget(c),o.autoClear=u,a.visible=!0,_inReflector=!1,this.forceUpdate=!1}}export const reflector=e=>nodeObject(new ReflectorNode(e));export default ReflectorNode;
//# sourceMappingURL=ReflectorNode.js.map