{"version":3,"file":"node_modules/three/src/nodes/utils/ReflectorNode.js","names":["Node","TextureNode","nodeObject","NodeUpdateType","screenUV","HalfFloatType","LinearMipMapLinearFilter","WebGPUCoordinateSystem","Plane","Object3D","Vector2","Vector3","Vector4","Matrix4","RenderTarget","DepthTexture","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size","_defaultRT","_defaultUV","flipX","depthTexture","_inReflector","ReflectorNode","type","constructor","parameters","super","defaultTexture","texture","this","_reflectorBaseNode","reflector","ReflectorBaseNode","_depthNode","setUpdateMatrix","target","getDepthNode","depth","Error","setup","builder","object","isQuadMesh","build","clone","newNode","reflectorNode","uvNode","levelNode","biasNode","sampler","depthNode","compareNode","gradNode","dispose","textureNode","resolution","generateMipmaps","bounces","updateBeforeType","RENDER","FRAME","virtualCameras","WeakMap","renderTargets","Map","forceUpdate","hasOutput","_updateResolution","renderTarget","renderer","getDrawingBufferSize","setSize","Math","round","width","height","values","getVirtualCamera","camera","virtualCamera","get","undefined","set","getRenderTarget","minFilter","updateBefore","frame","scene","material","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","needsClear","dot","reflect","negate","add","coordinateSystem","position","copy","up","lookAt","near","far","updateMatrixWorld","projectionMatrix","setFromNormalAndCoplanarPoint","matrixWorldInverse","normal","x","y","z","constant","sign","elements","w","multiplyScalar","value","visible","currentRenderTarget","currentMRT","getMRT","currentAutoClear","autoClear","setMRT","setRenderTarget","clear","render"],"sources":["node_modules/three/src/nodes/utils/ReflectorNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { screenUV } from '../display/ScreenNode.js';\n\nimport { HalfFloatType, LinearMipMapLinearFilter, WebGPUCoordinateSystem } from '../../constants.js';\nimport { Plane } from '../../math/Plane.js';\nimport { Object3D } from '../../core/Object3D.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { RenderTarget } from '../../core/RenderTarget.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\n/**\n * This node can be used to implement mirror-like flat reflective surfaces.\n *\n * ```js\n * const groundReflector = reflector();\n * material.colorNode = groundReflector;\n *\n * const plane = new Mesh( geometry, material );\n * plane.add( groundReflector.target );\n * ```\n *\n * @augments TextureNode\n */\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector node.\n\t *\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {number} [parameters.resolution=1] - The resolution scale.\n\t * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n\t * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\t/**\n\t\t * A reference to the internal reflector base node which holds the actual implementation.\n\t\t *\n\t\t * @private\n\t\t * @type {ReflectorBaseNode}\n\t\t * @default ReflectorBaseNode\n\t\t */\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\n\t\t/**\n\t\t * A reference to the internal depth node.\n\t\t *\n\t\t * @private\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\t/**\n\t * A reference to the internal reflector node.\n\t *\n\t * @type {ReflectorBaseNode}\n\t */\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\t/**\n\t * A reference to 3D object the reflector is linked to.\n\t *\n\t * @type {Object3D}\n\t */\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\t/**\n\t * Returns a node representing the mirror's depth. That can be used\n\t * to implement more advanced reflection effects like distance attenuation.\n\t *\n\t * @return {Node} The depth node.\n\t */\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.reflectorNode );\n\t\tnewNode.uvNode = this.uvNode;\n\t\tnewNode.levelNode = this.levelNode;\n\t\tnewNode.biasNode = this.biasNode;\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\t\tnewNode._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn newNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis._reflectorBaseNode.dispose();\n\n\t}\n\n}\n\n/**\n * Holds the actual implementation of the reflector.\n *\n * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented\n * in `ReflectorNode`, see #29619.\n *\n * @private\n * @augments Node\n */\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector base node.\n\t *\n\t * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {number} [parameters.resolution=1] - The resolution scale.\n\t * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t */\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false\n\t\t} = parameters;\n\n\t\t/**\n\t\t * Represents the rendered reflections as a texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The 3D object the reflector is linked to.\n\t\t *\n\t\t * @type {Object3D}\n\t\t * @default {new Object3D()}\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * The resolution scale.\n\t\t *\n\t\t * @type {number}\n\t\t * @default {1}\n\t\t */\n\t\tthis.resolution = resolution;\n\n\t\t/**\n\t\t * Whether mipmaps should be generated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.generateMipmaps = generateMipmaps;\n\n\t\t/**\n\t\t * Whether reflectors can render other reflector nodes or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {true}\n\t\t */\n\t\tthis.bounces = bounces;\n\n\t\t/**\n\t\t * Whether depth data should be generated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}\n\t\t * is `true`. Otherwise it's `NodeUpdateType.FRAME`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Weak map for managing virtual cameras.\n\t\t *\n\t\t * @type {WeakMap<Camera, Camera>}\n\t\t */\n\t\tthis.virtualCameras = new WeakMap();\n\n\t\t/**\n\t\t * Weak map for managing render targets.\n\t\t *\n\t\t * @type {Map<Camera, RenderTarget>}\n\t\t */\n\t\tthis.renderTargets = new Map();\n\n\t\t/**\n\t\t * Force render even if reflector is facing away from camera.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.forceUpdate = false;\n\n\t\t/**\n\t\t * Whether the reflector has been rendered or not.\n\t\t *\n\t\t * When the reflector is facing away from the camera,\n\t\t * this flag is set to `false` and the texture will be empty(black).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.hasOutput = false;\n\n\t}\n\n\t/**\n\t * Updates the resolution of the internal render target.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target to resize.\n\t * @param {Renderer} renderer - The renderer that is used to determine the new size.\n\t */\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\trenderTarget.setSize( Math.round( _size.width * resolution ), Math.round( _size.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tfor ( const renderTarget of this.renderTargets.values() ) {\n\n\t\t\trenderTarget.dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a virtual camera for the given camera. The virtual camera is used to\n\t * render the scene from the reflector's view so correct reflections can be produced.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {Camera} The corresponding virtual camera.\n\t */\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\t/**\n\t * Returns a render target for the given camera. The reflections are rendered\n\t * into this render target.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {RenderTarget} The render target.\n\t */\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away unless forcing an update\n\t\tconst isFacingAway = _view.dot( _normal ) > 0;\n\n\t\tlet needsClear = false;\n\n\t\tif ( isFacingAway === true && this.forceUpdate === false ) {\n\n\t\t\tif ( this.hasOutput === false ) {\n\n\t\t\t\t_inReflector = false;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tneedsClear = true;\n\n\t\t}\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentAutoClear = renderer.autoClear;\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\n\t\tif ( needsClear ) {\n\n\t\t\trenderer.clear();\n\n\t\t\tthis.hasOutput = false;\n\n\t\t} else {\n\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\tthis.hasOutput = true;\n\n\t\t}\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t\tthis.forceUpdate = false;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reflector node.\n *\n * @tsl\n * @function\n * @param {Object} [parameters={}] - An object holding configuration parameters.\n * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n * @param {number} [parameters.resolution=1] - The resolution scale.\n * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n * @returns {ReflectorNode}\n */\nexport const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nexport default ReflectorNode;\n"],"mappings":"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","ignoreList":[]}