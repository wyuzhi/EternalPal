{"version":3,"file":"node_modules/three/src/nodes/utils/SplitNode.js","names":["Node","vectorComponents","_stringVectorComponents","join","SplitNode","type","constructor","node","components","super","this","isSplitNode","getVectorLength","vectorLength","length","c","Math","max","indexOf","getComponentType","builder","getNodeType","getTypeFromLength","generate","output","nodeTypeLength","getTypeLength","snippet","nodeSnippet","build","slice","format","serialize","data","deserialize"],"sources":["node_modules/three/src/nodes/utils/SplitNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport { vectorComponents } from '../core/constants.js';\n\nconst _stringVectorComponents = vectorComponents.join( '' );\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\t/**\n\t * Constructs a new split node.\n\t *\n\t * @param {Node} node - The node that should be accessed.\n\t * @param {string} [components='x'] - The components that should be accessed.\n\t */\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be accessed.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The components that should be accessed.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the requested components.\n\t *\n\t * @return {number} The vector length.\n\t */\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\t/**\n\t * Returns the component type of the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The component type.\n\t */\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from requested components.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nexport default SplitNode;\n"],"mappings":"OAAOA,SAAU,yBACRC,qBAAwB,uBAEjC,MAAMC,wBAA0BD,iBAAiBE,KAAM,IAavD,MAAMC,kBAAkBJ,KAEvB,eAAWK,GAEV,MAAO,WAER,CAQA,WAAAC,CAAaC,EAAMC,EAAa,KAE/BC,QAOAC,KAAKH,KAAOA,EAOZG,KAAKF,WAAaA,EASlBE,KAAKC,aAAc,CAEpB,CAOA,eAAAC,GAEC,IAAIC,EAAeH,KAAKF,WAAWM,OAEnC,IAAM,MAAMC,KAAKL,KAAKF,WAErBK,EAAeG,KAAKC,IAAKhB,iBAAiBiB,QAASH,GAAM,EAAGF,GAI7D,OAAOA,CAER,CAQA,gBAAAM,CAAkBC,GAEjB,OAAOA,EAAQD,iBAAkBT,KAAKH,KAAKc,YAAaD,GAEzD,CAQA,WAAAC,CAAaD,GAEZ,OAAOA,EAAQE,kBAAmBZ,KAAKF,WAAWM,OAAQJ,KAAKS,iBAAkBC,GAElF,CAEA,QAAAG,CAAUH,EAASI,GAElB,MAAMjB,EAAOG,KAAKH,KACZkB,EAAiBL,EAAQM,cAAenB,EAAKc,YAAaD,IAEhE,IAAIO,EAAU,KAEd,GAAKF,EAAiB,EAAI,CAEzB,IAAIpB,EAAO,KAEcK,KAAKE,mBAELa,IAIxBpB,EAAOe,EAAQE,kBAAmBZ,KAAKE,kBAAmBF,KAAKS,iBAAkBC,KAIlF,MAAMQ,EAAcrB,EAAKsB,MAAOT,EAASf,GAMxCsB,EAJIjB,KAAKF,WAAWM,SAAWW,GAAkBf,KAAKF,aAAeN,wBAAwB4B,MAAO,EAAGpB,KAAKF,WAAWM,QAI7GM,EAAQW,OAAQH,EAAavB,EAAMmB,GAInCJ,EAAQW,OAAQ,GAAGH,KAAelB,KAAKF,aAAcE,KAAKW,YAAaD,GAAWI,EAI9F,MAICG,EAAUpB,EAAKsB,MAAOT,EAASI,GAIhC,OAAOG,CAER,CAEA,SAAAK,CAAWC,GAEVxB,MAAMuB,UAAWC,GAEjBA,EAAKzB,WAAaE,KAAKF,UAExB,CAEA,WAAA0B,CAAaD,GAEZxB,MAAMyB,YAAaD,GAEnBvB,KAAKF,WAAayB,EAAKzB,UAExB,iBAIcJ","ignoreList":[]}