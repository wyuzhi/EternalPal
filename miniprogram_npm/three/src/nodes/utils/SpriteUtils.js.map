{"version":3,"file":"node_modules/three/src/nodes/utils/SpriteUtils.js","names":["modelWorldMatrix","cameraViewMatrix","cameraProjectionMatrix","positionLocal","Fn","defined","billboarding","position","horizontal","vertical","worldMatrix","toVar","x","y","z","modelViewMatrix","mul","length"],"sources":["node_modules/three/src/nodes/utils/SpriteUtils.js"],"sourcesContent":["import { modelWorldMatrix } from '../accessors/ModelNode.js';\nimport { cameraViewMatrix, cameraProjectionMatrix } from '../accessors/Camera.js';\nimport { positionLocal } from '../accessors/Position.js';\nimport { Fn, defined } from '../tsl/TSLBase.js';\n\n/**\n * This can be used to achieve a billboarding behavior for flat meshes. That means they are\n * oriented always towards the camera.\n *\n * ```js\n * material.vertexNode = billboarding();\n * ```\n *\n * @tsl\n * @function\n * @param {Object} config - The configuration object.\n * @param {?Node<vec3>} [config.position=null] - Can be used to define the vertex positions in world space.\n * @param {boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.\n * @param {boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.\n * @return {Node<vec3>} The updated vertex position in clip space.\n */\nexport const billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n"],"mappings":"OAASA,qBAAwB,mCACxBC,iBAAkBC,2BAA8B,gCAChDC,kBAAqB,kCACrBC,GAAIC,YAAe,2BAkBrB,MAAMC,aAA6BF,IAAI,EAAIG,WAAW,KAAMC,cAAa,EAAMC,YAAW,MAEhG,IAAIC,EAEc,OAAbH,GAEJG,EAAcV,iBAAiBW,QAC/BD,EAAa,GAAK,GAAMH,EAASK,EACjCF,EAAa,GAAK,GAAMH,EAASM,EACjCH,EAAa,GAAK,GAAMH,EAASO,GAIjCJ,EAAcV,iBAIf,MAAMe,EAAkBd,iBAAiBe,IAAKN,GAsB9C,OApBKL,QAASG,KAEbO,EAAiB,GAAK,GAAMf,iBAAkB,GAAIiB,SAClDF,EAAiB,GAAK,GAAM,EAC5BA,EAAiB,GAAK,GAAM,GAIxBV,QAASI,KAEbM,EAAiB,GAAK,GAAM,EAC5BA,EAAiB,GAAK,GAAMf,iBAAkB,GAAIiB,SAClDF,EAAiB,GAAK,GAAM,GAI7BA,EAAiB,GAAK,GAAM,EAC5BA,EAAiB,GAAK,GAAM,EAC5BA,EAAiB,GAAK,GAAM,EAErBb,uBAAuBc,IAAKD,GAAkBC,IAAKb,cAAe","ignoreList":[]}