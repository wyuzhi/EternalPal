{"version":3,"file":"node_modules/three/src/nodes/utils/TriplanarTextures.js","names":["add","normalLocal","positionLocal","texture","float","vec3","Fn","triplanarTextures","textureXNode","textureYNode","textureZNode","scaleNode","positionNode","normalNode","bf","abs","normalize","div","dot","tx","yz","mul","ty","zx","tz","xy","textureX","value","textureY","textureZ","cx","x","cy","y","cz","z","triplanarTexture","params"],"sources":["node_modules/three/src/nodes/utils/TriplanarTextures.js"],"sourcesContent":["import { add } from '../math/OperatorNode.js';\nimport { normalLocal } from '../accessors/Normal.js';\nimport { positionLocal } from '../accessors/Position.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { float, vec3, Fn } from '../tsl/TSLBase.js';\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * Can be used for triplanar texture mapping.\n *\n * ```js\n * material.colorNode = triplanarTexture( texture( diffuseMap ) );\n * ```\n *\n * @tsl\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node<float>} [scaleNode=float(1)] - The scale node.\n * @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.\n * @returns {Node<vec4>}\n */\nexport const triplanarTextures = /*@__PURE__*/ Fn( ( [ textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ] ) => {\n\n\t// Reference: https://github.com/keijiro/StandardTriplanar\n\n\t// Blending factor of triplanar mapping\n\tlet bf = normalNode.abs().normalize();\n\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t// Triplanar mapping\n\tconst tx = positionNode.yz.mul( scaleNode );\n\tconst ty = positionNode.zx.mul( scaleNode );\n\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t// Base color\n\tconst textureX = textureXNode.value;\n\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\tconst cx = texture( textureX, tx ).mul( bf.x );\n\tconst cy = texture( textureY, ty ).mul( bf.y );\n\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\treturn add( cx, cy, cz );\n\n} );\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @tsl\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node<float>} [scaleNode=float(1)] - The scale node.\n * @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.\n * @returns {Node<vec4>}\n */\nexport const triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n"],"mappings":"OAASA,QAAW,iCACXC,gBAAmB,gCACnBC,kBAAqB,kCACrBC,YAAe,qCACfC,MAAOC,KAAMC,OAAU,2BAqBzB,MAAMC,kBAAkCD,IAAI,EAAIE,EAAcC,EAAe,KAAMC,EAAe,KAAMC,EAAYP,MAAO,GAAKQ,EAAeV,cAAeW,EAAaZ,gBAKjL,IAAIa,EAAKD,EAAWE,MAAMC,YAC1BF,EAAKA,EAAGG,IAAKH,EAAGI,IAAKb,KAAM,KAG3B,MAAMc,EAAKP,EAAaQ,GAAGC,IAAKV,GAC1BW,EAAKV,EAAaW,GAAGF,IAAKV,GAC1Ba,EAAKZ,EAAaa,GAAGJ,IAAKV,GAG1Be,EAAWlB,EAAamB,MACxBC,EAA4B,OAAjBnB,EAAwBA,EAAakB,MAAQD,EACxDG,EAA4B,OAAjBnB,EAAwBA,EAAaiB,MAAQD,EAExDI,EAAK3B,QAASuB,EAAUP,GAAKE,IAAKP,EAAGiB,GACrCC,EAAK7B,QAASyB,EAAUN,GAAKD,IAAKP,EAAGmB,GACrCC,EAAK/B,QAAS0B,EAAUL,GAAKH,IAAKP,EAAGqB,GAE3C,OAAOnC,IAAK8B,EAAIE,EAAIE,EAAI,WAiBlB,MAAME,iBAAmB,IAAKC,IAAY9B,qBAAsB8B","ignoreList":[]}