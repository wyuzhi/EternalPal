import{BufferAttribute}from"../core/BufferAttribute.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{DataTexture}from"../textures/DataTexture.js";import{FloatType,RedIntegerFormat,UnsignedIntType,RGBAFormat}from"../constants.js";import{Matrix4}from"../math/Matrix4.js";import{Mesh}from"./Mesh.js";import{ColorManagement}from"../math/ColorManagement.js";import{Box3}from"../math/Box3.js";import{Sphere}from"../math/Sphere.js";import{Frustum}from"../math/Frustum.js";import{Vector3}from"../math/Vector3.js";import{Color}from"../math/Color.js";import{FrustumArray}from"../math/FrustumArray.js";function ascIdSort(t,e){return t-e}function sortOpaque(t,e){return t.z-e.z}function sortTransparent(t,e){return e.z-t.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,r,n){const i=this.pool,s=this.list;this.index>=i.length&&i.push({start:-1,count:-1,z:-1,index:-1});const o=i[this.index];s.push(o),this.index++,o.start=t,o.count=e,o.z=r,o.index=n}reset(){this.list.length=0,this.index=0}}const _matrix=new Matrix4,_whiteColor=new Color(1,1,1),_frustum=new Frustum,_frustumArray=new FrustumArray,_box=new Box3,_sphere=new Sphere,_vector=new Vector3,_forward=new Vector3,_temp=new Vector3,_renderList=new MultiDrawRenderList,_mesh=new Mesh,_batchIntersects=[];function copyAttributeData(t,e,r=0){const n=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const i=t.count;for(let s=0;s<i;s++)for(let i=0;i<n;i++)e.setComponent(s+r,i,t.getComponent(s,i))}else e.array.set(t.array,r*n);e.needsUpdate=!0}function copyArrayContents(t,e){if(t.constructor!==e.constructor){const r=Math.min(t.length,e.length);for(let n=0;n<r;n++)e[n]=t[n]}else{const r=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,r))}}class BatchedMesh extends Mesh{constructor(t,e,r=2*e,n){super(new BufferGeometry,n),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=r,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(4*this._maxInstanceCount);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4),r=new DataTexture(e,t,t,RGBAFormat,FloatType);this._matricesTexture=r}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),r=new DataTexture(e,t,t,RedIntegerFormat,UnsignedIntType);this._indirectTexture=r}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),r=new DataTexture(e,t,t,RGBAFormat,FloatType);r.colorSpace=ColorManagement.workingColorSpace,this._colorsTexture=r}_initializeGeometry(t){const e=this.geometry,r=this._maxVertexCount,n=this._maxIndexCount;if(!1===this._geometryInitialized){for(const n in t.attributes){const i=t.getAttribute(n),{array:s,itemSize:o,normalized:a}=i,h=new s.constructor(r*o),u=new BufferAttribute(h,o,a);e.setAttribute(n,u)}if(null!==t.getIndex()){const t=r>65535?new Uint32Array(n):new Uint16Array(n);e.setIndex(new BufferAttribute(t,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(Boolean(t.getIndex())!==Boolean(e.getIndex()))throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const r in e.attributes){if(!t.hasAttribute(r))throw new Error(`THREE.BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);const n=t.getAttribute(r),i=e.getAttribute(r);if(n.itemSize!==i.itemSize||n.normalized!==i.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const e=this._instanceInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const e=this._geometryInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let r=0,n=e.length;r<n;r++){if(!1===e[r].active)continue;const n=e[r].geometryIndex;this.getMatrixAt(r,_matrix),this.getBoundingBoxAt(n,_box).applyMatrix4(_matrix),t.union(_box)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let r=0,n=e.length;r<n;r++){if(!1===e[r].active)continue;const n=e[r].geometryIndex;this.getMatrixAt(r,_matrix),this.getBoundingSphereAt(n,_sphere).applyMatrix4(_matrix),t.union(_sphere)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&0===this._availableInstanceIds.length)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const e={visible:!0,active:!0,geometryIndex:t};let r=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(ascIdSort),r=this._availableInstanceIds.shift(),this._instanceInfo[r]=e):(r=this._instanceInfo.length,this._instanceInfo.push(e));const n=this._matricesTexture;_matrix.identity().toArray(n.image.data,16*r),n.needsUpdate=!0;const i=this._colorsTexture;return i&&(_whiteColor.toArray(i.image.data,4*r),i.needsUpdate=!0),this._visibilityChanged=!0,r}addGeometry(t,e=-1,r=-1){this._initializeGeometry(t),this._validateGeometry(t);const n={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},i=this._geometryInfo;n.vertexStart=this._nextVertexStart,n.reservedVertexCount=-1===e?t.getAttribute("position").count:e;const s=t.getIndex();if(null!==s&&(n.indexStart=this._nextIndexStart,n.reservedIndexCount=-1===r?s.count:r),-1!==n.indexStart&&n.indexStart+n.reservedIndexCount>this._maxIndexCount||n.vertexStart+n.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let o;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(ascIdSort),o=this._availableGeometryIds.shift(),i[o]=n):(o=this._geometryCount,this._geometryCount++,i.push(n)),this.setGeometryAt(o,t),this._nextIndexStart=n.indexStart+n.reservedIndexCount,this._nextVertexStart=n.vertexStart+n.reservedVertexCount,o}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const r=this.geometry,n=null!==r.getIndex(),i=r.getIndex(),s=e.getIndex(),o=this._geometryInfo[t];if(n&&s.count>o.reservedIndexCount||e.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const a=o.vertexStart,h=o.reservedVertexCount;o.vertexCount=e.getAttribute("position").count;for(const t in r.attributes){const n=e.getAttribute(t),i=r.getAttribute(t);copyAttributeData(n,i,a);const s=n.itemSize;for(let t=n.count,e=h;t<e;t++){const e=a+t;for(let t=0;t<s;t++)i.setComponent(e,t,0)}i.needsUpdate=!0,i.addUpdateRange(a*s,h*s)}if(n){const t=o.indexStart,r=o.reservedIndexCount;o.indexCount=e.getIndex().count;for(let e=0;e<s.count;e++)i.setX(t+e,a+s.getX(e));for(let e=s.count,n=r;e<n;e++)i.setX(t+e,a);i.needsUpdate=!0,i.addUpdateRange(t,o.reservedIndexCount)}return o.start=n?o.indexStart:o.vertexStart,o.count=n?o.indexCount:o.vertexCount,o.boundingBox=null,null!==e.boundingBox&&(o.boundingBox=e.boundingBox.clone()),o.boundingSphere=null,null!==e.boundingSphere&&(o.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||!1===e[t].active)return this;const r=this._instanceInfo;for(let e=0,n=r.length;e<n;e++)r[e].active&&r[e].geometryIndex===t&&this.deleteInstance(e);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,e=0;const r=this._geometryInfo,n=r.map(((t,e)=>e)).sort(((t,e)=>r[t].vertexStart-r[e].vertexStart)),i=this.geometry;for(let s=0,o=r.length;s<o;s++){const o=n[s],a=r[o];if(!1!==a.active){if(null!==i.index){if(a.indexStart!==e){const{indexStart:r,vertexStart:n,reservedIndexCount:s}=a,o=i.index,h=o.array,u=t-n;for(let t=r;t<r+s;t++)h[t]=h[t]+u;o.array.copyWithin(e,r,r+s),o.addUpdateRange(e,s),a.indexStart=e}e+=a.reservedIndexCount}if(a.vertexStart!==t){const{vertexStart:e,reservedVertexCount:r}=a,n=i.attributes;for(const i in n){const s=n[i],{array:o,itemSize:a}=s;o.copyWithin(t*a,e*a,(e+r)*a),s.addUpdateRange(t*a,r*a)}a.vertexStart=t}t+=a.reservedVertexCount,a.start=i.index?a.indexStart:a.vertexStart,this._nextIndexStart=i.index?a.indexStart+a.reservedIndexCount:0,this._nextVertexStart=a.vertexStart+a.reservedVertexCount}}return this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const r=this.geometry,n=this._geometryInfo[t];if(null===n.boundingBox){const t=new Box3,e=r.index,i=r.attributes.position;for(let r=n.start,s=n.start+n.count;r<s;r++){let n=r;e&&(n=e.getX(n)),t.expandByPoint(_vector.fromBufferAttribute(i,n))}n.boundingBox=t}return e.copy(n.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const r=this.geometry,n=this._geometryInfo[t];if(null===n.boundingSphere){const e=new Sphere;this.getBoundingBoxAt(t,_box),_box.getCenter(e.center);const i=r.index,s=r.attributes.position;let o=0;for(let t=n.start,r=n.start+n.count;t<r;t++){let r=t;i&&(r=i.getX(r)),_vector.fromBufferAttribute(s,r),o=Math.max(o,e.center.distanceToSquared(_vector))}e.radius=Math.sqrt(o),n.boundingSphere=e}return e.copy(n.boundingSphere),e}setMatrixAt(t,e){this.validateInstanceId(t);const r=this._matricesTexture,n=this._matricesTexture.image.data;return e.toArray(n,16*t),r.needsUpdate=!0,this}getMatrixAt(t,e){return this.validateInstanceId(t),e.fromArray(this._matricesTexture.image.data,16*t)}setColorAt(t,e){return this.validateInstanceId(t),null===this._colorsTexture&&this._initColorsTexture(),e.toArray(this._colorsTexture.image.data,4*t),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,e){return this.validateInstanceId(t),e.fromArray(this._colorsTexture.image.data,4*t)}setVisibleAt(t,e){return this.validateInstanceId(t),this._instanceInfo[t].visible===e||(this._instanceInfo[t].visible=e,this._visibilityChanged=!0),this}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,e){return this.validateInstanceId(t),this.validateGeometryId(e),this._instanceInfo[t].geometryIndex=e,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,e={}){this.validateGeometryId(t);const r=this._geometryInfo[t];return e.vertexStart=r.vertexStart,e.vertexCount=r.vertexCount,e.reservedVertexCount=r.reservedVertexCount,e.indexStart=r.indexStart,e.indexCount=r.indexCount,e.reservedIndexCount=r.reservedIndexCount,e.start=r.start,e.count=r.count,e}setInstanceCount(t){const e=this._availableInstanceIds,r=this._instanceInfo;for(e.sort(ascIdSort);e[e.length-1]===r.length-1;)r.pop(),e.pop();if(t<r.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const n=new Int32Array(t),i=new Int32Array(t);copyArrayContents(this._multiDrawCounts,n),copyArrayContents(this._multiDrawStarts,i),this._multiDrawCounts=n,this._multiDrawStarts=i,this._maxInstanceCount=t;const s=this._indirectTexture,o=this._matricesTexture,a=this._colorsTexture;s.dispose(),this._initIndirectTexture(),copyArrayContents(s.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),copyArrayContents(o.image.data,this._matricesTexture.image.data),a&&(a.dispose(),this._initColorsTexture(),copyArrayContents(a.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const r=[...this._geometryInfo].filter((t=>t.active));if(Math.max(...r.map((t=>t.vertexStart+t.reservedVertexCount)))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index){if(Math.max(...r.map((t=>t.indexStart+t.reservedIndexCount)))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`)}const n=this.geometry;n.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new BufferGeometry,this._initializeGeometry(n));const i=this.geometry;n.index&&copyArrayContents(n.index.array,i.index.array);for(const t in n.attributes)copyArrayContents(n.attributes[t].array,i.attributes[t].array)}raycast(t,e){const r=this._instanceInfo,n=this._geometryInfo,i=this.matrixWorld,s=this.geometry;_mesh.material=this.material,_mesh.geometry.index=s.index,_mesh.geometry.attributes=s.attributes,null===_mesh.geometry.boundingBox&&(_mesh.geometry.boundingBox=new Box3),null===_mesh.geometry.boundingSphere&&(_mesh.geometry.boundingSphere=new Sphere);for(let s=0,o=r.length;s<o;s++){if(!r[s].visible||!r[s].active)continue;const o=r[s].geometryIndex,a=n[o];_mesh.geometry.setDrawRange(a.start,a.count),this.getMatrixAt(s,_mesh.matrixWorld).premultiply(i),this.getBoundingBoxAt(o,_mesh.geometry.boundingBox),this.getBoundingSphereAt(o,_mesh.geometry.boundingSphere),_mesh.raycast(t,_batchIntersects);for(let t=0,r=_batchIntersects.length;t<r;t++){const r=_batchIntersects[t];r.object=this,r.batchId=s,e.push(r)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=null!==t.boundingBox?t.boundingBox.clone():null,this.boundingSphere=null!==t.boundingSphere?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map((t=>({...t,boundingBox:null!==t.boundingBox?t.boundingBox.clone():null,boundingSphere:null!==t.boundingSphere?t.boundingSphere.clone():null}))),this._instanceInfo=t._instanceInfo.map((t=>({...t}))),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),null!==this._colorsTexture&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,null!==this._colorsTexture&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,e,r,n,i){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const s=n.getIndex(),o=null===s?1:s.array.BYTES_PER_ELEMENT,a=this._instanceInfo,h=this._multiDrawStarts,u=this._multiDrawCounts,d=this._geometryInfo,l=this.perObjectFrustumCulled,c=this._indirectTexture,m=c.image.data,x=r.isArrayCamera?_frustumArray:_frustum;l&&!r.isArrayCamera&&(_matrix.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse).multiply(this.matrixWorld),_frustum.setFromProjectionMatrix(_matrix,r.coordinateSystem,r.reversedDepth));let _=0;if(this.sortObjects){_matrix.copy(this.matrixWorld).invert(),_vector.setFromMatrixPosition(r.matrixWorld).applyMatrix4(_matrix),_forward.set(0,0,-1).transformDirection(r.matrixWorld).transformDirection(_matrix);for(let t=0,e=a.length;t<e;t++)if(a[t].visible&&a[t].active){const e=a[t].geometryIndex;this.getMatrixAt(t,_matrix),this.getBoundingSphereAt(e,_sphere).applyMatrix4(_matrix);let n=!1;if(l&&(n=!x.intersectsSphere(_sphere,r)),!n){const r=d[e],n=_temp.subVectors(_sphere.center,_vector).dot(_forward);_renderList.push(r.start,r.count,n,t)}}const t=_renderList.list,e=this.customSort;null===e?t.sort(i.transparent?sortTransparent:sortOpaque):e.call(this,t,r);for(let e=0,r=t.length;e<r;e++){const r=t[e];h[_]=r.start*o,u[_]=r.count,m[_]=r.index,_++}_renderList.reset()}else for(let t=0,e=a.length;t<e;t++)if(a[t].visible&&a[t].active){const e=a[t].geometryIndex;let n=!1;if(l&&(this.getMatrixAt(t,_matrix),this.getBoundingSphereAt(e,_sphere).applyMatrix4(_matrix),n=!x.intersectsSphere(_sphere,r)),!n){const r=d[e];h[_]=r.start*o,u[_]=r.count,m[_]=t,_++}}c.needsUpdate=!0,this._multiDrawCount=_,this._visibilityChanged=!1}onBeforeShadow(t,e,r,n,i,s){this.onBeforeRender(t,null,n,i,s)}}export{BatchedMesh};
//# sourceMappingURL=BatchedMesh.js.map