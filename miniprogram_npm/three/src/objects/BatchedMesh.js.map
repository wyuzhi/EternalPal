{"version":3,"file":"node_modules/three/src/objects/BatchedMesh.js","names":["BufferAttribute","BufferGeometry","DataTexture","FloatType","RedIntegerFormat","UnsignedIntType","RGBAFormat","Matrix4","Mesh","ColorManagement","Box3","Sphere","Frustum","Vector3","Color","FrustumArray","ascIdSort","a","b","sortOpaque","z","sortTransparent","MultiDrawRenderList","constructor","this","index","pool","list","push","start","count","length","item","reset","_matrix","_whiteColor","_frustum","_frustumArray","_box","_sphere","_vector","_forward","_temp","_renderList","_mesh","_batchIntersects","copyAttributeData","src","target","targetOffset","itemSize","isInterleavedBufferAttribute","array","vertexCount","i","c","setComponent","getComponent","set","needsUpdate","copyArrayContents","len","Math","min","buffer","BatchedMesh","maxInstanceCount","maxVertexCount","maxIndexCount","material","super","isBatchedMesh","perObjectFrustumCulled","sortObjects","boundingBox","boundingSphere","customSort","_instanceInfo","_geometryInfo","_availableInstanceIds","_availableGeometryIds","_nextIndexStart","_nextVertexStart","_geometryCount","_visibilityChanged","_geometryInitialized","_maxInstanceCount","_maxVertexCount","_maxIndexCount","_multiDrawCounts","Int32Array","_multiDrawStarts","_multiDrawCount","_multiDrawInstances","_matricesTexture","_indirectTexture","_colorsTexture","_initMatricesTexture","_initIndirectTexture","instanceCount","unusedVertexCount","unusedIndexCount","size","sqrt","ceil","max","matricesArray","Float32Array","matricesTexture","indirectArray","Uint32Array","indirectTexture","_initColorsTexture","colorsArray","fill","colorsTexture","colorSpace","workingColorSpace","_initializeGeometry","reference","geometry","attributeName","attributes","srcAttribute","getAttribute","normalized","dstArray","dstAttribute","setAttribute","getIndex","indexArray","Uint16Array","setIndex","_validateGeometry","batchGeometry","Boolean","Error","hasAttribute","validateInstanceId","instanceId","instanceInfo","active","validateGeometryId","geometryId","geometryInfoList","setCustomSort","func","computeBoundingBox","makeEmpty","l","geometryIndex","getMatrixAt","getBoundingBoxAt","applyMatrix4","union","computeBoundingSphere","getBoundingSphereAt","addInstance","visible","drawId","sort","shift","identity","toArray","image","data","addGeometry","reservedVertexCount","reservedIndexCount","geometryInfo","vertexStart","indexStart","indexCount","setGeometryAt","hasIndex","dstIndex","srcIndex","position","addUpdateRange","setX","getX","clone","deleteGeometry","deleteInstance","optimize","nextVertexStart","nextIndexStart","indices","map","e","elementDelta","j","copyWithin","key","attribute","box","iv","expandByPoint","fromBufferAttribute","copy","sphere","getCenter","center","maxRadiusSq","distanceToSquared","radius","setMatrixAt","matrix","fromArray","setColorAt","color","getColorAt","setVisibleAt","getVisibleAt","setGeometryIdAt","getGeometryIdAt","getGeometryRangeAt","setInstanceCount","availableInstanceIds","pop","multiDrawCounts","multiDrawStarts","dispose","setGeometrySize","validRanges","filter","info","range","oldGeometry","raycast","raycaster","intersects","matrixWorld","setDrawRange","premultiply","intersect","object","batchId","Infinity","source","slice","onBeforeRender","renderer","scene","camera","bytesPerElement","BYTES_PER_ELEMENT","frustum","isArrayCamera","multiplyMatrices","projectionMatrix","matrixWorldInverse","multiply","setFromProjectionMatrix","coordinateSystem","reversedDepth","multiDrawCount","invert","setFromMatrixPosition","transformDirection","culled","intersectsSphere","subVectors","dot","transparent","call","onBeforeShadow","shadowCamera","depthMaterial"],"sources":["node_modules/three/src/objects/BatchedMesh.js"],"sourcesContent":["import { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { FloatType, RedIntegerFormat, UnsignedIntType, RGBAFormat } from '../constants.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Mesh } from './Mesh.js';\nimport { ColorManagement } from '../math/ColorManagement.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { FrustumArray } from '../math/FrustumArray.js';\n\nfunction ascIdSort( a, b ) {\n\n\treturn a - b;\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( start, count, z, index ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\t\t\t\tindex: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = start;\n\t\titem.count = count;\n\t\titem.z = z;\n\t\titem.index = index;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _frustumArray = /*@__PURE__*/ new FrustumArray();\nconst _box = /*@__PURE__*/ new Box3();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _forward = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = [];\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\n// safely copies array contents to a potentially smaller array\nfunction copyArrayContents( src, target ) {\n\n\tif ( src.constructor !== target.constructor ) {\n\n\t\t// if arrays are of a different type (eg due to index size increasing) then data must be per-element copied\n\t\tconst len = Math.min( src.length, target.length );\n\t\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\t\ttarget[ i ] = src[ i ];\n\n\t\t}\n\n\t} else {\n\n\t\t// if the arrays use the same data layout we can use a fast block copy\n\t\tconst len = Math.min( src.length, target.length );\n\t\ttarget.set( new src.constructor( src.buffer, 0, len ) );\n\n\t}\n\n}\n\n/**\n * A special version of a mesh with multi draw batch rendering support. Use\n * this class if you have to render a large number of objects with the same\n * material but with different geometries or world transformations. The usage of\n * `BatchedMesh` will help you to reduce the number of draw calls and thus improve the overall\n * rendering performance in your application.\n *\n * ```js\n * const box = new THREE.BoxGeometry( 1, 1, 1 );\n * const sphere = new THREE.SphereGeometry( 1, 12, 12 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n *\n * // initialize and add geometries into the batched mesh\n * const batchedMesh = new BatchedMesh( 10, 5000, 10000, material );\n * const boxGeometryId = batchedMesh.addGeometry( box );\n * const sphereGeometryId = batchedMesh.addGeometry( sphere );\n *\n * // create instances of those geometries\n * const boxInstancedId1 = batchedMesh.addInstance( boxGeometryId );\n * const boxInstancedId2 = batchedMesh.addInstance( boxGeometryId );\n *\n * const sphereInstancedId1 = batchedMesh.addInstance( sphereGeometryId );\n * const sphereInstancedId2 = batchedMesh.addInstance( sphereGeometryId );\n *\n * // position the geometries\n * batchedMesh.setMatrixAt( boxInstancedId1, boxMatrix1 );\n * batchedMesh.setMatrixAt( boxInstancedId2, boxMatrix2 );\n *\n * batchedMesh.setMatrixAt( sphereInstancedId1, sphereMatrix1 );\n * batchedMesh.setMatrixAt( sphereInstancedId2, sphereMatrix2 );\n *\n * scene.add( batchedMesh );\n * ```\n *\n * @augments Mesh\n */\nclass BatchedMesh extends Mesh {\n\n\t/**\n\t * Constructs a new batched mesh.\n\t *\n\t * @param {number} maxInstanceCount - The maximum number of individual instances planned to be added and rendered.\n\t * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries.\n\t * @param {number} [maxIndexCount=maxVertexCount*2] - The maximum number of indices to be used by all unique geometries\n\t * @param {Material|Array<Material>} [material] - The mesh material.\n\t */\n\tconstructor( maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBatchedMesh = true;\n\n\t\t/**\n\t\t * When set ot `true`, the individual objects of a batch are frustum culled.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.perObjectFrustumCulled = true;\n\n\t\t/**\n\t\t * When set to `true`, the individual objects of a batch are sorted to improve overdraw-related artifacts.\n\t\t * If the material is marked as \"transparent\" objects are rendered back to front and if not then they are\n\t\t * rendered front to back.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t/**\n\t\t * The bounding box of the batched mesh. Can be computed via {@link BatchedMesh#computeBoundingBox}.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * The bounding sphere of the batched mesh. Can be computed via {@link BatchedMesh#computeBoundingSphere}.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Takes a sort a function that is run before render. The function takes a list of instances to\n\t\t * sort and a camera. The objects in the list include a \"z\" field to perform a depth-ordered\n\t\t * sort with.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.customSort = null;\n\n\t\t// stores visible, active, and geometry id per instance and reserved buffer ranges for geometries\n\t\tthis._instanceInfo = [];\n\t\tthis._geometryInfo = [];\n\n\t\t// instance, geometry ids that have been set as inactive, and are available to be overwritten\n\t\tthis._availableInstanceIds = [];\n\t\tthis._availableGeometryIds = [];\n\n\t\t// used to track where the next point is that geometry should be inserted\n\t\tthis._nextIndexStart = 0;\n\t\tthis._nextVertexStart = 0;\n\t\tthis._geometryCount = 0;\n\n\t\t// flags\n\t\tthis._visibilityChanged = true;\n\t\tthis._geometryInitialized = false;\n\n\t\t// cached user options\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\t// buffers for multi draw\n\t\tthis._multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\t\tthis._indirectTexture = null;\n\t\tthis._colorsTexture = null;\n\n\t\tthis._initMatricesTexture();\n\t\tthis._initIndirectTexture();\n\n\t}\n\n\t/**\n\t * The maximum number of individual instances that can be stored in the batch.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget maxInstanceCount() {\n\n\t\treturn this._maxInstanceCount;\n\n\t}\n\n\t/**\n\t * The instance count.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget instanceCount() {\n\n\t\treturn this._instanceInfo.length - this._availableInstanceIds.length;\n\n\t}\n\n\t/**\n\t * The number of unused vertices.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget unusedVertexCount() {\n\n\t\treturn this._maxVertexCount - this._nextVertexStart;\n\n\t}\n\n\t/**\n\t * The number of unused indices.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget unusedIndexCount() {\n\n\t\treturn this._maxIndexCount - this._nextIndexStart;\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initIndirectTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst indirectArray = new Uint32Array( size * size );\n\t\tconst indirectTexture = new DataTexture( indirectArray, size, size, RedIntegerFormat, UnsignedIntType );\n\n\t\tthis._indirectTexture = indirectTexture;\n\n\t}\n\n\t_initColorsTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\t// 4 floats per RGBA pixel initialized to white\n\t\tconst colorsArray = new Float32Array( size * size * 4 ).fill( 1 );\n\t\tconst colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );\n\t\tcolorsTexture.colorSpace = ColorManagement.workingColorSpace;\n\n\t\tthis._colorsTexture = colorsTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\t// Reserve last u16 index for primitive restart.\n\t\t\t\tconst indexArray = maxVertexCount > 65535\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `THREE.BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Validates the instance defined by the given ID.\n\t *\n\t * @param {number} instanceId - The instance to validate.\n\t */\n\tvalidateInstanceId( instanceId ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tif ( instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[ instanceId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Validates the geometry defined by the given ID.\n\t *\n\t * @param {number} geometryId - The geometry to validate.\n\t */\n\tvalidateGeometryId( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Takes a sort a function that is run before render. The function takes a list of instances to\n\t * sort and a camera. The objects in the list include a \"z\" field to perform a depth-ordered sort with.\n\t *\n\t * @param {Function} func - The custom sort function.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the bounding box, updating {@link BatchedMesh#boundingBox}.\n\t * Bounding boxes aren't computed by default. They need to be explicitly computed,\n\t * otherwise they are `null`.\n\t */\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix );\n\t\t\tthis.getBoundingBoxAt( geometryId, _box ).applyMatrix4( _matrix );\n\t\t\tboundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding sphere, updating {@link BatchedMesh#boundingSphere}.\n\t * Bounding spheres aren't computed by default. They need to be explicitly computed,\n\t * otherwise they are `null`.\n\t */\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix );\n\t\t\tthis.getBoundingSphereAt( geometryId, _sphere ).applyMatrix4( _matrix );\n\t\t\tboundingSphere.union( _sphere );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Adds a new instance to the batch using the geometry of the given ID and returns\n\t * a new id referring to the new instance to be used by other functions.\n\t *\n\t * @param {number} geometryId - The ID of a previously added geometry via {@link BatchedMesh#addGeometry}.\n\t * @return {number} The instance ID.\n\t */\n\taddInstance( geometryId ) {\n\n\t\tconst atCapacity = this._instanceInfo.length >= this.maxInstanceCount;\n\n\t\t// ensure we're not over geometry\n\t\tif ( atCapacity && this._availableInstanceIds.length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum item count reached.' );\n\n\t\t}\n\n\t\tconst instanceInfo = {\n\t\t\tvisible: true,\n\t\t\tactive: true,\n\t\t\tgeometryIndex: geometryId,\n\t\t};\n\n\t\tlet drawId = null;\n\n\t\t// Prioritize using previously freed instance ids\n\t\tif ( this._availableInstanceIds.length > 0 ) {\n\n\t\t\tthis._availableInstanceIds.sort( ascIdSort );\n\n\t\t\tdrawId = this._availableInstanceIds.shift();\n\t\t\tthis._instanceInfo[ drawId ] = instanceInfo;\n\n\t\t} else {\n\n\t\t\tdrawId = this._instanceInfo.length;\n\t\t\tthis._instanceInfo.push( instanceInfo );\n\n\t\t}\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\t_matrix.identity().toArray( matricesTexture.image.data, drawId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\tconst colorsTexture = this._colorsTexture;\n\t\tif ( colorsTexture ) {\n\n\t\t\t_whiteColor.toArray( colorsTexture.image.data, drawId * 4 );\n\t\t\tcolorsTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn drawId;\n\n\t}\n\n\t/**\n\t * Adds the given geometry to the batch and returns the associated\n\t * geometry id referring to it to be used in other functions.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to add.\n\t * @param {number} [reservedVertexCount=-1] - Optional parameter specifying the amount of\n\t * vertex buffer space to reserve for the added geometry. This is necessary if it is planned\n\t * to set a new geometry at this index at a later time that is larger than the original geometry.\n\t * Defaults to the length of the given geometry vertex buffer.\n\t * @param {number} [reservedIndexCount=-1] - Optional parameter specifying the amount of index\n\t * buffer space to reserve for the added geometry. This is necessary if it is planned to set a\n\t * new geometry at this index at a later time that is larger than the original geometry. Defaults to\n\t * the length of the given geometry index buffer.\n\t * @return {number} The geometry ID.\n\t */\n\taddGeometry( geometry, reservedVertexCount = - 1, reservedIndexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst geometryInfo = {\n\t\t\t// geometry information\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\treservedVertexCount: - 1,\n\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t\treservedIndexCount: - 1,\n\n\t\t\t// draw range information\n\t\t\tstart: - 1,\n\t\t\tcount: - 1,\n\n\t\t\t// state\n\t\t\tboundingBox: null,\n\t\t\tboundingSphere: null,\n\t\t\tactive: true,\n\t\t};\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tgeometryInfo.vertexStart = this._nextVertexStart;\n\t\tgeometryInfo.reservedVertexCount = reservedVertexCount === - 1 ? geometry.getAttribute( 'position' ).count : reservedVertexCount;\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tgeometryInfo.indexStart = this._nextIndexStart;\n\t\t\tgeometryInfo.reservedIndexCount = reservedIndexCount === - 1 ? index.count : reservedIndexCount;\n\n\t\t}\n\n\t\tif (\n\t\t\tgeometryInfo.indexStart !== - 1 &&\n\t\t\tgeometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||\n\t\t\tgeometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\t// update id\n\t\tlet geometryId;\n\t\tif ( this._availableGeometryIds.length > 0 ) {\n\n\t\t\tthis._availableGeometryIds.sort( ascIdSort );\n\n\t\t\tgeometryId = this._availableGeometryIds.shift();\n\t\t\tgeometryInfoList[ geometryId ] = geometryInfo;\n\n\n\t\t} else {\n\n\t\t\tgeometryId = this._geometryCount;\n\t\t\tthis._geometryCount ++;\n\t\t\tgeometryInfoList.push( geometryInfo );\n\n\t\t}\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\t// increment the next geometry position\n\t\tthis._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;\n\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\treturn geometryId;\n\n\t}\n\n\t/**\n\t * Replaces the geometry at the given ID with the provided geometry. Throws an error if there\n\t * is not enough space reserved for geometry. Calling this will change all instances that are\n\t * rendering that geometry.\n\t *\n\t * @param {number} geometryId - The ID of the geometry that should be replaced with the given geometry.\n\t * @param {BufferGeometry} geometry - The new geometry.\n\t * @return {number} The geometry ID.\n\t */\n\tsetGeometryAt( geometryId, geometry ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > geometryInfo.reservedIndexCount ||\n\t\t\tgeometry.attributes.position.count > geometryInfo.reservedVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry buffer data over\n\t\tconst vertexStart = geometryInfo.vertexStart;\n\t\tconst reservedVertexCount = geometryInfo.reservedVertexCount;\n\t\tgeometryInfo.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = reservedVertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = geometryInfo.indexStart;\n\t\t\tconst reservedIndexCount = geometryInfo.reservedIndexCount;\n\t\t\tgeometryInfo.indexCount = geometry.getIndex().count;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedIndexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, geometryInfo.reservedIndexCount );\n\n\t\t}\n\n\t\t// update the draw range\n\t\tgeometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\t\tgeometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;\n\n\t\t// store the bounding boxes\n\t\tgeometryInfo.boundingBox = null;\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tgeometryInfo.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tgeometryInfo.boundingSphere = null;\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tgeometryInfo.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn geometryId;\n\n\t}\n\n\t/**\n\t * Deletes the geometry defined by the given ID from this batch. Any instances referencing\n\t * this geometry will also be removed as a side effect.\n\t *\n\t * @param {number} geometryId - The ID of the geometry to remove from the batch.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tdeleteGeometry( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// delete any instances associated with this geometry\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active && instanceInfo[ i ].geometryIndex === geometryId ) {\n\n\t\t\t\tthis.deleteInstance( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryInfoList[ geometryId ].active = false;\n\t\tthis._availableGeometryIds.push( geometryId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes an existing instance from the batch using the given ID.\n\t *\n\t * @param {number} instanceId - The ID of the instance to remove from the batch.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tdeleteInstance( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tthis._instanceInfo[ instanceId ].active = false;\n\t\tthis._availableInstanceIds.push( instanceId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Repacks the sub geometries in [name] to remove any unused space remaining from\n\t * previously deleted geometry, freeing up space to add new geometry.\n\t *\n\t * @param {number} instanceId - The ID of the instance to remove from the batch.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\toptimize() {\n\n\t\t// track the next indices to copy data to\n\t\tlet nextVertexStart = 0;\n\t\tlet nextIndexStart = 0;\n\n\t\t// Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest\n\t\t// in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst indices = geometryInfoList\n\t\t\t.map( ( e, i ) => i )\n\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\treturn geometryInfoList[ a ].vertexStart - geometryInfoList[ b ].vertexStart;\n\n\t\t\t} );\n\n\t\tconst geometry = this.geometry;\n\t\tfor ( let i = 0, l = geometryInfoList.length; i < l; i ++ ) {\n\n\t\t\t// if a geometry range is inactive then don't copy anything\n\t\t\tconst index = indices[ i ];\n\t\t\tconst geometryInfo = geometryInfoList[ index ];\n\t\t\tif ( geometryInfo.active === false ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if a geometry contains an index buffer then shift it, as well\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tif ( geometryInfo.indexStart !== nextIndexStart ) {\n\n\t\t\t\t\tconst { indexStart, vertexStart, reservedIndexCount } = geometryInfo;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst array = index.array;\n\n\t\t\t\t\t// shift the index pointers based on how the vertex data will shift\n\t\t\t\t\t// adjusting the index must happen first so the original vertex start value is available\n\t\t\t\t\tconst elementDelta = nextVertexStart - vertexStart;\n\t\t\t\t\tfor ( let j = indexStart; j < indexStart + reservedIndexCount; j ++ ) {\n\n\t\t\t\t\t\tarray[ j ] = array[ j ] + elementDelta;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex.array.copyWithin( nextIndexStart, indexStart, indexStart + reservedIndexCount );\n\t\t\t\t\tindex.addUpdateRange( nextIndexStart, reservedIndexCount );\n\n\t\t\t\t\tgeometryInfo.indexStart = nextIndexStart;\n\n\t\t\t\t}\n\n\t\t\t\tnextIndexStart += geometryInfo.reservedIndexCount;\n\n\t\t\t}\n\n\t\t\t// if a geometry needs to be moved then copy attribute data to overwrite unused space\n\t\t\tif ( geometryInfo.vertexStart !== nextVertexStart ) {\n\n\t\t\t\tconst { vertexStart, reservedVertexCount } = geometryInfo;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\t\tconst { array, itemSize } = attribute;\n\t\t\t\t\tarray.copyWithin( nextVertexStart * itemSize, vertexStart * itemSize, ( vertexStart + reservedVertexCount ) * itemSize );\n\t\t\t\t\tattribute.addUpdateRange( nextVertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometryInfo.vertexStart = nextVertexStart;\n\n\t\t\t}\n\n\t\t\tnextVertexStart += geometryInfo.reservedVertexCount;\n\t\t\tgeometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\n\t\t\t// step the next geometry points to the shifted position\n\t\t\tthis._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;\n\t\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the bounding box for the given geometry.\n\t *\n\t * @param {number} geometryId - The ID of the geometry to return the bounding box for.\n\t * @param {Box3} target - The target object that is used to store the method's result.\n\t * @return {Box3|null} The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.\n\t */\n\tgetBoundingBoxAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingBox === null ) {\n\n\t\t\tconst box = new Box3();\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tgeometryInfo.boundingBox = box;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingBox );\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns the bounding sphere for the given geometry.\n\t *\n\t * @param {number} geometryId - The ID of the geometry to return the bounding sphere for.\n\t * @param {Sphere} target - The target object that is used to store the method's result.\n\t * @return {Sphere|null} The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.\n\t */\n\tgetBoundingSphereAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingSphere === null ) {\n\n\t\t\tconst sphere = new Sphere();\n\t\t\tthis.getBoundingBoxAt( geometryId, _box );\n\t\t\t_box.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tgeometryInfo.boundingSphere = sphere;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingSphere );\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Sets the given local transformation matrix to the defined instance.\n\t * Negatively scaled matrices are not supported.\n\t *\n\t * @param {number} instanceId - The ID of an instance to set the matrix of.\n\t * @param {Matrix4} matrix - A 4x4 matrix representing the local transformation of a single instance.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tmatrix.toArray( matricesArray, instanceId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the local transformation matrix of the defined instance.\n\t *\n\t * @param {number} instanceId - The ID of an instance to get the matrix of.\n\t * @param {Matrix4} matrix - The target object that is used to store the method's result.\n\t * @return {Matrix4} The instance's local transformation matrix.\n\t */\n\tgetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn matrix.fromArray( this._matricesTexture.image.data, instanceId * 16 );\n\n\t}\n\n\t/**\n\t * Sets the given color to the defined instance.\n\t *\n\t * @param {number} instanceId - The ID of an instance to set the color of.\n\t * @param {Color} color - The color to set the instance to.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tsetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._colorsTexture === null ) {\n\n\t\t\tthis._initColorsTexture();\n\n\t\t}\n\n\t\tcolor.toArray( this._colorsTexture.image.data, instanceId * 4 );\n\t\tthis._colorsTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the color of the defined instance.\n\t *\n\t * @param {number} instanceId - The ID of an instance to get the color of.\n\t * @param {Color} color - The target object that is used to store the method's result.\n\t * @return {Color} The instance's color.\n\t */\n\tgetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn color.fromArray( this._colorsTexture.image.data, instanceId * 4 );\n\n\t}\n\n\t/**\n\t * Sets the visibility of the instance.\n\t *\n\t * @param {number} instanceId - The id of the instance to set the visibility of.\n\t * @param {boolean} visible - Whether the instance is visible or not.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tsetVisibleAt( instanceId, visible ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._instanceInfo[ instanceId ].visible === visible ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis._instanceInfo[ instanceId ].visible = visible;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the visibility state of the defined instance.\n\t *\n\t * @param {number} instanceId - The ID of an instance to get the visibility state of.\n\t * @return {boolean} Whether the instance is visible or not.\n\t */\n\tgetVisibleAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].visible;\n\n\t}\n\n\t/**\n\t * Sets the geometry ID of the instance at the given index.\n\t *\n\t * @param {number} instanceId - The ID of the instance to set the geometry ID of.\n\t * @param {number} geometryId - The geometry ID to be use by the instance.\n\t * @return {BatchedMesh} A reference to this batched mesh.\n\t */\n\tsetGeometryIdAt( instanceId, geometryId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tthis._instanceInfo[ instanceId ].geometryIndex = geometryId;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the geometry ID of the defined instance.\n\t *\n\t * @param {number} instanceId - The ID of an instance to get the geometry ID of.\n\t * @return {number} The instance's geometry ID.\n\t */\n\tgetGeometryIdAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].geometryIndex;\n\n\t}\n\n\t/**\n\t * Get the range representing the subset of triangles related to the attached geometry,\n\t * indicating the starting offset and count, or `null` if invalid.\n\t *\n\t * @param {number} geometryId - The id of the geometry to get the range of.\n\t * @param {Object} [target] - The target object that is used to store the method's result.\n\t * @return {{\n\t * \tvertexStart:number,vertexCount:number,reservedVertexCount:number,\n\t * \tindexStart:number,indexCount:number,reservedIndexCount:number,\n\t * \tstart:number,count:number\n\t * }} The result object with range data.\n\t */\n\tgetGeometryRangeAt( geometryId, target = {} ) {\n\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\ttarget.vertexStart = geometryInfo.vertexStart;\n\t\ttarget.vertexCount = geometryInfo.vertexCount;\n\t\ttarget.reservedVertexCount = geometryInfo.reservedVertexCount;\n\n\t\ttarget.indexStart = geometryInfo.indexStart;\n\t\ttarget.indexCount = geometryInfo.indexCount;\n\t\ttarget.reservedIndexCount = geometryInfo.reservedIndexCount;\n\n\t\ttarget.start = geometryInfo.start;\n\t\ttarget.count = geometryInfo.count;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Resizes the necessary buffers to support the provided number of instances.\n\t * If the provided arguments shrink the number of instances but there are not enough\n\t * unused Ids at the end of the list then an error is thrown.\n\t *\n\t * @param {number} maxInstanceCount - The max number of individual instances that can be added and rendered by the batch.\n\t*/\n\tsetInstanceCount( maxInstanceCount ) {\n\n\t\t// shrink the available instances as much as possible\n\t\tconst availableInstanceIds = this._availableInstanceIds;\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tavailableInstanceIds.sort( ascIdSort );\n\t\twhile ( availableInstanceIds[ availableInstanceIds.length - 1 ] === instanceInfo.length - 1 ) {\n\n\t\t\tinstanceInfo.pop();\n\t\t\tavailableInstanceIds.pop();\n\n\t\t}\n\n\t\t// throw an error if it can't be shrunk to the desired size\n\t\tif ( maxInstanceCount < instanceInfo.length ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Instance ids outside the range ${ maxInstanceCount } are being used. Cannot shrink instance count.` );\n\n\t\t}\n\n\t\t// copy the multi draw counts\n\t\tconst multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tconst multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tcopyArrayContents( this._multiDrawCounts, multiDrawCounts );\n\t\tcopyArrayContents( this._multiDrawStarts, multiDrawStarts );\n\n\t\tthis._multiDrawCounts = multiDrawCounts;\n\t\tthis._multiDrawStarts = multiDrawStarts;\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\n\t\t// update texture data for instance sampling\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst colorsTexture = this._colorsTexture;\n\n\t\tindirectTexture.dispose();\n\t\tthis._initIndirectTexture();\n\t\tcopyArrayContents( indirectTexture.image.data, this._indirectTexture.image.data );\n\n\t\tmatricesTexture.dispose();\n\t\tthis._initMatricesTexture();\n\t\tcopyArrayContents( matricesTexture.image.data, this._matricesTexture.image.data );\n\n\t\tif ( colorsTexture ) {\n\n\t\t\tcolorsTexture.dispose();\n\t\t\tthis._initColorsTexture();\n\t\t\tcopyArrayContents( colorsTexture.image.data, this._colorsTexture.image.data );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.\n\t * If the provided arguments shrink the geometry buffers but there is not enough unused space at the\n\t * end of the geometry attributes then an error is thrown.\n\t *\n\t * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries to resize to.\n\t * @param {number} maxIndexCount - The maximum number of indices to be used by all unique geometries to resize to.\n\t*/\n\tsetGeometrySize( maxVertexCount, maxIndexCount ) {\n\n\t\t// Check if we can shrink to the requested vertex attribute size\n\t\tconst validRanges = [ ...this._geometryInfo ].filter( info => info.active );\n\t\tconst requiredVertexLength = Math.max( ...validRanges.map( range => range.vertexStart + range.reservedVertexCount ) );\n\t\tif ( requiredVertexLength > maxVertexCount ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry vertex values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t}\n\n\t\t// Check if we can shrink to the requested index attribute size\n\t\tif ( this.geometry.index ) {\n\n\t\t\tconst requiredIndexLength = Math.max( ...validRanges.map( range => range.indexStart + range.reservedIndexCount ) );\n\t\t\tif ( requiredIndexLength > maxIndexCount ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Geometry index values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\t// dispose of the previous geometry\n\t\tconst oldGeometry = this.geometry;\n\t\toldGeometry.dispose();\n\n\t\t// recreate the geometry needed based on the previous variant\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tif ( this._geometryInitialized ) {\n\n\t\t\tthis._geometryInitialized = false;\n\t\t\tthis.geometry = new BufferGeometry();\n\t\t\tthis._initializeGeometry( oldGeometry );\n\n\t\t}\n\n\t\t// copy data from the previous geometry\n\t\tconst geometry = this.geometry;\n\t\tif ( oldGeometry.index ) {\n\n\t\t\tcopyArrayContents( oldGeometry.index.array, geometry.index.array );\n\n\t\t}\n\n\t\tfor ( const key in oldGeometry.attributes ) {\n\n\t\t\tcopyArrayContents( oldGeometry.attributes[ key ].array, geometry.attributes[ key ].array );\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! instanceInfo[ i ].visible || ! instanceInfo[ i ].active ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t_mesh.geometry.setDrawRange( geometryInfo.start, geometryInfo.count );\n\n\t\t\t// get the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._geometryInfo = source._geometryInfo.map( info => ( {\n\t\t\t...info,\n\n\t\t\tboundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,\n\t\t\tboundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,\n\t\t} ) );\n\t\tthis._instanceInfo = source._instanceInfo.map( info => ( { ...info } ) );\n\n\t\tthis._availableInstanceIds = source._availableInstanceIds.slice();\n\t\tthis._availableGeometryIds = source._availableGeometryIds.slice();\n\n\t\tthis._nextIndexStart = source._nextIndexStart;\n\t\tthis._nextVertexStart = source._nextVertexStart;\n\t\tthis._geometryCount = source._geometryCount;\n\n\t\tthis._maxInstanceCount = source._maxInstanceCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._indirectTexture = source._indirectTexture.clone();\n\t\tthis._indirectTexture.image.data = this._indirectTexture.image.data.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.data.slice();\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture = source._colorsTexture.clone();\n\t\t\tthis._colorsTexture.image.data = this._colorsTexture.image.data.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\n\t\tthis._indirectTexture.dispose();\n\t\tthis._indirectTexture = null;\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture.dispose();\n\t\t\tthis._colorsTexture = null;\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst indirectArray = indirectTexture.image.data;\n\n\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled && ! camera.isArrayCamera ) {\n\n\t\t\t_matrix\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_matrix,\n\t\t\t\tcamera.coordinateSystem,\n\t\t\t\tcamera.reversedDepth\n\t\t\t);\n\n\t\t}\n\n\t\tlet multiDrawCount = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_matrix.copy( this.matrixWorld ).invert();\n\t\t\t_vector.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _matrix );\n\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).transformDirection( _matrix );\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere ).applyMatrix4( _matrix );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! frustum.intersectsSphere( _sphere, camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tconst z = _temp.subVectors( _sphere.center, _vector ).dot( _forward );\n\t\t\t\t\t\t_renderList.push( geometryInfo.start, geometryInfo.count, z, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ multiDrawCount ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ multiDrawCount ] = item.count;\n\t\t\t\tindirectArray[ multiDrawCount ] = item.index;\n\t\t\t\tmultiDrawCount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix );\n\t\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere ).applyMatrix4( _matrix );\n\t\t\t\t\t\tculled = ! frustum.intersectsSphere( _sphere, camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tmultiDrawStarts[ multiDrawCount ] = geometryInfo.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ multiDrawCount ] = geometryInfo.count;\n\t\t\t\t\t\tindirectArray[ multiDrawCount ] = i;\n\t\t\t\t\t\tmultiDrawCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tindirectTexture.needsUpdate = true;\n\t\tthis._multiDrawCount = multiDrawCount;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nexport { BatchedMesh };\n"],"mappings":"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","ignoreList":[]}