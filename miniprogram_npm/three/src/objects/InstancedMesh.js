import{InstancedBufferAttribute}from"../core/InstancedBufferAttribute.js";import{Mesh}from"./Mesh.js";import{Box3}from"../math/Box3.js";import{Matrix4}from"../math/Matrix4.js";import{Sphere}from"../math/Sphere.js";import{DataTexture}from"../textures/DataTexture.js";import{FloatType,RedFormat}from"../constants.js";const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh=new Mesh,_sphere=new Sphere;class InstancedMesh extends Mesh{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(16*n),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<n;t++)this.setMatrixAt(t,_identity)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new Box3),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,_instanceLocalMatrix),_box3.copy(t.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new Sphere),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,_instanceLocalMatrix),_sphere.copy(t.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const n=e.morphTargetInfluences,r=this.morphTexture.source.data.data,o=t*(n.length+1)+1;for(let t=0;t<n.length;t++)n[t]=r[o+t]}raycast(t,e){const n=this.matrixWorld,r=this.count;if(_mesh.geometry=this.geometry,_mesh.material=this.material,void 0!==_mesh.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),_sphere.copy(this.boundingSphere),_sphere.applyMatrix4(n),!1!==t.ray.intersectsSphere(_sphere)))for(let o=0;o<r;o++){this.getMatrixAt(o,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(n,_instanceLocalMatrix),_mesh.matrixWorld=_instanceWorldMatrix,_mesh.raycast(t,_instanceIntersects);for(let t=0,n=_instanceIntersects.length;t<n;t++){const n=_instanceIntersects[t];n.instanceId=o,n.object=this,e.push(n)}_instanceIntersects.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const n=e.morphTargetInfluences,r=n.length+1;null===this.morphTexture&&(this.morphTexture=new DataTexture(new Float32Array(r*this.count),r,this.count,RedFormat,FloatType));const o=this.morphTexture.source.data.data;let i=0;for(let t=0;t<n.length;t++)i+=n[t];const s=this.geometry.morphTargetsRelative?1:1-i,a=r*t;o[a]=s,o.set(n,a+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}export{InstancedMesh};
//# sourceMappingURL=InstancedMesh.js.map