{"version":3,"file":"node_modules/three/src/objects/InstancedMesh.js","names":["InstancedBufferAttribute","Mesh","Box3","Matrix4","Sphere","DataTexture","FloatType","RedFormat","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_box3","_identity","_mesh","_sphere","InstancedMesh","constructor","geometry","material","count","super","this","isInstancedMesh","instanceMatrix","Float32Array","instanceColor","morphTexture","boundingBox","boundingSphere","i","setMatrixAt","computeBoundingBox","makeEmpty","getMatrixAt","copy","applyMatrix4","union","computeBoundingSphere","source","recursive","clone","getColorAt","index","color","fromArray","array","matrix","getMorphAt","object","objectInfluences","morphTargetInfluences","data","dataIndex","length","raycast","raycaster","intersects","matrixWorld","raycastTimes","undefined","ray","intersectsSphere","instanceId","multiplyMatrices","l","intersect","push","setColorAt","fill","toArray","setMorphAt","len","morphInfluencesSum","morphBaseInfluence","morphTargetsRelative","set","updateMorphTargets","dispose","dispatchEvent","type"],"sources":["node_modules/three/src/objects/InstancedMesh.js"],"sourcesContent":["import { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { FloatType, RedFormat } from '../constants.js';\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _sphere = /*@__PURE__*/ new Sphere();\n\n/**\n * A special version of a mesh with instanced rendering support. Use\n * this class if you have to render a large number of objects with the same\n * geometry and material(s) but with different world transformations. The usage\n * of 'InstancedMesh' will help you to reduce the number of draw calls and thus\n * improve the overall rendering performance in your application.\n *\n * @augments Mesh\n */\nclass InstancedMesh extends Mesh {\n\n\t/**\n\t * Constructs a new instanced mesh.\n\t *\n\t * @param {BufferGeometry} [geometry] - The mesh geometry.\n\t * @param {Material|Array<Material>} [material] - The mesh material.\n\t * @param {number} count - The number of instances.\n\t */\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInstancedMesh = true;\n\n\t\t/**\n\t\t * Represents the local transformation of all instances. You have to set its\n\t\t * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data\n\t\t * via {@link InstancedMesh#setMatrixAt}.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\n\t\t/**\n\t\t * Represents the color of all instances. You have to set its\n\t\t * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data\n\t\t * via {@link InstancedMesh#setColorAt}.\n\t\t *\n\t\t * @type {?InstancedBufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.instanceColor = null;\n\n\t\t/**\n\t\t * Represents the morph target weights of all instances. You have to set its\n\t\t * {@link Texture#needsUpdate} flag to true if you modify instanced data\n\t\t * via {@link InstancedMesh#setMorphAt}.\n\t\t *\n\t\t * @type {?DataTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.morphTexture = null;\n\n\t\t/**\n\t\t * The number of instances.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The bounding box of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingBox}.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * The bounding sphere of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingSphere}.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.\n\t * The bounding box is not automatically computed by the engine; this method must be called by your app.\n\t * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.\n\t */\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}\n\t * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\n\t * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.\n\t */\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the color of the defined instance.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Color} color - The target object that is used to store the method's result.\n\t */\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\t/**\n\t * Gets the local transformation matrix of the defined instance.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Matrix4} matrix - The target object that is used to store the method's result.\n\t */\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\t/**\n\t * Gets the morph target weights of the defined instance.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Mesh} object - The target object that is used to store the method's result.\n\t */\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere.copy( this.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of\n\t * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Color} color - The instance color.\n\t */\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\t/**\n\t * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of\n\t * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Matrix4} matrix - The local transformation.\n\t */\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\t/**\n\t * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of\n\t * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.\n\t *\n\t * @param {number} index - The instance index.\n\t * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights\n\t * of a single instance.\n\t */\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { InstancedMesh };\n"],"mappings":"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","ignoreList":[]}