import{Vector3}from"../math/Vector3.js";import{Object3D}from"../core/Object3D.js";const _v1=new Vector3,_v2=new Vector3;class LOD extends Object3D{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let e=0,s=t.length;e<s;e++){const s=t[e];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,s=0){t=Math.abs(t);const i=this.levels;let o;for(o=0;o<i.length&&!(t<i[o].distance);o++);return i.splice(o,0,{distance:t,hysteresis:s,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let s=0;s<t.length;s++)if(t[s].distance===e){const e=t.splice(s,1);return this.remove(e[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let s,i;for(s=1,i=t.length;s<i;s++){let i=t[s].distance;if(t[s].object.visible&&(i-=i*t[s].hysteresis),e<i)break}return t[s-1].object}return null}raycast(e,t){if(this.levels.length>0){_v1.setFromMatrixPosition(this.matrixWorld);const s=e.ray.origin.distanceTo(_v1);this.getObjectForDistance(s).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){_v1.setFromMatrixPosition(e.matrixWorld),_v2.setFromMatrixPosition(this.matrixWorld);const s=_v1.distanceTo(_v2)/e.zoom;let i,o;for(t[0].object.visible=!0,i=1,o=t.length;i<o;i++){let e=t[i].distance;if(t[i].object.visible&&(e-=e*t[i].hysteresis),!(s>=e))break;t[i-1].object.visible=!1,t[i].object.visible=!0}for(this._currentLevel=i-1;i<o;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const s=this.levels;for(let e=0,i=s.length;e<i;e++){const i=s[e];t.object.levels.push({object:i.object.uuid,distance:i.distance,hysteresis:i.hysteresis})}return t}}export{LOD};
//# sourceMappingURL=LOD.js.map