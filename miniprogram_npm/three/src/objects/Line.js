import{Sphere}from"../math/Sphere.js";import{Ray}from"../math/Ray.js";import{Matrix4}from"../math/Matrix4.js";import{Object3D}from"../core/Object3D.js";import{Vector3}from"../math/Vector3.js";import{LineBasicMaterial}from"../materials/LineBasicMaterial.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";const _vStart=new Vector3,_vEnd=new Vector3,_inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_intersectPointOnRay=new Vector3,_intersectPointOnSegment=new Vector3;class Line extends Object3D{constructor(t=new BufferGeometry,e=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,r=[0];for(let t=1,i=e.count;t<i;t++)_vStart.fromBufferAttribute(e,t-1),_vEnd.fromBufferAttribute(e,t),r[t]=r[t-1],r[t]+=_vStart.distanceTo(_vEnd);t.setAttribute("lineDistance",new Float32BufferAttribute(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const r=this.geometry,i=this.matrixWorld,n=t.params.Line.threshold,o=r.drawRange;if(null===r.boundingSphere&&r.computeBoundingSphere(),_sphere.copy(r.boundingSphere),_sphere.applyMatrix4(i),_sphere.radius+=n,!1===t.ray.intersectsSphere(_sphere))return;_inverseMatrix.copy(i).invert(),_ray.copy(t.ray).applyMatrix4(_inverseMatrix);const s=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=s*s,c=this.isLineSegments?2:1,h=r.index,m=r.attributes.position;if(null!==h){const r=Math.max(0,o.start),i=Math.min(h.count,o.start+o.count);for(let n=r,o=i-1;n<o;n+=c){const r=h.getX(n),i=h.getX(n+1),o=checkIntersection(this,t,_ray,a,r,i,n);o&&e.push(o)}if(this.isLineLoop){const n=h.getX(i-1),o=h.getX(r),s=checkIntersection(this,t,_ray,a,n,o,i-1);s&&e.push(s)}}else{const r=Math.max(0,o.start),i=Math.min(m.count,o.start+o.count);for(let n=r,o=i-1;n<o;n+=c){const r=checkIntersection(this,t,_ray,a,n,n+1,n);r&&e.push(r)}if(this.isLineLoop){const n=checkIntersection(this,t,_ray,a,i-1,r,i-1);n&&e.push(n)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const r=t[e[0]];if(void 0!==r){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=r.length;t<e;t++){const e=r[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function checkIntersection(t,e,r,i,n,o,s){const a=t.geometry.attributes.position;_vStart.fromBufferAttribute(a,n),_vEnd.fromBufferAttribute(a,o);if(r.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>i)return;_intersectPointOnRay.applyMatrix4(t.matrixWorld);const c=e.ray.origin.distanceTo(_intersectPointOnRay);return c<e.near||c>e.far?void 0:{distance:c,point:_intersectPointOnSegment.clone().applyMatrix4(t.matrixWorld),index:s,face:null,faceIndex:null,barycoord:null,object:t}}export{Line};
//# sourceMappingURL=Line.js.map