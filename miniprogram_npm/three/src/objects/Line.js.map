{"version":3,"file":"node_modules/three/src/objects/Line.js","names":["Sphere","Ray","Matrix4","Object3D","Vector3","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","_vStart","_vEnd","_inverseMatrix","_ray","_sphere","_intersectPointOnRay","_intersectPointOnSegment","Line","constructor","geometry","material","super","this","isLine","type","morphTargetDictionary","undefined","morphTargetInfluences","updateMorphTargets","copy","source","recursive","Array","isArray","slice","computeLineDistances","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","console","warn","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","step","isLineSegments","start","Math","max","end","min","a","getX","b","intersect","checkIntersection","push","isLineLoop","morphAttributes","keys","Object","length","morphAttribute","m","ml","name","String","object","thresholdSq","distanceSqToSegment","distance","origin","near","far","point","clone","face","faceIndex","barycoord"],"sources":["node_modules/three/src/objects/Line.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\n/**\n * A continuous line. The line are rendered by connecting consecutive\n * vertices with straight lines.\n *\n * ```js\n * const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );\n *\n * const points = [];\n * points.push( new THREE.Vector3( - 10, 0, 0 ) );\n * points.push( new THREE.Vector3( 0, 10, 0 ) );\n * points.push( new THREE.Vector3( 10, 0, 0 ) );\n *\n * const geometry = new THREE.BufferGeometry().setFromPoints( points );\n *\n * const line = new THREE.Line( geometry, material );\n * scene.add( line );\n * ```\n *\n * @augments Object3D\n */\nclass Line extends Object3D {\n\n\t/**\n\t * Constructs a new line.\n\t *\n\t * @param {BufferGeometry} [geometry] - The line geometry.\n\t * @param {Material|Array<Material>} [material] - The line material.\n\t */\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\t/**\n\t\t * The line geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = geometry;\n\n\t\t/**\n\t\t * The line material.\n\t\t *\n\t\t * @type {Material|Array<Material>}\n\t\t * @default LineBasicMaterial\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * A dictionary representing the morph targets in the geometry. The key is the\n\t\t * morph targets name, the value its attribute index. This member is `undefined`\n\t\t * by default and only set when morph targets are detected in the geometry.\n\t\t *\n\t\t * @type {Object<String,number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetDictionary = undefined;\n\n\t\t/**\n\t\t * An array of weights typically in the range `[0,1]` that specify how much of the morph\n\t\t * is applied. This member is `undefined` by default and only set when morph targets are\n\t\t * detected in the geometry.\n\t\t *\n\t\t * @type {Array<number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetInfluences = undefined;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes an array of distance values which are necessary for rendering dashed lines.\n\t * For each vertex in the geometry, the method calculates the cumulative length from the\n\t * current point to the very beginning of the line.\n\t *\n\t * @return {Line} A reference to this line.\n\t */\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this line.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray, localThresholdSq, a, b, i );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray, localThresholdSq, a, b, end - 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray, localThresholdSq, i, i + 1, i );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray, localThresholdSq, end - 1, start, end - 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}\n\t * to make sure existing morph targets can influence this 3D object.\n\t */\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b, i ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: i,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tbarycoord: null,\n\t\tobject: object\n\n\t};\n\n}\n\nexport { Line };\n"],"mappings":"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","ignoreList":[]}