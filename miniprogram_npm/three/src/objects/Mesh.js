import{Vector3}from"../math/Vector3.js";import{Vector2}from"../math/Vector2.js";import{Sphere}from"../math/Sphere.js";import{Ray}from"../math/Ray.js";import{Matrix4}from"../math/Matrix4.js";import{Object3D}from"../core/Object3D.js";import{Triangle}from"../math/Triangle.js";import{BackSide,FrontSide}from"../constants.js";import{MeshBasicMaterial}from"../materials/MeshBasicMaterial.js";import{BufferGeometry}from"../core/BufferGeometry.js";const _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_sphereHitAt=new Vector3,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(t=new BufferGeometry,e=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const r=t[e[0]];if(void 0!==r){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=r.length;t<e;t++){const e=r[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const r=this.geometry,o=r.attributes.position,i=r.morphAttributes.position,n=r.morphTargetsRelative;e.fromBufferAttribute(o,t);const a=this.morphTargetInfluences;if(i&&a){_morphA.set(0,0,0);for(let r=0,o=i.length;r<o;r++){const o=a[r],s=i[r];0!==o&&(_tempA.fromBufferAttribute(s,t),n?_morphA.addScaledVector(_tempA,o):_morphA.addScaledVector(_tempA.sub(e),o))}e.add(_morphA)}return e}raycast(t,e){const r=this.geometry,o=this.material,i=this.matrixWorld;if(void 0!==o){if(null===r.boundingSphere&&r.computeBoundingSphere(),_sphere.copy(r.boundingSphere),_sphere.applyMatrix4(i),_ray.copy(t.ray).recast(t.near),!1===_sphere.containsPoint(_ray.origin)){if(null===_ray.intersectSphere(_sphere,_sphereHitAt))return;if(_ray.origin.distanceToSquared(_sphereHitAt)>(t.far-t.near)**2)return}_inverseMatrix.copy(i).invert(),_ray.copy(t.ray).applyMatrix4(_inverseMatrix),null!==r.boundingBox&&!1===_ray.intersectsBox(r.boundingBox)||this._computeIntersections(t,e,_ray)}}_computeIntersections(t,e,r){let o;const i=this.geometry,n=this.material,a=i.index,s=i.attributes.position,c=i.attributes.uv,h=i.attributes.uv1,m=i.attributes.normal,l=i.groups,p=i.drawRange;if(null!==a)if(Array.isArray(n))for(let i=0,s=l.length;i<s;i++){const s=l[i],u=n[s.materialIndex];for(let i=Math.max(s.start,p.start),n=Math.min(a.count,Math.min(s.start+s.count,p.start+p.count));i<n;i+=3){o=checkGeometryIntersection(this,u,t,r,c,h,m,a.getX(i),a.getX(i+1),a.getX(i+2)),o&&(o.faceIndex=Math.floor(i/3),o.face.materialIndex=s.materialIndex,e.push(o))}}else{for(let i=Math.max(0,p.start),s=Math.min(a.count,p.start+p.count);i<s;i+=3){o=checkGeometryIntersection(this,n,t,r,c,h,m,a.getX(i),a.getX(i+1),a.getX(i+2)),o&&(o.faceIndex=Math.floor(i/3),e.push(o))}}else if(void 0!==s)if(Array.isArray(n))for(let i=0,a=l.length;i<a;i++){const a=l[i],u=n[a.materialIndex];for(let i=Math.max(a.start,p.start),n=Math.min(s.count,Math.min(a.start+a.count,p.start+p.count));i<n;i+=3){o=checkGeometryIntersection(this,u,t,r,c,h,m,i,i+1,i+2),o&&(o.faceIndex=Math.floor(i/3),o.face.materialIndex=a.materialIndex,e.push(o))}}else{for(let i=Math.max(0,p.start),a=Math.min(s.count,p.start+p.count);i<a;i+=3){o=checkGeometryIntersection(this,n,t,r,c,h,m,i,i+1,i+2),o&&(o.faceIndex=Math.floor(i/3),e.push(o))}}}}function checkIntersection(t,e,r,o,i,n,a,s){let c;if(c=e.side===BackSide?o.intersectTriangle(a,n,i,!0,s):o.intersectTriangle(i,n,a,e.side===FrontSide,s),null===c)return null;_intersectionPointWorld.copy(s),_intersectionPointWorld.applyMatrix4(t.matrixWorld);const h=r.ray.origin.distanceTo(_intersectionPointWorld);return h<r.near||h>r.far?null:{distance:h,point:_intersectionPointWorld.clone(),object:t}}function checkGeometryIntersection(t,e,r,o,i,n,a,s,c,h){t.getVertexPosition(s,_vA),t.getVertexPosition(c,_vB),t.getVertexPosition(h,_vC);const m=checkIntersection(t,e,r,o,_vA,_vB,_vC,_intersectionPoint);if(m){const t=new Vector3;Triangle.getBarycoord(_intersectionPoint,_vA,_vB,_vC,t),i&&(m.uv=Triangle.getInterpolatedAttribute(i,s,c,h,t,new Vector2)),n&&(m.uv1=Triangle.getInterpolatedAttribute(n,s,c,h,t,new Vector2)),a&&(m.normal=Triangle.getInterpolatedAttribute(a,s,c,h,t,new Vector3),m.normal.dot(o.direction)>0&&m.normal.multiplyScalar(-1));const e={a:s,b:c,c:h,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA,_vB,_vC,e.normal),m.face=e,m.barycoord=t}return m}export{Mesh};
//# sourceMappingURL=Mesh.js.map