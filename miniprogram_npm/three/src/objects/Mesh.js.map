{"version":3,"file":"node_modules/three/src/objects/Mesh.js","names":["Vector3","Vector2","Sphere","Ray","Matrix4","Object3D","Triangle","BackSide","FrontSide","MeshBasicMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_sphereHitAt","_vA","_vB","_vC","_tempA","_morphA","_intersectionPoint","_intersectionPointWorld","Mesh","constructor","geometry","material","super","this","isMesh","type","morphTargetDictionary","undefined","morphTargetInfluences","count","updateMorphTargets","copy","source","recursive","slice","Object","assign","Array","isArray","morphAttributes","keys","length","morphAttribute","m","ml","name","String","push","getVertexPosition","index","target","position","attributes","morphPosition","morphTargetsRelative","fromBufferAttribute","morphInfluences","set","i","il","influence","addScaledVector","sub","add","raycast","raycaster","intersects","matrixWorld","boundingSphere","computeBoundingSphere","applyMatrix4","ray","recast","near","containsPoint","origin","intersectSphere","distanceToSquared","far","invert","boundingBox","intersectsBox","_computeIntersections","rayLocalSpace","intersection","uv","uv1","normal","groups","drawRange","group","groupMaterial","materialIndex","j","Math","max","start","jl","min","checkGeometryIntersection","getX","faceIndex","floor","face","checkIntersection","object","pA","pB","pC","point","intersect","side","intersectTriangle","distance","distanceTo","clone","a","b","c","barycoord","getBarycoord","getInterpolatedAttribute","dot","direction","multiplyScalar","getNormal"],"sources":["node_modules/three/src/objects/Mesh.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { BackSide, FrontSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\n/**\n * Class representing triangular polygon mesh based objects.\n *\n * ```js\n * const geometry = new THREE.BoxGeometry( 1, 1, 1 );\n * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n * ```\n *\n * @augments Object3D\n */\nclass Mesh extends Object3D {\n\n\t/**\n\t * Constructs a new mesh.\n\t *\n\t * @param {BufferGeometry} [geometry] - The mesh geometry.\n\t * @param {Material|Array<Material>} [material] - The mesh material.\n\t */\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\t/**\n\t\t * The mesh geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = geometry;\n\n\t\t/**\n\t\t * The mesh material.\n\t\t *\n\t\t * @type {Material|Array<Material>}\n\t\t * @default MeshBasicMaterial\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * A dictionary representing the morph targets in the geometry. The key is the\n\t\t * morph targets name, the value its attribute index. This member is `undefined`\n\t\t * by default and only set when morph targets are detected in the geometry.\n\t\t *\n\t\t * @type {Object<String,number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetDictionary = undefined;\n\n\t\t/**\n\t\t * An array of weights typically in the range `[0,1]` that specify how much of the morph\n\t\t * is applied. This member is `undefined` by default and only set when morph targets are\n\t\t * detected in the geometry.\n\t\t *\n\t\t * @type {Array<number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetInfluences = undefined;\n\n\t\t/**\n\t\t * The number of instances of this mesh.\n\t\t * Can only be used with {@link WebGPURenderer}.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.count = 1;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}\n\t * to make sure existing morph targets can influence this 3D object.\n\t */\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the local-space position of the vertex at the given index, taking into\n\t * account the current animation state of both morph targets and skinning.\n\t *\n\t * @param {number} index - The vertex index.\n\t * @param {Vector3} target - The target object that is used to store the method's result.\n\t * @return {Vector3} The vertex position in local space.\n\t */\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this line.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere.containsPoint( _ray.origin ) === false ) {\n\n\t\t\tif ( _ray.intersectSphere( _sphere, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA );\n\tobject.getVertexPosition( b, _vB );\n\tobject.getVertexPosition( c, _vC );\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\tintersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\tintersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\tintersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.barycoord = barycoord;\n\n\t}\n\n\treturn intersection;\n\n}\n\nexport { Mesh };\n"],"mappings":"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","ignoreList":[]}