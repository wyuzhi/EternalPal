import{Sphere}from"../math/Sphere.js";import{Ray}from"../math/Ray.js";import{Matrix4}from"../math/Matrix4.js";import{Object3D}from"../core/Object3D.js";import{Vector3}from"../math/Vector3.js";import{PointsMaterial}from"../materials/PointsMaterial.js";import{BufferGeometry}from"../core/BufferGeometry.js";const _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_position=new Vector3;class Points extends Object3D{constructor(t=new BufferGeometry,e=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const r=this.geometry,i=this.matrixWorld,o=t.params.Points.threshold,s=r.drawRange;if(null===r.boundingSphere&&r.computeBoundingSphere(),_sphere.copy(r.boundingSphere),_sphere.applyMatrix4(i),_sphere.radius+=o,!1===t.ray.intersectsSphere(_sphere))return;_inverseMatrix.copy(i).invert(),_ray.copy(t.ray).applyMatrix4(_inverseMatrix);const a=o/((this.scale.x+this.scale.y+this.scale.z)/3),n=a*a,h=r.index,p=r.attributes.position;if(null!==h){for(let r=Math.max(0,s.start),o=Math.min(h.count,s.start+s.count);r<o;r++){const o=h.getX(r);_position.fromBufferAttribute(p,o),testPoint(_position,o,n,i,t,e,this)}}else{for(let r=Math.max(0,s.start),o=Math.min(p.count,s.start+s.count);r<o;r++)_position.fromBufferAttribute(p,r),testPoint(_position,r,n,i,t,e,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const r=t[e[0]];if(void 0!==r){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=r.length;t<e;t++){const e=r[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function testPoint(t,e,r,i,o,s,a){const n=_ray.distanceSqToPoint(t);if(n<r){const r=new Vector3;_ray.closestPointToPoint(t,r),r.applyMatrix4(i);const h=o.ray.origin.distanceTo(r);if(h<o.near||h>o.far)return;s.push({distance:h,distanceToRay:Math.sqrt(n),point:r,index:e,face:null,faceIndex:null,barycoord:null,object:a})}}export{Points};
//# sourceMappingURL=Points.js.map