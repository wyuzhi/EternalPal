{"version":3,"file":"node_modules/three/src/objects/Points.js","names":["Sphere","Ray","Matrix4","Object3D","Vector3","PointsMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_position","Points","constructor","geometry","material","super","this","isPoints","type","morphTargetDictionary","undefined","morphTargetInfluences","updateMorphTargets","copy","source","recursive","Array","isArray","slice","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","index","positionAttribute","attributes","position","i","Math","max","start","il","min","count","a","getX","fromBufferAttribute","testPoint","l","morphAttributes","keys","Object","length","morphAttribute","m","ml","name","String","push","point","object","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","distanceToRay","sqrt","face","faceIndex","barycoord"],"sources":["node_modules/three/src/objects/Points.js"],"sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position = /*@__PURE__*/ new Vector3();\n\n/**\n * A class for displaying points or point clouds.\n *\n * @augments Object3D\n */\nclass Points extends Object3D {\n\n\t/**\n\t * Constructs a new point cloud.\n\t *\n\t * @param {BufferGeometry} [geometry] - The points geometry.\n\t * @param {Material|Array<Material>} [material] - The points material.\n\t */\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\t/**\n\t\t * The points geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = geometry;\n\n\t\t/**\n\t\t * The line material.\n\t\t *\n\t\t * @type {Material|Array<Material>}\n\t\t * @default PointsMaterial\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * A dictionary representing the morph targets in the geometry. The key is the\n\t\t * morph targets name, the value its attribute index. This member is `undefined`\n\t\t * by default and only set when morph targets are detected in the geometry.\n\t\t *\n\t\t * @type {Object<String,number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetDictionary = undefined;\n\n\t\t/**\n\t\t * An array of weights typically in the range `[0,1]` that specify how much of the morph\n\t\t * is applied. This member is `undefined` by default and only set when morph targets are\n\t\t * detected in the geometry.\n\t\t *\n\t\t * @type {Array<number>|undefined}\n\t\t * @default undefined\n\t\t */\n\t\tthis.morphTargetInfluences = undefined;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this point cloud.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}\n\t * to make sure existing morph targets can influence this 3D object.\n\t */\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tfaceIndex: null,\n\t\t\tbarycoord: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nexport { Points };\n"],"mappings":"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","ignoreList":[]}