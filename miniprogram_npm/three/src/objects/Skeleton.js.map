{"version":3,"file":"node_modules/three/src/objects/Skeleton.js","names":["RGBAFormat","FloatType","Bone","Matrix4","DataTexture","generateUUID","_offsetMatrix","_identityMatrix","Skeleton","constructor","bones","boneInverses","this","uuid","slice","boneMatrices","boneTexture","init","Float32Array","length","calculateInverses","console","warn","i","il","push","inverse","copy","matrixWorld","invert","pose","bone","parent","isBone","matrix","multiply","decompose","position","quaternion","scale","update","multiplyMatrices","toArray","needsUpdate","clone","computeBoneTexture","size","Math","sqrt","ceil","max","set","getBoneByName","name","dispose","fromJSON","json","l","undefined","fromArray","toJSON","data","metadata","version","type","generator","boneInverse"],"sources":["node_modules/three/src/objects/Skeleton.js"],"sourcesContent":["import {\n\tRGBAFormat,\n\tFloatType\n} from '../constants.js';\nimport { Bone } from './Bone.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { generateUUID } from '../math/MathUtils.js';\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\n/**\n * Class for representing the armatures in `three.js`. The skeleton\n * is defined by a hierarchy of bones.\n *\n * ```js\n * const bones = [];\n *\n * const shoulder = new THREE.Bone();\n * const elbow = new THREE.Bone();\n * const hand = new THREE.Bone();\n *\n * shoulder.add( elbow );\n * elbow.add( hand );\n *\n * bones.push( shoulder , elbow, hand);\n *\n * shoulder.position.y = -5;\n * elbow.position.y = 0;\n * hand.position.y = 5;\n *\n * const armSkeleton = new THREE.Skeleton( bones );\n * ```\n */\nclass Skeleton {\n\n\t/**\n\t * Constructs a new skeleton.\n\t *\n\t * @param {Array<Bone>} [bones] - An array of bones.\n\t * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.\n\t * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.\n\t */\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * An array of bones defining the skeleton.\n\t\t *\n\t\t * @type {Array<Bone>}\n\t\t */\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t/**\n\t\t * An array of bone inverse matrices.\n\t\t *\n\t\t * @type {Array<Matrix4>}\n\t\t */\n\t\tthis.boneInverses = boneInverses;\n\n\t\t/**\n\t\t * An array buffer holding the bone data.\n\t\t * Input data for {@link Skeleton#boneTexture}.\n\t\t *\n\t\t * @type {?Float32Array}\n\t\t * @default null\n\t\t */\n\t\tthis.boneMatrices = null;\n\n\t\t/**\n\t\t * A texture holding the bone data for use\n\t\t * in the vertex shader.\n\t\t *\n\t\t * @type {?DataTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\t/**\n\t * Initializes the skeleton. This method gets automatically called by the constructor\n\t * but depending on how the skeleton is created it might be necessary to call this method\n\t * manually.\n\t */\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}\n\t * and fills it with new matrices.\n\t */\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resets the skeleton to the base pose.\n\t */\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resets the skeleton to the base pose.\n\t */\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a new skeleton with copied values from this instance.\n\t *\n\t * @return {Skeleton} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\t/**\n\t * Computes a data texture for passing bone data to the vertex shader.\n\t *\n\t * @return {Skeleton} A reference of this instance.\n\t */\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Searches through the skeleton's bone array and returns the first with a\n\t * matching name.\n\t *\n\t * @param {string} name - The name of the bone.\n\t * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.\n\t */\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the skeleton by the given JSON and bones.\n\t *\n\t * @param {Object} json - The skeleton as serialized JSON.\n\t * @param {Object<string, Bone>} bones - An array of bones.\n\t * @return {Skeleton} A reference of this instance.\n\t */\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Serializes the skeleton into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized skeleton.\n\t * @see {@link ObjectLoader#parse}\n\t */\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport { Skeleton };\n"],"mappings":"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","ignoreList":[]}