import{Mesh}from"./Mesh.js";import{Box3}from"../math/Box3.js";import{Matrix4}from"../math/Matrix4.js";import{Sphere}from"../math/Sphere.js";import{Vector3}from"../math/Vector3.js";import{Vector4}from"../math/Vector4.js";import{Ray}from"../math/Ray.js";import{AttachedBindMode,DetachedBindMode}from"../constants.js";const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere=new Sphere,_inverseMatrix=new Matrix4,_ray=new Ray;class SkinnedMesh extends Mesh{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,n=this.matrixWorld;void 0!==i&&(null===this.boundingSphere&&this.computeBoundingSphere(),_sphere.copy(this.boundingSphere),_sphere.applyMatrix4(n),!1!==t.ray.intersectsSphere(_sphere)&&(_inverseMatrix.copy(n).invert(),_ray.copy(t.ray).applyMatrix4(_inverseMatrix),null!==this.boundingBox&&!1===_ray.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,_ray)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Vector4,e=this.geometry.attributes.skinWeight;for(let i=0,n=e.count;i<n;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const i=this.skeleton,n=this.geometry;_skinIndex.fromBufferAttribute(n.attributes.skinIndex,t),_skinWeight.fromBufferAttribute(n.attributes.skinWeight,t),_basePosition.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const n=_skinWeight.getComponent(t);if(0!==n){const o=_skinIndex.getComponent(t);_matrix4.multiplyMatrices(i.bones[o].matrixWorld,i.boneInverses[o]),e.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),n)}}return e.applyMatrix4(this.bindMatrixInverse)}}export{SkinnedMesh};
//# sourceMappingURL=SkinnedMesh.js.map