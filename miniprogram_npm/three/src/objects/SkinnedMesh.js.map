{"version":3,"file":"node_modules/three/src/objects/SkinnedMesh.js","names":["Mesh","Box3","Matrix4","Sphere","Vector3","Vector4","Ray","AttachedBindMode","DetachedBindMode","_basePosition","_skinIndex","_skinWeight","_vector3","_matrix4","_vertex","_sphere","_inverseMatrix","_ray","SkinnedMesh","constructor","geometry","material","super","this","isSkinnedMesh","type","bindMode","bindMatrix","bindMatrixInverse","boundingBox","boundingSphere","computeBoundingBox","makeEmpty","positionAttribute","getAttribute","i","count","getVertexPosition","expandByPoint","computeBoundingSphere","copy","source","recursive","skeleton","clone","raycast","raycaster","intersects","matrixWorld","undefined","applyMatrix4","ray","intersectsSphere","invert","intersectsBox","_computeIntersections","index","target","applyBoneTransform","bind","updateMatrixWorld","calculateInverses","pose","normalizeSkinWeights","vector","skinWeight","attributes","l","fromBufferAttribute","scale","manhattanLength","Infinity","multiplyScalar","set","setXYZW","x","y","z","w","force","console","warn","skinIndex","weight","getComponent","boneIndex","multiplyMatrices","bones","boneInverses","addScaledVector"],"sources":["node_modules/three/src/objects/SkinnedMesh.js"],"sourcesContent":["import { Mesh } from './Mesh.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { Ray } from '../math/Ray.js';\nimport { AttachedBindMode, DetachedBindMode } from '../constants.js';\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\n\n/**\n * A mesh that has a {@link Skeleton} that can then be used to animate the\n * vertices of the geometry with skinning/skeleton animation.\n *\n * Next to a valid skeleton, the skinned mesh requires skin indices and weights\n * as buffer attributes in its geometry. These attribute define which bones affect a single\n * vertex to a certain extend.\n *\n * Typically skinned meshes are not created manually but loaders like {@link GLTFLoader}\n * or {@link FBXLoader } import respective models.\n *\n * @augments Mesh\n */\nclass SkinnedMesh extends Mesh {\n\n\t/**\n\t * Constructs a new skinned mesh.\n\t *\n\t * @param {BufferGeometry} [geometry] - The mesh geometry.\n\t * @param {Material|Array<Material>} [material] - The mesh material.\n\t */\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\t/**\n\t\t * `AttachedBindMode` means the skinned mesh shares the same world space as the skeleton.\n\t\t * This is not true when using `DetachedBindMode` which is useful when sharing a skeleton\n\t\t * across multiple skinned meshes.\n\t\t *\n\t\t * @type {(AttachedBindMode|DetachedBindMode)}\n\t\t * @default AttachedBindMode\n\t\t */\n\t\tthis.bindMode = AttachedBindMode;\n\n\t\t/**\n\t\t * The base matrix that is used for the bound bone transforms.\n\t\t *\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis.bindMatrix = new Matrix4();\n\n\t\t/**\n\t\t * The base matrix that is used for resetting the bound bone transforms.\n\t\t *\n\t\t * @type {Matrix4}\n\t\t */\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t/**\n\t\t * The bounding box of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingBox}.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * The bounding sphere of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingSphere}.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\t/**\n\t * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.\n\t * The bounding box is not automatically computed by the engine; this method must be called by your app.\n\t * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect\n\t * the current animation state.\n\t */\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.\n\t * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting\n\t * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed\n\t * per frame in order to reflect the current animation state.\n\t */\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere.copy( this.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Binds the given skeleton to the skinned mesh.\n\t *\n\t * @param {Skeleton} skeleton - The skeleton to bind.\n\t * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,\n\t * the skinned mesh's world matrix will be used instead.\n\t */\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\t/**\n\t * This method sets the skinned mesh in the rest pose).\n\t */\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\t/**\n\t * Normalizes the skin weights which are defined as a buffer attribute\n\t * in the skinned mesh's geometry.\n\t */\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies the bone transform associated with the given index to the given\n\t * vertex position. Returns the updated vector.\n\t *\n\t * @param {number} index - The vertex index.\n\t * @param {Vector3} target - The target object that is used to store the method's result.\n\t * the skinned mesh's world matrix will be used instead.\n\t * @return {Vector3} The updated vertex position.\n\t */\n\tapplyBoneTransform( index, target ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( target ).applyMatrix4( this.bindMatrix );\n\n\t\ttarget.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\ttarget.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nexport { SkinnedMesh };\n"],"mappings":"OAASA,SAAY,mBACZC,SAAY,yBACZC,YAAe,4BACfC,WAAc,2BACdC,YAAe,4BACfC,YAAe,4BACfC,QAAW,wBACXC,iBAAkBC,qBAAwB,kBAEnD,MAAMC,cAA8B,IAAIL,QAElCM,WAA2B,IAAIL,QAC/BM,YAA4B,IAAIN,QAEhCO,SAAyB,IAAIR,QAC7BS,SAAyB,IAAIX,QAC7BY,QAAwB,IAAIV,QAE5BW,QAAwB,IAAIZ,OAC5Ba,eAA+B,IAAId,QACnCe,KAAqB,IAAIX,IAe/B,MAAMY,oBAAoBlB,KAQzB,WAAAmB,CAAaC,EAAUC,GAEtBC,MAAOF,EAAUC,GASjBE,KAAKC,eAAgB,EAErBD,KAAKE,KAAO,cAUZF,KAAKG,SAAWnB,iBAOhBgB,KAAKI,WAAa,IAAIzB,QAOtBqB,KAAKK,kBAAoB,IAAI1B,QAQ7BqB,KAAKM,YAAc,KAQnBN,KAAKO,eAAiB,IAEvB,CAQA,kBAAAC,GAEC,MAAMX,EAAWG,KAAKH,SAEI,OAArBG,KAAKM,cAETN,KAAKM,YAAc,IAAI5B,MAIxBsB,KAAKM,YAAYG,YAEjB,MAAMC,EAAoBb,EAASc,aAAc,YAEjD,IAAM,IAAIC,EAAI,EAAGA,EAAIF,EAAkBG,MAAOD,IAE7CZ,KAAKc,kBAAmBF,EAAGrB,SAC3BS,KAAKM,YAAYS,cAAexB,QAIlC,CAQA,qBAAAyB,GAEC,MAAMnB,EAAWG,KAAKH,SAEO,OAAxBG,KAAKO,iBAETP,KAAKO,eAAiB,IAAI3B,QAI3BoB,KAAKO,eAAeE,YAEpB,MAAMC,EAAoBb,EAASc,aAAc,YAEjD,IAAM,IAAIC,EAAI,EAAGA,EAAIF,EAAkBG,MAAOD,IAE7CZ,KAAKc,kBAAmBF,EAAGrB,SAC3BS,KAAKO,eAAeQ,cAAexB,QAIrC,CAEA,IAAA0B,CAAMC,EAAQC,GAab,OAXApB,MAAMkB,KAAMC,EAAQC,GAEpBnB,KAAKG,SAAWe,EAAOf,SACvBH,KAAKI,WAAWa,KAAMC,EAAOd,YAC7BJ,KAAKK,kBAAkBY,KAAMC,EAAOb,mBAEpCL,KAAKoB,SAAWF,EAAOE,SAEK,OAAvBF,EAAOZ,cAAuBN,KAAKM,YAAcY,EAAOZ,YAAYe,SAC1C,OAA1BH,EAAOX,iBAA0BP,KAAKO,eAAiBW,EAAOX,eAAec,SAE3ErB,IAER,CAEA,OAAAsB,CAASC,EAAWC,GAEnB,MAAM1B,EAAWE,KAAKF,SAChB2B,EAAczB,KAAKyB,iBAEPC,IAAb5B,IAIwB,OAAxBE,KAAKO,gBAA0BP,KAAKgB,wBAEzCxB,QAAQyB,KAAMjB,KAAKO,gBACnBf,QAAQmC,aAAcF,IAE6B,IAA9CF,EAAUK,IAAIC,iBAAkBrC,WAIrCC,eAAewB,KAAMQ,GAAcK,SACnCpC,KAAKuB,KAAMM,EAAUK,KAAMD,aAAclC,gBAIf,OAArBO,KAAKM,cAEuC,IAA3CZ,KAAKqC,cAAe/B,KAAKM,cAM/BN,KAAKgC,sBAAuBT,EAAWC,EAAY9B,OAEpD,CAEA,iBAAAoB,CAAmBmB,EAAOC,GAMzB,OAJAnC,MAAMe,kBAAmBmB,EAAOC,GAEhClC,KAAKmC,mBAAoBF,EAAOC,GAEzBA,CAER,CASA,IAAAE,CAAMhB,EAAUhB,GAEfJ,KAAKoB,SAAWA,OAEIM,IAAftB,IAEJJ,KAAKqC,mBAAmB,GAExBrC,KAAKoB,SAASkB,oBAEdlC,EAAaJ,KAAKyB,aAInBzB,KAAKI,WAAWa,KAAMb,GACtBJ,KAAKK,kBAAkBY,KAAMb,GAAa0B,QAE3C,CAKA,IAAAS,GAECvC,KAAKoB,SAASmB,MAEf,CAMA,oBAAAC,GAEC,MAAMC,EAAS,IAAI3D,QAEb4D,EAAa1C,KAAKH,SAAS8C,WAAWD,WAE5C,IAAM,IAAI9B,EAAI,EAAGgC,EAAIF,EAAW7B,MAAOD,EAAIgC,EAAGhC,IAAO,CAEpD6B,EAAOI,oBAAqBH,EAAY9B,GAExC,MAAMkC,EAAQ,EAAML,EAAOM,kBAEtBD,IAAUE,IAEdP,EAAOQ,eAAgBH,GAIvBL,EAAOS,IAAK,EAAG,EAAG,EAAG,GAItBR,EAAWS,QAASvC,EAAG6B,EAAOW,EAAGX,EAAOY,EAAGZ,EAAOa,EAAGb,EAAOc,EAE7D,CAED,CAEA,iBAAAlB,CAAmBmB,GAElBzD,MAAMsC,kBAAmBmB,GAEpBxD,KAAKG,WAAanB,iBAEtBgB,KAAKK,kBAAkBY,KAAMjB,KAAKyB,aAAcK,SAErC9B,KAAKG,WAAalB,iBAE7Be,KAAKK,kBAAkBY,KAAMjB,KAAKI,YAAa0B,SAI/C2B,QAAQC,KAAM,6CAA+C1D,KAAKG,SAIpE,CAWA,kBAAAgC,CAAoBF,EAAOC,GAE1B,MAAMd,EAAWpB,KAAKoB,SAChBvB,EAAWG,KAAKH,SAEtBV,WAAW0D,oBAAqBhD,EAAS8C,WAAWgB,UAAW1B,GAC/D7C,YAAYyD,oBAAqBhD,EAAS8C,WAAWD,WAAYT,GAEjE/C,cAAc+B,KAAMiB,GAASP,aAAc3B,KAAKI,YAEhD8B,EAAOgB,IAAK,EAAG,EAAG,GAElB,IAAM,IAAItC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMgD,EAASxE,YAAYyE,aAAcjD,GAEzC,GAAgB,IAAXgD,EAAe,CAEnB,MAAME,EAAY3E,WAAW0E,aAAcjD,GAE3CtB,SAASyE,iBAAkB3C,EAAS4C,MAAOF,GAAYrC,YAAaL,EAAS6C,aAAcH,IAE3F5B,EAAOgC,gBAAiB7E,SAAS4B,KAAM/B,eAAgByC,aAAcrC,UAAYsE,EAElF,CAED,CAEA,OAAO1B,EAAOP,aAAc3B,KAAKK,kBAElC,SAIQV","ignoreList":[]}