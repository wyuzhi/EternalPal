import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";import{Matrix4}from"../math/Matrix4.js";import{Triangle}from"../math/Triangle.js";import{Object3D}from"../core/Object3D.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{InterleavedBuffer}from"../core/InterleavedBuffer.js";import{InterleavedBufferAttribute}from"../core/InterleavedBufferAttribute.js";import{SpriteMaterial}from"../materials/SpriteMaterial.js";let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(t=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",void 0===_geometry){_geometry=new BufferGeometry;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new InterleavedBuffer(t,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(e,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(e,2,3,!1))}this.geometry=_geometry,this.material=t,this.center=new Vector2(.5,.5),this.count=1}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&_worldScale.multiplyScalar(-_mvPosition.z);const r=this.material.rotation;let o,i;0!==r&&(i=Math.cos(r),o=Math.sin(r));const n=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,n,_worldScale,o,i),transformVertex(_vB.set(.5,-.5,0),_mvPosition,n,_worldScale,o,i),transformVertex(_vC.set(.5,.5,0),_mvPosition,n,_worldScale,o,i),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let a=t.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(null===a&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,n,_worldScale,o,i),_uvB.set(0,1),a=t.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),null===a))return;const s=t.ray.origin.distanceTo(_intersectPoint);s<t.near||s>t.far||e.push({distance:s,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function transformVertex(t,e,r,o,i,n){_alignedPosition.subVectors(t,r).addScalar(.5).multiply(o),void 0!==i?(_rotatedPosition.x=n*_alignedPosition.x-i*_alignedPosition.y,_rotatedPosition.y=i*_alignedPosition.x+n*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),t.copy(e),t.x+=_rotatedPosition.x,t.y+=_rotatedPosition.y,t.applyMatrix4(_viewWorldMatrix)}export{Sprite};
//# sourceMappingURL=Sprite.js.map