{"version":3,"file":"node_modules/three/src/renderers/WebGLCubeRenderTarget.js","names":["BackSide","LinearFilter","LinearMipmapLinearFilter","NoBlending","Mesh","BoxGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","CubeTexture","WebGLCubeRenderTarget","constructor","size","options","super","this","isWebGLCubeRenderTarget","image","width","height","depth","images","texture","_setTextureOptions","isRenderTargetTexture","fromEquirectangularTexture","renderer","type","colorSpace","generateMipmaps","minFilter","magFilter","shader","uniforms","tEquirect","value","vertexShader","fragmentShader","geometry","material","name","side","blending","mesh","currentMinFilter","update","dispose","clear","color","stencil","currentRenderTarget","getRenderTarget","i","setRenderTarget"],"sources":["node_modules/three/src/renderers/WebGLCubeRenderTarget.js"],"sourcesContent":["import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\n\n/**\n * A cube render target used in context of {@link WebGLRenderer}.\n *\n * @augments WebGLRenderTarget\n */\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\t/**\n\t * Constructs a new cube render target.\n\t *\n\t * @param {number} [size=1] - The size of the render target.\n\t * @param {RenderTarget~Options} [options] - The configuration object.\n\t */\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\t/**\n\t\t * Overwritten with a different texture type.\n\t\t *\n\t\t * @type {DataArrayTexture}\n\t\t */\n\t\tthis.texture = new CubeTexture( images );\n\t\tthis._setTextureOptions( options );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n\t/**\n\t * Converts the given equirectangular texture to a cube map.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {Texture} texture - The equirectangular texture.\n\t * @return {WebGLCubeRenderTarget} A reference to this cube render target.\n\t */\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears this cube render target.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t */\n\tclear( renderer, color = true, depth = true, stencil = true ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nexport { WebGLCubeRenderTarget };\n"],"mappings":"OAASA,SAAUC,aAAcC,yBAA0BC,eAAkB,yBACpEC,SAAY,4BACZC,gBAAmB,sCACnBC,mBAAsB,wCACtBC,kBAAqB,oCACrBC,sBAAyB,gCACzBC,eAAkB,kCAClBC,gBAAmB,6BAO5B,MAAMC,8BAA8BH,kBAQnC,WAAAI,CAAaC,EAAO,EAAGC,EAAU,CAAC,GAEjCC,MAAOF,EAAMA,EAAMC,GASnBE,KAAKC,yBAA0B,EAE/B,MAAMC,EAAQ,CAAEC,MAAON,EAAMO,OAAQP,EAAMQ,MAAO,GAC5CC,EAAS,CAAEJ,EAAOA,EAAOA,EAAOA,EAAOA,EAAOA,GAOpDF,KAAKO,QAAU,IAAIb,YAAaY,GAChCN,KAAKQ,mBAAoBV,GAUzBE,KAAKO,QAAQE,uBAAwB,CAEtC,CASA,0BAAAC,CAA4BC,EAAUJ,GAErCP,KAAKO,QAAQK,KAAOL,EAAQK,KAC5BZ,KAAKO,QAAQM,WAAaN,EAAQM,WAElCb,KAAKO,QAAQO,gBAAkBP,EAAQO,gBACvCd,KAAKO,QAAQQ,UAAYR,EAAQQ,UACjCf,KAAKO,QAAQS,UAAYT,EAAQS,UAEjC,MAAMC,EAAS,CAEdC,SAAU,CACTC,UAAW,CAAEC,MAAO,OAGrBC,aAAwB,qYAoBxBC,eAA0B,gVAoBrBC,EAAW,IAAIlC,YAAa,EAAG,EAAG,GAElCmC,EAAW,IAAIlC,eAAgB,CAEpCmC,KAAM,sBAENP,SAAU3B,cAAe0B,EAAOC,UAChCG,aAAcJ,EAAOI,aACrBC,eAAgBL,EAAOK,eACvBI,KAAM1C,SACN2C,SAAUxC,aAIXqC,EAASN,SAASC,UAAUC,MAAQb,EAEpC,MAAMqB,EAAO,IAAIxC,KAAMmC,EAAUC,GAE3BK,EAAmBtB,EAAQQ,UAG5BR,EAAQQ,YAAc7B,2BAA2BqB,EAAQQ,UAAY9B,cAU1E,OARe,IAAIQ,WAAY,EAAG,GAAIO,MAC/B8B,OAAQnB,EAAUiB,GAEzBrB,EAAQQ,UAAYc,EAEpBD,EAAKL,SAASQ,UACdH,EAAKJ,SAASO,UAEP/B,IAER,CAUA,KAAAgC,CAAOrB,EAAUsB,GAAQ,EAAM5B,GAAQ,EAAM6B,GAAU,GAEtD,MAAMC,EAAsBxB,EAASyB,kBAErC,IAAM,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAEvB1B,EAAS2B,gBAAiBtC,KAAMqC,GAEhC1B,EAASqB,MAAOC,EAAO5B,EAAO6B,GAI/BvB,EAAS2B,gBAAiBH,EAE3B,SAIQxC","ignoreList":[]}