{"version":3,"file":"node_modules/three/src/renderers/WebGLRenderer.js","names":["REVISION","BackSide","FrontSide","DoubleSide","HalfFloatType","UnsignedByteType","NoToneMapping","LinearMipmapLinearFilter","SRGBColorSpace","LinearSRGBColorSpace","RGBAIntegerFormat","RGIntegerFormat","RedIntegerFormat","UnsignedIntType","UnsignedShortType","UnsignedInt248Type","UnsignedShort4444Type","UnsignedShort5551Type","WebGLCoordinateSystem","Color","Frustum","Matrix4","Vector3","Vector4","WebGLAnimation","WebGLAttributes","WebGLBackground","WebGLBindingStates","WebGLBufferRenderer","WebGLCapabilities","WebGLClipping","WebGLCubeMaps","WebGLCubeUVMaps","WebGLExtensions","WebGLGeometries","WebGLIndexedBufferRenderer","WebGLInfo","WebGLMorphtargets","WebGLObjects","WebGLPrograms","WebGLProperties","WebGLRenderLists","WebGLRenderStates","WebGLRenderTarget","WebGLShadowMap","WebGLState","WebGLTextures","WebGLUniforms","WebGLUtils","WebXRManager","WebGLMaterials","WebGLUniformsGroups","createCanvasElement","probeAsync","warnOnce","ColorManagement","WebGLRenderer","constructor","parameters","canvas","context","depth","stencil","alpha","antialias","premultipliedAlpha","preserveDrawingBuffer","powerPreference","failIfMajorPerformanceCaveat","reversedDepthBuffer","_alpha","this","isWebGLRenderer","WebGLRenderingContext","Error","getContextAttributes","uintClearColor","Uint32Array","intClearColor","Int32Array","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","debug","checkShaderErrors","onShaderError","autoClear","autoClearColor","autoClearDepth","autoClearStencil","sortObjects","clippingPlanes","localClippingEnabled","toneMapping","toneMappingExposure","transmissionResolutionScale","_this","_isContextLost","_outputColorSpace","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_currentClearColor","_currentClearAlpha","_width","width","_height","height","_pixelRatio","_opaqueSort","_transparentSort","_viewport","_scissor","_scissorTest","_frustum","_clippingEnabled","_localClippingEnabled","_projScreenMatrix","_vector3","_vector4","_emptyScene","background","fog","environment","overrideMaterial","isScene","_renderBackground","getTargetPixelRatio","extensions","capabilities","state","info","properties","textures","cubemaps","cubeuvmaps","attributes","geometries","objects","programCache","materials","renderLists","renderStates","clipping","shadowMap","morphtargets","bufferRenderer","indexedBufferRenderer","utils","bindingStates","uniformsGroups","_gl","getContext","contextName","contextAttributes","setAttribute","addEventListener","onContextLost","onContextRestore","onContextCreationError","error","console","message","initGLContext","init","buffers","setReversed","programs","xr","event","preventDefault","log","infoAutoReset","autoReset","shadowMapEnabled","enabled","shadowMapAutoUpdate","autoUpdate","shadowMapNeedsUpdate","needsUpdate","shadowMapType","type","statusMessage","onMaterialDispose","material","target","removeEventListener","get","undefined","forEach","program","releaseProgram","isShaderMaterial","releaseShaderCache","releaseMaterialProgramReferences","remove","deallocateMaterial","prepareMaterial","scene","object","transparent","side","forceSinglePass","getProgram","forceContextLoss","extension","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","value","setSize","getSize","set","updateStyle","isPresenting","warn","Math","floor","style","setViewport","getDrawingBufferSize","setDrawingBufferSize","pixelRatio","getCurrentViewport","copy","getViewport","x","y","isVector4","z","w","viewport","multiplyScalar","round","getScissor","setScissor","scissor","getScissorTest","setScissorTest","boolean","setOpaqueSort","method","setTransparentSort","getClearColor","setClearColor","arguments","getClearAlpha","setClearAlpha","clear","color","bits","isIntegerFormat","targetFormat","texture","format","targetType","isUnsignedType","clearColor","a","r","g","b","clearBufferuiv","COLOR","clearBufferiv","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","setMask","clearDepth","clearStencil","dispose","onXRSessionStart","onXRSessionEnd","animation","stop","renderBufferDirect","camera","geometry","group","frontFaceCW","isMesh","matrixWorld","determinant","resetTextureUnits","isMeshStandardMaterial","colorSpace","outputColorSpace","isXRRenderTarget","envMap","vertexAlphas","vertexColors","itemSize","vertexTangents","tangent","normalMap","anisotropy","morphTargets","morphAttributes","position","morphNormals","normal","morphColors","toneMapped","morphAttribute","morphTargetsCount","length","materialProperties","lights","useCache","id","setState","needsProgramChange","version","__version","needsLights","lightsStateVersion","isBatchedMesh","batching","batchingColor","colorTexture","isInstancedMesh","instancing","isSkinnedMesh","skinning","instancingColor","instanceColor","instancingMorph","morphTexture","numClippingPlanes","numPlanes","numIntersection","currentProgram","refreshProgram","refreshMaterial","refreshLights","p_uniforms","getUniforms","m_uniforms","uniforms","useProgram","getReversed","reversedDepth","_reversedDepth","updateProjectionMatrix","setValue","projectionMatrix","matrixWorldInverse","uCamPos","map","cameraPosition","setFromMatrixPosition","logarithmicDepthBuffer","far","LN2","isMeshPhongMaterial","isMeshToonMaterial","isMeshLambertMaterial","isMeshBasicMaterial","isOrthographicCamera","setOptional","skeleton","boneTexture","computeBoneTexture","_matricesTexture","_indirectTexture","_colorsTexture","update","receiveShadow","isMeshGouraudMaterial","flipEnvMap","isCubeTexture","isRenderTargetTexture","envMapIntensity","environmentIntensity","ambientLightColor","lightProbe","directionalLights","directionalLightShadows","pointLights","pointLightShadows","spotLights","spotLightShadows","rectAreaLights","hemisphereLights","refreshFogUniforms","refreshMaterialUniforms","transmissionRenderTarget","upload","getUniformList","uniformsNeedUpdate","isSpriteMaterial","center","modelViewMatrix","normalMatrix","isRawShaderMaterial","groups","i","l","bind","setProgram","setMaterial","index","rangeFactor","wireframe","getWireframeAttribute","drawRange","drawStart","start","drawEnd","count","max","min","drawCount","Infinity","attribute","setup","renderer","setIndex","setLineWidth","wireframeLinewidth","setMode","LINES","TRIANGLES","isLine","lineWidth","linewidth","isLineSegments","isLineLoop","LINE_LOOP","LINE_STRIP","isPoints","POINTS","isSprite","_multiDrawInstances","renderMultiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","renderMultiDraw","starts","counts","bytesPerElement","render","renderInstances","isInstancedBufferGeometry","maxInstanceCount","_maxInstanceCount","instanceCount","compile","targetScene","push","traverseVisible","isLight","layers","test","pushLight","castShadow","pushShadow","setupLights","Set","traverse","Array","isArray","material2","add","pop","compileAsync","Promise","resolve","checkMaterialsReady","isReady","delete","size","setTimeout","onAnimationFrameCallback","projectObject","groupOrder","visible","isGroup","renderOrder","isLOD","frustumCulled","intersectsSprite","applyMatrix4","intersectsObject","boundingSphere","computeBoundingSphere","groupMaterial","materialIndex","children","renderScene","opaqueObjects","opaque","transmissiveObjects","transmissive","transparentObjects","setupLightsView","setGlobalState","renderObjects","setTest","setPolygonOffset","renderTransmissionPass","generateMipmaps","has","minFilter","samples","stencilBuffer","resolveDepthBuffer","resolveStencilBuffer","workingColorSpace","activeViewport","currentRenderTarget","getRenderTarget","currentActiveCubeFace","getActiveCubeFace","currentActiveMipmapLevel","getActiveMipmapLevel","setRenderTarget","currentToneMapping","currentCameraViewport","updateMultisampleRenderTarget","updateRenderTargetMipmap","renderTargetNeedsUpdate","renderItem","currentSide","renderObject","renderList","allowOverride","onBeforeRender","multiplyMatrices","getNormalMatrix","onAfterRender","shadowsArray","getParameters","programCacheKey","getProgramCacheKey","envMapRotation","environmentRotation","Map","updateCommonMaterialProperties","onBeforeCompile","acquireProgram","uniform","isShadowMaterial","materialNeedsLights","ambient","probe","directional","directionalShadow","spot","spotShadow","rectArea","ltc_1","rectAreaLTC1","ltc_2","rectAreaLTC2","point","pointShadow","hemi","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotLightMatrix","spotLightMap","pointShadowMap","pointShadowMatrix","uniformsList","progUniforms","seqWithValue","seq","numClipIntersection","setAnimationLoop","time","self","setContext","callback","isCamera","matrixWorldAutoUpdate","updateMatrixWorld","parent","cameraAutoUpdate","updateCamera","getCamera","setFromProjectionMatrix","depthSensingMesh","getDepthSensingMesh","finish","sort","hasDepthSensing","addToRenderList","frame","beginShadows","endShadows","reset","isArrayCamera","cameras","camera2","resetDefaultState","setRenderTargetTextures","renderTarget","depthTexture","renderTargetProperties","__autoAllocateDepthBuffer","__useRenderToTexture","__webglTexture","__hasExternalTextures","setRenderTargetFramebuffer","defaultFramebuffer","__webglFramebuffer","__useDefaultFramebuffer","_scratchFrameBuffer","createFramebuffer","activeCubeFace","activeMipmapLevel","useDefaultFramebuffer","framebuffer","isCube","isRenderTarget3D","bindFramebuffer","FRAMEBUFFER","setupRenderTarget","rebindTextures","depthBuffer","__boundDepthTexture","image","setupDepthRenderbuffer","isData3DTexture","isDataArrayTexture","isCompressedArrayTexture","isWebGLCubeRenderTarget","useMultisampledRTT","__webglMultisampledFramebuffer","scissorTest","drawBuffers","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","layer","framebufferTextureLayer","TEXTURE_2D","readRenderTargetPixels","buffer","activeCubeFaceIndex","textureIndex","isWebGLRenderTarget","textureFormat","textureType","textureFormatReadable","textureTypeReadable","readBuffer","readPixels","convert","readRenderTargetPixelsAsync","async","glBuffer","createBuffer","bindBuffer","PIXEL_PACK_BUFFER","bufferData","byteLength","STREAM_READ","currFramebuffer","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","getBufferSubData","deleteBuffer","deleteSync","copyFramebufferToTexture","level","levelScale","pow","setTexture2D","copyTexSubImage2D","unbindTexture","_srcFramebuffer","_dstFramebuffer","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","srcLevel","dstLevel","minX","minY","minZ","dstX","dstY","dstZ","isCompressedTexture","mipmaps","isBox3","glFormat","glType","glTarget","setTexture3D","TEXTURE_3D","setTexture2DArray","TEXTURE_2D_ARRAY","pixelStorei","UNPACK_FLIP_Y_WEBGL","flipY","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","currentUnpackRowLen","getParameter","UNPACK_ROW_LENGTH","currentUnpackImageHeight","UNPACK_IMAGE_HEIGHT","currentUnpackSkipPixels","UNPACK_SKIP_PIXELS","currentUnpackSkipRows","UNPACK_SKIP_ROWS","currentUnpackSkipImages","UNPACK_SKIP_IMAGES","isSrc3D","isDst3D","isDepthTexture","srcTextureProperties","dstTextureProperties","srcRenderTargetProperties","__renderTarget","dstRenderTargetProperties","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","blitFramebuffer","NEAREST","copyTexSubImage3D","isDataTexture","texSubImage3D","data","compressedTexSubImage3D","texSubImage2D","compressedTexSubImage2D","generateMipmap","copyTextureToTexture3D","initRenderTarget","initTexture","setTextureCube","resetState","__THREE_DEVTOOLS__","dispatchEvent","CustomEvent","detail","coordinateSystem","gl","drawingBufferColorSpace","_getDrawingBufferColorSpace","unpackColorSpace","_getUnpackColorSpace"],"sources":["node_modules/three/src/renderers/WebGLRenderer.js"],"sourcesContent":["import {\n\tREVISION,\n\tBackSide,\n\tFrontSide,\n\tDoubleSide,\n\tHalfFloatType,\n\tUnsignedByteType,\n\tNoToneMapping,\n\tLinearMipmapLinearFilter,\n\tSRGBColorSpace,\n\tLinearSRGBColorSpace,\n\tRGBAIntegerFormat,\n\tRGIntegerFormat,\n\tRedIntegerFormat,\n\tUnsignedIntType,\n\tUnsignedShortType,\n\tUnsignedInt248Type,\n\tUnsignedShort4444Type,\n\tUnsignedShort5551Type,\n\tWebGLCoordinateSystem\n} from '../constants.js';\nimport { Color } from '../math/Color.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { WebGLAnimation } from './webgl/WebGLAnimation.js';\nimport { WebGLAttributes } from './webgl/WebGLAttributes.js';\nimport { WebGLBackground } from './webgl/WebGLBackground.js';\nimport { WebGLBindingStates } from './webgl/WebGLBindingStates.js';\nimport { WebGLBufferRenderer } from './webgl/WebGLBufferRenderer.js';\nimport { WebGLCapabilities } from './webgl/WebGLCapabilities.js';\nimport { WebGLClipping } from './webgl/WebGLClipping.js';\nimport { WebGLCubeMaps } from './webgl/WebGLCubeMaps.js';\nimport { WebGLCubeUVMaps } from './webgl/WebGLCubeUVMaps.js';\nimport { WebGLExtensions } from './webgl/WebGLExtensions.js';\nimport { WebGLGeometries } from './webgl/WebGLGeometries.js';\nimport { WebGLIndexedBufferRenderer } from './webgl/WebGLIndexedBufferRenderer.js';\nimport { WebGLInfo } from './webgl/WebGLInfo.js';\nimport { WebGLMorphtargets } from './webgl/WebGLMorphtargets.js';\nimport { WebGLObjects } from './webgl/WebGLObjects.js';\nimport { WebGLPrograms } from './webgl/WebGLPrograms.js';\nimport { WebGLProperties } from './webgl/WebGLProperties.js';\nimport { WebGLRenderLists } from './webgl/WebGLRenderLists.js';\nimport { WebGLRenderStates } from './webgl/WebGLRenderStates.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { WebGLShadowMap } from './webgl/WebGLShadowMap.js';\nimport { WebGLState } from './webgl/WebGLState.js';\nimport { WebGLTextures } from './webgl/WebGLTextures.js';\nimport { WebGLUniforms } from './webgl/WebGLUniforms.js';\nimport { WebGLUtils } from './webgl/WebGLUtils.js';\nimport { WebXRManager } from './webxr/WebXRManager.js';\nimport { WebGLMaterials } from './webgl/WebGLMaterials.js';\nimport { WebGLUniformsGroups } from './webgl/WebGLUniformsGroups.js';\nimport { createCanvasElement, probeAsync, warnOnce } from '../utils.js';\nimport { ColorManagement } from '../math/ColorManagement.js';\n\n/**\n * This renderer uses WebGL 2 to display scenes.\n *\n * WebGL 1 is not supported since `r163`.\n */\nclass WebGLRenderer {\n\n\t/**\n\t * Constructs a new WebGL renderer.\n\t *\n\t * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tconst {\n\t\t\tcanvas = createCanvasElement(),\n\t\t\tcontext = null,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\talpha = false,\n\t\t\tantialias = false,\n\t\t\tpremultipliedAlpha = true,\n\t\t\tpreserveDrawingBuffer = false,\n\t\t\tpowerPreference = 'default',\n\t\t\tfailIfMajorPerformanceCaveat = false,\n\t\t\treversedDepthBuffer = false,\n\t\t} = parameters;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLRenderer = true;\n\n\t\tlet _alpha;\n\n\t\tif ( context !== null ) {\n\n\t\t\tif ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );\n\n\t\t\t}\n\n\t\t\t_alpha = context.getContextAttributes().alpha;\n\n\t\t} else {\n\n\t\t\t_alpha = alpha;\n\n\t\t}\n\n\t\tconst uintClearColor = new Uint32Array( 4 );\n\t\tconst intClearColor = new Int32Array( 4 );\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null;\n\n\t\t// render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = [];\n\n\t\t// public properties\n\n\t\t/**\n\t\t * A canvas where the renderer draws its output.This is automatically created by the renderer\n\t\t * in the constructor (if not provided already); you just need to add it to your page like so:\n\t\t * ```js\n\t\t * document.body.appendChild( renderer.domElement );\n\t\t * ```\n\t\t *\n\t\t * @type {DOMElement}\n\t\t */\n\t\tthis.domElement = canvas;\n\n\t\t/**\n\t\t * A object with debug configuration settings.\n\t\t *\n\t\t * - `checkShaderErrors`: If it is `true`, defines whether material shader programs are\n\t\t * checked for errors during compilation and linkage process. It may be useful to disable\n\t\t * this check in production for performance gain. It is strongly recommended to keep these\n\t\t * checks enabled during development. If the shader does not compile and link - it will not\n\t\t * work and associated material will not render.\n\t\t * - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that\n\t\t * can be used for custom error reporting. The callback receives the WebGL context, an instance\n\t\t * of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.\n\t\t * Assigning a custom function disables the default error reporting.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.debug = {\n\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true,\n\t\t\t/**\n\t\t\t * Callback for custom error reporting.\n\t\t\t * @type {?Function}\n\t\t\t */\n\t\t\tonShaderError: null\n\t\t};\n\n\t\t// clearing\n\n\t\t/**\n\t\t * Whether the renderer should automatically clear its output before rendering a frame or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear\n\t\t * the color buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearColor = true;\n\n\t\t/**\n\t\t * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear\n\t\t * the depth buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearDepth = true;\n\n\t\t/**\n\t\t * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear\n\t\t * the stencil buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\t/**\n\t\t * Whether the renderer should sort objects or not.\n\t\t *\n\t\t * Note: Sorting is used to attempt to properly render objects that have some\n\t\t * degree of transparency. By definition, sorting objects may not work in all\n\t\t * cases. Depending on the needs of application, it may be necessary to turn\n\t\t * off sorting and use other methods to deal with transparency rendering e.g.\n\t\t * manually determining each object's rendering order.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\t/**\n\t\t * User-defined clipping planes specified in world space. These planes apply globally.\n\t\t * Points in space whose dot product with the plane is negative are cut away.\n\t\t *\n\t\t * @type {Array<Plane>}\n\t\t */\n\t\tthis.clippingPlanes = [];\n\n\t\t/**\n\t\t * Whether the renderer respects object-level clipping planes or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.localClippingEnabled = false;\n\n\t\t// tone mapping\n\n\t\t/**\n\t\t * The tone mapping technique of the renderer.\n\t\t *\n\t\t * @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}\n\t\t * @default NoToneMapping\n\t\t */\n\t\tthis.toneMapping = NoToneMapping;\n\n\t\t/**\n\t\t * Exposure level of tone mapping.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t// transmission\n\n\t\t/**\n\t\t * The normalized resolution scale for the transmission render target, measured in percentage\n\t\t * of viewport dimensions. Lowering this value can result in significant performance improvements\n\t\t * when using {@link MeshPhysicalMaterial#transmission}.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.transmissionResolutionScale = 1.0;\n\n\t\t// internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false;\n\n\t\t// internal state cache\n\n\t\tthis._outputColorSpace = SRGBColorSpace;\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\t\tlet _currentMaterialId = - 1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\t\tconst _currentScissor = new Vector4();\n\t\tlet _currentScissorTest = null;\n\n\t\tconst _currentClearColor = new Color( 0x000000 );\n\t\tlet _currentClearAlpha = 0;\n\n\t\t//\n\n\t\tlet _width = canvas.width;\n\t\tlet _height = canvas.height;\n\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\t\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\t\tlet _scissorTest = false;\n\n\t\t// frustum\n\n\t\tconst _frustum = new Frustum();\n\n\t\t// clipping\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false;\n\n\t\t// camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _vector4 = new Vector4();\n\n\t\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\t\tlet _renderBackground = false;\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tlet _gl = context;\n\n\t\tfunction getContext( contextName, contextAttributes ) {\n\n\t\t\treturn canvas.getContext( contextName, contextAttributes );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: true,\n\t\t\t\tdepth,\n\t\t\t\tstencil,\n\t\t\t\tantialias,\n\t\t\t\tpremultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer,\n\t\t\t\tpowerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat,\n\t\t\t};\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t\tcanvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tconst contextName = 'webgl2';\n\n\t\t\t\t_gl = getContext( contextName, contextAttributes );\n\n\t\t\t\tif ( _gl === null ) {\n\n\t\t\t\t\tif ( getContext( contextName ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\t\tthrow error;\n\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\t\tlet utils, bindingStates, uniformsGroups;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\textensions.init();\n\n\t\t\tutils = new WebGLUtils( _gl, extensions );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );\n\n\t\t\tstate = new WebGLState( _gl, extensions );\n\n\t\t\tif ( capabilities.reversedDepthBuffer && reversedDepthBuffer ) {\n\n\t\t\t\tstate.buffers.depth.setReversed( true );\n\n\t\t\t}\n\n\t\t\tinfo = new WebGLInfo( _gl );\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\tbindingStates = new WebGLBindingStates( _gl, attributes );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\t\tclipping = new WebGLClipping( properties );\n\t\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates( extensions );\n\t\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );\n\t\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );\n\n\t\t\tinfo.programs = programCache.programs;\n\n\t\t\t/**\n\t\t\t * Holds details about the capabilities of the current rendering context.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#capabilities\n\t\t\t * @type {WebGLRenderer~Capabilities}\n\t\t\t */\n\t\t\t_this.capabilities = capabilities;\n\n\t\t\t/**\n\t\t\t * Provides methods for retrieving and testing WebGL extensions.\n\t\t\t *\n\t\t\t * - `get(extensionName:string)`: Used to check whether a WebGL extension is supported\n\t\t\t * and return the extension object if available.\n\t\t\t * - `has(extensionName:string)`: returns `true` if the extension is supported.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#extensions\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\t_this.extensions = extensions;\n\n\t\t\t/**\n\t\t\t * Used to track properties of other objects like native WebGL objects.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#properties\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\t_this.properties = properties;\n\n\t\t\t/**\n\t\t\t * Manages the render lists of the renderer.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#renderLists\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\t_this.renderLists = renderLists;\n\n\n\n\t\t\t/**\n\t\t\t * Interface for managing shadows.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#shadowMap\n\t\t\t * @type {WebGLRenderer~ShadowMap}\n\t\t\t */\n\t\t\t_this.shadowMap = shadowMap;\n\n\t\t\t/**\n\t\t\t * Interface for managing the WebGL state.\n\t\t\t *\n\t\t\t * @name WebGLRenderer#state\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\t_this.state = state;\n\n\t\t\t/**\n\t\t\t * Holds a series of statistical information about the GPU memory\n\t\t\t * and the rendering process. Useful for debugging and monitoring.\n\t\t\t *\n\t\t\t * By default these data are reset at each render call but when having\n\t\t\t * multiple render passes per frame (e.g. when using post processing) it can\n\t\t\t * be preferred to reset with a custom pattern. First, set `autoReset` to\n\t\t\t * `false`.\n\t\t\t * ```js\n\t\t\t * renderer.info.autoReset = false;\n\t\t\t * ```\n\t\t\t * Call `reset()` whenever you have finished to render a single frame.\n\t\t\t * ```js\n\t\t\t * renderer.info.reset();\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @name WebGLRenderer#info\n\t\t\t * @type {WebGLRenderer~Info}\n\t\t\t */\n\t\t\t_this.info = info;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// xr\n\n\t\tconst xr = new WebXRManager( _this, _gl );\n\n\t\t/**\n\t\t * A reference to the XR manager.\n\t\t *\n\t\t * @type {WebXRManager}\n\t\t */\n\t\tthis.xr = xr;\n\n\t\t/**\n\t\t * Returns the rendering context.\n\t\t *\n\t\t * @return {WebGL2RenderingContext} The rendering context.\n\t\t */\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the rendering context attributes.\n\t\t *\n\t\t * @return {WebGLContextAttributes} The rendering context attributes.\n\t\t */\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\t/**\n\t\t * Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.\n\t\t */\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\t/**\n\t\t * Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.\n\t\t */\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the pixel ratio.\n\t\t *\n\t\t * @return {number} The pixel ratio.\n\t\t */\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets the given pixel ratio and resizes the canvas if necessary.\n\t\t *\n\t\t * @param {number} value - The pixel ratio.\n\t\t */\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t\t *\n\t\t * @param {Vector2} target - The method writes the result in this target object.\n\t\t * @return {Vector2} The renderer's size in logical pixels.\n\t\t */\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn target.set( _width, _height );\n\n\t\t};\n\n\t\t/**\n\t\t * Resizes the output canvas to (width, height) with device pixel ratio taken\n\t\t * into account, and also sets the viewport to fit that size, starting in (0,\n\t\t * 0). Setting `updateStyle` to false prevents any style changes to the output canvas.\n\t\t *\n\t\t * @param {number} width - The width in logical pixels.\n\t\t * @param {number} height - The height in logical pixels.\n\t\t * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t\t */\n\t\tthis.setSize = function ( width, height, updateStyle = true ) {\n\n\t\t\tif ( xr.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\tcanvas.width = Math.floor( width * _pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * _pixelRatio );\n\n\t\t\tif ( updateStyle === true ) {\n\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\tcanvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t\t *\n\t\t * @param {Vector2} target - The method writes the result in this target object.\n\t\t * @return {Vector2} The drawing buffer size.\n\t\t */\n\t\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t\t};\n\n\t\t/**\n\t\t * This method allows to define the drawing buffer size by specifying\n\t\t * width, height and pixel ratio all at once. The size of the drawing\n\t\t * buffer is computed with this formula:\n\t\t * ```js\n\t\t * size.x = width * pixelRatio;\n\t\t * size.y = height * pixelRatio;\n\t\t * ```\n\t\t *\n\t\t * @param {number} width - The width in logical pixels.\n\t\t * @param {number} height - The height in logical pixels.\n\t\t * @param {number} pixelRatio - The pixel ratio.\n\t\t */\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\tcanvas.width = Math.floor( width * pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * pixelRatio );\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the current viewport definition.\n\t\t *\n\t\t * @param {Vector2} target - The method writes the result in this target object.\n\t\t * @return {Vector2} The current viewport definition.\n\t\t */\n\t\tthis.getCurrentViewport = function ( target ) {\n\n\t\t\treturn target.copy( _currentViewport );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the viewport definition.\n\t\t *\n\t\t * @param {Vector4} target - The method writes the result in this target object.\n\t\t * @return {Vector4} The viewport definition.\n\t\t */\n\t\tthis.getViewport = function ( target ) {\n\n\t\t\treturn target.copy( _viewport );\n\n\t\t};\n\n\t\t/**\n\t\t * Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.\n\t\t *\n\t\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t\t * Or alternatively a four-component vector specifying all the parameters of the viewport.\n\t\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t\t */\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the scissor region.\n\t\t *\n\t\t * @param {Vector4} target - The method writes the result in this target object.\n\t\t * @return {Vector4} The scissor region.\n\t\t */\n\t\tthis.getScissor = function ( target ) {\n\n\t\t\treturn target.copy( _scissor );\n\n\t\t};\n\n\t\t/**\n\t\t * Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.\n\t\t *\n\t\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.\n\t\t * Or alternatively a four-component vector specifying all the parameters of the scissor region.\n\t\t * @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.\n\t\t * @param {number} width - The width of the scissor region in logical pixel unit.\n\t\t * @param {number} height - The height of the scissor region in logical pixel unit.\n\t\t */\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns `true` if the scissor test is enabled.\n\t\t *\n\t\t * @return {boolean} Whether the scissor test is enabled or not.\n\t\t */\n\t\tthis.getScissorTest = function () {\n\n\t\t\treturn _scissorTest;\n\n\t\t};\n\n\t\t/**\n\t\t * Enable or disable the scissor test. When this is enabled, only the pixels\n\t\t * within the defined scissor area will be affected by further renderer\n\t\t * actions.\n\t\t *\n\t\t * @param {boolean} boolean - Whether the scissor test is enabled or not.\n\t\t */\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t/**\n\t\t * Sets a custom opaque sort function for the render lists. Pass `null`\n\t\t * to use the default `painterSortStable` function.\n\t\t *\n\t\t * @param {?Function} method - The opaque sort function.\n\t\t */\n\t\tthis.setOpaqueSort = function ( method ) {\n\n\t\t\t_opaqueSort = method;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets a custom transparent sort function for the render lists. Pass `null`\n\t\t * to use the default `reversePainterSortStable` function.\n\t\t *\n\t\t * @param {?Function} method - The opaque sort function.\n\t\t */\n\t\tthis.setTransparentSort = function ( method ) {\n\n\t\t\t_transparentSort = method;\n\n\t\t};\n\n\t\t// Clearing\n\n\t\t/**\n\t\t * Returns the clear color.\n\t\t *\n\t\t * @param {Color} target - The method writes the result in this target object.\n\t\t * @return {Color} The clear color.\n\t\t */\n\t\tthis.getClearColor = function ( target ) {\n\n\t\t\treturn target.copy( background.getClearColor() );\n\n\t\t};\n\n\t\t/**\n\t\t * Sets the clear color and alpha.\n\t\t *\n\t\t * @param {Color} color - The clear color.\n\t\t * @param {number} [alpha=1] - The clear alpha.\n\t\t */\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor( ...arguments );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the clear alpha. Ranges within `[0,1]`.\n\t\t *\n\t\t * @return {number} The clear alpha.\n\t\t */\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\t/**\n\t\t * Sets the clear alpha.\n\t\t *\n\t\t * @param {number} alpha - The clear alpha.\n\t\t */\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha( ...arguments );\n\n\t\t};\n\n\t\t/**\n\t\t * Tells the renderer to clear its color, depth or stencil drawing buffer(s).\n\t\t * This method initializes the buffers to the current clear color values.\n\t\t *\n\t\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t\t */\n\t\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\t\tlet bits = 0;\n\n\t\t\tif ( color ) {\n\n\t\t\t\t// check if we're trying to clear an integer target\n\t\t\t\tlet isIntegerFormat = false;\n\t\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t\tconst targetFormat = _currentRenderTarget.texture.format;\n\t\t\t\t\tisIntegerFormat = targetFormat === RGBAIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RGIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RedIntegerFormat;\n\n\t\t\t\t}\n\n\t\t\t\t// use the appropriate clear functions to clear the target if it's a signed\n\t\t\t\t// or unsigned integer target\n\t\t\t\tif ( isIntegerFormat ) {\n\n\t\t\t\t\tconst targetType = _currentRenderTarget.texture.type;\n\t\t\t\t\tconst isUnsignedType = targetType === UnsignedByteType ||\n\t\t\t\t\t\ttargetType === UnsignedIntType ||\n\t\t\t\t\t\ttargetType === UnsignedShortType ||\n\t\t\t\t\t\ttargetType === UnsignedInt248Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort4444Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort5551Type;\n\n\t\t\t\t\tconst clearColor = background.getClearColor();\n\t\t\t\t\tconst a = background.getClearAlpha();\n\t\t\t\t\tconst r = clearColor.r;\n\t\t\t\t\tconst g = clearColor.g;\n\t\t\t\t\tconst b = clearColor.b;\n\n\t\t\t\t\tif ( isUnsignedType ) {\n\n\t\t\t\t\t\tuintClearColor[ 0 ] = r;\n\t\t\t\t\t\tuintClearColor[ 1 ] = g;\n\t\t\t\t\t\tuintClearColor[ 2 ] = b;\n\t\t\t\t\t\tuintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintClearColor[ 0 ] = r;\n\t\t\t\t\t\tintClearColor[ 1 ] = g;\n\t\t\t\t\t\tintClearColor[ 2 ] = b;\n\t\t\t\t\t\tintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbits |= _gl.COLOR_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tbits |= _gl.DEPTH_BUFFER_BIT;\n\n\t\t\t}\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tbits |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\tthis.state.buffers.stencil.setMask( 0xffffffff );\n\n\t\t\t}\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\t/**\n\t\t * Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.\n\t\t */\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\t/**\n\t\t * Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.\n\t\t */\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\t/**\n\t\t * Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.\n\t\t */\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tcanvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tbackground.dispose();\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tcubeuvmaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\tuniformsGroups.dispose();\n\t\t\tprogramCache.dispose();\n\n\t\t\txr.dispose();\n\n\t\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t\tanimation.stop();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\n\t\t\tinitGLContext();\n\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\n\t\t}\n\n\t\tfunction onContextCreationError( event ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tconst material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReferences( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\t\tconst programs = properties.get( material ).programs;\n\n\t\t\tif ( programs !== undefined ) {\n\n\t\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t//\n\n\t\t\tlet index = geometry.index;\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\n\t\t\t\tif ( index === undefined ) return;\n\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst drawRange = geometry.drawRange;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\t\tif ( group !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t\t}\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t\t}\n\n\t\t\tconst drawCount = drawEnd - drawStart;\n\n\t\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t\t//\n\n\t\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\t// @deprecated, r174\n\t\t\t\t\twarnOnce( 'THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! extensions.get( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\t\t\tconst starts = object._multiDrawStarts;\n\t\t\t\t\t\tconst counts = object._multiDrawCounts;\n\t\t\t\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\t\t\t\tconst bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;\n\t\t\t\t\t\tconst uniforms = properties.get( material ).currentProgram.getUniforms();\n\t\t\t\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\t\t\t\tuniforms.setValue( _gl, '_gl_DrawID', i );\n\t\t\t\t\t\t\trenderer.render( starts[ i ] / bytesPerElement, counts[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isInstancedMesh ) {\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Compile\n\n\t\tfunction prepareMaterial( material, scene, object ) {\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Compiles all materials in the scene with the camera. This is useful to precompile shaders\n\t\t * before the first rendering. If you want to add a 3D object to an existing scene, use the third\n\t\t * optional parameter for applying the target scene.\n\t\t *\n\t\t * Note that the (target) scene's lighting and environment must be configured before calling this method.\n\t\t *\n\t\t * @param {Object3D} scene - The scene or another type of 3D object to precompile.\n\t\t * @param {Camera} camera - The camera.\n\t\t * @param {?Scene} [targetScene=null] - The target scene.\n\t\t * @return {Set<Material>} The precompiled materials.\n\t\t */\n\t\tthis.compile = function ( scene, camera, targetScene = null ) {\n\n\t\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\t\tcurrentRenderState = renderStates.get( targetScene );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t// gather lights from both the target scene and the new object that will be added to the scene.\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( scene !== targetScene ) {\n\n\t\t\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\t// Only initialize materials in the new scene, not the targetScene.\n\n\t\t\tconst materials = new Set();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( ! ( object.isMesh || object.isPoints || object.isLine || object.isSprite ) ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\t\tprepareMaterial( material2, targetScene, object );\n\t\t\t\t\t\t\tmaterials.add( material2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprepareMaterial( material, targetScene, object );\n\t\t\t\t\t\tmaterials.add( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tcurrentRenderState = renderStateStack.pop();\n\n\t\t\treturn materials;\n\n\t\t};\n\n\t\t// compileAsync\n\n\t\t/**\n\t\t * Asynchronous version of {@link WebGLRenderer#compile}.\n\t\t *\n\t\t * This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,\n\t\t * it is recommended to use this version of `compile()` whenever possible.\n\t\t *\n\t\t * @async\n\t\t * @param {Object3D} scene - The scene or another type of 3D object to precompile.\n\t\t * @param {Camera} camera - The camera.\n\t\t * @param {?Scene} [targetScene=null] - The target scene.\n\t\t * @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.\n\t\t */\n\t\tthis.compileAsync = function ( scene, camera, targetScene = null ) {\n\n\t\t\tconst materials = this.compile( scene, camera, targetScene );\n\n\t\t\t// Wait for all the materials in the new object to indicate that they're\n\t\t\t// ready to be used before resolving the promise.\n\n\t\t\treturn new Promise( ( resolve ) => {\n\n\t\t\t\tfunction checkMaterialsReady() {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tconst materialProperties = properties.get( material );\n\t\t\t\t\t\tconst program = materialProperties.currentProgram;\n\n\t\t\t\t\t\tif ( program.isReady() ) {\n\n\t\t\t\t\t\t\t// remove any programs that report they're ready to use from the list\n\t\t\t\t\t\t\tmaterials.delete( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// once the list of compiling materials is empty, call the callback\n\n\t\t\t\t\tif ( materials.size === 0 ) {\n\n\t\t\t\t\t\tresolve( scene );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if some materials are still not ready, wait a bit and check again\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {\n\n\t\t\t\t\t// If we can check the compilation status of the materials without\n\t\t\t\t\t// blocking then do so right away.\n\n\t\t\t\t\tcheckMaterialsReady();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise start by waiting a bit to give the materials we just\n\t\t\t\t\t// initialized a chance to finish.\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time ) {\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\n\t\t\tanimation.start();\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop( callback );\n\n\t\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t\t};\n\n\t\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t// Rendering\n\n\t\t/**\n\t\t * Renders the given scene (or other type of 3D object) using the given camera.\n\t\t *\n\t\t * The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}\n\t\t * or to the canvas as usual.\n\t\t *\n\t\t * By default render buffers are cleared before rendering but you can prevent\n\t\t * this by setting the property `autoClear` to `false`. If you want to prevent\n\t\t * only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`\n\t\t * or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost === true ) return;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, WebGLCoordinateSystem, camera.reversedDepth );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\t\tcurrentRenderList.init();\n\n\t\t\trenderListStack.push( currentRenderList );\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tconst depthSensingMesh = _this.xr.getDepthSensingMesh();\n\n\t\t\t\tif ( depthSensingMesh !== null ) {\n\n\t\t\t\t\tprojectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t\t}\n\n\t\t\t_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;\n\t\t\tif ( _renderBackground ) {\n\n\t\t\t\tbackground.addToRenderList( currentRenderList, scene );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.info.render.frame ++;\n\n\t\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\t// render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\n\t\t\tcurrentRenderState.setupLights();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\t\trenderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );\n\n\t\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _currentRenderTarget !== null && _currentActiveMipmapLevel === 0 ) {\n\n\t\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t\t// _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\trenderStateStack.pop();\n\n\t\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderState = null;\n\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderList = null;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tconst visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isGroup ) {\n\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector4.copy( object.boundingSphere.center );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector4.copy( geometry.boundingSphere.center );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t}\n\n\t\tfunction renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tif ( overrideMaterial !== null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {\n\n\t\t\t\tcurrentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\ttype: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tsamples: 4,\n\t\t\t\t\tstencilBuffer: stencil,\n\t\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\t\tresolveStencilBuffer: false,\n\t\t\t\t\tcolorSpace: ColorManagement.workingColorSpace,\n\t\t\t\t} );\n\n\t\t\t\t// debug\n\n\t\t\t\t/*\n\t\t\t\tconst geometry = new PlaneGeometry();\n\t\t\t\tconst material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );\n\n\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tconst transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];\n\n\t\t\tconst activeViewport = camera.viewport || _currentViewport;\n\t\t\ttransmissionRenderTarget.setSize( activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale );\n\n\t\t\t//\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t\tconst currentActiveCubeFace = _this.getActiveCubeFace();\n\t\t\tconst currentActiveMipmapLevel = _this.getActiveMipmapLevel();\n\n\t\t\t_this.setRenderTarget( transmissionRenderTarget );\n\n\t\t\t_this.getClearColor( _currentClearColor );\n\t\t\t_currentClearAlpha = _this.getClearAlpha();\n\t\t\tif ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );\n\n\t\t\t_this.clear();\n\n\t\t\tif ( _renderBackground ) background.render( scene );\n\n\t\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\t\tconst currentToneMapping = _this.toneMapping;\n\t\t\t_this.toneMapping = NoToneMapping;\n\n\t\t\t// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).\n\t\t\t// Transmission render pass requires viewport to match the transmissionRenderTarget.\n\t\t\tconst currentCameraViewport = camera.viewport;\n\t\t\tif ( camera.viewport !== undefined ) camera.viewport = undefined;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131\n\n\t\t\t\tlet renderTargetNeedsUpdate = false;\n\n\t\t\t\tfor ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst renderItem = transmissiveObjects[ i ];\n\n\t\t\t\t\tconst object = renderItem.object;\n\t\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\t\tconst material = renderItem.material;\n\t\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\t\tif ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tconst currentSide = material.side;\n\n\t\t\t\t\t\tmaterial.side = BackSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t\t\tmaterial.side = currentSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderTargetNeedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetNeedsUpdate === true ) {\n\n\t\t\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\t\t_this.setClearColor( _currentClearColor, _currentClearAlpha );\n\n\t\t\tif ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;\n\n\t\t\t_this.toneMapping = currentToneMapping;\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst group = renderItem.group;\n\t\t\t\tlet material = renderItem.material;\n\n\t\t\t\tif ( material.allowOverride === true && overrideMaterial !== null ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t\t}\n\n\t\tfunction getProgram( material, scene, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tconst lightsStateVersion = lights.state.version;\n\n\t\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\t\tlet programs = materialProperties.programs;\n\n\t\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\t\t\tmaterialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;\n\n\t\t\tif ( programs === undefined ) {\n\n\t\t\t\t// new material\n\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\n\t\t\t}\n\n\t\t\tlet program = programs.get( programCacheKey );\n\n\t\t\tif ( program !== undefined ) {\n\n\t\t\t\t// early out if program and light state is identical\n\n\t\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\t\treturn program;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = null;\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction getUniformList( materialProperties ) {\n\n\t\t\tif ( materialProperties.uniformsList === null ) {\n\n\t\t\t\tconst progUniforms = materialProperties.currentProgram.getUniforms();\n\t\t\t\tmaterialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );\n\n\t\t\t}\n\n\t\t\treturn materialProperties.uniformsList;\n\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tmaterialProperties.outputColorSpace = parameters.outputColorSpace;\n\t\t\tmaterialProperties.batching = parameters.batching;\n\t\t\tmaterialProperties.batchingColor = parameters.batchingColor;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.instancingColor = parameters.instancingColor;\n\t\t\tmaterialProperties.instancingMorph = parameters.instancingMorph;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t\t}\n\n\t\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );\n\t\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\t\tconst vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );\n\t\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\t\tconst morphColors = !! geometry.morphAttributes.color;\n\n\t\t\tlet toneMapping = NoToneMapping;\n\n\t\t\tif ( material.toneMapped ) {\n\n\t\t\t\tif ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\t\ttoneMapping = _this.toneMapping;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tconst materialProperties = properties.get( material );\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled === true ) {\n\n\t\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\t\tconst useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.outputColorSpace !== colorSpace ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batching === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif ( needsProgramChange === true ) {\n\n\t\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\t\t// common camera uniforms\n\n\t\t\t\tconst reversedDepthBuffer = state.buffers.depth.getReversed();\n\n\t\t\t\tif ( reversedDepthBuffer && camera.reversedDepth !== true ) {\n\n\t\t\t\t\tcamera._reversedDepth = true;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingIdTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingColorTexture' );\n\t\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, program );\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {\n\n\t\t\t\tm_uniforms.envMapIntensity.value = scene.environmentIntensity;\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\t// UBOs\n\n\t\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\tfunction materialNeedsLights( material ) {\n\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the active cube face.\n\t\t *\n\t\t * @return {number} The active cube face.\n\t\t */\n\t\tthis.getActiveCubeFace = function () {\n\n\t\t\treturn _currentActiveCubeFace;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the active mipmap level.\n\t\t *\n\t\t * @return {number} The active mipmap level.\n\t\t */\n\t\tthis.getActiveMipmapLevel = function () {\n\n\t\t\treturn _currentActiveMipmapLevel;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the active render target.\n\t\t *\n\t\t * @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target\n\t\t * is currently set.\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;\n\t\t\tif ( renderTargetProperties.__autoAllocateDepthBuffer === false ) {\n\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t}\n\n\t\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? undefined : depthTexture;\n\n\t\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\t};\n\n\t\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t\t};\n\n\t\tconst _scratchFrameBuffer = _gl.createFramebuffer();\n\n\t\t/**\n\t\t * Sets the active rendertarget.\n\t\t *\n\t\t * @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,\n\t\t * the canvas is set as the active render target instead.\n\t\t * @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.\n\t\t * Indicates the z layer to render in to when using 3D or array render targets.\n\t\t * @param {number} [activeMipmapLevel=0] - The active mipmap level.\n\t\t */\n\t\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tlet useDefaultFramebuffer = true;\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t\t} else if ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t// check if the depth texture is already bound to the frame buffer and that it's been initialized\n\t\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\t\t\t\t\tif ( renderTargetProperties.__boundDepthTexture !== depthTexture ) {\n\n\t\t\t\t\t\t// check if the depth texture is compatible\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tdepthTexture !== null &&\n\t\t\t\t\t\t\tproperties.has( depthTexture ) &&\n\t\t\t\t\t\t\t( renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tthrow new Error( 'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Swap the depth buffer to the currently attached one\n\t\t\t\t\t\ttextures.setupDepthRenderbuffer( renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\t// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers\n\t\t\t// being bound that are different sizes.\n\t\t\tif ( activeMipmapLevel !== 0 ) {\n\n\t\t\t\tframebuffer = _scratchFrameBuffer;\n\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( framebufferBound && useDefaultFramebuffer ) {\n\n\t\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\t\tconst layer = activeCubeFace;\n\n\t\t\t\tfor ( let i = 0; i < renderTarget.textures.length; i ++ ) {\n\n\t\t\t\t\tconst textureProperties = properties.get( renderTarget.textures[ i ] );\n\n\t\t\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, textureProperties.__webglTexture, activeMipmapLevel, layer );\n\n\t\t\t\t}\n\n\t\t\t} else if ( renderTarget !== null && activeMipmapLevel !== 0 ) {\n\n\t\t\t\t// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.\n\t\t\t\t// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t}\n\n\t\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t\t};\n\n\t\t/**\n\t\t * Reads the pixel data from the given render target into the given buffer.\n\t\t *\n\t\t * @param {WebGLRenderTarget} renderTarget - The render target to read from.\n\t\t * @param {number} x - The `x` coordinate of the copy region's origin.\n\t\t * @param {number} y - The `y` coordinate of the copy region's origin.\n\t\t * @param {number} width - The width of the copy region.\n\t\t * @param {number} height - The height of the copy region.\n\t\t * @param {TypedArray} buffer - The result buffer.\n\t\t * @param {number} [activeCubeFaceIndex] - The active cube face index.\n\t\t * @param {number} [textureIndex=0] - The texture index of an MRT render target.\n\t\t */\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.textures[ textureIndex ];\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t// when using MRT, select the correct color buffer for the subsequent read command\n\n\t\t\t\t\t\tif ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.\n\t\t *\n\t\t * It is recommended to use this version of `readRenderTargetPixels()` whenever possible.\n\t\t *\n\t\t * @async\n\t\t * @param {WebGLRenderTarget} renderTarget - The render target to read from.\n\t\t * @param {number} x - The `x` coordinate of the copy region's origin.\n\t\t * @param {number} y - The `y` coordinate of the copy region's origin.\n\t\t * @param {number} width - The width of the copy region.\n\t\t * @param {number} height - The height of the copy region.\n\t\t * @param {TypedArray} buffer - The result buffer.\n\t\t * @param {number} [activeCubeFaceIndex] - The active cube face index.\n\t\t * @param {number} [textureIndex=0] - The texture index of an MRT render target.\n\t\t * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n\t\t */\n\t\tthis.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t// set the active frame buffer to the one we want to read\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\tconst texture = renderTarget.textures[ textureIndex ];\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst glBuffer = _gl.createBuffer();\n\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );\n\n\t\t\t\t\t// when using MRT, select the correct color buffer for the subsequent read command\n\n\t\t\t\t\tif ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );\n\n\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );\n\n\t\t\t\t\t// reset the frame buffer to the currently set buffer before waiting\n\t\t\t\t\tconst currFramebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, currFramebuffer );\n\n\t\t\t\t\t// check if the commands have finished every 8 ms\n\t\t\t\t\tconst sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\t\t\t\t_gl.flush();\n\n\t\t\t\t\tawait probeAsync( _gl, sync, 4 );\n\n\t\t\t\t\t// read the data and delete the buffer\n\t\t\t\t\t_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );\n\t\t\t\t\t_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );\n\t\t\t\t\t_gl.deleteBuffer( glBuffer );\n\t\t\t\t\t_gl.deleteSync( sync );\n\n\t\t\t\t\treturn buffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Copies pixels from the current bound framebuffer into the given texture.\n\t\t *\n\t\t * @param {FramebufferTexture} texture - The texture.\n\t\t * @param {?Vector2} [position=null] - The start position of the copy operation.\n\t\t * @param {number} [level=0] - The mip level. The default represents the base mip.\n\t\t */\n\t\tthis.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {\n\n\t\t\tconst levelScale = Math.pow( 2, - level );\n\t\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\t\tconst x = position !== null ? position.x : 0;\n\t\t\tconst y = position !== null ? position.y : 0;\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tconst _srcFramebuffer = _gl.createFramebuffer();\n\t\tconst _dstFramebuffer = _gl.createFramebuffer();\n\n\t\t/**\n\t\t * Copies data of the given source texture into a destination texture.\n\t\t *\n\t\t * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized\n\t\t * {@link WebGLRenderer#initRenderTarget}.\n\t\t *\n\t\t * @param {Texture} srcTexture - The source texture.\n\t\t * @param {Texture} dstTexture - The destination texture.\n\t\t * @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n\t\t * @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n\t\t * @param {number} [srcLevel=0] - The source mipmap level to copy.\n\t\t * @param {?number} [dstLevel=null] - The destination mipmap level.\n\t\t */\n\t\tthis.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null ) {\n\n\t\t\t// support the previous signature with just a single dst mipmap level\n\t\t\tif ( dstLevel === null ) {\n\n\t\t\t\tif ( srcLevel !== 0 ) {\n\n\t\t\t\t\t// @deprecated, r171\n\t\t\t\t\twarnOnce( 'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.' );\n\t\t\t\t\tdstLevel = srcLevel;\n\t\t\t\t\tsrcLevel = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdstLevel = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// gather the necessary dimensions to copy\n\t\t\tlet width, height, depth, minX, minY, minZ;\n\t\t\tlet dstX, dstY, dstZ;\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;\n\t\t\tif ( srcRegion !== null ) {\n\n\t\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tdepth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;\n\t\t\t\tminX = srcRegion.min.x;\n\t\t\t\tminY = srcRegion.min.y;\n\t\t\t\tminZ = srcRegion.isBox3 ? srcRegion.min.z : 0;\n\n\t\t\t} else {\n\n\t\t\t\tconst levelScale = Math.pow( 2, - srcLevel );\n\t\t\t\twidth = Math.floor( image.width * levelScale );\n\t\t\t\theight = Math.floor( image.height * levelScale );\n\t\t\t\tif ( srcTexture.isDataArrayTexture ) {\n\n\t\t\t\t\tdepth = image.depth;\n\n\t\t\t\t} else if ( srcTexture.isData3DTexture ) {\n\n\t\t\t\t\tdepth = Math.floor( image.depth * levelScale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepth = 1;\n\n\t\t\t\t}\n\n\t\t\t\tminX = 0;\n\t\t\t\tminY = 0;\n\t\t\t\tminZ = 0;\n\n\t\t\t}\n\n\t\t\tif ( dstPosition !== null ) {\n\n\t\t\t\tdstX = dstPosition.x;\n\t\t\t\tdstY = dstPosition.y;\n\t\t\t\tdstZ = dstPosition.z;\n\n\t\t\t} else {\n\n\t\t\t\tdstX = 0;\n\t\t\t\tdstY = 0;\n\t\t\t\tdstZ = 0;\n\n\t\t\t}\n\n\t\t\t// Set up the destination target\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\t\t\tlet glTarget;\n\n\t\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t\t} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D;\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\t// used for copying data from cpu\n\t\t\tconst currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );\n\n\t\t\t// set up the src texture\n\t\t\tconst isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;\n\t\t\tconst isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;\n\t\t\tif ( srcTexture.isDepthTexture ) {\n\n\t\t\t\tconst srcTextureProperties = properties.get( srcTexture );\n\t\t\t\tconst dstTextureProperties = properties.get( dstTexture );\n\t\t\t\tconst srcRenderTargetProperties = properties.get( srcTextureProperties.__renderTarget );\n\t\t\t\tconst dstRenderTargetProperties = properties.get( dstTextureProperties.__renderTarget );\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t\t// if the source or destination are a 3d target then a layer needs to be bound\n\t\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( srcTexture ).__webglTexture, srcLevel, minZ + i );\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( dstTexture ).__webglTexture, dstLevel, dstZ + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has( srcTexture ) ) {\n\n\t\t\t\t// get the appropriate frame buffers\n\t\t\t\tconst srcTextureProperties = properties.get( srcTexture );\n\t\t\t\tconst dstTextureProperties = properties.get( dstTexture );\n\n\t\t\t\t// bind the frame buffer targets\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, _srcFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, _dstFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t\t// assign the correct layers and mip maps to the frame buffers\n\t\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isDst3D ) {\n\n\t\t\t\t\t\t_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy the data using the fastest function that can achieve the copy\n\t\t\t\t\tif ( srcLevel !== 0 ) {\n\n\t\t\t\t\t\t_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST );\n\n\t\t\t\t\t} else if ( isDst3D ) {\n\n\t\t\t\t\t\t_gl.copyTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.copyTexSubImage2D( glTarget, dstLevel, dstX, dstY, minX, minY, width, height );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// unbind read, draw buffers\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isDst3D ) {\n\n\t\t\t\t\t// copy data into the 3d texture\n\t\t\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t\t\t_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t\t\t} else if ( dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t_gl.compressedTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// copy data into the 2d texture\n\t\t\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t\t\t} else if ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// reset values\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( dstLevel === 0 && dstTexture.generateMipmaps ) {\n\n\t\t\t\t_gl.generateMipmap( glTarget );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\t\t// @deprecated, r170\n\t\t\twarnOnce( 'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use \"copyTextureToTexture\" instead.' );\n\n\t\t\treturn this.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data\n\t\t * can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been\n\t\t * rendered to.\n\t\t *\n\t\t * @param {WebGLRenderTarget} target - The render target.\n\t\t */\n\t\tthis.initRenderTarget = function ( target ) {\n\n\t\t\tif ( properties.get( target ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( target );\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the given texture. Useful for preloading a texture rather than waiting until first\n\t\t * render (which can cause noticeable lags due to decode and GPU upload overhead).\n\t\t *\n\t\t * @param {Texture} texture - The texture.\n\t\t */\n\t\tthis.initTexture = function ( texture ) {\n\n\t\t\tif ( texture.isCubeTexture ) {\n\n\t\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\t/**\n\t\t * Can be used to reset the internal WebGL state. This method is mostly\n\t\t * relevant for applications which share a single WebGL context across\n\t\t * multiple WebGL libraries.\n\t\t */\n\t\tthis.resetState = function () {\n\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\n\t\t};\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the coordinate system of the renderer.\n\t *\n\t * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.\n\t *\n\t * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}\n\t * @default WebGLCoordinateSystem\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * Defines the output color space of the renderer.\n\t *\n\t * @type {SRGBColorSpace|LinearSRGBColorSpace}\n\t * @default SRGBColorSpace\n\t */\n\tget outputColorSpace() {\n\n\t\treturn this._outputColorSpace;\n\n\t}\n\n\tset outputColorSpace( colorSpace ) {\n\n\t\tthis._outputColorSpace = colorSpace;\n\n\t\tconst gl = this.getContext();\n\t\tgl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace( colorSpace );\n\t\tgl.unpackColorSpace = ColorManagement._getUnpackColorSpace();\n\n\t}\n\n}\n\n// JSDoc\n\n/**\n * WebGLRenderer options.\n *\n * @typedef {Object} WebGLRenderer~Options\n * @property {DOMElement} [canvas=null] - A canvas element where the renderer draws its output. If not passed in here, a new canvas element will be created by the renderer.\n * @property {WebGL2RenderingContext} [context=null] - Can be used to attach an existing rendering context to this renderer.\n * @property {('highp'|'mediump'|'lowp')} [precision='highp'] - The default shader precision. Uses `highp` if supported by the device.\n * @property {boolean} [alpha=false] - Controls the default clear alpha value. When set to`true`, the value is `0`. Otherwise it's `1`.\n * @property {boolean} [premultipliedAlpha=true] Whether the renderer will assume colors have premultiplied alpha or not.\n * @property {boolean} [antialias=false] Whether to use the default MSAA or not.\n * @property {boolean} [stencil=false] Whether the drawing buffer has a stencil buffer of at least 8 bits or not.\n * @property {boolean} [preserveDrawingBuffer=false] Whether to preserve the buffer until manually cleared or overwritten.\n * @property {('default'|'low-power'|'high-performance')} [powerPreference='default'] Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context.\n * @property {boolean} [failIfMajorPerformanceCaveat=false] Whether the renderer creation will fail upon low performance is detected.\n * @property {boolean} [depth=true] Whether the drawing buffer has a depth buffer of at least 16 bits.\n * @property {boolean} [logarithmicDepthBuffer=false] Whether to use a logarithmic depth buffer. It may be necessary to use this if dealing with huge differences in scale in a single scene.\n * Note that this setting uses `gl_FragDepth` if available which disables the Early Fragment Test optimization and can cause a decrease in performance.\n * @property {boolean} [reversedDepthBuffer=false] Whether to use a reverse depth buffer. Requires the `EXT_clip_control` extension.\n * This is a more faster and accurate version than logarithmic depth buffer.\n **/\n\n/**\n * WebGLRenderer Capabilities.\n *\n * @typedef {Object} WebGLRenderer~Capabilities\n * @property {Function} getMaxAnisotropy - Returns the maximum available anisotropy.\n * @property {Function} getMaxPrecision - Returns the maximum available precision for vertex and fragment shaders.\n * @property {boolean} logarithmicDepthBuffer - `true` if `logarithmicDepthBuffer` was set to `true` in the constructor.\n * @property {number} maxAttributes - The number of shader attributes that can be used by the vertex shader.\n * @property {number} maxCubemapSize - Maximum height * width of cube map textures that a shader can use.\n * @property {number} maxFragmentUniforms - The number of uniforms that can be used by a fragment shader.\n * @property {number} maxSamples - Maximum number of samples in context of Multisample anti-aliasing (MSAA).\n * @property {number} maxTextures - The maximum number of textures that can be used by a shader.\n * @property {number} maxTextureSize - Maximum height * width of a texture that a shader use.\n * @property {number} maxVaryings - The number of varying vectors that can used by shaders.\n * @property {number} maxVertexTextures - The number of textures that can be used in a vertex shader.\n * @property {number} maxVertexUniforms - The maximum number of uniforms that can be used in a vertex shader.\n * @property {string} precision - The shader precision currently being used by the renderer.\n * @property {boolean} reversedDepthBuffer - `true` if `reversedDepthBuffer` was set to `true` in the constructor\n * and the rendering context supports `EXT_clip_control`.\n * @property {boolean} vertexTextures - `true` if vertex textures can be used.\n **/\n\n/**\n * WebGLRenderer Info Memory\n *\n * @typedef {Object} WebGLRenderer~InfoMemory\n * @property {number} geometries - The number of active geometries.\n * @property {number} textures - The number of active textures.\n **/\n\n/**\n * WebGLRenderer Info Render\n *\n * @typedef {Object} WebGLRenderer~InfoRender\n * @property {number} frame - The frame ID.\n * @property {number} calls - The number of draw calls per frame.\n * @property {number} triangles - The number of rendered triangles primitives per frame.\n * @property {number} points - The number of rendered points primitives per frame.\n * @property {number} lines - The number of rendered lines primitives per frame.\n **/\n\n/**\n * WebGLRenderer Info\n *\n * @typedef {Object} WebGLRenderer~Info\n * @property {boolean} [autoReset=true] - Whether to automatically reset the info by the renderer or not.\n * @property {WebGLRenderer~InfoMemory} memory - Information about allocated objects.\n * @property {WebGLRenderer~InfoRender} render - Information about rendered objects.\n * @property {?Array<WebGLProgram>} programs - An array `WebGLProgram`s used for rendering.\n * @property {Function} reset - Resets the info object for the next frame.\n **/\n\n/**\n * WebGLRenderer Shadow Map.\n *\n * @typedef {Object} WebGLRenderer~ShadowMap\n * @property {boolean} [enabled=false] - If set to `true`, use shadow maps in the scene.\n * @property {boolean} [autoUpdate=true] - Enables automatic updates to the shadows in the scene.\n * If you do not require dynamic lighting / shadows, you may set this to `false`.\n * @property {boolean} [needsUpdate=false] - When set to `true`, shadow maps in the scene\n * will be updated in the next `render` call.\n * @property {(BasicShadowMap|PCFShadowMap|PCFSoftShadowMap|VSMShadowMap)} [type=PCFShadowMap] - Defines the shadow map type.\n **/\n\nexport { WebGLRenderer };\n"],"mappings":"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","ignoreList":[]}