{"version":3,"file":"node_modules/three/src/renderers/common/Backend.js","names":["_vector2","_color4","Color4","Vector2","createCanvasElement","warnOnce","REVISION","Backend","constructor","parameters","this","Object","assign","data","WeakMap","renderer","domElement","timestampQueryPool","render","compute","trackTimestamp","init","coordinateSystem","beginRender","finishRender","beginCompute","finishCompute","draw","createProgram","destroyProgram","createBindings","updateBindings","updateBinding","createRenderPipeline","createComputePipeline","needsRenderUpdate","getRenderCacheKey","createNodeBuilder","createSampler","destroySampler","createDefaultTexture","createTexture","updateTexture","generateMipmaps","destroyTexture","copyTextureToBuffer","copyTextureToTexture","copyFramebufferToTexture","createAttribute","createIndexAttribute","createStorageAttribute","updateAttribute","destroyAttribute","getContext","updateSize","updateViewport","isOccluded","resolveTimestampsAsync","type","queryPool","duration","resolveQueriesAsync","info","timestamp","waitForGPU","getArrayBufferAsync","hasFeatureAsync","hasFeature","getMaxAnisotropy","getDrawingBufferSize","setScissorTest","getClearColor","getRGB","getDomElement","undefined","canvas","setAttribute","set","object","value","get","map","has","delete","dispose"],"sources":["node_modules/three/src/renderers/common/Backend.js"],"sourcesContent":["let _vector2 = null;\nlet _color4 = null;\n\nimport Color4 from './Color4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { createCanvasElement, warnOnce } from '../../utils.js';\nimport { REVISION } from '../../constants.js';\n\n/**\n * Most of the rendering related logic is implemented in the\n * {@link Renderer} module and related management components.\n * Sometimes it is required though to execute commands which are\n * specific to the current 3D backend (which is WebGPU or WebGL 2).\n * This abstract base class defines an interface that encapsulates\n * all backend-related logic. Derived classes for each backend must\n * implement the interface.\n *\n * @abstract\n * @private\n */\nclass Backend {\n\n\t/**\n\t * Constructs a new backend.\n\t *\n\t * @param {Object} parameters - An object holding parameters for the backend.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\t/**\n\t\t * The parameters of the backend.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = Object.assign( {}, parameters );\n\n\t\t/**\n\t\t * This weak map holds backend-specific data of objects\n\t\t * like textures, attributes or render targets.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t *\n\t\t * @type {?(HTMLCanvasElement|OffscreenCanvas)}\n\t\t * @default null\n\t\t */\n\t\tthis.domElement = null;\n\n\t\t/**\n\t\t * A reference to the timestamp query pool.\n   \t\t *\n   \t\t * @type {{render: ?TimestampQueryPool, compute: ?TimestampQueryPool}}\n\t\t */\n\t\tthis.timestampQueryPool = {\n\t\t\t'render': null,\n\t\t\t'compute': null\n\t\t};\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage. Concrete backends\n\t * are supposed to implement their rendering context creation and related\n\t * operations in this method.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @abstract\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {}\n\n\t// render context\n\n\t/**\n\t * This method is executed at the beginning of a render call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * draw calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a render call and\n\t * can be used by the backend to finalize work after draw\n\t * calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * compute tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( /*computeGroup*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * can be used by the backend to finalize work after compute\n\t * tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( /*computeGroup*/ ) {}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// compute node\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t */\n\tcompute( /*computeGroup, computeNode, computeBindings, computePipeline*/ ) { }\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( /*program*/ ) { }\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t * @abstract\n\t * @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( /*binding*/ ) { }\n\n\t// pipeline\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( /*renderObject, promises*/ ) { }\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @abstract\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( /*computePipeline, bindings*/ ) { }\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) { }\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) { }\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {NodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( /*renderObject, renderer*/ ) { }\n\n\t// textures\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( /*texture, options={}*/ ) { }\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( /*texture, options = {}*/ ) { }\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( /*texture*/ ) { }\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @abstract\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/ ) {}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @abstract\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0*/ ) {}\n\n\t/**\n\t* Copies the current bound framebuffer to the given texture.\n\t*\n\t* @abstract\n\t* @param {Texture} texture - The destination texture.\n\t* @param {RenderContext} renderContext - The render context.\n\t* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t*/\n\tcopyFramebufferToTexture( /*texture, renderContext, rectangle*/ ) {}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @abstract\n\t * @return {Object} The rendering context.\n\t */\n\tgetContext() { }\n\n\t/**\n\t * Backends can use this method if they have to run\n\t * logic when the renderer gets resized.\n\t *\n\t * @abstract\n\t */\n\tupdateSize() { }\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( /*renderContext*/ ) {}\n\n\t// utils\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene. Backends must implement this method by using\n\t * a Occlusion Query API.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( /*renderContext, object*/ ) {}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {string} [type='render'] - The type of the time stamp.\n\t * @return {Promise<number>} A Promise that resolves with the time stamp.\n\t */\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) {\n\n\t\t\twarnOnce( 'WebGPURenderer: Timestamp tracking is disabled.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst queryPool = this.timestampQueryPool[ type ];\n\t\tif ( ! queryPool ) {\n\n\t\t\twarnOnce( `WebGPURenderer: No timestamp query pool for type '${type}' found.` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst duration = await queryPool.resolveQueriesAsync();\n\n\t\tthis.renderer.info[ type ].timestamp = duration;\n\n\t\treturn duration;\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @abstract\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( /* attribute */ ) {}\n\n\t/**\n\t * Checks if the given feature is supported by the backend.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {string} name - The feature's name.\n\t * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( /*name*/ ) { }\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @abstract\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( /*name*/ ) {}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @abstract\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {}\n\n\t/**\n\t * Returns the drawing buffer size.\n\t *\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize() {\n\n\t\t_vector2 = _vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( _vector2 );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @abstract\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( /*boolean*/ ) { }\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\t_color4 = _color4 || new Color4();\n\n\t\trenderer.getClearColor( _color4 );\n\n\t\t_color4.getRGB( _color4 );\n\n\t\treturn _color4;\n\n\t}\n\n\t/**\n\t * Returns the DOM element. If no DOM element exists, the backend\n\t * creates a new one.\n\t *\n\t * @return {HTMLCanvasElement} The DOM element.\n\t */\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t/**\n\t * Sets a dictionary for the given object into the\n\t * internal data structure.\n\t *\n\t * @param {Object} object - The object.\n\t * @param {Object} value - The dictionary to set.\n\t */\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The object's dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Checks if the given object has a dictionary\n\t * with data defined.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {boolean} Whether a dictionary for the given object as been defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Deletes an object from the internal data structure.\n\t *\n\t * @param {Object} object - The object to delete.\n\t */\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t *\n\t * @abstract\n\t */\n\tdispose() { }\n\n}\n\nexport default Backend;\n"],"mappings":"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","ignoreList":[]}