import DataMap from"./DataMap.js";import{AttributeType}from"./Constants.js";class Bindings extends DataMap{constructor(t,e,i,s,n,r){super(),this.backend=t,this.textures=i,this.pipelines=n,this.attributes=s,this.nodes=e,this.info=r,this.pipelines.bindings=this}getForRender(t){const e=t.getBindings();for(const t of e){const i=this.get(t);void 0===i.bindGroup&&(this._init(t),this.backend.createBindings(t,e,0),i.bindGroup=t)}return e}getForCompute(t){const e=this.nodes.getForCompute(t).bindings;for(const t of e){const i=this.get(t);void 0===i.bindGroup&&(this._init(t),this.backend.createBindings(t,e,0),i.bindGroup=t)}return e}updateForCompute(t){this._updateBindings(this.getForCompute(t))}updateForRender(t){this._updateBindings(this.getForRender(t))}_updateBindings(t){for(const e of t)this._update(e,t)}_init(t){for(const e of t.bindings)if(e.isSampledTexture)this.textures.updateTexture(e.texture);else if(e.isStorageBuffer){const t=e.attribute,i=t.isIndirectStorageBufferAttribute?AttributeType.INDIRECT:AttributeType.STORAGE;this.attributes.update(t,i)}}_update(t,e){const{backend:i}=this;let s=!1,n=!0,r=0,o=0;for(const e of t.bindings){if(e.isNodeUniformsGroup){if(!1===this.nodes.updateGroup(e))continue}if(e.isStorageBuffer){const t=e.attribute,i=t.isIndirectStorageBufferAttribute?AttributeType.INDIRECT:AttributeType.STORAGE;this.attributes.update(t,i)}if(e.isUniformBuffer){e.update()&&i.updateBinding(e)}else if(e.isSampledTexture){const t=e.update(),u=e.texture,a=this.textures.get(u);t&&(this.textures.updateTexture(u),e.generation!==a.generation&&(e.generation=a.generation,s=!0));if(void 0!==i.get(u).externalTexture||a.isDefaultTexture?n=!1:(r=10*r+u.id,o+=u.version),!0===u.isStorageTexture){const t=this.get(u);!0===e.store?t.needsMipmap=!0:this.textures.needsMipmaps(u)&&!0===t.needsMipmap&&(this.backend.generateMipmaps(u),t.needsMipmap=!1)}}else e.isSampler&&e.update()}!0===s&&this.backend.updateBindings(t,e,n?r:0,o)}}export default Bindings;
//# sourceMappingURL=Bindings.js.map