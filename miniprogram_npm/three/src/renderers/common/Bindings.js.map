{"version":3,"file":"node_modules/three/src/renderers/common/Bindings.js","names":["DataMap","AttributeType","Bindings","constructor","backend","nodes","textures","attributes","pipelines","info","super","this","bindings","getForRender","renderObject","getBindings","bindGroup","groupData","get","undefined","_init","createBindings","getForCompute","computeNode","updateForCompute","_updateBindings","updateForRender","_update","binding","isSampledTexture","updateTexture","texture","isStorageBuffer","attribute","attributeType","isIndirectStorageBufferAttribute","INDIRECT","STORAGE","update","needsBindingsUpdate","cacheBindings","cacheIndex","version","isNodeUniformsGroup","updateGroup","isUniformBuffer","updateBinding","updated","texturesTextureData","generation","externalTexture","isDefaultTexture","id","isStorageTexture","textureData","store","needsMipmap","needsMipmaps","generateMipmaps","isSampler","updateBindings"],"sources":["node_modules/three/src/renderers/common/Bindings.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport { AttributeType } from './Constants.js';\n\n/**\n * This renderer module manages the bindings of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Bindings extends DataMap {\n\n\t/**\n\t * Constructs a new bindings management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Textures} textures - Renderer component for managing textures.\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing textures.\n\t\t *\n\t\t * @type {Textures}\n\t\t */\n\t\tthis.textures = textures;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t/**\n\t * Updates the given array of bindings.\n\t *\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Initializes the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to initialize.\n\t */\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to update.\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\t// every uniforms group is a uniform buffer. So if no update is required,\n\t\t\t\t// we move one with the next binding. Otherwise the next if block will update the group.\n\n\t\t\t\tif ( updated === false ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\t// get the texture data after the update, to sync the texture reference from node\n\n\t\t\t\tconst texture = binding.texture;\n\t\t\t\tconst texturesTextureData = this.textures.get( texture );\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\t// version: update the texture data or create a new one\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t\t// generation: update the bindings if a new texture has been created\n\n\t\t\t\t\tif ( binding.generation !== texturesTextureData.generation ) {\n\n\t\t\t\t\t\tbinding.generation = texturesTextureData.generation;\n\n\t\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tbinding.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\nexport default Bindings;\n"],"mappings":"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","ignoreList":[]}