{"version":3,"file":"node_modules/three/src/renderers/common/Geometries.js","names":["DataMap","AttributeType","arrayNeedsUint32","Uint16BufferAttribute","Uint32BufferAttribute","getWireframeVersion","geometry","index","version","attributes","position","getWireframeIndex","indices","geometryIndex","geometryPosition","array","i","l","length","a","b","c","push","attribute","Geometries","constructor","info","super","this","wireframes","WeakMap","attributeCall","has","renderObject","get","initialized","updateForRender","initGeometry","updateAttributes","memory","geometries","onDispose","geometryAttributes","getAttributes","delete","geometryAttribute","wireframeAttribute","undefined","removeEventListener","addEventListener","isStorageBufferAttribute","isStorageInstancedBufferAttribute","updateAttribute","STORAGE","VERTEX","getIndex","INDEX","indirect","INDIRECT","type","callId","render","calls","isInterleavedBufferAttribute","update","set","data","getIndirect","material","wireframe"],"sources":["node_modules/three/src/renderers/common/Geometries.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport { AttributeType } from './Constants.js';\nimport { arrayNeedsUint32 } from '../../utils.js';\n\nimport { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';\n\n/**\n * Returns the wireframe version for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The version.\n */\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\n/**\n * Returns a wireframe index attribute for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {BufferAttribute} The wireframe index attribute.\n */\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\n/**\n * This renderer module manages geometries.\n *\n * @private\n * @augments DataMap\n */\nclass Geometries extends DataMap {\n\n\t/**\n\t * Constructs a new geometry management component.\n\t *\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * Weak Map for managing attributes for wireframe rendering.\n\t\t *\n\t\t * @type {WeakMap<BufferGeometry,BufferAttribute>}\n\t\t */\n\t\tthis.wireframes = new WeakMap();\n\n\t\t/**\n\t\t * This Weak Map is used to make sure buffer attributes are\n\t\t * updated only once per render call.\n\t\t *\n\t\t * @type {WeakMap<BufferAttribute,number>}\n\t\t */\n\t\tthis.attributeCall = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has an initialized geometry.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether if the given render object has an initialized geometry or not.\n\t */\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\t/**\n\t * Prepares the geometry of the given render object for rendering.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\t/**\n\t * Initializes the geometry of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t}\n\n\t/**\n\t * Updates the geometry attributes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {number} type - The attribute type.\n\t */\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\t/**\n\t * Returns the index of the given render object's geometry. This is implemented\n\t * in a method to return a wireframe index if necessary.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n}\n\nexport default Geometries;\n"],"mappings":"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","ignoreList":[]}