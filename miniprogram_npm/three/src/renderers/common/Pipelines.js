import DataMap from"./DataMap.js";import RenderPipeline from"./RenderPipeline.js";import ComputePipeline from"./ComputePipeline.js";import ProgrammableStage from"./ProgrammableStage.js";class Pipelines extends DataMap{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e,t){const{backend:r}=this,s=this.get(e);if(this._needsComputeUpdate(e)){const i=s.pipeline;i&&(i.usedTimes--,i.computeProgram.usedTimes--);const a=this.nodes.getForCompute(e);let m=this.programs.compute.get(a.computeShader);void 0===m&&(i&&0===i.computeProgram.usedTimes&&this._releaseProgram(i.computeProgram),m=new ProgrammableStage(a.computeShader,"compute",e.name,a.transforms,a.nodeAttributes),this.programs.compute.set(a.computeShader,m),r.createProgram(m));const n=this._getComputeCacheKey(e,m);let o=this.caches.get(n);void 0===o&&(i&&0===i.usedTimes&&this._releasePipeline(i),o=this._getComputePipeline(e,m,n,t)),o.usedTimes++,m.usedTimes++,s.version=e.version,s.pipeline=o}return s.pipeline}getForRender(e,t=null){const{backend:r}=this,s=this.get(e);if(this._needsRenderUpdate(e)){const i=s.pipeline;i&&(i.usedTimes--,i.vertexProgram.usedTimes--,i.fragmentProgram.usedTimes--);const a=e.getNodeBuilderState(),m=e.material?e.material.name:"";let n=this.programs.vertex.get(a.vertexShader);void 0===n&&(i&&0===i.vertexProgram.usedTimes&&this._releaseProgram(i.vertexProgram),n=new ProgrammableStage(a.vertexShader,"vertex",m),this.programs.vertex.set(a.vertexShader,n),r.createProgram(n));let o=this.programs.fragment.get(a.fragmentShader);void 0===o&&(i&&0===i.fragmentProgram.usedTimes&&this._releaseProgram(i.fragmentProgram),o=new ProgrammableStage(a.fragmentShader,"fragment",m),this.programs.fragment.set(a.fragmentShader,o),r.createProgram(o));const p=this._getRenderCacheKey(e,n,o);let d=this.caches.get(p);void 0===d?(i&&0===i.usedTimes&&this._releasePipeline(i),d=this._getRenderPipeline(e,n,o,p,t)):e.pipeline=d,d.usedTimes++,n.usedTimes++,o.usedTimes++,s.pipeline=d}return s.pipeline}delete(e){const t=this.get(e).pipeline;return t&&(t.usedTimes--,0===t.usedTimes&&this._releasePipeline(t),t.isComputePipeline?(t.computeProgram.usedTimes--,0===t.computeProgram.usedTimes&&this._releaseProgram(t.computeProgram)):(t.fragmentProgram.usedTimes--,t.vertexProgram.usedTimes--,0===t.vertexProgram.usedTimes&&this._releaseProgram(t.vertexProgram),0===t.fragmentProgram.usedTimes&&this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(e){this.getForRender(e)}_getComputePipeline(e,t,r,s){r=r||this._getComputeCacheKey(e,t);let i=this.caches.get(r);return void 0===i&&(i=new ComputePipeline(r,t),this.caches.set(r,i),this.backend.createComputePipeline(i,s)),i}_getRenderPipeline(e,t,r,s,i){s=s||this._getRenderCacheKey(e,t,r);let a=this.caches.get(s);return void 0===a&&(a=new RenderPipeline(s,t,r),this.caches.set(s,a),e.pipeline=a,this.backend.createRenderPipeline(e,i)),a}_getComputeCacheKey(e,t){return e.id+","+t.id}_getRenderCacheKey(e,t,r){return t.id+","+r.id+","+this.backend.getRenderCacheKey(e)}_releasePipeline(e){this.caches.delete(e.cacheKey)}_releaseProgram(e){const t=e.code,r=e.stage;this.programs[r].delete(t)}_needsComputeUpdate(e){const t=this.get(e);return void 0===t.pipeline||t.version!==e.version}_needsRenderUpdate(e){return void 0===this.get(e).pipeline||this.backend.needsRenderUpdate(e)}}export default Pipelines;
//# sourceMappingURL=Pipelines.js.map