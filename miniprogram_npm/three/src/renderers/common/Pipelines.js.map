{"version":3,"file":"node_modules/three/src/renderers/common/Pipelines.js","names":["DataMap","RenderPipeline","ComputePipeline","ProgrammableStage","Pipelines","constructor","backend","nodes","super","this","bindings","caches","Map","programs","vertex","fragment","compute","getForCompute","computeNode","data","get","_needsComputeUpdate","previousPipeline","pipeline","usedTimes","computeProgram","nodeBuilderState","stageCompute","computeShader","undefined","_releaseProgram","name","transforms","nodeAttributes","set","createProgram","cacheKey","_getComputeCacheKey","_releasePipeline","_getComputePipeline","version","getForRender","renderObject","promises","_needsRenderUpdate","vertexProgram","fragmentProgram","getNodeBuilderState","material","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","object","isComputePipeline","delete","dispose","updateForRender","createComputePipeline","createRenderPipeline","id","getRenderCacheKey","program","code","stage","needsRenderUpdate"],"sources":["node_modules/three/src/renderers/common/Pipelines.js"],"sourcesContent":["import DataMap from './DataMap.js';\nimport RenderPipeline from './RenderPipeline.js';\nimport ComputePipeline from './ComputePipeline.js';\nimport ProgrammableStage from './ProgrammableStage.js';\n\n/**\n * This renderer module manages the pipelines of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Pipelines extends DataMap {\n\n\t/**\n\t * Constructs a new pipeline management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * A references to the bindings management component.\n\t\t * This reference will be set inside the `Bindings`\n\t\t * constructor.\n\t\t *\n\t\t * @type {?Bindings}\n\t\t * @default null\n\t\t */\n\t\tthis.bindings = null;\n\n\t\t/**\n\t\t * Internal cache for maintaining pipelines.\n\t\t * The key of the map is a cache key, the value the pipeline.\n\t\t *\n\t\t * @type {Map<string,Pipeline>}\n\t\t */\n\t\tthis.caches = new Map();\n\n\t\t/**\n\t\t * This dictionary maintains for each shader stage type (vertex,\n\t\t * fragment and compute) the programmable stage objects which\n\t\t * represent the actual shader code.\n\t\t *\n\t\t * @type {Object<string,Map>}\n\t\t */\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {RenderPipeline} The render pipeline.\n\t */\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\tconst name = renderObject.material ? renderObject.material.name : '';\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex', name );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment', name );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Deletes the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @return {?Object} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Updates the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @param {string} cacheKey - The cache key.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @param {string} cacheKey - The cache key.\n\t * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t// The `promises` array is `null` by default and only set to an empty array when\n\t\t\t// `Renderer.compileAsync()` is used. The next call actually fills the array with\n\t\t\t// pending promises that resolve when the render pipelines are ready for rendering.\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a compute pipeline.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @return {string} The cache key.\n\t */\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a render pipeline.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @return {string} The cache key.\n\t */\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t/**\n\t * Releases the given pipeline.\n\t *\n\t * @private\n\t * @param {Pipeline} pipeline - The pipeline to release.\n\t */\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t/**\n\t * Releases the shader program.\n\t *\n\t * @private\n\t * @param {Object} program - The shader program to release.\n\t */\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t/**\n\t * Returns `true` if the compute pipeline for the given compute node requires an update.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.\n\t */\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t/**\n\t * Returns `true` if the render pipeline for the given render object requires an update.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render object for the given render object requires an update or not.\n\t */\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\nexport default Pipelines;\n"],"mappings":"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","ignoreList":[]}