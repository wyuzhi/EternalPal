import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{ColorManagement}from"../../math/ColorManagement.js";import{vec4,renderOutput}from"../../nodes/TSL.js";import{NoToneMapping}from"../../constants.js";import QuadMesh from"../../renderers/common/QuadMesh.js";class PostProcessing{constructor(e,t=vec4(0,0,1,1)){this.renderer=e,this.outputNode=t,this.outputColorTransform=!0,this.needsUpdate=!0;const o=new NodeMaterial;o.name="PostProcessing",this._quadMesh=new QuadMesh(o),this._context=null}render(){const e=this.renderer;this._update(),null!==this._context.onBeforePostProcessing&&this._context.onBeforePostProcessing();const t=e.toneMapping,o=e.outputColorSpace;e.toneMapping=NoToneMapping,e.outputColorSpace=ColorManagement.workingColorSpace;const n=e.xr.enabled;e.xr.enabled=!1,this._quadMesh.render(e),e.xr.enabled=n,e.toneMapping=t,e.outputColorSpace=o,null!==this._context.onAfterPostProcessing&&this._context.onAfterPostProcessing()}get context(){return this._context}dispose(){this._quadMesh.material.dispose()}_update(){if(!0===this.needsUpdate){const e=this.renderer,t=e.toneMapping,o=e.outputColorSpace,n={postProcessing:this,onBeforePostProcessing:null,onAfterPostProcessing:null};let s=this.outputNode;!0===this.outputColorTransform?(s=s.context(n),s=renderOutput(s,t,o)):(n.toneMapping=t,n.outputColorSpace=o,s=s.context(n)),this._context=n,this._quadMesh.material.fragmentNode=s,this._quadMesh.material.needsUpdate=!0,this.needsUpdate=!1}}async renderAsync(){this._update(),null!==this._context.onBeforePostProcessing&&this._context.onBeforePostProcessing();const e=this.renderer,t=e.toneMapping,o=e.outputColorSpace;e.toneMapping=NoToneMapping,e.outputColorSpace=ColorManagement.workingColorSpace;const n=e.xr.enabled;e.xr.enabled=!1,await this._quadMesh.renderAsync(e),e.xr.enabled=n,e.toneMapping=t,e.outputColorSpace=o,null!==this._context.onAfterPostProcessing&&this._context.onAfterPostProcessing()}}export default PostProcessing;
//# sourceMappingURL=PostProcessing.js.map