import{hash,hashString}from"../../nodes/core/NodeUtils.js";let _id=0;function getKeys(t){const e=Object.keys(t);let i=Object.getPrototypeOf(t);for(;i;){const t=Object.getOwnPropertyDescriptors(i);for(const i in t)if(void 0!==t[i]){const s=t[i];s&&"function"==typeof s.get&&e.push(i)}i=Object.getPrototypeOf(i)}return e}class RenderObject{constructor(t,e,i,s,n,r,o,a,h,u){this.id=_id++,this._nodes=t,this._geometries=e,this.renderer=i,this.object=s,this.material=n,this.scene=r,this.camera=o,this.lightsNode=a,this.context=h,this.geometry=s.geometry,this.version=n.version,this.drawRange=null,this.attributes=null,this.attributesId=null,this.pipeline=null,this.group=null,this.vertexBuffers=null,this.drawParams=null,this.bundle=null,this.clippingContext=u,this.clippingContextCacheKey=null!==u?u.cacheKey:"",this.initialNodesCacheKey=this.getDynamicCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this._monitor=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.onGeometryDispose=()=>{this.attributes=null,this.attributesId=null},this.material.addEventListener("dispose",this.onMaterialDispose),this.geometry.addEventListener("dispose",this.onGeometryDispose)}updateClipping(t){this.clippingContext=t}get clippingNeedsUpdate(){return null!==this.clippingContext&&this.clippingContext.cacheKey!==this.clippingContextCacheKey&&(this.clippingContextCacheKey=this.clippingContext.cacheKey,!0)}get hardwareClippingPlanes(){return!0===this.material.hardwareClipping?this.clippingContext.unionClippingCount:0}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getMonitor(){return this._monitor||(this._monitor=this.getNodeBuilderState().observer)}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getBindingGroup(t){for(const e of this.getBindings())if(e.name===t)return e}getIndex(){return this._geometries.getIndex(this)}getIndirect(){return this._geometries.getIndirect(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}setGeometry(t){this.geometry=t,this.attributes=null,this.attributesId=null}getAttributes(){if(null!==this.attributes)return this.attributes;const t=this.getNodeBuilderState().nodeAttributes,e=this.geometry,i=[],s=new Set,n={};for(const r of t){let t;if(r.node&&r.node.attribute?t=r.node.attribute:(t=e.getAttribute(r.name),n[r.name]=t.version),void 0===t)continue;i.push(t);const o=t.isInterleavedBufferAttribute?t.data:t;s.add(o)}return this.attributes=i,this.attributesId=n,this.vertexBuffers=Array.from(s.values()),i}getVertexBuffers(){return null===this.vertexBuffers&&this.getAttributes(),this.vertexBuffers}getDrawParameters(){const{object:t,material:e,geometry:i,group:s,drawRange:n}=this,r=this.drawParams||(this.drawParams={vertexCount:0,firstVertex:0,instanceCount:0,firstInstance:0}),o=this.getIndex(),a=null!==o;let h=1;if(!0===i.isInstancedBufferGeometry?h=i.instanceCount:void 0!==t.count&&(h=Math.max(0,t.count)),0===h)return null;if(r.instanceCount=h,!0===t.isBatchedMesh)return r;let u=1;!0!==e.wireframe||t.isPoints||t.isLineSegments||t.isLine||t.isLineLoop||(u=2);let l=n.start*u,c=(n.start+n.count)*u;null!==s&&(l=Math.max(l,s.start*u),c=Math.min(c,(s.start+s.count)*u));const d=i.attributes.position;let g=1/0;a?g=o.count:null!=d&&(g=d.count),l=Math.max(l,0),c=Math.min(c,g);const m=c-l;return m<0||m===1/0?null:(r.vertexCount=m,r.firstVertex=l,r)}getGeometryCacheKey(){const{geometry:t}=this;let e="";for(const i of Object.keys(t.attributes).sort()){const s=t.attributes[i];e+=i+",",s.data&&(e+=s.data.stride+","),s.offset&&(e+=s.offset+","),s.itemSize&&(e+=s.itemSize+","),s.normalized&&(e+="n,")}for(const i of Object.keys(t.morphAttributes).sort()){const s=t.morphAttributes[i];e+="morph-"+i+",";for(let t=0,i=s.length;t<i;t++){e+=s[t].id+","}}return t.index&&(e+="index,"),e}getMaterialCacheKey(){const{object:t,material:e}=this;let i=e.customProgramCacheKey();for(const t of getKeys(e)){if(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(t))continue;const s=e[t];let n;if(null!==s){const t=typeof s;"number"===t?n=0!==s?"1":"0":"object"===t?(n="{",s.isTexture&&(n+=s.mapping),n+="}"):n=String(s)}else n=String(s);i+=n+","}return i+=this.clippingContextCacheKey+",",t.geometry&&(i+=this.getGeometryCacheKey()),t.skeleton&&(i+=t.skeleton.bones.length+","),t.isBatchedMesh&&(i+=t._matricesTexture.uuid+",",null!==t._colorsTexture&&(i+=t._colorsTexture.uuid+",")),t.count>1&&(i+=t.uuid+","),i+=t.receiveShadow+",",hashString(i)}get needsGeometryUpdate(){if(this.geometry.id!==this.object.geometry.id)return!0;if(null!==this.attributes){const t=this.attributesId;for(const e in t){const i=this.geometry.getAttribute(e);if(void 0===i||t[e]!==i.id)return!0}}return!1}get needsUpdate(){return this.initialNodesCacheKey!==this.getDynamicCacheKey()||this.clippingNeedsUpdate}getDynamicCacheKey(){let t=0;return!0!==this.material.isShadowPassMaterial&&(t=this._nodes.getCacheKey(this.scene,this.lightsNode)),this.camera.isArrayCamera&&(t=hash(t,this.camera.cameras.length)),this.object.receiveShadow&&(t=hash(t,1)),t}getCacheKey(){return this.getMaterialCacheKey()+this.getDynamicCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.geometry.removeEventListener("dispose",this.onGeometryDispose),this.onDispose()}}export default RenderObject;
//# sourceMappingURL=RenderObject.js.map