{"version":3,"file":"node_modules/three/src/renderers/common/RenderObject.js","names":["hash","hashString","_id","getKeys","obj","keys","Object","proto","getPrototypeOf","descriptors","getOwnPropertyDescriptors","key","undefined","descriptor","get","push","RenderObject","constructor","nodes","geometries","renderer","object","material","scene","camera","lightsNode","renderContext","clippingContext","this","id","_nodes","_geometries","context","geometry","version","drawRange","attributes","attributesId","pipeline","group","vertexBuffers","drawParams","bundle","clippingContextCacheKey","cacheKey","initialNodesCacheKey","getDynamicCacheKey","initialCacheKey","getCacheKey","_nodeBuilderState","_bindings","_monitor","onDispose","isRenderObject","onMaterialDispose","dispose","onGeometryDispose","addEventListener","updateClipping","clippingNeedsUpdate","hardwareClippingPlanes","hardwareClipping","unionClippingCount","getNodeBuilderState","getForRender","getMonitor","observer","getBindings","createBindings","getBindingGroup","name","bindingGroup","getIndex","getIndirect","getChainArray","setGeometry","getAttributes","nodeAttributes","Set","nodeAttribute","attribute","node","getAttribute","bufferAttribute","isInterleavedBufferAttribute","data","add","Array","from","values","getVertexBuffers","getDrawParameters","vertexCount","firstVertex","instanceCount","firstInstance","index","hasIndex","isInstancedBufferGeometry","count","Math","max","isBatchedMesh","rangeFactor","wireframe","isPoints","isLineSegments","isLine","isLineLoop","start","lastVertex","min","position","itemCount","Infinity","getGeometryCacheKey","sort","stride","offset","itemSize","normalized","morphAttributes","targets","i","l","length","getMaterialCacheKey","customProgramCacheKey","property","test","value","valueKey","type","isTexture","mapping","String","skeleton","bones","_matricesTexture","uuid","_colorsTexture","receiveShadow","needsGeometryUpdate","needsUpdate","isShadowPassMaterial","isArrayCamera","cameras","removeEventListener"],"sources":["node_modules/three/src/renderers/common/RenderObject.js"],"sourcesContent":["import { hash, hashString } from '../../nodes/core/NodeUtils.js';\n\nlet _id = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\n/**\n * A render object is the renderer's representation of single entity that gets drawn\n * with a draw command. There is no unique mapping of render objects to 3D objects in the\n * scene since render objects also depend from the used material, the current render context\n * and the current scene's lighting.\n *\n * In general, the basic process of the renderer is:\n *\n * - Analyze the 3D objects in the scene and generate render lists containing render items.\n * - Process the render lists by calling one or more render commands for each render item.\n * - For each render command, request a render object and perform the draw.\n *\n * The module provides an interface to get data required for the draw command like the actual\n * draw parameters or vertex buffers. It also holds a series of caching related methods since\n * creating render objects should only be done when necessary.\n *\n * @private\n */\nclass RenderObject {\n\n\t/**\n\t * Constructs a new render object.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t */\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis.id = _id ++;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t * @private\n\t\t */\n\t\tthis._nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t * @private\n\t\t */\n\t\tthis._geometries = geometries;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The 3D object's material.\n\t\t *\n\t\t * @type {Material}\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the 3D object should be rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The lights node.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lightsNode;\n\n\t\t/**\n\t\t * The render context.\n\t\t *\n\t\t * @type {RenderContext}\n\t\t */\n\t\tthis.context = renderContext;\n\n\t\t/**\n\t\t * The 3D object's geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = object.geometry;\n\n\t\t/**\n\t\t * The render object's version.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = material.version;\n\n\t\t/**\n\t\t * The draw range of the geometry.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.drawRange = null;\n\n\t\t/**\n\t\t * An array holding the buffer attributes\n\t\t * of the render object. This entails attribute\n\t\t * definitions on geometry and node level.\n\t\t *\n\t\t * @type {?Array<BufferAttribute>}\n\t\t * @default null\n\t\t */\n\t\tthis.attributes = null;\n\n\t\t/**\n\t\t * An object holding the version of the\n\t\t * attributes. The keys are the attribute names\n\t\t * and the values are the attribute versions.\n\t\t *\n\t\t * @type {?Object<string, number>}\n\t\t * @default null\n\t\t */\n\t\tthis.attributesId = null;\n\n\t\t/**\n\t\t * A reference to a render pipeline the render\n\t\t * object is processed with.\n\t\t *\n\t\t * @type {RenderPipeline}\n\t\t * @default null\n\t\t */\n\t\tthis.pipeline = null;\n\n\t\t/**\n\t\t * Only relevant for objects using\n\t\t * multiple materials. This represents a group entry\n\t\t * from the respective `BufferGeometry`.\n\t\t *\n\t\t * @type {?{start: number, count: number}}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An array holding the vertex buffers which can\n\t\t * be buffer attributes but also interleaved buffers.\n\t\t *\n\t\t * @type {?Array<BufferAttribute|InterleavedBuffer>}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexBuffers = null;\n\n\t\t/**\n\t\t * The parameters for the draw command.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.drawParams = null;\n\n\t\t/**\n\t\t * If this render object is used inside a render bundle,\n\t\t * this property points to the respective bundle group.\n\t\t *\n\t\t * @type {?BundleGroup}\n\t\t * @default null\n\t\t */\n\t\tthis.bundle = null;\n\n\t\t/**\n\t\t * The clipping context.\n\t\t *\n\t\t * @type {ClippingContext}\n\t\t */\n\t\tthis.clippingContext = clippingContext;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\t/**\n\t\t * The initial node cache key.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\n\t\t/**\n\t\t * The initial cache key.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\t/**\n\t\t * The node builder state.\n\t\t *\n\t\t * @type {?NodeBuilderState}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._nodeBuilderState = null;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {?Array<BindGroup>}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * Reference to the node material observer.\n\t\t *\n\t\t * @type {?NodeMaterialObserver}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._monitor = null;\n\n\t\t/**\n\t\t * An event listener which is defined by `RenderObjects`. It performs\n\t\t * clean up tasks when `dispose()` on this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onDispose = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderObject = true;\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the material of this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the geometry of this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onGeometryDispose = () => {\n\n\t\t\t// clear geometry cache attributes\n\n\t\t\tthis.attributes = null;\n\t\t\tthis.attributesId = null;\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\t\tthis.geometry.addEventListener( 'dispose', this.onGeometryDispose );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} context - The clipping context to set.\n\t */\n\tupdateClipping( context ) {\n\n\t\tthis.clippingContext = context;\n\n\t}\n\n\t/**\n\t * Whether the clipping requires an update or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * The number of clipping planes defined in context of hardware clipping.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\t/**\n\t * Returns the node builder state of this render object.\n\t *\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\t/**\n\t * Returns the node material observer of this render object.\n\t *\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().observer );\n\n\t}\n\n\t/**\n\t * Returns an array of bind groups of this render object.\n\t *\n\t * @return {Array<BindGroup>} The bindings.\n\t */\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\t/**\n\t * Returns a binding group by group name of this render object.\n\t *\n\t * @param {string} name - The name of the binding group.\n\t * @return {?BindGroup} The bindings.\n\t */\n\tgetBindingGroup( name ) {\n\n\t\tfor ( const bindingGroup of this.getBindings() ) {\n\n\t\t\tif ( bindingGroup.name === name ) {\n\n\t\t\t\treturn bindingGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the index of the render object's geometry.\n\t *\n\t * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute.\n\t *\n\t * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\t/**\n\t * Returns an array that acts as a key for identifying the render object in a chain map.\n\t *\n\t * @return {Array<Object>} An array with object references.\n\t */\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\t/**\n\t * This method is used when the geometry of a 3D object has been exchanged and the\n\t * respective render object now requires an update.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to set.\n\t */\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\t\tthis.attributesId = null;\n\n\t}\n\n\t/**\n\t * Returns the buffer attributes of the render object. The returned array holds\n\t * attribute definitions on geometry and node level.\n\t *\n\t * @return {Array<BufferAttribute>} An array with buffer attributes.\n\t */\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tconst attributesId = {};\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tlet attribute;\n\n\t\t\tif ( nodeAttribute.node && nodeAttribute.node.attribute ) {\n\n\t\t\t\t// node attribute\n\t\t\t\tattribute = nodeAttribute.node.attribute;\n\n\t\t\t} else {\n\n\t\t\t\t// geometry attribute\n\t\t\t\tattribute = geometry.getAttribute( nodeAttribute.name );\n\n\t\t\t\tattributesId[ nodeAttribute.name ] = attribute.version;\n\n\t\t\t}\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.attributesId = attributesId;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\t/**\n\t * Returns the vertex buffers of the render object.\n\t *\n\t * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.\n\t */\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\t/**\n\t * Returns the draw parameters for the render object.\n\t *\n\t * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.\n\t */\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\n\t\tlet instanceCount = 1;\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tinstanceCount = geometry.instanceCount;\n\n\t\t} else if ( object.count !== undefined ) {\n\n\t\t\tinstanceCount = Math.max( 0, object.count );\n\n\t\t}\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\t/**\n\t * Returns the render object's geometry cache key.\n\t *\n\t * The geometry cache key is part of the material cache key.\n\t *\n\t * @return {string} The geometry cache key.\n\t */\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\t// structural equality isn't sufficient for morph targets since the\n\t\t// data are maintained in textures. only if the targets are all equal\n\t\t// the texture and thus the instance of `MorphNode` can be shared.\n\n\t\tfor ( const name of Object.keys( geometry.morphAttributes ).sort() ) {\n\n\t\t\tconst targets = geometry.morphAttributes[ name ];\n\n\t\t\tcacheKey += 'morph-' + name + ',';\n\n\t\t\tfor ( let i = 0, l = targets.length; i < l; i ++ ) {\n\n\t\t\t\tconst attribute = targets[ i ];\n\n\t\t\t\tcacheKey += attribute.id + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's material cache key.\n\t *\n\t * The material cache key is part of the render object cache key.\n\t *\n\t * @return {number} The material cache key.\n\t */\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\t/**\n\t * Whether the geometry requires an update or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget needsGeometryUpdate() {\n\n\t\tif ( this.geometry.id !== this.object.geometry.id ) return true;\n\n\t\tif ( this.attributes !== null ) {\n\n\t\t\tconst attributesId = this.attributesId;\n\n\t\t\tfor ( const name in attributesId ) {\n\n\t\t\t\tconst attribute = this.geometry.getAttribute( name );\n\n\t\t\t\tif ( attribute === undefined || attributesId[ name ] !== attribute.id ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Whether the render object requires an update or not.\n\t *\n\t * Note: There are two distinct places where render objects are checked for an update.\n\t *\n\t * 1. In `RenderObjects.get()` which is executed when the render object is request. This\n\t * method checks the `needsUpdate` flag and recreates the render object if necessary.\n\t * 2. In `Renderer._renderObjectDirect()` right after getting the render object via\n\t * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect\n\t * a need for a refresh due to material, geometry or object related value changes.\n\t *\n\t * TODO: Investigate if it's possible to merge both steps so there is only a single place\n\t * that performs the 'needsUpdate' check.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\t/**\n\t * Returns the dynamic cache key which represents a key that is computed per draw command.\n\t *\n\t * @return {number} The cache key.\n\t */\n\tgetDynamicCacheKey() {\n\n\t\tlet cacheKey = 0;\n\n\t\t// `Nodes.getCacheKey()` returns an environment cache key which is not relevant when\n\t\t// the renderer is inside a shadow pass.\n\n\t\tif ( this.material.isShadowPassMaterial !== true ) {\n\n\t\t\tcacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\t}\n\n\t\tif ( this.camera.isArrayCamera ) {\n\n\t\t\tcacheKey = hash( cacheKey, this.camera.cameras.length );\n\n\t\t}\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey = hash( cacheKey, 1 );\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's cache key.\n\t *\n\t * @return {number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\t\tthis.geometry.removeEventListener( 'dispose', this.onGeometryDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nexport default RenderObject;\n"],"mappings":"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","ignoreList":[]}