import Animation from"./Animation.js";import RenderObjects from"./RenderObjects.js";import Attributes from"./Attributes.js";import Geometries from"./Geometries.js";import Info from"./Info.js";import Pipelines from"./Pipelines.js";import Bindings from"./Bindings.js";import RenderLists from"./RenderLists.js";import RenderContexts from"./RenderContexts.js";import Textures from"./Textures.js";import Background from"./Background.js";import Nodes from"./nodes/Nodes.js";import Color4 from"./Color4.js";import ClippingContext from"./ClippingContext.js";import QuadMesh from"./QuadMesh.js";import RenderBundles from"./RenderBundles.js";import NodeLibrary from"./nodes/NodeLibrary.js";import Lighting from"./Lighting.js";import XRManager from"./XRManager.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{Scene}from"../../scenes/Scene.js";import{ColorManagement}from"../../math/ColorManagement.js";import{Frustum}from"../../math/Frustum.js";import{FrustumArray}from"../../math/FrustumArray.js";import{Matrix4}from"../../math/Matrix4.js";import{Vector2}from"../../math/Vector2.js";import{Vector4}from"../../math/Vector4.js";import{RenderTarget}from"../../core/RenderTarget.js";import{DoubleSide,BackSide,FrontSide,SRGBColorSpace,NoToneMapping,LinearFilter,HalfFloatType,RGBAFormat,PCFShadowMap}from"../../constants.js";import{highpModelNormalViewMatrix,highpModelViewMatrix}from"../../nodes/accessors/ModelNode.js";const _scene=new Scene,_drawingBufferSize=new Vector2,_screen=new Vector4,_frustum=new Frustum,_frustumArray=new FrustumArray,_projScreenMatrix=new Matrix4,_vector4=new Vector4;class Renderer{constructor(e,t={}){this.isRenderer=!0;const{logarithmicDepthBuffer:i=!1,alpha:r=!0,depth:s=!0,stencil:n=!1,antialias:o=!1,samples:a=0,getFallback:h=null,colorBufferType:d=HalfFloatType,multiview:l=!1}=t;this.domElement=e.getDomElement(),this.backend=e,this.samples=a||!0===o?4:0,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=r,this.logarithmicDepthBuffer=i,this.outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=s,this.stencil=n,this.info=new Info,this.overrideNodes={modelViewMatrix:null,modelNormalViewMatrix:null},this.library=new NodeLibrary,this.lighting=new Lighting,this._getFallback=h,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new Vector4(0,0,this._width,this._height),this._scissor=new Vector4(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new QuadMesh(new NodeMaterial),this._quad.material.name="Renderer_output",this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const c=!0===this.alpha?0:1;this._clearColor=new Color4(0,0,0,c),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._outputRenderTarget=null,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._isDeviceLost=!1,this.onDeviceLost=this._onDeviceLost,this._colorBufferType=d,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,type:PCFShadowMap},this.xr=new XRManager(this,l),this.debug={checkShaderErrors:!0,onShaderError:null,getShaderAsync:async(e,t,i)=>{await this.compileAsync(e,t);const r=this._renderLists.get(e,t),s=this._renderContexts.get(e,t,this._renderTarget),n=e.overrideMaterial||i.material,o=this._objects.get(i,n,e,t,r.lightsNode,s,s.clippingContext),{fragmentShader:a,vertexShader:h}=o.getNodeBuilderState();return{fragmentShader:a,vertexShader:h}}}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(e,t)=>{let i=this.backend;try{await i.init(this)}catch(e){if(null===this._getFallback)return void t(e);try{this.backend=i=this._getFallback(e),await i.init(this)}catch(e){return void t(e)}}this._nodes=new Nodes(this,i),this._animation=new Animation(this._nodes,this.info),this._attributes=new Attributes(i),this._background=new Background(this,this._nodes),this._geometries=new Geometries(this._attributes,this.info),this._textures=new Textures(this,i,this.info),this._pipelines=new Pipelines(i,this._nodes),this._bindings=new Bindings(i,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new RenderObjects(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new RenderLists(this.lighting),this._bundles=new RenderBundles,this._renderContexts=new RenderContexts,this._animation.start(),this._initialized=!0,e(this)}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(e,t,i=null){if(!0===this._isDeviceLost)return;!1===this._initialized&&await this.init();const r=this._nodes.nodeFrame,s=r.renderId,n=this._currentRenderContext,o=this._currentRenderObjectFunction,a=this._compilationPromises,h=!0===e.isScene?e:_scene;null===i&&(i=e);const d=this._renderTarget,l=this._renderContexts.get(i,t,d),c=this._activeMipmapLevel,u=[];this._currentRenderContext=l,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=u,r.renderId++,r.update(),l.depth=this.depth,l.stencil=this.stencil,l.clippingContext||(l.clippingContext=new ClippingContext),l.clippingContext.updateGlobal(h,t),h.onBeforeRender(this,e,t,d);const p=this._renderLists.get(e,t);if(p.begin(),this._projectObject(e,t,0,p,l.clippingContext),i!==e&&i.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&p.pushLight(e)})),p.finish(),null!==d){this._textures.updateRenderTarget(d,c);const e=this._textures.get(d);l.textures=e.textures,l.depthTexture=e.depthTexture}else l.textures=null,l.depthTexture=null;this._background.update(h,p,l);const _=p.opaque,g=p.transparent,m=p.transparentDoublePass,f=p.lightsNode;!0===this.opaque&&_.length>0&&this._renderObjects(_,t,h,f),!0===this.transparent&&g.length>0&&this._renderTransparents(g,m,t,h,f),r.renderId=s,this._currentRenderContext=n,this._currentRenderObjectFunction=o,this._compilationPromises=a,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(u)}async renderAsync(e,t){!1===this._initialized&&await this.init(),this._renderScene(e,t)}async waitForGPU(){await this.backend.waitForGPU()}set highPrecision(e){!0===e?(this.overrideNodes.modelViewMatrix=highpModelViewMatrix,this.overrideNodes.modelNormalViewMatrix=highpModelNormalViewMatrix):this.highPrecision&&(this.overrideNodes.modelViewMatrix=null,this.overrideNodes.modelNormalViewMatrix=null)}get highPrecision(){return this.overrideNodes.modelViewMatrix===highpModelViewMatrix&&this.overrideNodes.modelNormalViewMatrix===highpModelNormalViewMatrix}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}getColorBufferType(){return this._colorBufferType}_onDeviceLost(e){let t=`THREE.WebGPURenderer: ${e.api} Device Lost:\n\nMessage: ${e.message}`;e.reason&&(t+=`\nReason: ${e.reason}`),console.error(t),this._isDeviceLost=!0}_renderBundle(e,t,i){const{bundleGroup:r,camera:s,renderList:n}=e,o=this._currentRenderContext,a=this._bundles.get(r,s),h=this.backend.get(a);void 0===h.renderContexts&&(h.renderContexts=new Set);const d=r.version!==h.version,l=!1===h.renderContexts.has(o)||d;if(h.renderContexts.add(o),l){this.backend.beginBundle(o),(void 0===h.renderObjects||d)&&(h.renderObjects=[]),this._currentRenderBundle=a;const{transparentDoublePass:e,transparent:l,opaque:c}=n;!0===this.opaque&&c.length>0&&this._renderObjects(c,s,t,i),!0===this.transparent&&l.length>0&&this._renderTransparents(l,e,s,t,i),this._currentRenderBundle=null,this.backend.finishBundle(o,a),h.version=r.version}else{const{renderObjects:e}=h;for(let t=0,i=e.length;t<i;t++){const i=e[t];this._nodes.needsRefresh(i)&&(this._nodes.updateBefore(i),this._nodes.updateForRender(i),this._bindings.updateForRender(i),this._nodes.updateAfter(i))}}this.backend.addBundle(o,a)}render(e,t){if(!1===this._initialized)return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."),this.renderAsync(e,t);this._renderScene(e,t)}_getFrameBufferTarget(){const{currentToneMapping:e,currentColorSpace:t}=this,i=e!==NoToneMapping,r=t!==ColorManagement.workingColorSpace;if(!1===i&&!1===r)return null;const{width:s,height:n}=this.getDrawingBufferSize(_drawingBufferSize),{depth:o,stencil:a}=this;let h=this._frameBufferTarget;null===h&&(h=new RenderTarget(s,n,{depthBuffer:o,stencilBuffer:a,type:this._colorBufferType,format:RGBAFormat,colorSpace:ColorManagement.workingColorSpace,generateMipmaps:!1,minFilter:LinearFilter,magFilter:LinearFilter,samples:this.samples}),h.isPostProcessingRenderTarget=!0,this._frameBufferTarget=h);const d=this.getOutputRenderTarget();return h.depthBuffer=o,h.stencilBuffer=a,null!==d?h.setSize(d.width,d.height,d.depth):h.setSize(s,n,1),h.viewport.copy(this._viewport),h.scissor.copy(this._scissor),h.viewport.multiplyScalar(this._pixelRatio),h.scissor.multiplyScalar(this._pixelRatio),h.scissorTest=this._scissorTest,h.multiview=null!==d&&d.multiview,h.resolveDepthBuffer=null===d||d.resolveDepthBuffer,h._autoAllocateDepthBuffer=null!==d&&d._autoAllocateDepthBuffer,h}_renderScene(e,t,i=!0){if(!0===this._isDeviceLost)return;const r=i?this._getFrameBufferTarget():null,s=this._nodes.nodeFrame,n=s.renderId,o=this._currentRenderContext,a=this._currentRenderObjectFunction,h=!0===e.isScene?e:_scene,d=this._renderTarget||this._outputRenderTarget,l=this._activeCubeFace,c=this._activeMipmapLevel;let u;null!==r?(u=r,this.setRenderTarget(u)):u=d;const p=this._renderContexts.get(e,t,u);this._currentRenderContext=p,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,s.renderId=this.info.calls;const _=this.coordinateSystem,g=this.xr;if(t.coordinateSystem!==_&&!1===g.isPresenting&&(t.coordinateSystem=_,t.updateProjectionMatrix(),t.isArrayCamera))for(const e of t.cameras)e.coordinateSystem=_,e.updateProjectionMatrix();!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===g.enabled&&!0===g.isPresenting&&(!0===g.cameraAutoUpdate&&g.updateCamera(t),t=g.getCamera());let m=this._viewport,f=this._scissor,b=this._pixelRatio;null!==u&&(m=u.viewport,f=u.scissor,b=1),this.getDrawingBufferSize(_drawingBufferSize),_screen.set(0,0,_drawingBufferSize.width,_drawingBufferSize.height);const x=void 0===m.minDepth?0:m.minDepth,w=void 0===m.maxDepth?1:m.maxDepth;p.viewportValue.copy(m).multiplyScalar(b).floor(),p.viewportValue.width>>=c,p.viewportValue.height>>=c,p.viewportValue.minDepth=x,p.viewportValue.maxDepth=w,p.viewport=!1===p.viewportValue.equals(_screen),p.scissorValue.copy(f).multiplyScalar(b).floor(),p.scissor=this._scissorTest&&!1===p.scissorValue.equals(_screen),p.scissorValue.width>>=c,p.scissorValue.height>>=c,p.clippingContext||(p.clippingContext=new ClippingContext),p.clippingContext.updateGlobal(h,t),h.onBeforeRender(this,e,t,u);const R=t.isArrayCamera?_frustumArray:_frustum;t.isArrayCamera||(_projScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),R.setFromProjectionMatrix(_projScreenMatrix,t.coordinateSystem,t.reversedDepth));const T=this._renderLists.get(e,t);if(T.begin(),this._projectObject(e,t,0,T,p.clippingContext),T.finish(),!0===this.sortObjects&&T.sort(this._opaqueSort,this._transparentSort),null!==u){this._textures.updateRenderTarget(u,c);const e=this._textures.get(u);p.textures=e.textures,p.depthTexture=e.depthTexture,p.width=e.width,p.height=e.height,p.renderTarget=u,p.depth=u.depthBuffer,p.stencil=u.stencilBuffer}else p.textures=null,p.depthTexture=null,p.width=this.domElement.width,p.height=this.domElement.height,p.depth=this.depth,p.stencil=this.stencil;p.width>>=c,p.height>>=c,p.activeCubeFace=l,p.activeMipmapLevel=c,p.occlusionQueryCount=T.occlusionQueryCount,this._background.update(h,T,p),p.camera=t,this.backend.beginRender(p);const{bundles:y,lightsNode:C,transparentDoublePass:S,transparent:v,opaque:j}=T;return y.length>0&&this._renderBundles(y,h,C),!0===this.opaque&&j.length>0&&this._renderObjects(j,t,h,C),!0===this.transparent&&v.length>0&&this._renderTransparents(v,S,t,h,C),this.backend.finishRender(p),s.renderId=n,this._currentRenderContext=o,this._currentRenderObjectFunction=a,null!==r&&(this.setRenderTarget(d,l,c),this._renderOutput(u)),h.onAfterRender(this,e,t,u),p}_setXRLayerSize(e,t){this._width=e,this._height=t,this.setViewport(0,0,e,t)}_renderOutput(e){const t=this._quad;this._nodes.hasOutputChange(e.texture)&&(t.material.fragmentNode=this._nodes.getOutputNode(e.texture),t.material.needsUpdate=!0);const i=this.autoClear,r=this.xr.enabled;this.autoClear=!1,this.xr.enabled=!1,this._renderScene(t,t.camera,!1),this.autoClear=i,this.xr.enabled=r}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(e){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(e)}async getArrayBufferAsync(e){return await this.backend.getArrayBufferAsync(e)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio!==e&&(this._pixelRatio=e,this.setSize(this._width,this._height,!1))}setDrawingBufferSize(e,t,i){this.xr&&this.xr.isPresenting||(this._width=e,this._height=t,this._pixelRatio=i,this.domElement.width=Math.floor(e*i),this.domElement.height=Math.floor(t*i),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize())}setSize(e,t,i=!0){this.xr&&this.xr.isPresenting||(this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===i&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize())}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,i,r){const s=this._scissor;e.isVector4?s.copy(e):s.set(e,t,i,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e,this.backend.setScissorTest(e)}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,i,r,s=0,n=1){const o=this._viewport;e.isVector4?o.copy(e):o.set(e,t,i,r),o.minDepth=s,o.maxDepth=n}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearColor.a=t}getClearAlpha(){return this._clearColor.a}setClearAlpha(e){this._clearColor.a=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}isOccluded(e){const t=this._currentRenderContext;return t&&this.backend.isOccluded(t,e)}clear(e=!0,t=!0,i=!0){if(!1===this._initialized)return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."),this.clearAsync(e,t,i);const r=this._renderTarget||this._getFrameBufferTarget();let s=null;if(null!==r){this._textures.updateRenderTarget(r);const e=this._textures.get(r);s=this._renderContexts.getForClear(r),s.textures=e.textures,s.depthTexture=e.depthTexture,s.width=e.width,s.height=e.height,s.renderTarget=r,s.depth=r.depthBuffer,s.stencil=r.stencilBuffer,s.clearColorValue=this.backend.getClearColor(),s.activeCubeFace=this.getActiveCubeFace(),s.activeMipmapLevel=this.getActiveMipmapLevel()}this.backend.clear(e,t,i,s),null!==r&&null===this._renderTarget&&this._renderOutput(r)}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(e=!0,t=!0,i=!0){!1===this._initialized&&await this.init(),this.clear(e,t,i)}async clearColorAsync(){this.clearAsync(!0,!1,!1)}async clearDepthAsync(){this.clearAsync(!1,!0,!1)}async clearStencilAsync(){this.clearAsync(!1,!1,!0)}get currentToneMapping(){return this.isOutputTarget?this.toneMapping:NoToneMapping}get currentColorSpace(){return this.isOutputTarget?this.outputColorSpace:ColorManagement.workingColorSpace}get isOutputTarget(){return this._renderTarget===this._outputRenderTarget||null===this._renderTarget}dispose(){this.info.dispose(),this.backend.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),null!==this._frameBufferTarget&&this._frameBufferTarget.dispose(),Object.values(this.backend.timestampQueryPool).forEach((e=>{null!==e&&e.dispose()})),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0,i=0){this._renderTarget=e,this._activeCubeFace=t,this._activeMipmapLevel=i}getRenderTarget(){return this._renderTarget}setOutputRenderTarget(e){this._outputRenderTarget=e}getOutputRenderTarget(){return this._outputRenderTarget}_resetXRState(){this.backend.setXRTarget(null),this.setOutputRenderTarget(null),this.setRenderTarget(null),this._frameBufferTarget.dispose(),this._frameBufferTarget=null}setRenderObjectFunction(e){this._renderObjectFunction=e}getRenderObjectFunction(){return this._renderObjectFunction}compute(e,t=null){if(!0===this._isDeviceLost)return;if(!1===this._initialized)return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."),this.computeAsync(e);const i=this._nodes.nodeFrame,r=i.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,i.renderId=this.info.calls;const s=this.backend,n=this._pipelines,o=this._bindings,a=this._nodes,h=Array.isArray(e)?e:[e];if(void 0===h[0]||!0!==h[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");s.beginCompute(e);for(const i of h){if(!1===n.has(i)){const e=()=>{i.removeEventListener("dispose",e),n.delete(i),o.delete(i),a.delete(i)};i.addEventListener("dispose",e);const t=i.onInitFunction;null!==t&&t.call(i,{renderer:this})}a.updateForCompute(i),o.updateForCompute(i);const r=o.getForCompute(i),h=n.getForCompute(i,r);s.compute(e,i,r,h,t)}s.finishCompute(e),i.renderId=r}async computeAsync(e,t=null){!1===this._initialized&&await this.init(),this.compute(e,t)}async hasFeatureAsync(e){return!1===this._initialized&&await this.init(),this.backend.hasFeature(e)}async resolveTimestampsAsync(e="render"){return!1===this._initialized&&await this.init(),this.backend.resolveTimestampsAsync(e)}hasFeature(e){return!1===this._initialized?(console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."),!1):this.backend.hasFeature(e)}hasInitialized(){return this._initialized}async initTextureAsync(e){!1===this._initialized&&await this.init(),this._textures.updateTexture(e)}initTexture(e){!1===this._initialized&&console.warn("THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."),this._textures.updateTexture(e)}copyFramebufferToTexture(e,t=null){if(null!==t)if(t.isVector2)t=_vector4.set(t.x,t.y,e.image.width,e.image.height).floor();else{if(!t.isVector4)return void console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");t=_vector4.copy(t).floor()}else t=_vector4.set(0,0,e.image.width,e.image.height);let i,r=this._currentRenderContext;null!==r?i=r.renderTarget:(i=this._renderTarget||this._getFrameBufferTarget(),null!==i&&(this._textures.updateRenderTarget(i),r=this._textures.get(i))),this._textures.updateTexture(e,{renderTarget:i}),this.backend.copyFramebufferToTexture(e,r,t)}copyTextureToTexture(e,t,i=null,r=null,s=0,n=0){this._textures.updateTexture(e),this._textures.updateTexture(t),this.backend.copyTextureToTexture(e,t,i,r,s,n)}async readRenderTargetPixelsAsync(e,t,i,r,s,n=0,o=0){return this.backend.copyTextureToBuffer(e.textures[n],t,i,r,s,o)}_projectObject(e,t,i,r,s){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)i=e.renderOrder,e.isClippingGroup&&e.enabled&&(s=s.getGroupContext(e));else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){const n=t.isArrayCamera?_frustumArray:_frustum;if(!e.frustumCulled||n.intersectsSprite(e,t)){!0===this.sortObjects&&_vector4.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_projScreenMatrix);const{geometry:t,material:n}=e;n.visible&&r.push(e,t,n,i,_vector4.z,null,s)}}else if(e.isLineLoop)console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if(e.isMesh||e.isLine||e.isPoints){const n=t.isArrayCamera?_frustumArray:_frustum;if(!e.frustumCulled||n.intersectsObject(e,t)){const{geometry:t,material:n}=e;if(!0===this.sortObjects&&(null===t.boundingSphere&&t.computeBoundingSphere(),_vector4.copy(t.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(_projScreenMatrix)),Array.isArray(n)){const o=t.groups;for(let a=0,h=o.length;a<h;a++){const h=o[a],d=n[h.materialIndex];d&&d.visible&&r.push(e,t,d,i,_vector4.z,h,s)}}else n.visible&&r.push(e,t,n,i,_vector4.z,null,s)}}if(!0===e.isBundleGroup&&void 0!==this.backend.beginBundle){const i=r;(r=this._renderLists.get(e,t)).begin(),i.pushBundle({bundleGroup:e,camera:t,renderList:r}),r.finish()}const n=e.children;for(let e=0,o=n.length;e<o;e++)this._projectObject(n[e],t,i,r,s)}_renderBundles(e,t,i){for(const r of e)this._renderBundle(r,t,i)}_renderTransparents(e,t,i,r,s){if(t.length>0){for(const{material:e}of t)e.side=BackSide;this._renderObjects(t,i,r,s,"backSide");for(const{material:e}of t)e.side=FrontSide;this._renderObjects(e,i,r,s);for(const{material:e}of t)e.side=DoubleSide}else this._renderObjects(e,i,r,s)}_renderObjects(e,t,i,r,s=null){for(let n=0,o=e.length;n<o;n++){const{object:o,geometry:a,material:h,group:d,clippingContext:l}=e[n];this._currentRenderObjectFunction(o,i,t,a,h,d,r,l,s)}}renderObject(e,t,i,r,s,n,o,a=null,h=null){let d,l,c;if(e.onBeforeRender(this,t,i,r,s,n),!0===s.allowOverride&&null!==t.overrideMaterial){const e=t.overrideMaterial;s.positionNode&&s.positionNode.isNode&&(d=e.positionNode,e.positionNode=s.positionNode),e.alphaTest=s.alphaTest,e.alphaMap=s.alphaMap,e.transparent=s.transparent||s.transmission>0,e.isShadowPassMaterial&&(e.side=null===s.shadowSide?s.side:s.shadowSide,s.depthNode&&s.depthNode.isNode&&(c=e.depthNode,e.depthNode=s.depthNode),s.castShadowNode&&s.castShadowNode.isNode&&(l=e.colorNode,e.colorNode=s.castShadowNode),s.castShadowPositionNode&&s.castShadowPositionNode.isNode&&(d=e.positionNode,e.positionNode=s.castShadowPositionNode)),s=e}!0===s.transparent&&s.side===DoubleSide&&!1===s.forceSinglePass?(s.side=BackSide,this._handleObjectFunction(e,s,t,i,o,n,a,"backSide"),s.side=FrontSide,this._handleObjectFunction(e,s,t,i,o,n,a,h),s.side=DoubleSide):this._handleObjectFunction(e,s,t,i,o,n,a,h),void 0!==d&&(t.overrideMaterial.positionNode=d),void 0!==c&&(t.overrideMaterial.depthNode=c),void 0!==l&&(t.overrideMaterial.colorNode=l),e.onAfterRender(this,t,i,r,s,n)}_renderObjectDirect(e,t,i,r,s,n,o,a){const h=this._objects.get(e,t,i,r,s,this._currentRenderContext,o,a);h.drawRange=e.geometry.drawRange,h.group=n;const d=this._nodes.needsRefresh(h);if(d&&(this._nodes.updateBefore(h),this._geometries.updateForRender(h),this._nodes.updateForRender(h),this._bindings.updateForRender(h)),this._pipelines.updateForRender(h),null!==this._currentRenderBundle){this.backend.get(this._currentRenderBundle).renderObjects.push(h),h.bundle=this._currentRenderBundle.bundleGroup}this.backend.draw(h,this.info),d&&this._nodes.updateAfter(h)}_createObjectPipeline(e,t,i,r,s,n,o,a){const h=this._objects.get(e,t,i,r,s,this._currentRenderContext,o,a);h.drawRange=e.geometry.drawRange,h.group=n,this._nodes.updateBefore(h),this._geometries.updateForRender(h),this._nodes.updateForRender(h),this._bindings.updateForRender(h),this._pipelines.getForRender(h,this._compilationPromises),this._nodes.updateAfter(h)}get compile(){return this.compileAsync}}export default Renderer;
//# sourceMappingURL=Renderer.js.map