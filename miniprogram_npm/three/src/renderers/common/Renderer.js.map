{"version":3,"file":"node_modules/three/src/renderers/common/Renderer.js","names":["Animation","RenderObjects","Attributes","Geometries","Info","Pipelines","Bindings","RenderLists","RenderContexts","Textures","Background","Nodes","Color4","ClippingContext","QuadMesh","RenderBundles","NodeLibrary","Lighting","XRManager","NodeMaterial","Scene","ColorManagement","Frustum","FrustumArray","Matrix4","Vector2","Vector4","RenderTarget","DoubleSide","BackSide","FrontSide","SRGBColorSpace","NoToneMapping","LinearFilter","HalfFloatType","RGBAFormat","PCFShadowMap","highpModelNormalViewMatrix","highpModelViewMatrix","_scene","_drawingBufferSize","_screen","_frustum","_frustumArray","_projScreenMatrix","_vector4","Renderer","constructor","backend","parameters","this","isRenderer","logarithmicDepthBuffer","alpha","depth","stencil","antialias","samples","getFallback","colorBufferType","multiview","domElement","getDomElement","autoClear","autoClearColor","autoClearDepth","autoClearStencil","outputColorSpace","toneMapping","toneMappingExposure","sortObjects","info","overrideNodes","modelViewMatrix","modelNormalViewMatrix","library","lighting","_getFallback","_pixelRatio","_width","width","_height","height","_viewport","_scissor","_scissorTest","_attributes","_geometries","_nodes","_animation","_bindings","_objects","_pipelines","_bundles","_renderLists","_renderContexts","_textures","_background","_quad","material","name","_currentRenderContext","_opaqueSort","_transparentSort","_frameBufferTarget","alphaClear","_clearColor","_clearDepth","_clearStencil","_renderTarget","_activeCubeFace","_activeMipmapLevel","_outputRenderTarget","_mrt","_renderObjectFunction","_currentRenderObjectFunction","_currentRenderBundle","_handleObjectFunction","_renderObjectDirect","_isDeviceLost","onDeviceLost","_onDeviceLost","_colorBufferType","_initialized","_initPromise","_compilationPromises","transparent","opaque","shadowMap","enabled","type","xr","debug","checkShaderErrors","onShaderError","getShaderAsync","async","scene","camera","object","compileAsync","renderList","get","renderContext","overrideMaterial","renderObject","lightsNode","clippingContext","fragmentShader","vertexShader","getNodeBuilderState","init","Error","Promise","resolve","reject","error","start","coordinateSystem","targetScene","nodeFrame","previousRenderId","renderId","previousRenderContext","previousRenderObjectFunction","previousCompilationPromises","sceneRef","isScene","renderTarget","activeMipmapLevel","compilationPromises","_createObjectPipeline","update","updateGlobal","onBeforeRender","begin","_projectObject","traverseVisible","isLight","layers","test","pushLight","finish","updateRenderTarget","renderTargetData","textures","depthTexture","opaqueObjects","transparentObjects","transparentDoublePassObjects","transparentDoublePass","length","_renderObjects","_renderTransparents","all","renderAsync","_renderScene","waitForGPU","highPrecision","value","setMRT","mrt","getMRT","getColorBufferType","errorMessage","api","message","reason","console","_renderBundle","bundle","bundleGroup","renderBundle","renderBundleData","undefined","renderContexts","Set","needsUpdate","version","renderBundleNeedsUpdate","has","add","beginBundle","renderObjects","finishBundle","i","l","needsRefresh","updateBefore","updateForRender","updateAfter","addBundle","render","warn","_getFrameBufferTarget","currentToneMapping","currentColorSpace","useToneMapping","useColorSpace","workingColorSpace","getDrawingBufferSize","frameBufferTarget","depthBuffer","stencilBuffer","format","colorSpace","generateMipmaps","minFilter","magFilter","isPostProcessingRenderTarget","outputRenderTarget","getOutputRenderTarget","setSize","viewport","copy","scissor","multiplyScalar","scissorTest","resolveDepthBuffer","_autoAllocateDepthBuffer","useFrameBufferTarget","activeCubeFace","setRenderTarget","calls","frameCalls","isPresenting","updateProjectionMatrix","isArrayCamera","subCamera","cameras","matrixWorldAutoUpdate","updateMatrixWorld","parent","cameraAutoUpdate","updateCamera","getCamera","pixelRatio","set","minDepth","maxDepth","viewportValue","floor","equals","scissorValue","frustum","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","reversedDepth","sort","occlusionQueryCount","beginRender","bundles","_renderBundles","finishRender","_renderOutput","onAfterRender","_setXRLayerSize","setViewport","quad","hasOutputChange","texture","fragmentNode","getOutputNode","currentAutoClear","currentXR","getMaxAnisotropy","getActiveCubeFace","getActiveMipmapLevel","setAnimationLoop","callback","getArrayBufferAsync","attribute","getContext","getPixelRatio","target","getSize","setPixelRatio","setDrawingBufferSize","Math","updateSize","updateStyle","style","setOpaqueSort","method","setTransparentSort","getScissor","x","y","setScissor","isVector4","getScissorTest","setScissorTest","boolean","getViewport","getClearColor","setClearColor","color","a","getClearAlpha","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","clear","clearAsync","getForClear","clearColorValue","clearColor","clearDepth","clearStencil","clearColorAsync","clearDepthAsync","clearStencilAsync","isOutputTarget","dispose","Object","values","timestampQueryPool","forEach","queryPool","getRenderTarget","setOutputRenderTarget","_resetXRState","setXRTarget","setRenderObjectFunction","renderObjectFunction","getRenderObjectFunction","compute","computeNodes","dispatchSizeOrCount","computeAsync","pipelines","bindings","nodes","computeList","Array","isArray","isComputeNode","beginCompute","computeNode","removeEventListener","delete","addEventListener","onInitFn","onInitFunction","call","renderer","updateForCompute","computeBindings","getForCompute","computePipeline","finishCompute","hasFeatureAsync","hasFeature","resolveTimestampsAsync","hasInitialized","initTextureAsync","updateTexture","initTexture","copyFramebufferToTexture","framebufferTexture","rectangle","isVector2","image","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","srcLevel","dstLevel","readRenderTargetPixelsAsync","textureIndex","faceIndex","copyTextureToBuffer","groupOrder","visible","isGroup","renderOrder","isClippingGroup","getGroupContext","isLOD","autoUpdate","isSprite","frustumCulled","intersectsSprite","setFromMatrixPosition","matrixWorld","applyMatrix4","geometry","push","z","isLineLoop","isMesh","isLine","isPoints","intersectsObject","boundingSphere","computeBoundingSphere","center","groups","group","groupMaterial","materialIndex","isBundleGroup","baseRenderList","pushBundle","children","doublePassList","side","passId","il","overridePositionNode","overrideColorNode","overrideDepthNode","allowOverride","positionNode","isNode","alphaTest","alphaMap","transmission","isShadowPassMaterial","shadowSide","depthNode","castShadowNode","colorNode","castShadowPositionNode","forceSinglePass","drawRange","draw","getForRender","compile"],"sources":["node_modules/three/src/renderers/common/Renderer.js"],"sourcesContent":["import Animation from './Animation.js';\nimport RenderObjects from './RenderObjects.js';\nimport Attributes from './Attributes.js';\nimport Geometries from './Geometries.js';\nimport Info from './Info.js';\nimport Pipelines from './Pipelines.js';\nimport Bindings from './Bindings.js';\nimport RenderLists from './RenderLists.js';\nimport RenderContexts from './RenderContexts.js';\nimport Textures from './Textures.js';\nimport Background from './Background.js';\nimport Nodes from './nodes/Nodes.js';\nimport Color4 from './Color4.js';\nimport ClippingContext from './ClippingContext.js';\nimport QuadMesh from './QuadMesh.js';\nimport RenderBundles from './RenderBundles.js';\nimport NodeLibrary from './nodes/NodeLibrary.js';\nimport Lighting from './Lighting.js';\nimport XRManager from './XRManager.js';\n\nimport NodeMaterial from '../../materials/nodes/NodeMaterial.js';\n\nimport { Scene } from '../../scenes/Scene.js';\nimport { ColorManagement } from '../../math/ColorManagement.js';\nimport { Frustum } from '../../math/Frustum.js';\nimport { FrustumArray } from '../../math/FrustumArray.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { RenderTarget } from '../../core/RenderTarget.js';\nimport { DoubleSide, BackSide, FrontSide, SRGBColorSpace, NoToneMapping, LinearFilter, HalfFloatType, RGBAFormat, PCFShadowMap } from '../../constants.js';\n\nimport { highpModelNormalViewMatrix, highpModelViewMatrix } from '../../nodes/accessors/ModelNode.js';\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _frustumArray = /*@__PURE__*/ new FrustumArray();\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\n/**\n * Base class for renderers.\n */\nclass Renderer {\n\n\t/**\n\t * Renderer options.\n\t *\n\t * @typedef {Object} Renderer~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0\n\t * to overwrite the default.\n\t * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best\n\t * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.\n\t * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.\n\t */\n\n\t/**\n\t * Constructs a new renderer.\n\t *\n\t * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).\n\t * @param {Renderer~Options} [parameters] - The configuration parameter.\n\n\t */\n\tconstructor( backend, parameters = {} ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null,\n\t\t\tcolorBufferType = HalfFloatType,\n\t\t\tmultiview = false\n\t\t} = parameters;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t * This value of this property will automatically be created by\n\t\t * the renderer.\n\t\t *\n\t\t * @type {HTMLCanvasElement|OffscreenCanvas}\n\t\t */\n\t\tthis.domElement = backend.getDomElement();\n\n\t\t/**\n\t\t * A reference to the current backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The number of MSAA samples.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\t/**\n\t\t * Whether the renderer should automatically clear the current rendering target\n\t\t * before execute a `render()` call. The target can be the canvas (default framebuffer)\n\t\t * or the current bound render target (custom framebuffer).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the color buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearColor = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the depth buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearDepth = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the stencil buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearStencil = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should be transparent or opaque.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.alpha = alpha;\n\n\t\t/**\n\t\t * Whether logarithmic depth buffer is enabled or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\t/**\n\t\t * Defines the output color space of the renderer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default SRGBColorSpace\n\t\t */\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\t/**\n\t\t * Defines the tone mapping of the renderer.\n\t\t *\n\t\t * @type {number}\n\t\t * @default NoToneMapping\n\t\t */\n\t\tthis.toneMapping = NoToneMapping;\n\n\t\t/**\n\t\t * Defines the tone mapping exposure.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t/**\n\t\t * Whether the renderer should sort its render lists or not.\n\t\t *\n\t\t * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.\n\t\t * By definition, sorting objects may not work in all cases. Depending on the needs of application,\n\t\t * it may be necessary to turn off sorting and use other methods to deal with transparency rendering\n\t\t * e.g. manually determining each object's rendering order.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a depth buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a stencil buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = stencil;\n\n\t\t/**\n\t\t * Holds a series of statistical information about the GPU memory\n\t\t * and the rendering process. Useful for debugging and monitoring.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = new Info();\n\n\t\t/**\n\t\t * Stores override nodes for specific transformations or calculations.\n\t\t * These nodes can be used to replace default behavior in the rendering pipeline.\n\t\t *\n\t\t * @type {Object}\n\t\t * @property {?Node} modelViewMatrix - An override node for the model-view matrix.\n\t\t * @property {?Node} modelNormalViewMatrix - An override node for the model normal view matrix.\n\t\t */\n\t\tthis.overrideNodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\t/**\n\t\t * The node library defines how certain library objects like materials, lights\n\t\t * or tone mapping functions are mapped to node types. This is required since\n\t\t * although instances of classes like `MeshBasicMaterial` or `PointLight` can\n\t\t * be part of the scene graph, they are internally represented as nodes for\n\t\t * further processing.\n\t\t *\n\t\t * @type {NodeLibrary}\n\t\t */\n\t\tthis.library = new NodeLibrary();\n\n\t\t/**\n\t\t * A map-like data structure for managing lights.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\t/**\n\t\t * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t */\n\t\tthis._getFallback = getFallback;\n\n\t\t/**\n\t\t * The renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The width of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._width = this.domElement.width;\n\n\t\t/**\n\t\t * The height of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._height = this.domElement.height;\n\n\t\t/**\n\t\t * The viewport of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * The scissor rectangle of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * Whether the scissor test should be enabled or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._scissorTest = false;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {?Attributes}\n\t\t * @default null\n\t\t */\n\t\tthis._attributes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing geometries.\n\t\t *\n\t\t * @private\n\t\t * @type {?Geometries}\n\t\t * @default null\n\t\t */\n\t\tthis._geometries = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing node related logic.\n\t\t *\n\t\t * @private\n\t\t * @type {?Nodes}\n\t\t * @default null\n\t\t */\n\t\tthis._nodes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing the internal animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {?Animation}\n\t\t * @default null\n\t\t */\n\t\tthis._animation = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader program bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {?Bindings}\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render objects.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderObjects}\n\t\t * @default null\n\t\t */\n\t\tthis._objects = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render and compute pipelines.\n\t\t *\n\t\t * @private\n\t\t * @type {?Pipelines}\n\t\t * @default null\n\t\t */\n\t\tthis._pipelines = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render bundles.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderBundles}\n\t\t * @default null\n\t\t */\n\t\tthis._bundles = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render lists.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderLists}\n\t\t * @default null\n\t\t */\n\t\tthis._renderLists = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render contexts.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderContexts}\n\t\t * @default null\n\t\t */\n\t\tthis._renderContexts = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing textures.\n\t\t *\n\t\t * @private\n\t\t * @type {?Textures}\n\t\t * @default null\n\t\t */\n\t\tthis._textures = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for backgrounds.\n\t\t *\n\t\t * @private\n\t\t * @type {?Background}\n\t\t * @default null\n\t\t */\n\t\tthis._background = null;\n\n\t\t/**\n\t\t * This fullscreen quad is used for internal render passes\n\t\t * like the tone mapping and color space output pass.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.material.name = 'Renderer_output';\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderContext = null;\n\n\t\t/**\n\t\t * A custom sort function for the opaque render list.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._opaqueSort = null;\n\n\t\t/**\n\t\t * A custom sort function for the transparent render list.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._transparentSort = null;\n\n\t\t/**\n\t\t * The framebuffer target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @private\n\t\t * @type {Color4}\n\t\t */\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._clearDepth = 1;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._clearStencil = 0;\n\n\t\t/**\n\t\t * The current render target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._renderTarget = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The current output render target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._outputRenderTarget = null;\n\n\t\t/**\n\t\t * The MRT setting.\n\t\t *\n\t\t * @private\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This function defines how a render object is going\n\t\t * to be rendered.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._renderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render object function.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render bundle.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderBundle}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderBundle = null;\n\n\t\t/**\n\t\t * Next to `_renderObjectFunction()`, this function provides another hook\n\t\t * for influencing the render process of a render object. It is meant for internal\n\t\t * use and only relevant for `compileAsync()` right now. Instead of using\n\t\t * the default logic of `_renderObjectDirect()` which actually draws the render object,\n\t\t * a different function might be used which performs no draw but just the node\n\t\t * and pipeline updates.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t/**\n\t\t * Indicates whether the device has been lost or not. In WebGL terms, the device\n\t\t * lost is considered as a context lost. When this is set to `true`, rendering\n\t\t * isn't possible anymore.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._isDeviceLost = false;\n\n\t\t/**\n\t\t * A callback function that defines what should happen when a device/context lost occurs.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\t/**\n\t\t * Defines the type of color buffers. The default `HalfFloatType` is recommend for\n\t\t * best quality. To save memory and bandwidth, `UnsignedByteType` might be used.\n\t\t * This will reduce rendering quality though.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis._colorBufferType = colorBufferType;\n\n\t\t/**\n\t\t * Whether the renderer has been initialized or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * A reference to the promise which initializes the renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {?Promise<this>}\n\t\t * @default null\n\t\t */\n\t\tthis._initPromise = null;\n\n\t\t/**\n\t\t * An array of compilation promises which are used in `compileAsync()`.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<Promise>}\n\t\t * @default null\n\t\t */\n\t\tthis._compilationPromises = null;\n\n\t\t/**\n\t\t * Whether the renderer should render transparent render objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\t/**\n\t\t * Whether the renderer should render opaque render objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.opaque = true;\n\n\t\t/**\n\t\t * Shadow map configuration\n\t\t * @typedef {Object} ShadowMapConfig\n\t\t * @property {boolean} enabled - Whether to globally enable shadows or not.\n\t\t * @property {number} type - The shadow map type.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's shadow configuration.\n\t\t *\n\t\t * @type {ShadowMapConfig}\n\t\t */\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\t/**\n\t\t * XR configuration.\n\t\t * @typedef {Object} XRConfig\n\t\t * @property {boolean} enabled - Whether to globally enable XR or not.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's XR manager.\n\t\t *\n\t\t * @type {XRManager}\n\t\t */\n\t\tthis.xr = new XRManager( this, multiview );\n\n\t\t/**\n\t\t * Debug configuration.\n\t\t * @typedef {Object} DebugConfig\n\t\t * @property {boolean} checkShaderErrors - Whether shader errors should be checked or not.\n\t\t * @property {?Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.\n\t\t * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camera and 3D object.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's debug configuration.\n\t\t *\n\t\t * @type {DebugConfig}\n\t\t */\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\t/**\n\t * Initializes the renderer so it is ready for usage.\n\t *\n\t * @async\n\t * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.\n\t */\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve( this );\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\t/**\n\t * The coordinate system of the renderer. The value of this property\n\t * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or\n\t * `THREE.WebGPUCoordinateSystem`.\n\t *\n\t * @readonly\n\t * @type {number}\n\t */\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\t/**\n\t * Compiles all materials in the given scene. This can be useful to avoid a\n\t * phenomenon which is called \"shader compilation stutter\", which occurs when\n\t * rendering an object with a new shader for the first time.\n\t *\n\t * If you want to add a 3D object to an existing scene, use the third optional\n\t * parameter for applying the target scene. Note that the (target) scene's lighting\n\t * and environment must be configured before calling this method.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.\n\t */\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\t/**\n\t * Renders the scene in an async fashion.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.backend.waitForGPU();\n\n\t}\n\n\t/**\n\t * Enables or disables high precision for model-view and normal-view matrices.\n\t * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.\n\t *\n\t * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.\n\t *\n\t * @param {boolean} value - Whether to enable or disable high precision.\n\t * @type {boolean}\n\t */\n\tset highPrecision( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.overrideNodes.modelViewMatrix = highpModelViewMatrix;\n\t\t\tthis.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;\n\n\t\t} else if ( this.highPrecision ) {\n\n\t\t\tthis.overrideNodes.modelViewMatrix = null;\n\t\t\tthis.overrideNodes.modelNormalViewMatrix = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns whether high precision is enabled or not.\n\t *\n\t * @return {boolean} Whether high precision is enabled or not.\n\t * @type {boolean}\n\t */\n\tget highPrecision() {\n\n\t\treturn this.overrideNodes.modelViewMatrix === highpModelViewMatrix && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix;\n\n\t}\n\n\t/**\n\t * Sets the given MRT configuration.\n\t *\n\t * @param {MRTNode} mrt - The MRT node to set.\n\t * @return {Renderer} A reference to this renderer.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the MRT configuration.\n\t *\n\t * @return {MRTNode} The MRT configuration.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Returns the color buffer type.\n\t *\n\t * @return {number} The color buffer type.\n\t */\n\tgetColorBufferType() {\n\n\t\treturn this._colorBufferType;\n\n\t}\n\n\t/**\n\t * Default implementation of the device lost callback.\n\t *\n\t * @private\n\t * @param {Object} info - Information about the context lost.\n\t */\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\tconsole.error( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\t/**\n\t * Renders the given render bundle.\n\t *\n\t * @private\n\t * @param {Object} bundle - Render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundle belongs to.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t */\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst {\n\t\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\t\ttransparent: transparentObjects,\n\t\t\t\topaque: opaqueObjects\n\t\t\t} = renderList;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * The target of the method is the default framebuffer (meaning the canvas)\n\t * or alternatively a render target when specified via `setRenderTarget()`.\n\t *\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @return {?Promise} A Promise that resolve when the scene has been rendered.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );\n\n\t\t\treturn this.renderAsync( scene, camera );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Returns an internal render target which is used when computing the output tone mapping\n\t * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render\n\t * pass and not inline to achieve more correct results.\n\t *\n\t * @private\n\t * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.\n\t */\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: this._colorBufferType,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: ColorManagement.workingColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tconst outputRenderTarget = this.getOutputRenderTarget();\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tif ( outputRenderTarget !== null ) {\n\n\t\t\tframeBufferTarget.setSize( outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth );\n\n\t\t} else {\n\n\t\t\tframeBufferTarget.setSize( width, height, 1 );\n\n\t\t}\n\n\t\tframeBufferTarget.viewport.copy( this._viewport );\n\t\tframeBufferTarget.scissor.copy( this._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissorTest = this._scissorTest;\n\t\tframeBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;\n\t\tframeBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;\n\t\tframeBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera.\n\t *\n\t * @private\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.\n\t * @return {RenderContext} The current render context.\n\t */\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget || this._outputRenderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\t\tconst xr = this.xr;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\t\t\tsubCamera.coordinateSystem = coordinateSystem;\n\t\t\t\t\tsubCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t}\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\tif ( ! camera.isArrayCamera ) {\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\tfrustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );\n\n\t\t}\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\trenderContext.camera = camera;\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tthis._renderOutput( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\t_setXRLayerSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t}\n\n\t/**\n\t * The output pass performs tone mapping and color space conversion.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The current render target.\n\t */\n\t_renderOutput( renderTarget ) {\n\n\t\tconst quad = this._quad;\n\n\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\tquad.material.needsUpdate = true;\n\n\t\t}\n\n\t\t// a clear operation clears the intermediate renderTarget texture, but should not update the screen canvas.\n\n\t\tconst currentAutoClear = this.autoClear;\n\t\tconst currentXR = this.xr.enabled;\n\n\t\tthis.autoClear = false;\n\t\tthis.xr.enabled = false;\n\n\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\tthis.autoClear = currentAutoClear;\n\t\tthis.xr.enabled = currentXR;\n\n\n\t}\n\n\t/**\n\t * Returns the maximum available anisotropy for texture filtering.\n\t *\n\t * @return {number} The maximum available anisotropy.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Returns the active cube face.\n\t *\n\t * @return {number} The active cube face.\n\t */\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\t/**\n\t * Returns the active mipmap level.\n\t *\n\t * @return {number} The active mipmap level.\n\t */\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Applications are advised to always define the animation loop\n\t * with this method and not manually with `requestAnimationFrame()`\n\t * for best compatibility.\n\t *\n\t * @async\n\t * @param {?Function} callback - The application's animation loop.\n\t * @return {Promise} A Promise that resolves when the set has been executed.\n\t */\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\t/**\n\t * Can be used to transfer buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the rendering context.\n\t *\n\t * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\t/**\n\t * Returns the pixel ratio.\n\t *\n\t * @return {number} The pixel ratio.\n\t */\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\t/**\n\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\t/**\n\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The renderer's size in logical pixels.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Sets the given pixel ratio and resizes the canvas if necessary.\n\t *\n\t * @param {number} [value=1] - The pixel ratio.\n\t */\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\t/**\n\t * This method allows to define the drawing buffer size by specifying\n\t * width, height and pixel ratio all at once. The size of the drawing\n\t * buffer is computed with this formula:\n\t * ```js\n\t * size.x = width * pixelRatio;\n\t * size.y = height * pixelRatio;\n\t * ```\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {number} pixelRatio - The pixel ratio.\n\t */\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Sets the size of the renderer.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t */\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the opaque render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the transparent render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\t/**\n\t * Returns the scissor rectangle.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The scissor rectangle.\n\t */\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Defines the scissor rectangle.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {number} width - The width of the scissor box in logical pixel unit.\n\t * @param {number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the scissor test value.\n\t *\n\t * @return {boolean} Whether the scissor test should be enabled or not.\n\t */\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the viewport definition.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The viewport definition.\n\t */\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * Defines the viewport.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.\n\t * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n\t */\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\t/**\n\t * Returns the clear color.\n\t *\n\t * @param {Color} target - The method writes the result in this target object.\n\t * @return {Color} The clear color.\n\t */\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\t/**\n\t * Defines the clear color and optionally the clear alpha.\n\t *\n\t * @param {Color} color - The clear color.\n\t * @param {number} [alpha=1] - The clear alpha.\n\t */\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear alpha.\n\t *\n\t * @return {number} The clear alpha.\n\t */\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\t/**\n\t * Defines the clear alpha.\n\t *\n\t * @param {number} alpha - The clear alpha.\n\t */\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear depth.\n\t *\n\t * @return {number} The clear depth.\n\t */\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\t/**\n\t * Defines the clear depth.\n\t *\n\t * @param {number} depth - The clear depth.\n\t */\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\t/**\n\t * Returns the clear stencil.\n\t *\n\t * @return {number} The clear stencil.\n\t */\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\t/**\n\t * Defines the clear stencil.\n\t *\n\t * @param {number} stencil - The clear stencil.\n\t */\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\t/**\n\t * This method performs an occlusion query for the given 3D object.\n\t * It returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation. This method ignores `autoClear` properties.\n\t *\n\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );\n\n\t\t\treturn this.clearAsync( color, depth, stencil );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderContext = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext = this._renderContexts.getForClear( renderTarget );\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\t\t\t// #30329\n\t\t\trenderContext.clearColorValue = this.backend.getClearColor();\n\t\t\trenderContext.activeCubeFace = this.getActiveCubeFace();\n\t\t\trenderContext.activeMipmapLevel = this.getActiveMipmapLevel();\n\n\t\t}\n\n\t\tthis.backend.clear( color, depth, stencil, renderContext );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\tthis._renderOutput( renderTarget );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearColor() {\n\n\t\treturn this.clear( true, false, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearDepth() {\n\n\t\treturn this.clear( false, true, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearStencil() {\n\n\t\treturn this.clear( false, false, true );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clear}.\n\t *\n\t * @async\n\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearColor}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearColorAsync() {\n\n\t\tthis.clearAsync( true, false, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearDepth}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearDepthAsync() {\n\n\t\tthis.clearAsync( false, true, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearStencil}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearStencilAsync() {\n\n\t\tthis.clearAsync( false, false, true );\n\n\t}\n\n\t/**\n\t * The current tone mapping of the renderer. When not producing screen output,\n\t * the tone mapping is always `NoToneMapping`.\n\t *\n\t * @type {number}\n\t */\n\tget currentToneMapping() {\n\n\t\treturn this.isOutputTarget ? this.toneMapping : NoToneMapping;\n\n\t}\n\n\t/**\n\t * The current color space of the renderer. When not producing screen output,\n\t * the color space is always the working color space.\n\t *\n\t * @type {string}\n\t */\n\tget currentColorSpace() {\n\n\t\treturn this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;\n\n\t}\n\n\t/**\n\t * Returns `true` if the rendering settings are set to screen output.\n\t *\n\t * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.\n\t */\n\tget isOutputTarget() {\n\n\t\treturn this._renderTarget === this._outputRenderTarget || this._renderTarget === null;\n\n\t}\n\n\t/**\n\t * Frees all internal resources of the renderer. Call this method if the renderer\n\t * is no longer in use by your app.\n\t */\n\tdispose() {\n\n\t\tthis.info.dispose();\n\t\tthis.backend.dispose();\n\n\t\tthis._animation.dispose();\n\t\tthis._objects.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tif ( this._frameBufferTarget !== null ) this._frameBufferTarget.dispose();\n\n\t\tObject.values( this.backend.timestampQueryPool ).forEach( queryPool => {\n\n\t\t\tif ( queryPool !== null ) queryPool.dispose();\n\n\t\t} );\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\t/**\n\t * Sets the given render target. Calling this method means the renderer does not\n\t * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {?RenderTarget} renderTarget - The render target to set.\n\t * @param {number} [activeCubeFace=0] - The active cube face.\n\t * @param {number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Returns the current render target.\n\t *\n\t * @return {?RenderTarget} The render target. Returns `null` if no render target is set.\n\t */\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\t/**\n\t * Sets the output render target for the renderer.\n\t *\n\t * @param {Object} renderTarget - The render target to set as the output target.\n\t */\n\tsetOutputRenderTarget( renderTarget ) {\n\n\t\tthis._outputRenderTarget = renderTarget;\n\n\t}\n\n\t/**\n\t * Returns the current output target.\n\t *\n\t * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.\n\t */\n\tgetOutputRenderTarget() {\n\n\t\treturn this._outputRenderTarget;\n\n\t}\n\n\t/**\n\t * Resets the renderer to the initial state before WebXR started.\n\t *\n\t */\n\t_resetXRState() {\n\n\t\tthis.backend.setXRTarget( null );\n\t\tthis.setOutputRenderTarget( null );\n\t\tthis.setRenderTarget( null );\n\n\t\tthis._frameBufferTarget.dispose();\n\t\tthis._frameBufferTarget = null;\n\n\t}\n\n\t/**\n\t * Callback for {@link Renderer#setRenderObjectFunction}.\n\t *\n\t * @callback renderObjectFunction\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\n\t/**\n\t * Sets the given render object function. Calling this method overwrites the default implementation\n\t * which is {@link Renderer#renderObject}. Defining a custom function can be useful\n\t * if you want to modify the way objects are rendered. For example you can define things like \"every\n\t * object that has material of a certain type should perform a pre-pass with a special overwrite material\".\n\t * The custom function must always call `renderObject()` in its implementation.\n\t *\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {?renderObjectFunction} renderObjectFunction - The render object function.\n\t */\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Returns the current render object function.\n\t *\n\t * @return {?Function} The current render object function. Returns `null` if no function is set.\n\t */\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.\n\t * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.\n\t */\n\tcompute( computeNodes, dispatchSizeOrCount = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline, dispatchSizeOrCount );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes.\n\t *\n\t * @async\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.\n\t * @return {Promise} A Promise that resolve when the compute has finished.\n\t */\n\tasync computeAsync( computeNodes, dispatchSizeOrCount = null ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes, dispatchSizeOrCount );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend.\n\t *\n\t * @async\n\t * @param {string} name - The feature's name.\n\t * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( name ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.resolveTimestampsAsync( type );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend. If the\n\t * renderer has not been initialized, this method always returns `false`.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\t/**\n\t * Returns `true` when the renderer has been initialized.\n\t *\n\t * @return {boolean} Whether the renderer has been initialized or not.\n\t */\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture.\n\t * @return {Promise} A Promise that resolves when the texture has been initialized.\n\t */\n\tasync initTextureAsync( texture ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Initializes the given texture. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * This method can only be used if the renderer has been initialized.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer into the given texture.\n\t *\n\t * @param {FramebufferTexture} framebufferTexture - The texture.\n\t * @param {?Vector2|Vector4} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.\n\t */\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture into a destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n\t * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );\n\n\t}\n\n\t/**\n\t * Reads pixel data from the given render target.\n\t *\n\t * @async\n\t * @param {RenderTarget} renderTarget - The render target to read from.\n\t * @param {number} x - The `x` coordinate of the copy region's origin.\n\t * @param {number} y - The `y` coordinate of the copy region's origin.\n\t * @param {number} width - The width of the copy region.\n\t * @param {number} height - The height of the copy region.\n\t * @param {number} [textureIndex=0] - The texture index of a MRT render target.\n\t * @param {number} [faceIndex=0] - The active cube face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n\t */\n\tasync readRenderTargetPixelsAsync( renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ textureIndex ], x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Analyzes the given 3D object's hierarchy and builds render lists from the\n\t * processed hierarchy.\n\t *\n\t * @param {Object3D} object - The 3D object to process (usually a scene).\n\t * @param {Camera} camera - The camera the object is rendered with.\n\t * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\t\t\tif ( ! object.frustumCulled || frustum.intersectsSprite( object, camera ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\t\t\tif ( ! object.frustumCulled || frustum.intersectsObject( object, camera ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the given render bundles.\n\t *\n\t * @private\n\t * @param {Array<Object>} bundles - Array with render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundles belong to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the transparent objects from the given render lists.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The transparent render list.\n\t * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the objects from the given render list.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The render list.\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderList[ i ];\n\n\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method represents the default render object function that manages the render lifecycle\n\t * of the object.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?ClippingContext} clippingContext - The clipping context.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet overridePositionNode;\n\t\tlet overrideColorNode;\n\t\tlet overrideDepthNode;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( material.allowOverride === true && scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\t\t\toverrideMaterial.transparent = material.transparent || material.transmission > 0;\n\n\t\t\tif ( overrideMaterial.isShadowPassMaterial ) {\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\t\toverrideDepthNode = overrideMaterial.depthNode;\n\t\t\t\t\toverrideMaterial.depthNode = material.depthNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowNode && material.castShadowNode.isNode ) {\n\n\t\t\t\t\toverrideColorNode = overrideMaterial.colorNode;\n\t\t\t\t\toverrideMaterial.colorNode = material.castShadowNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowPositionNode && material.castShadowPositionNode.isNode ) {\n\n\t\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\t\toverrideMaterial.positionNode = material.castShadowPositionNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( overridePositionNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.positionNode = overridePositionNode;\n\n\t\t}\n\n\t\tif ( overrideDepthNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.depthNode = overrideDepthNode;\n\n\t\t}\n\n\t\tif ( overrideColorNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.colorNode = overrideColorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t/**\n\t * This method represents the default `_handleObjectFunction` implementation which creates\n\t * a render object from the given data and performs the draw command with the selected backend.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t */\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.bundleGroup;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.\n\t * Used in `compileAsync()`.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t */\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * Alias for `compileAsync()`.\n\t *\n\t * @method\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.\n\t */\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\nexport default Renderer;\n"],"mappings":"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","ignoreList":[]}