import DataMap from"./DataMap.js";import{Vector3}from"../../math/Vector3.js";import{DepthTexture}from"../../textures/DepthTexture.js";import{DepthStencilFormat,DepthFormat,UnsignedIntType,UnsignedInt248Type,UnsignedByteType}from"../../constants.js";const _size=new Vector3;class Textures extends DataMap{constructor(e,t,i){super(),this.renderer=e,this.backend=t,this.info=i}updateRenderTarget(e,t=0){const i=this.get(e),s=0===e.samples?1:e.samples,r=i.depthTextureMips||(i.depthTextureMips={}),n=e.textures,a=this.getSize(n[0]),d=a.width>>t,h=a.height>>t;let p=e.depthTexture||r[t];const o=!0===e.depthBuffer||!0===e.stencilBuffer;let u=!1;void 0===p&&o&&(p=new DepthTexture,p.format=e.stencilBuffer?DepthStencilFormat:DepthFormat,p.type=e.stencilBuffer?UnsignedInt248Type:UnsignedIntType,p.image.width=d,p.image.height=h,p.image.depth=a.depth,p.isArrayTexture=!0===e.multiview&&a.depth>1,r[t]=p),i.width===a.width&&a.height===i.height||(u=!0,p&&(p.needsUpdate=!0,p.image.width=d,p.image.height=h,p.image.depth=p.isArrayTexture?p.image.depth:1)),i.width=a.width,i.height=a.height,i.textures=n,i.depthTexture=p||null,i.depth=e.depthBuffer,i.stencil=e.stencilBuffer,i.renderTarget=e,i.sampleCount!==s&&(u=!0,p&&(p.needsUpdate=!0),i.sampleCount=s);const m={sampleCount:s};if(!0!==e.isXRRenderTarget){for(let e=0;e<n.length;e++){const t=n[e];u&&(t.needsUpdate=!0),this.updateTexture(t,m)}p&&this.updateTexture(p,m)}if(!0!==i.initialized){i.initialized=!0;const t=()=>{e.removeEventListener("dispose",t);for(let e=0;e<n.length;e++)this._destroyTexture(n[e]);p&&this._destroyTexture(p),this.delete(e)};e.addEventListener("dispose",t)}}updateTexture(e,t={}){const i=this.get(e);if(!0===i.initialized&&i.version===e.version)return;const s=e.isRenderTargetTexture||e.isDepthTexture||e.isFramebufferTexture,r=this.backend;if(s&&!0===i.initialized&&(r.destroySampler(e),r.destroyTexture(e)),e.isFramebufferTexture){const t=this.renderer.getRenderTarget();e.type=t?t.texture.type:UnsignedByteType}const{width:n,height:a,depth:d}=this.getSize(e);if(t.width=n,t.height=a,t.depth=d,t.needsMipmaps=this.needsMipmaps(e),t.levels=t.needsMipmaps?this.getMipLevels(e,n,a):1,s||!0===e.isStorageTexture)r.createSampler(e),r.createTexture(e,t),i.generation=e.version;else{if(!0!==i.initialized&&r.createSampler(e),e.version>0){const s=e.image;if(void 0===s)console.warn("THREE.Renderer: Texture marked for update but image is undefined.");else if(!1===s.complete)console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");else{if(e.images){const i=[];for(const t of e.images)i.push(t);t.images=i}else t.image=s;void 0!==i.isDefaultTexture&&!0!==i.isDefaultTexture||(r.createTexture(e,t),i.isDefaultTexture=!1,i.generation=e.version),!0===e.source.dataReady&&r.updateTexture(e,t),t.needsMipmaps&&0===e.mipmaps.length&&r.generateMipmaps(e)}}else r.createDefaultTexture(e),i.isDefaultTexture=!0,i.generation=e.version}if(!0!==i.initialized){i.initialized=!0,i.generation=e.version,this.info.memory.textures++;const t=()=>{e.removeEventListener("dispose",t),this._destroyTexture(e)};e.addEventListener("dispose",t)}i.version=e.version}getSize(e,t=_size){let i=e.images?e.images[0]:e.image;return i?(void 0!==i.image&&(i=i.image),i instanceof HTMLVideoElement?(t.width=i.videoWidth||1,t.height=i.videoHeight||1,t.depth=1):i instanceof VideoFrame?(t.width=i.displayWidth||1,t.height=i.displayHeight||1,t.depth=1):(t.width=i.width||1,t.height=i.height||1,t.depth=e.isCubeTexture?6:i.depth||1)):t.width=t.height=t.depth=1,t}getMipLevels(e,t,i){let s;return s=e.isCompressedTexture?e.mipmaps?e.mipmaps.length:1:Math.floor(Math.log2(Math.max(t,i)))+1,s}needsMipmaps(e){return!0===e.isCompressedTexture||e.generateMipmaps}_destroyTexture(e){!0===this.has(e)&&(this.backend.destroySampler(e),this.backend.destroyTexture(e),this.delete(e),this.info.memory.textures--)}}export default Textures;
//# sourceMappingURL=Textures.js.map