{"version":3,"file":"node_modules/three/src/renderers/common/Textures.js","names":["DataMap","Vector3","DepthTexture","DepthStencilFormat","DepthFormat","UnsignedIntType","UnsignedInt248Type","UnsignedByteType","_size","Textures","constructor","renderer","backend","info","super","this","updateRenderTarget","renderTarget","activeMipmapLevel","renderTargetData","get","sampleCount","samples","depthTextureMips","textures","size","getSize","mipWidth","width","mipHeight","height","depthTexture","useDepthTexture","depthBuffer","stencilBuffer","textureNeedsUpdate","undefined","format","type","image","depth","isArrayTexture","multiview","needsUpdate","stencil","options","isXRRenderTarget","i","length","texture","updateTexture","initialized","onDispose","removeEventListener","_destroyTexture","delete","addEventListener","textureData","version","isRenderTarget","isRenderTargetTexture","isDepthTexture","isFramebufferTexture","destroySampler","destroyTexture","getRenderTarget","needsMipmaps","levels","getMipLevels","isStorageTexture","createSampler","createTexture","generation","console","warn","complete","images","push","isDefaultTexture","source","dataReady","mipmaps","generateMipmaps","createDefaultTexture","memory","target","HTMLVideoElement","videoWidth","videoHeight","VideoFrame","displayWidth","displayHeight","isCubeTexture","mipLevelCount","isCompressedTexture","Math","floor","log2","max","has"],"sources":["node_modules/three/src/renderers/common/Textures.js"],"sourcesContent":["import DataMap from './DataMap.js';\n\nimport { Vector3 } from '../../math/Vector3.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport { DepthStencilFormat, DepthFormat, UnsignedIntType, UnsignedInt248Type, UnsignedByteType } from '../../constants.js';\n\nconst _size = /*@__PURE__*/ new Vector3();\n\n/**\n * This module manages the textures of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Textures extends DataMap {\n\n\t/**\n\t * Constructs a new texture management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t}\n\n\t/**\n\t * Updates the given render target. Based on the given render target configuration,\n\t * it updates the texture states representing the attachments of the framebuffer.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target to update.\n\t * @param {number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\t\t\tdepthTexture.image.depth = size.depth;\n\t\t\tdepthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\t\t\t\tdepthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\n\t\tconst options = { sampleCount };\n\n\t\t// XR render targets require no texture updates\n\n\t\tif ( renderTarget.isXRRenderTarget !== true ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\t\tthis.updateTexture( texture, options );\n\n\t\t\t}\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( depthTexture ) {\n\n\t\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t\t}\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given texture. Depending on the texture state, this method\n\t * triggers the upload of texture data to the GPU memory. If the texture data are\n\t * not yet ready for the upload, it uses default texture data for as a placeholder.\n\t *\n\t * @param {Texture} texture - The texture to update.\n\t * @param {Object} [options={}] - The options.\n\t */\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroySampler( texture );\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true ) {\n\n\t\t\tbackend.createSampler( texture );\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tconst needsCreate = textureData.initialized !== true;\n\n\t\t\tif ( needsCreate ) backend.createSampler( texture );\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\ttexture.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\t/**\n\t * Computes the size of the given texture and writes the result\n\t * into the target vector. This vector is also returned by the\n\t * method.\n\t *\n\t * If no texture data are available for the compute yet, the method\n\t * returns default size values.\n\t *\n\t * @param {Texture} texture - The texture to compute the size for.\n\t * @param {Vector3} target - The target vector.\n\t * @return {Vector3} The target vector.\n\t */\n\tgetSize( texture, target = _size ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\tif ( image instanceof HTMLVideoElement ) {\n\n\t\t\t\ttarget.width = image.videoWidth || 1;\n\t\t\t\ttarget.height = image.videoHeight || 1;\n\t\t\t\ttarget.depth = 1;\n\n\t\t\t} else if ( image instanceof VideoFrame ) {\n\n\t\t\t\ttarget.width = image.displayWidth || 1;\n\t\t\t\ttarget.height = image.displayHeight || 1;\n\t\t\t\ttarget.depth = 1;\n\n\t\t\t} else {\n\n\t\t\t\ttarget.width = image.width || 1;\n\t\t\t\ttarget.height = image.height || 1;\n\t\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the number of mipmap levels for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {number} width - The texture's width.\n\t * @param {number} height - The texture's height.\n\t * @return {number} The number of mipmap levels.\n\t */\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tif ( texture.mipmaps ) {\n\n\t\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture requires mipmaps.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether mipmaps are required or not.\n\t */\n\tneedsMipmaps( texture ) {\n\n\t\treturn texture.isCompressedTexture === true || texture.generateMipmaps;\n\n\t}\n\n\t/**\n\t * Frees internal resource when the given texture isn't\n\t * required anymore.\n\t *\n\t * @param {Texture} texture - The texture to destroy.\n\t */\n\t_destroyTexture( texture ) {\n\n\t\tif ( this.has( texture ) === true ) {\n\n\t\t\tthis.backend.destroySampler( texture );\n\t\t\tthis.backend.destroyTexture( texture );\n\n\t\t\tthis.delete( texture );\n\n\t\t\tthis.info.memory.textures --;\n\n\t\t}\n\n\t}\n\n}\n\nexport default Textures;\n"],"mappings":"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","ignoreList":[]}