{"version":3,"file":"node_modules/three/src/renderers/common/UniformsGroup.js","names":["UniformBuffer","GPU_CHUNK_BYTES","UniformsGroup","constructor","name","super","this","isUniformsGroup","_values","uniforms","addUniform","uniform","push","removeUniform","index","indexOf","splice","values","Array","from","buffer","_buffer","byteLength","Float32Array","ArrayBuffer","bytesPerElement","offset","i","l","length","boundary","itemSize","chunkOffset","chunkPadding","chunkStart","Math","ceil","update","updated","updateByType","isNumberUniform","updateNumber","isVector2Uniform","updateVector2","isVector3Uniform","updateVector3","isVector4Uniform","updateVector4","isColorUniform","updateColor","isMatrix3Uniform","updateMatrix3","isMatrix4Uniform","updateMatrix4","console","error","a","v","getValue","type","getType","_getBufferForType","x","y","b","z","w","c","r","g","e","elements","arraysEqual","set","setArray","Int32Array","Uint32Array"],"sources":["node_modules/three/src/renderers/common/UniformsGroup.js"],"sourcesContent":["import UniformBuffer from './UniformBuffer.js';\nimport { GPU_CHUNK_BYTES } from './Constants.js';\n\n/**\n * This class represents a uniform buffer binding but with\n * an API that allows to maintain individual uniform objects.\n *\n * @private\n * @augments UniformBuffer\n */\nclass UniformsGroup extends UniformBuffer {\n\n\t/**\n\t * Constructs a new uniforms group.\n\t *\n\t * @param {string} name - The group's name.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformsGroup = true;\n\n\t\t/**\n\t\t * An array with the raw uniform values.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<number>}\n\t\t * @default null\n\t\t */\n\t\tthis._values = null;\n\n\t\t/**\n\t\t * An array of uniform objects.\n\t\t *\n\t\t * The order of uniforms in this array must match the order of uniforms in the shader.\n\t\t *\n\t\t * @type {Array<Uniform>}\n\t\t */\n\t\tthis.uniforms = [];\n\n\t}\n\n\t/**\n\t * Adds a uniform to this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to add.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a uniform from this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to remove.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * An array with the raw uniform values.\n\t *\n\t * @type {Array<number>}\n\t */\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\t/**\n\t * A Float32 array buffer with the uniform values.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\t/**\n\t * The byte length of the buffer with correct buffer alignment.\n\t *\n\t * @type {number}\n\t */\n\tget byteLength() {\n\n\t\tconst bytesPerElement = this.bytesPerElement;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst boundary = uniform.boundary;\n\t\t\tconst itemSize = uniform.itemSize * bytesPerElement; // size of the uniform in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk\n\t\t\tconst chunkPadding = chunkOffset % boundary; // required padding to match boundary\n\t\t\tconst chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data\n\n\t\t\toffset += chunkPadding;\n\n\t\t\t// Check for chunk overflow\n\t\t\tif ( chunkStart !== 0 && ( GPU_CHUNK_BYTES - chunkStart ) < itemSize ) {\n\n\t\t\t\t// Add padding to the end of the chunk\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkStart );\n\n\t\t\t}\n\n\t\t\tuniform.offset = offset / bytesPerElement;\n\n\t\t\toffset += itemSize;\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\t/**\n\t * Updates this group by updating each uniform object of\n\t * the internal uniform list. The uniform objects check if their\n\t * values has actually changed so this method only returns\n\t * `true` if there is a real value change.\n\t *\n\t * @return {boolean} Whether the uniforms have been updated and\n\t * must be uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given uniform by calling an update method matching\n\t * the uniforms type.\n\t *\n\t * @param {Uniform} uniform - The uniform to update.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\t/**\n\t * Updates a given Number uniform.\n\t *\n\t * @param {NumberUniform} uniform - The Number uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector2 uniform.\n\t *\n\t * @param {Vector2Uniform} uniform - The Vector2 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector3 uniform.\n\t *\n\t * @param {Vector3Uniform} uniform - The Vector3 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector4 uniform.\n\t *\n\t * @param {Vector4Uniform} uniform - The Vector4 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Color uniform.\n\t *\n\t * @param {ColorUniform} uniform - The Color uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix3 uniform.\n\t *\n\t * @param {Matrix3Uniform} uniform - The Matrix3 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix4 uniform.\n\t *\n\t * @param {Matrix4Uniform} uniform - The Matrix4 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Returns a typed array that matches the given data type.\n\t *\n\t * @param {string} type - The data type.\n\t * @return {TypedArray} The typed array.\n\t */\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\n/**\n * Sets the values of the second array to the first array.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {number} offset - An index offset for the first array.\n */\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given arrays are equal.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {number} offset - An index offset for the first array.\n * @return {boolean} Whether the given arrays are equal or not.\n */\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nexport default UniformsGroup;\n"],"mappings":"OAAOA,kBAAmB,4BACjBC,oBAAuB,iBAShC,MAAMC,sBAAsBF,cAO3B,WAAAG,CAAaC,GAEZC,MAAOD,GASPE,KAAKC,iBAAkB,EASvBD,KAAKE,QAAU,KASfF,KAAKG,SAAW,EAEjB,CAQA,UAAAC,CAAYC,GAIX,OAFAL,KAAKG,SAASG,KAAMD,GAEbL,IAER,CAQA,aAAAO,CAAeF,GAEd,MAAMG,EAAQR,KAAKG,SAASM,QAASJ,GAQrC,OANiB,IAAZG,GAEJR,KAAKG,SAASO,OAAQF,EAAO,GAIvBR,IAER,CAOA,UAAIW,GAQH,OANsB,OAAjBX,KAAKE,UAETF,KAAKE,QAAUU,MAAMC,KAAMb,KAAKc,SAI1Bd,KAAKE,OAEb,CAOA,UAAIY,GAEH,IAAIA,EAASd,KAAKe,QAElB,GAAgB,OAAXD,EAAkB,CAEtB,MAAME,EAAahB,KAAKgB,WAExBF,EAAS,IAAIG,aAAc,IAAIC,YAAaF,IAE5ChB,KAAKe,QAAUD,CAEhB,CAEA,OAAOA,CAER,CAOA,cAAIE,GAEH,MAAMG,EAAkBnB,KAAKmB,gBAE7B,IAAIC,EAAS,EAEb,IAAM,IAAIC,EAAI,EAAGC,EAAItB,KAAKG,SAASoB,OAAQF,EAAIC,EAAGD,IAAO,CAExD,MAAMhB,EAAUL,KAAKG,SAAUkB,GAEzBG,EAAWnB,EAAQmB,SACnBC,EAAWpB,EAAQoB,SAAWN,EAE9BO,EAAcN,EAASzB,gBACvBgC,EAAeD,EAAcF,EAC7BI,EAAaF,EAAcC,EAEjCP,GAAUO,EAGU,IAAfC,GAAsBjC,gBAAkBiC,EAAeH,IAG3DL,GAAYzB,gBAAkBiC,GAI/BvB,EAAQe,OAASA,EAASD,EAE1BC,GAAUK,CAEX,CAEA,OAAOI,KAAKC,KAAMV,EAASzB,iBAAoBA,eAEhD,CAWA,MAAAoC,GAEC,IAAIC,GAAU,EAEd,IAAM,MAAM3B,KAAWL,KAAKG,UAEW,IAAjCH,KAAKiC,aAAc5B,KAEvB2B,GAAU,GAMZ,OAAOA,CAER,CASA,YAAAC,CAAc5B,GAEb,OAAKA,EAAQ6B,gBAAyBlC,KAAKmC,aAAc9B,GACpDA,EAAQ+B,iBAA0BpC,KAAKqC,cAAehC,GACtDA,EAAQiC,iBAA0BtC,KAAKuC,cAAelC,GACtDA,EAAQmC,iBAA0BxC,KAAKyC,cAAepC,GACtDA,EAAQqC,eAAwB1C,KAAK2C,YAAatC,GAClDA,EAAQuC,iBAA0B5C,KAAK6C,cAAexC,GACtDA,EAAQyC,iBAA0B9C,KAAK+C,cAAe1C,QAE3D2C,QAAQC,MAAO,uDAAwD5C,EAExE,CAQA,YAAA8B,CAAc9B,GAEb,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTwC,EAAI9C,EAAQ+C,WACZhC,EAASf,EAAQe,OACjBiC,EAAOhD,EAAQiD,UAErB,GAAKJ,EAAG9B,KAAa+B,EAAI,CAEdnD,KAAKuD,kBAAmBF,GAE/BjC,GAAW8B,EAAG9B,GAAW+B,EAC5BnB,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAK,CAAehC,GAEd,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTwC,EAAI9C,EAAQ+C,WACZhC,EAASf,EAAQe,OACjBiC,EAAOhD,EAAQiD,UAErB,GAAKJ,EAAG9B,EAAS,KAAQ+B,EAAEK,GAAKN,EAAG9B,EAAS,KAAQ+B,EAAEM,EAAI,CAEzD,MAAMC,EAAI1D,KAAKuD,kBAAmBF,GAElCK,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEK,EACtCE,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEM,EAEtCzB,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAO,CAAelC,GAEd,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTwC,EAAI9C,EAAQ+C,WACZhC,EAASf,EAAQe,OACjBiC,EAAOhD,EAAQiD,UAErB,GAAKJ,EAAG9B,EAAS,KAAQ+B,EAAEK,GAAKN,EAAG9B,EAAS,KAAQ+B,EAAEM,GAAKP,EAAG9B,EAAS,KAAQ+B,EAAEQ,EAAI,CAEpF,MAAMD,EAAI1D,KAAKuD,kBAAmBF,GAElCK,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEK,EACtCE,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEM,EACtCC,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEQ,EAEtC3B,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAS,CAAepC,GAEd,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTwC,EAAI9C,EAAQ+C,WACZhC,EAASf,EAAQe,OACjBiC,EAAOhD,EAAQiD,UAErB,GAAKJ,EAAG9B,EAAS,KAAQ+B,EAAEK,GAAKN,EAAG9B,EAAS,KAAQ+B,EAAEM,GAAKP,EAAG9B,EAAS,KAAQ+B,EAAEQ,GAAKT,EAAG9B,EAAS,KAAQ+B,EAAES,EAAI,CAE/G,MAAMF,EAAI1D,KAAKuD,kBAAmBF,GAElCK,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEK,EACtCE,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEM,EACtCC,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAEQ,EACtCD,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM+B,EAAES,EAEtC5B,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,WAAAW,CAAatC,GAEZ,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTkD,EAAIxD,EAAQ+C,WACZhC,EAASf,EAAQe,OAEvB,GAAK8B,EAAG9B,EAAS,KAAQyC,EAAEC,GAAKZ,EAAG9B,EAAS,KAAQyC,EAAEE,GAAKb,EAAG9B,EAAS,KAAQyC,EAAEH,EAAI,CAEpF,MAAMA,EAAI1D,KAAKc,OAEf4C,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAMyC,EAAEC,EACtCJ,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAMyC,EAAEE,EACtCL,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAMyC,EAAEH,EAEtC1B,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAa,CAAexC,GAEd,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTqD,EAAI3D,EAAQ+C,WAAWa,SACvB7C,EAASf,EAAQe,OAEvB,GAAK8B,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,KAAQ4C,EAAG,IACvFd,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,KAAQ4C,EAAG,IACnFd,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,KAAQ4C,EAAG,IAAOd,EAAG9B,EAAS,MAAS4C,EAAG,GAAM,CAE1F,MAAMN,EAAI1D,KAAKc,OAEf4C,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,GAAM8B,EAAG9B,EAAS,GAAM4C,EAAG,GACvCN,EAAGtC,EAAS,IAAO8B,EAAG9B,EAAS,IAAO4C,EAAG,GAEzChC,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAe,CAAe1C,GAEd,IAAI2B,GAAU,EAEd,MAAMkB,EAAIlD,KAAKW,OACTqD,EAAI3D,EAAQ+C,WAAWa,SACvB7C,EAASf,EAAQe,OAEvB,IAAqC,IAAhC8C,YAAahB,EAAGc,EAAG5C,GAAqB,CAElCpB,KAAKc,OACbqD,IAAKH,EAAG5C,GACVgD,SAAUlB,EAAGc,EAAG5C,GAChBY,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,iBAAAuB,CAAmBF,GAElB,MAAc,QAATA,GAA2B,UAATA,GAA6B,UAATA,GAA6B,UAATA,EAA0B,IAAIgB,WAAYrE,KAAKc,OAAOA,QACvG,SAATuC,GAA4B,UAATA,GAA6B,UAATA,GAA6B,UAATA,EAA0B,IAAIiB,YAAatE,KAAKc,OAAOA,QAChHd,KAAKc,MAEb,EAYD,SAASsD,SAAUlB,EAAGQ,EAAGtC,GAExB,IAAM,IAAIC,EAAI,EAAGC,EAAIoC,EAAEnC,OAAQF,EAAIC,EAAGD,IAErC6B,EAAG9B,EAASC,GAAMqC,EAAGrC,EAIvB,CAWA,SAAS6C,YAAahB,EAAGQ,EAAGtC,GAE3B,IAAM,IAAIC,EAAI,EAAGC,EAAIoC,EAAEnC,OAAQF,EAAIC,EAAGD,IAErC,GAAK6B,EAAG9B,EAASC,KAAQqC,EAAGrC,GAAM,OAAO,EAI1C,OAAO,CAER,gBAEezB","ignoreList":[]}