{"version":3,"file":"node_modules/three/src/renderers/common/XRRenderTarget.js","names":["RenderTarget","XRRenderTarget","constructor","width","height","options","super","this","isXRRenderTarget","_hasExternalTextures","_autoAllocateDepthBuffer","_isOpaqueFramebuffer","copy","source"],"sources":["node_modules/three/src/renderers/common/XRRenderTarget.js"],"sourcesContent":["import { RenderTarget } from '../../core/RenderTarget.js';\n\n/**\n * A special type of render target that is used when rendering\n * with the WebXR Device API.\n *\n * @private\n * @augments RenderTarget\n */\nclass XRRenderTarget extends RenderTarget {\n\n\t/**\n\t * Constructs a new XR render target.\n\t *\n\t * @param {number} [width=1] - The width of the render target.\n\t * @param {number} [height=1] - The height of the render target.\n\t * @param {Object} [options={}] - The configuration options.\n\t */\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isXRRenderTarget = true;\n\n\t\t/**\n\t\t * Whether the attachments of the render target\n\t\t * are defined by external textures. This flag is\n\t\t * set to `true` when using the WebXR Layers API.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._hasExternalTextures = false;\n\n\t\t/**\n\t\t * Whether a depth buffer should automatically be allocated\n\t\t * for this XR render target or not.\n\t\t *\n\t\t * Allocating a depth buffer is the default behavior of XR render\n\t\t * targets. However, when using the WebXR Layers API, this flag\n\t\t * must be set to `false` when the `ignoreDepthValues` property of\n\t\t * the projection layers evaluates to `false`.\n\t\t *\n\t\t * Reference: {@link https://www.w3.org/TR/webxrlayers-1/#dom-xrprojectionlayer-ignoredepthvalues}.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis._autoAllocateDepthBuffer = true;\n\n\t\t/**\n\t\t * Whether this render target is associated with a XRWebGLLayer.\n\t\t *\n\t\t * A XRWebGLLayer points to an opaque framebuffer. Basically,\n\t\t * this means that you don't have access to its bound color,\n\t\t * stencil and depth buffers. We need to handle this framebuffer\n\t\t * differently since its textures are always bound.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * */\n\t\tthis._isOpaqueFramebuffer = false;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis._hasExternalTextures = source._hasExternalTextures;\n\t\tthis._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;\n\t\tthis._isOpaqueFramebuffer = source._isOpaqueFramebuffer;\n\n\t\treturn this;\n\n\t}\n\n\n}\n\nexport { XRRenderTarget };\n"],"mappings":"OAASA,iBAAoB,6BAS7B,MAAMC,uBAAuBD,aAS5B,WAAAE,CAAaC,EAAQ,EAAGC,EAAS,EAAGC,EAAU,CAAC,GAE9CC,MAAOH,EAAOC,EAAQC,GAStBE,KAAKC,kBAAmB,EAWxBD,KAAKE,sBAAuB,EAiB5BF,KAAKG,0BAA2B,EAchCH,KAAKI,sBAAuB,CAE7B,CAEA,IAAAC,CAAMC,GAQL,OANAP,MAAMM,KAAMC,GAEZN,KAAKE,qBAAuBI,EAAOJ,qBACnCF,KAAKG,yBAA2BG,EAAOH,yBACvCH,KAAKI,qBAAuBE,EAAOF,qBAE5BJ,IAER,SAKQN","ignoreList":[]}