import NodeMaterial from"../../../materials/nodes/NodeMaterial.js";import{getDirection,blur}from"../../../nodes/pmrem/PMREMUtils.js";import{equirectUV}from"../../../nodes/utils/EquirectUV.js";import{uniform}from"../../../nodes/core/UniformNode.js";import{uniformArray}from"../../../nodes/accessors/UniformArrayNode.js";import{texture}from"../../../nodes/accessors/TextureNode.js";import{cubeTexture}from"../../../nodes/accessors/CubeTextureNode.js";import{float,vec3}from"../../../nodes/tsl/TSLBase.js";import{uv}from"../../../nodes/accessors/UV.js";import{attribute}from"../../../nodes/core/AttributeNode.js";import{OrthographicCamera}from"../../../cameras/OrthographicCamera.js";import{Color}from"../../../math/Color.js";import{Vector3}from"../../../math/Vector3.js";import{BufferGeometry}from"../../../core/BufferGeometry.js";import{BufferAttribute}from"../../../core/BufferAttribute.js";import{RenderTarget}from"../../../core/RenderTarget.js";import{Mesh}from"../../../objects/Mesh.js";import{PerspectiveCamera}from"../../../cameras/PerspectiveCamera.js";import{MeshBasicMaterial}from"../../../materials/MeshBasicMaterial.js";import{BoxGeometry}from"../../../geometries/BoxGeometry.js";import{CubeReflectionMapping,CubeRefractionMapping,CubeUVReflectionMapping,LinearFilter,NoBlending,RGBAFormat,HalfFloatType,BackSide,LinearSRGBColorSpace}from"../../../constants.js";const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera(-1,1,1,-1,0,1),_cubeCamera=new PerspectiveCamera(90,1),_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(-PHI,INV_PHI,0),new Vector3(PHI,INV_PHI,0),new Vector3(-INV_PHI,0,PHI),new Vector3(INV_PHI,0,PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(0,PHI,INV_PHI),new Vector3(-1,1,-1),new Vector3(1,1,-1),new Vector3(-1,1,1),new Vector3(1,1,1)],_origin=new Vector3,_uniformsMap=new WeakMap,_faceLib=[3,1,5,0,4,2],_direction=getDirection(uv(),attribute("faceIndex")).normalize(),_outputDirection=vec3(_direction.x,_direction.y,_direction.z);class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}get _hasInitialized(){return this._renderer.hasInitialized()}fromScene(e,t=0,r=.1,i=100,a={}){const{size:s=256,position:o=_origin,renderTarget:n=null}=a;if(this._setSize(s),!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");const s=n||this._allocateTarget();return a.renderTarget=s,this.fromSceneAsync(e,t,r,i,a),s}_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const l=n||this._allocateTarget();return l.depthBuffer=!0,this._init(l),this._sceneToCubeUV(e,r,i,l,o),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}async fromSceneAsync(e,t=0,r=.1,i=100,a={}){return!1===this._hasInitialized&&await this._renderer.init(),this.fromScene(e,t,r,i,a)}fromEquirectangular(e,t=null){if(!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."),this._setSizeFromTexture(e);const r=t||this._allocateTarget();return this.fromEquirectangularAsync(e,r),r}return this._fromTexture(e,t)}async fromEquirectangularAsync(e,t=null){return!1===this._hasInitialized&&await this._renderer.init(),this._fromTexture(e,t)}fromCubemap(e,t=null){if(!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."),this._setSizeFromTexture(e);const r=t||this._allocateTarget();return this.fromCubemapAsync(e,t),r}return this._fromTexture(e,t)}async fromCubemapAsync(e,t=null){return!1===this._hasInitialized&&await this._renderer.init(),this._fromTexture(e,t)}async compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSizeFromTexture(e){e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4)}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e,t){this._setSizeFromTexture(e),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const r=t||this._allocateTarget();return this._init(r),this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTarget(){return _createRenderTarget(3*Math.max(this._cubeSize,112),4*this._cubeSize)}_init(e){if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e.width||this._pingPongRenderTarget.height!==e.height){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(e.width,e.height);const{_lodMax:t}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=_createPlanes(t)),this._blurMaterial=_getBlurShader(t,e.width,e.height)}}async _compileMaterial(e){const t=new Mesh(this._lodPlanes[0],e);await this._renderer.compile(t,_flatCamera)}_sceneToCubeUV(e,t,r,i,a){const s=_cubeCamera;s.near=t,s.far=r;const o=[1,1,1,1,-1,1],n=[1,-1,1,-1,1,-1],l=this._renderer,u=l.autoClear;l.getClearColor(_clearColor),l.autoClear=!1;let c=this._backgroundBox;if(null===c){const e=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1});c=new Mesh(new BoxGeometry,e)}let _=!1;const h=e.background;h?h.isColor&&(c.material.color.copy(h),e.background=null,_=!0):(c.material.color.copy(_clearColor),_=!0),l.setRenderTarget(i),l.clear(),_&&l.render(c,s);for(let t=0;t<6;t++){const r=t%3;0===r?(s.up.set(0,o[t],0),s.position.set(a.x,a.y,a.z),s.lookAt(a.x+n[t],a.y,a.z)):1===r?(s.up.set(0,0,o[t]),s.position.set(a.x,a.y,a.z),s.lookAt(a.x,a.y+n[t],a.z)):(s.up.set(0,o[t],0),s.position.set(a.x,a.y,a.z),s.lookAt(a.x,a.y,a.z+n[t]));const u=this._cubeSize;_setViewport(i,r*u,t>2?u:0,u,u),l.render(e,s)}l.autoClear=u,e.background=h}_textureToCubeUV(e,t){const r=this._renderer,i=e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping;i?null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(e)):null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(e));const a=i?this._cubemapMaterial:this._equirectMaterial;a.fragmentNode.value=e;const s=this._lodMeshes[0];s.material=a;const o=this._cubeSize;_setViewport(t,0,0,3*o,2*o),r.setRenderTarget(t),r.render(s,_flatCamera)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let t=1;t<i;t++){const r=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),a=_axisDirections[(i-t-1)%_axisDirections.length];this._blur(e,t-1,t,r,a)}t.autoClear=r}_blur(e,t,r,i,a){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,r,i,"latitudinal",a),this._halfBlur(s,e,r,r,i,"longitudinal",a)}_halfBlur(e,t,r,i,a,s,o){const n=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const u=this._lodMeshes[i];u.material=l;const c=_uniformsMap.get(l),_=this._sizeLods[r]-1,h=isFinite(a)?Math.PI/(2*_):2*Math.PI/39,d=a/h,m=isFinite(a)?1+Math.floor(3*d):20;m>20&&console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const p=[];let g=0;for(let e=0;e<20;++e){const t=e/d,r=Math.exp(-t*t/2);p.push(r),0===e?g+=r:e<m&&(g+=2*r)}for(let e=0;e<p.length;e++)p[e]=p[e]/g;e.texture.frame=(e.texture.frame||0)+1,c.envMap.value=e.texture,c.samples.value=m,c.weights.array=p,c.latitudinal.value="latitudinal"===s?1:0,o&&(c.poleAxis.value=o);const{_lodMax:f}=this;c.dTheta.value=h,c.mipInt.value=f-r;const M=this._sizeLods[i];_setViewport(t,3*M*(i>f-4?i-f+4:0),4*(this._cubeSize-M),3*M,2*M),n.setRenderTarget(t),n.render(u,_flatCamera)}}function _createPlanes(e){const t=[],r=[],i=[],a=[];let s=e;const o=e-4+1+EXTRA_LOD_SIGMA.length;for(let n=0;n<o;n++){const o=Math.pow(2,s);r.push(o);let l=1/o;n>e-4?l=EXTRA_LOD_SIGMA[n-e+4-1]:0===n&&(l=0),i.push(l);const u=1/(o-2),c=-u,_=1+u,h=[c,c,_,c,_,_,c,c,_,_,c,_],d=6,m=6,p=3,g=2,f=1,M=new Float32Array(p*m*d),b=new Float32Array(g*m*d),T=new Float32Array(f*m*d);for(let e=0;e<d;e++){const t=e%3*2/3-1,r=e>2?0:-1,i=[t,r,0,t+2/3,r,0,t+2/3,r+1,0,t,r,0,t+2/3,r+1,0,t,r+1,0],a=_faceLib[e];M.set(i,p*m*a),b.set(h,g*m*a);const s=[a,a,a,a,a,a];T.set(s,f*m*a)}const w=new BufferGeometry;w.setAttribute("position",new BufferAttribute(M,p)),w.setAttribute("uv",new BufferAttribute(b,g)),w.setAttribute("faceIndex",new BufferAttribute(T,f)),t.push(w),a.push(new Mesh(w,null)),s>4&&s--}return{lodPlanes:t,sizeLods:r,sigmas:i,lodMeshes:a}}function _createRenderTarget(e,t){const r=new RenderTarget(e,t,{magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace});return r.texture.mapping=CubeUVReflectionMapping,r.texture.name="PMREM.cubeUv",r.texture.isPMREMTexture=!0,r.scissorTest=!0,r}function _setViewport(e,t,r,i,a){e.viewport.set(t,r,i,a),e.scissor.set(t,r,i,a)}function _getMaterial(e){const t=new NodeMaterial;return t.depthTest=!1,t.depthWrite=!1,t.blending=NoBlending,t.name=`PMREM_${e}`,t}function _getBlurShader(e,t,r){const i=uniformArray(new Array(20).fill(0)),a=uniform(new Vector3(0,1,0)),s=uniform(0),o=float(20),n=uniform(0),l=uniform(1),u=texture(null),c=uniform(0),_=float(1/t),h=float(1/r),d=float(e),m={n:o,latitudinal:n,weights:i,poleAxis:a,outputDirection:_outputDirection,dTheta:s,samples:l,envMap:u,mipInt:c,CUBEUV_TEXEL_WIDTH:_,CUBEUV_TEXEL_HEIGHT:h,CUBEUV_MAX_MIP:d},p=_getMaterial("blur");return p.fragmentNode=blur({...m,latitudinal:n.equal(1)}),_uniformsMap.set(p,m),p}function _getCubemapMaterial(e){const t=_getMaterial("cubemap");return t.fragmentNode=cubeTexture(e,_outputDirection),t}function _getEquirectMaterial(e){const t=_getMaterial("equirect");return t.fragmentNode=texture(e,equirectUV(_outputDirection),0),t}export default PMREMGenerator;
//# sourceMappingURL=PMREMGenerator.js.map