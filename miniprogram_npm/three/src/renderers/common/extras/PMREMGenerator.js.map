{"version":3,"file":"node_modules/three/src/renderers/common/extras/PMREMGenerator.js","names":["NodeMaterial","getDirection","blur","equirectUV","uniform","uniformArray","texture","cubeTexture","float","vec3","uv","attribute","OrthographicCamera","Color","Vector3","BufferGeometry","BufferAttribute","RenderTarget","Mesh","PerspectiveCamera","MeshBasicMaterial","BoxGeometry","CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","LinearFilter","NoBlending","RGBAFormat","HalfFloatType","BackSide","LinearSRGBColorSpace","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_cubeCamera","_clearColor","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","Math","sqrt","INV_PHI","_axisDirections","_origin","_uniformsMap","WeakMap","_faceLib","_direction","normalize","_outputDirection","x","y","z","PMREMGenerator","constructor","renderer","this","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","_hasInitialized","hasInitialized","fromScene","scene","sigma","near","far","options","size","position","renderTarget","_setSize","console","warn","cubeUVRenderTarget","_allocateTarget","fromSceneAsync","getRenderTarget","getActiveCubeFace","getActiveMipmapLevel","depthBuffer","_init","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","init","fromEquirectangular","equirectangular","_setSizeFromTexture","fromEquirectangularAsync","_fromTexture","fromCubemap","cubemap","fromCubemapAsync","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","dispose","_dispose","geometry","material","mapping","image","length","width","cubeSize","floor","log2","pow","i","outputTarget","setRenderTarget","scissorTest","_setViewport","height","_textureToCubeUV","_createRenderTarget","max","sizeLods","lodPlanes","sigmas","lodMeshes","_createPlanes","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","getClearColor","backgroundBox","backgroundMaterial","name","side","depthWrite","depthTest","useSolidColor","background","isColor","color","copy","clear","render","col","up","set","lookAt","isCubeTexture","fragmentNode","value","mesh","n","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","error","blurMesh","blurUniforms","get","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","weights","sum","weight","exp","push","frame","envMap","array","latitudinal","dTheta","mipInt","outputSize","lodMax","lod","totalLods","sizeLod","texelSize","min","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","Float32Array","faceIndex","face","coordinates","faceIdx","fill","planes","setAttribute","magFilter","minFilter","generateMipmaps","type","format","colorSpace","isPMREMTexture","target","viewport","scissor","_getMaterial","blending","Array","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","materialUniforms","outputDirection","equal","envTexture"],"sources":["node_modules/three/src/renderers/common/extras/PMREMGenerator.js"],"sourcesContent":["import NodeMaterial from '../../../materials/nodes/NodeMaterial.js';\nimport { getDirection, blur } from '../../../nodes/pmrem/PMREMUtils.js';\nimport { equirectUV } from '../../../nodes/utils/EquirectUV.js';\nimport { uniform } from '../../../nodes/core/UniformNode.js';\nimport { uniformArray } from '../../../nodes/accessors/UniformArrayNode.js';\nimport { texture } from '../../../nodes/accessors/TextureNode.js';\nimport { cubeTexture } from '../../../nodes/accessors/CubeTextureNode.js';\nimport { float, vec3 } from '../../../nodes/tsl/TSLBase.js';\nimport { uv } from '../../../nodes/accessors/UV.js';\nimport { attribute } from '../../../nodes/core/AttributeNode.js';\n\nimport { OrthographicCamera } from '../../../cameras/OrthographicCamera.js';\nimport { Color } from '../../../math/Color.js';\nimport { Vector3 } from '../../../math/Vector3.js';\nimport { BufferGeometry } from '../../../core/BufferGeometry.js';\nimport { BufferAttribute } from '../../../core/BufferAttribute.js';\nimport { RenderTarget } from '../../../core/RenderTarget.js';\nimport { Mesh } from '../../../objects/Mesh.js';\nimport { PerspectiveCamera } from '../../../cameras/PerspectiveCamera.js';\nimport { MeshBasicMaterial } from '../../../materials/MeshBasicMaterial.js';\nimport { BoxGeometry } from '../../../geometries/BoxGeometry.js';\nimport {\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tCubeUVReflectionMapping,\n\tLinearFilter,\n\tNoBlending,\n\tRGBAFormat,\n\tHalfFloatType,\n\tBackSide,\n\tLinearSRGBColorSpace\n} from '../../../constants.js';\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\nconst _origin = /*@__PURE__*/ new Vector3();\n\n// maps blur materials to their uniforms dictionary\n\nconst _uniformsMap = new WeakMap();\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst _direction = /*@__PURE__*/ getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst _outputDirection = /*@__PURE__*/ vec3( _direction.x, _direction.y, _direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting:\n * {@link https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view}\n*/\nclass PMREMGenerator {\n\n\t/**\n\t * Constructs a new PMREM generator.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety.\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {number} [sigma=0] - The blur radius in radians.\n\t * @param {number} [near=0.1] - The near plane distance.\n\t * @param {number} [far=100] - The far plane distance.\n\t * @param {Object} [options={}] - The configuration options.\n\t * @param {number} [options.size=256] - The texture size of the PMREM.\n\t * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.\n\t * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromSceneAsync}\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {\n\n\t\tconst {\n\t\t\tsize = 256,\n\t\t\tposition = _origin,\n\t\t\trenderTarget = null,\n\t\t} = options;\n\n\t\tthis._setSize( size );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\toptions.renderTarget = cubeUVRenderTarget;\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, options );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._init( cubeUVRenderTarget );\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {number} [sigma=0] - The blur radius in radians.\n\t * @param {number} [near=0.1] - The near plane distance.\n\t * @param {number} [far=100] - The far plane distance.\n\t * @param {Object} [options={}] - The configuration options.\n\t * @param {number} [options.size=256] - The texture size of the PMREM.\n\t * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.\n\t * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.\n\t * @see {@link PMREMGenerator#fromScene}\n\t */\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, options );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromEquirectangularAsync}\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromEquirectangular}\n\t */\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromCubemapAsync}\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromCubemap}\n\t */\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\t\tthis._init( cubeUVRenderTarget );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTarget() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_init( renderTarget ) {\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( renderTarget.width, renderTarget.height );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tawait this._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ 1, 1, 1, 1, - 1, 1 ];\n\t\tconst forwardSign = [ 1, - 1, 1, - 1, 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );\n\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );\n\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * @private\n\t * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.\n\t * @param {number} lodIn - The input level-of-detail.\n\t * @param {number} lodOut - The output level-of-detail.\n\t * @param {number} sigma - The blur radius in radians.\n\t * @param {Vector3} [poleAxis] - The pole axis.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = _uniformsMap.get( blurMaterial );\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height ) {\n\n\tconst params = {\n\t\tmagFilter: LinearFilter,\n\t\tminFilter: LinearFilter,\n\t\tgenerateMipmaps: false,\n\t\ttype: HalfFloatType,\n\t\tformat: RGBAFormat,\n\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t//depthBuffer: false\n\t};\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection: _outputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\t_uniformsMap.set( material, materialUniforms );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, _outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( _outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nexport default PMREMGenerator;\n"],"mappings":"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","ignoreList":[]}