{"version":3,"file":"node_modules/three/src/renderers/common/nodes/NodeBuilderState.js","names":["BindGroup","NodeBuilderState","constructor","vertexShader","fragmentShader","computeShader","nodeAttributes","bindings","updateNodes","updateBeforeNodes","updateAfterNodes","observer","transforms","this","usedTimes","createBindings","instanceGroup","groupNode","shared","bindingsGroup","name","index","push","instanceBinding","clone"],"sources":["node_modules/three/src/renderers/common/nodes/NodeBuilderState.js"],"sourcesContent":["import BindGroup from '../BindGroup.js';\n\n/**\n * This module represents the state of a node builder after it was\n * used to build the nodes for a render object. The state holds the\n * results of the build for further processing in the renderer.\n *\n * Render objects with identical cache keys share the same node builder state.\n *\n * @private\n */\nclass NodeBuilderState {\n\n\t/**\n\t * Constructs a new node builder state.\n\t *\n\t * @param {string} vertexShader - The native vertex shader code.\n\t * @param {string} fragmentShader - The native fragment shader code.\n\t * @param {string} computeShader - The native compute shader code.\n\t * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.\n\t * @param {Array<BindGroup>} bindings - An array of bind groups.\n\t * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.\n\t * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.\n\t * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.\n\t * @param {NodeMaterialObserver} observer - A node material observer.\n\t * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.\n\t */\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = [] ) {\n\n\t\t/**\n\t\t * The native vertex shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.vertexShader = vertexShader;\n\n\t\t/**\n\t\t * The native fragment shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.fragmentShader = fragmentShader;\n\n\t\t/**\n\t\t * The native compute shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.computeShader = computeShader;\n\n\t\t/**\n\t\t * An array with transform attribute objects.\n\t\t * Only relevant when using compute shaders with WebGL 2.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * An array of node attributes representing\n\t\t * the attributes of the shaders.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.nodeAttributes = nodeAttributes;\n\n\t\t/**\n\t\t * An array of bind groups representing the uniform or storage\n\t\t * buffers, texture or samplers of the shader.\n\t\t *\n\t\t * @type {Array<BindGroup>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * An array of nodes that implement their `update()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = updateNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateBefore()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateAfter()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\t/**\n\t\t * A node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver}\n\t\t */\n\t\tthis.observer = observer;\n\n\t\t/**\n\t\t * How often this state is used by render objects.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\t/**\n\t * This method is used to create a array of bind groups based\n\t * on the existing bind groups of this state. Shared groups are\n\t * not cloned.\n\t *\n\t * @return {Array<BindGroup>} A array of bind groups.\n\t */\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared; // All bindings in the group must have the same groupNode.\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\nexport default NodeBuilderState;\n"],"mappings":"OAAOA,cAAe,kBAWtB,MAAMC,iBAgBL,WAAAC,CAAaC,EAAcC,EAAgBC,EAAeC,EAAgBC,EAAUC,EAAaC,EAAmBC,EAAkBC,EAAUC,EAAa,IAO5JC,KAAKV,aAAeA,EAOpBU,KAAKT,eAAiBA,EAOtBS,KAAKR,cAAgBA,EAQrBQ,KAAKD,WAAaA,EAQlBC,KAAKP,eAAiBA,EAQtBO,KAAKN,SAAWA,EAOhBM,KAAKL,YAAcA,EAOnBK,KAAKJ,kBAAoBA,EAOzBI,KAAKH,iBAAmBA,EAOxBG,KAAKF,SAAWA,EAOhBE,KAAKC,UAAY,CAElB,CASA,cAAAC,GAEC,MAAMR,EAAW,GAEjB,IAAM,MAAMS,KAAiBH,KAAKN,SAAW,CAI5C,IAAgB,IAFDS,EAAcT,SAAU,GAAIU,UAAUC,OAE9B,CAEtB,MAAMC,EAAgB,IAAInB,UAAWgB,EAAcI,KAAM,GAAIJ,EAAcK,MAAOL,GAClFT,EAASe,KAAMH,GAEf,IAAM,MAAMI,KAAmBP,EAAcT,SAE5CY,EAAcZ,SAASe,KAAMC,EAAgBC,QAI/C,MAECjB,EAASe,KAAMN,EAIjB,CAEA,OAAOT,CAER,iBAIcN","ignoreList":[]}