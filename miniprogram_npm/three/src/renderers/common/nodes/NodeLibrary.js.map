{"version":3,"file":"node_modules/three/src/renderers/common/nodes/NodeLibrary.js","names":["NodeLibrary","constructor","this","lightNodes","WeakMap","materialNodes","Map","toneMappingNodes","fromMaterial","material","isNodeMaterial","nodeMaterial","nodeMaterialClass","getMaterialNodeClass","type","key","addToneMapping","toneMappingNode","toneMapping","addType","getToneMappingFunction","get","materialType","addMaterial","materialNodeClass","materialClassType","getLightNodeClass","light","addLight","lightNodeClass","lightClass","addClass","nodeClass","library","has","console","warn","Error","name","set","baseClass"],"sources":["node_modules/three/src/renderers/common/nodes/NodeLibrary.js"],"sourcesContent":["/**\n * The purpose of a node library is to assign node implementations\n * to existing library features. In `WebGPURenderer` lights, materials\n * which are not based on `NodeMaterial` as well as tone mapping techniques\n * are implemented with node-based modules.\n *\n * @private\n */\nclass NodeLibrary {\n\n\t/**\n\t * Constructs a new node library.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A weak map that maps lights to light nodes.\n\t\t *\n\t\t * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}\n\t\t */\n\t\tthis.lightNodes = new WeakMap();\n\n\t\t/**\n\t\t * A map that maps materials to node materials.\n\t\t *\n\t\t * @type {Map<string,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.materialNodes = new Map();\n\n\t\t/**\n\t\t * A map that maps tone mapping techniques (constants)\n\t\t * to tone mapping node functions.\n\t\t *\n\t\t * @type {Map<number,Function>}\n\t\t */\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\t/**\n\t * Returns a matching node material instance for the given material object.\n\t *\n\t * This method also assigns/copies the properties of the given material object\n\t * to the node material. This is done to make sure the current material\n\t * configuration carries over to the node version.\n\t *\n\t * @param {Material} material - A material.\n\t * @return {NodeMaterial} The corresponding node material.\n\t */\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\t/**\n\t * Adds a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Function} toneMappingNode - The tone mapping node function.\n\t * @param {number} toneMapping - The tone mapping.\n\t */\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\t/**\n\t * Returns a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {number} toneMapping - The tone mapping.\n\t * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.\n\t */\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\t/**\n\t * Returns a node material class definition for a material type.\n\t *\n\t * @param {string} materialType - The material type.\n\t * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.\n\t */\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\t/**\n\t * Adds a node material class definition for a given material type.\n\t *\n\t * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.\n\t * @param {string} materialClassType - The material type.\n\t */\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\t/**\n\t * Returns a light node class definition for a light class definition.\n\t *\n\t * @param {Light.constructor} light - The light class definition.\n\t * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.\n\t */\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\t/**\n\t * Adds a light node class definition for a given light class definition.\n\t *\n\t * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.\n\t * @param {Light.constructor} lightClass - The light class definition.\n\t */\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given type to the provided type library.\n\t *\n\t * @param {any} nodeClass - The node class definition.\n\t * @param {number|string} type - The object type.\n\t * @param {Map} library - The type library.\n\t */\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given class definition to the provided type library.\n\t *\n\t * @param {any} nodeClass - The node class definition.\n\t * @param {any} baseClass - The class definition.\n\t * @param {WeakMap} library - The type library.\n\t */\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nexport default NodeLibrary;\n"],"mappings":"AAQA,MAAMA,YAKL,WAAAC,GAOCC,KAAKC,WAAa,IAAIC,QAOtBF,KAAKG,cAAgB,IAAIC,IAQzBJ,KAAKK,iBAAmB,IAAID,GAE7B,CAYA,YAAAE,CAAcC,GAEb,GAAKA,EAASC,eAAiB,OAAOD,EAEtC,IAAIE,EAAe,KAEnB,MAAMC,EAAoBV,KAAKW,qBAAsBJ,EAASK,MAE9D,GAA2B,OAAtBF,EAA6B,CAEjCD,EAAe,IAAIC,EAEnB,IAAM,MAAMG,KAAON,EAElBE,EAAcI,GAAQN,EAAUM,EAIlC,CAEA,OAAOJ,CAER,CAQA,cAAAK,CAAgBC,EAAiBC,GAEhChB,KAAKiB,QAASF,EAAiBC,EAAahB,KAAKK,iBAElD,CAQA,sBAAAa,CAAwBF,GAEvB,OAAOhB,KAAKK,iBAAiBc,IAAKH,IAAiB,IAEpD,CAQA,oBAAAL,CAAsBS,GAErB,OAAOpB,KAAKG,cAAcgB,IAAKC,IAAkB,IAElD,CAQA,WAAAC,CAAaC,EAAmBC,GAE/BvB,KAAKiB,QAASK,EAAmBC,EAAmBvB,KAAKG,cAE1D,CAQA,iBAAAqB,CAAmBC,GAElB,OAAOzB,KAAKC,WAAWkB,IAAKM,IAAW,IAExC,CAQA,QAAAC,CAAUC,EAAgBC,GAEzB5B,KAAK6B,SAAUF,EAAgBC,EAAY5B,KAAKC,WAEjD,CASA,OAAAgB,CAASa,EAAWlB,EAAMmB,GAEzB,GAAKA,EAAQC,IAAKpB,GAEjBqB,QAAQC,KAAM,wBAAyBtB,SAFxC,CAOA,GAA0B,mBAAdkB,EAA2B,MAAM,IAAIK,MAAO,cAAeL,EAAUM,wBACjF,GAAqB,mBAATxB,GAAuC,iBAATA,EAAoB,MAAM,IAAIuB,MAAO,cAAevB,qBAE9FmB,EAAQM,IAAKzB,EAAMkB,EALnB,CAOD,CASA,QAAAD,CAAUC,EAAWQ,EAAWP,GAE/B,GAAKA,EAAQC,IAAKM,GAEjBL,QAAQC,KAAM,wBAAyBI,EAAUF,YAFlD,CAOA,GAA0B,mBAAdN,EAA2B,MAAM,IAAIK,MAAO,cAAeL,EAAUM,wBACjF,GAA0B,mBAAdE,EAA2B,MAAM,IAAIH,MAAO,cAAeG,EAAUF,wBAEjFL,EAAQM,IAAKC,EAAWR,EALxB,CAOD,iBAIchC","ignoreList":[]}