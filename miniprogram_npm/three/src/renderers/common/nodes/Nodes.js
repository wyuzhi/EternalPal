import DataMap from"../DataMap.js";import ChainMap from"../ChainMap.js";import NodeBuilderState from"./NodeBuilderState.js";import{cubeMapNode}from"../../../nodes/utils/CubeMapNode.js";import{NodeFrame}from"../../../nodes/Nodes.js";import{objectGroup,renderGroup,frameGroup,cubeTexture,texture,texture3D,vec3,fog,rangeFogFactor,densityFogFactor,reference,pmremTexture,screenUV}from"../../../nodes/TSL.js";import{builtin}from"../../../nodes/accessors/BuiltinNode.js";import{CubeUVReflectionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping}from"../../../constants.js";import{hashArray}from"../../../nodes/core/NodeUtils.js";const _outputNodeMap=new WeakMap,_chainKeys=[],_cacheKeyValues=[];class Nodes extends DataMap{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.callHashCache=new ChainMap,this.groupsData=new ChainMap,this.cacheLib={}}updateGroup(e){const t=e.groupNode,r=t.name;if(r===objectGroup.name)return!0;if(r===renderGroup.name){const t=this.get(e),r=this.nodeFrame.renderId;return t.renderId!==r&&(t.renderId=r,!0)}if(r===frameGroup.name){const t=this.get(e),r=this.nodeFrame.frameId;return t.frameId!==r&&(t.frameId=r,!0)}_chainKeys[0]=t,_chainKeys[1]=e;let o=this.groupsData.get(_chainKeys);return void 0===o&&this.groupsData.set(_chainKeys,o={}),_chainKeys.length=0,o.version!==t.version&&(o.version=t.version,!0)}getForRenderCacheKey(e){return e.initialCacheKey}getForRender(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const{nodeBuilderCache:o}=this,n=this.getForRenderCacheKey(e);if(r=o.get(n),void 0===r){const t=this.backend.createNodeBuilder(e.object,this.renderer);t.scene=e.scene,t.material=e.material,t.camera=e.camera,t.context.material=e.material,t.lightsNode=e.lightsNode,t.environmentNode=this.getEnvironmentNode(e.scene),t.fogNode=this.getFogNode(e.scene),t.clippingContext=e.clippingContext,this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview&&t.enableMultiview(),t.build(),r=this._createNodeBuilderState(t),o.set(n,r)}r.usedTimes++,t.nodeBuilderState=r}return r}delete(e){if(e.isRenderObject){const t=this.get(e).nodeBuilderState;t.usedTimes--,0===t.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(e))}return super.delete(e)}getForCompute(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const o=this.backend.createNodeBuilder(e,this.renderer);o.build(),r=this._createNodeBuilderState(o),t.nodeBuilderState=r}return r}_createNodeBuilderState(e){return new NodeBuilderState(e.vertexShader,e.fragmentShader,e.computeShader,e.getAttributesArray(),e.getBindings(),e.updateNodes,e.updateBeforeNodes,e.updateAfterNodes,e.observer,e.transforms)}getEnvironmentNode(e){this.updateEnvironment(e);let t=null;if(e.environmentNode&&e.environmentNode.isNode)t=e.environmentNode;else{const r=this.get(e);r.environmentNode&&(t=r.environmentNode)}return t}getBackgroundNode(e){this.updateBackground(e);let t=null;if(e.backgroundNode&&e.backgroundNode.isNode)t=e.backgroundNode;else{const r=this.get(e);r.backgroundNode&&(t=r.backgroundNode)}return t}getFogNode(e){return this.updateFog(e),e.fogNode||this.get(e).fogNode||null}getCacheKey(e,t){_chainKeys[0]=e,_chainKeys[1]=t;const r=this.renderer.info.calls,o=this.callHashCache.get(_chainKeys)||{};if(o.callId!==r){const n=this.getEnvironmentNode(e),a=this.getFogNode(e);t&&_cacheKeyValues.push(t.getCacheKey(!0)),n&&_cacheKeyValues.push(n.getCacheKey()),a&&_cacheKeyValues.push(a.getCacheKey()),_cacheKeyValues.push(this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview?1:0),_cacheKeyValues.push(this.renderer.shadowMap.enabled?1:0),o.callId=r,o.cacheKey=hashArray(_cacheKeyValues),this.callHashCache.set(_chainKeys,o),_cacheKeyValues.length=0}return _chainKeys.length=0,o.cacheKey}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(e){const t=this.get(e),r=e.background;if(r){const o=0===e.backgroundBlurriness&&t.backgroundBlurriness>0||e.backgroundBlurriness>0&&0===t.backgroundBlurriness;if(t.background!==r||o){const n=this.getCacheNode("background",r,(()=>{if(!0===r.isCubeTexture||r.mapping===EquirectangularReflectionMapping||r.mapping===EquirectangularRefractionMapping||r.mapping===CubeUVReflectionMapping){if(e.backgroundBlurriness>0||r.mapping===CubeUVReflectionMapping)return pmremTexture(r);{let e;return e=!0===r.isCubeTexture?cubeTexture(r):texture(r),cubeMapNode(e)}}if(!0===r.isTexture)return texture(r,screenUV.flipY()).setUpdateMatrix(!0);!0!==r.isColor&&console.error("WebGPUNodes: Unsupported background configuration.",r)}),o);t.backgroundNode=n,t.background=r,t.backgroundBlurriness=e.backgroundBlurriness}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}getCacheNode(e,t,r,o=!1){const n=this.cacheLib[e]||(this.cacheLib[e]=new WeakMap);let a=n.get(t);return(void 0===a||o)&&(a=r(),n.set(t,a)),a}updateFog(e){const t=this.get(e),r=e.fog;if(r){if(t.fog!==r){const e=this.getCacheNode("fog",r,(()=>{if(r.isFogExp2){const e=reference("color","color",r).setGroup(renderGroup),t=reference("density","float",r).setGroup(renderGroup);return fog(e,densityFogFactor(t))}if(r.isFog){const e=reference("color","color",r).setGroup(renderGroup),t=reference("near","float",r).setGroup(renderGroup),o=reference("far","float",r).setGroup(renderGroup);return fog(e,rangeFogFactor(t,o))}console.error("THREE.Renderer: Unsupported fog configuration.",r)}));t.fogNode=e,t.fog=r}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),r=e.environment;if(r){if(t.environment!==r){const e=this.getCacheNode("environment",r,(()=>!0===r.isCubeTexture?cubeTexture(r):!0===r.isTexture?texture(r):void console.error("Nodes: Unsupported environment configuration.",r)));t.environmentNode=e,t.environment=r}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e=this.renderer,t=null,r=null,o=null,n=null){const a=this.nodeFrame;return a.renderer=e,a.scene=t,a.object=r,a.camera=o,a.material=n,a}getNodeFrameForRender(e){return this.getNodeFrame(e.renderer,e.scene,e.object,e.camera,e.material)}getOutputCacheKey(){const e=this.renderer;return e.toneMapping+","+e.currentColorSpace+","+e.xr.isPresenting}hasOutputChange(e){return _outputNodeMap.get(e)!==this.getOutputCacheKey()}getOutputNode(e){const t=this.renderer,r=this.getOutputCacheKey(),o=e.isArrayTexture?texture3D(e,vec3(screenUV,builtin("gl_ViewID_OVR"))).renderOutput(t.toneMapping,t.currentColorSpace):texture(e,screenUV).renderOutput(t.toneMapping,t.currentColorSpace);return _outputNodeMap.set(e,r),o}updateBefore(e){const t=e.getNodeBuilderState();for(const r of t.updateBeforeNodes)this.getNodeFrameForRender(e).updateBeforeNode(r)}updateAfter(e){const t=e.getNodeBuilderState();for(const r of t.updateAfterNodes)this.getNodeFrameForRender(e).updateAfterNode(r)}updateForCompute(e){const t=this.getNodeFrame(),r=this.getForCompute(e);for(const e of r.updateNodes)t.updateNode(e)}updateForRender(e){const t=this.getNodeFrameForRender(e),r=e.getNodeBuilderState();for(const e of r.updateNodes)t.updateNode(e)}needsRefresh(e){const t=this.getNodeFrameForRender(e);return e.getMonitor().needsRefresh(e,t)}dispose(){super.dispose(),this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.cacheLib={}}}export default Nodes;
//# sourceMappingURL=Nodes.js.map