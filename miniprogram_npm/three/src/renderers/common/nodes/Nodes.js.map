{"version":3,"file":"node_modules/three/src/renderers/common/nodes/Nodes.js","names":["DataMap","ChainMap","NodeBuilderState","cubeMapNode","NodeFrame","objectGroup","renderGroup","frameGroup","cubeTexture","texture","texture3D","vec3","fog","rangeFogFactor","densityFogFactor","reference","pmremTexture","screenUV","builtin","CubeUVReflectionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","hashArray","_outputNodeMap","WeakMap","_chainKeys","_cacheKeyValues","Nodes","constructor","renderer","backend","super","this","nodeFrame","nodeBuilderCache","Map","callHashCache","groupsData","cacheLib","updateGroup","nodeUniformsGroup","groupNode","name","uniformsGroupData","get","renderId","frameId","groupData","undefined","set","length","version","getForRenderCacheKey","renderObject","initialCacheKey","getForRender","renderObjectData","nodeBuilderState","cacheKey","nodeBuilder","createNodeBuilder","object","scene","material","camera","context","lightsNode","environmentNode","getEnvironmentNode","fogNode","getFogNode","clippingContext","getOutputRenderTarget","multiview","enableMultiview","build","_createNodeBuilderState","usedTimes","isRenderObject","delete","getForCompute","computeNode","computeData","vertexShader","fragmentShader","computeShader","getAttributesArray","getBindings","updateNodes","updateBeforeNodes","updateAfterNodes","observer","transforms","updateEnvironment","isNode","sceneData","getBackgroundNode","updateBackground","backgroundNode","updateFog","getCacheKey","callId","info","calls","cacheKeyData","push","shadowMap","enabled","isToneMappingState","getRenderTarget","background","forceUpdate","backgroundBlurriness","getCacheNode","isCubeTexture","mapping","envMap","isTexture","flipY","setUpdateMatrix","isColor","console","error","type","callback","nodeCache","node","sceneFog","isFogExp2","color","setGroup","density","isFog","near","far","environment","getNodeFrame","getNodeFrameForRender","getOutputCacheKey","toneMapping","currentColorSpace","xr","isPresenting","hasOutputChange","outputTarget","getOutputNode","output","isArrayTexture","renderOutput","updateBefore","getNodeBuilderState","updateBeforeNode","updateAfter","updateAfterNode","updateForCompute","updateNode","updateForRender","needsRefresh","getMonitor","dispose"],"sources":["node_modules/three/src/renderers/common/nodes/Nodes.js"],"sourcesContent":["import DataMap from '../DataMap.js';\nimport ChainMap from '../ChainMap.js';\nimport NodeBuilderState from './NodeBuilderState.js';\nimport { cubeMapNode } from '../../../nodes/utils/CubeMapNode.js';\nimport { NodeFrame } from '../../../nodes/Nodes.js';\nimport { objectGroup, renderGroup, frameGroup, cubeTexture, texture, texture3D, vec3, fog, rangeFogFactor, densityFogFactor, reference, pmremTexture, screenUV } from '../../../nodes/TSL.js';\nimport { builtin } from '../../../nodes/accessors/BuiltinNode.js';\n\nimport { CubeUVReflectionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../../constants.js';\nimport { hashArray } from '../../../nodes/core/NodeUtils.js';\n\nconst _outputNodeMap = new WeakMap();\nconst _chainKeys = [];\nconst _cacheKeyValues = [];\n\n/**\n * This renderer module manages node-related objects and is the\n * primary interface between the renderer and the node system.\n *\n * @private\n * @augments DataMap\n */\nclass Nodes extends DataMap {\n\n\t/**\n\t * Constructs a new nodes management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The node frame.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.nodeFrame = new NodeFrame();\n\n\t\t/**\n\t\t * A cache for managing node builder states.\n\t\t *\n\t\t * @type {Map<number,NodeBuilderState>}\n\t\t */\n\t\tthis.nodeBuilderCache = new Map();\n\n\t\t/**\n\t\t * A cache for managing data cache key data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.callHashCache = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node uniforms group data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.groupsData = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node objects of\n\t\t * scene properties like fog or environments.\n\t\t *\n\t\t * @type {Object<string,WeakMap>}\n\t\t */\n\t\tthis.cacheLib = {};\n\n\t}\n\n\t/**\n\t * Returns `true` if the given node uniforms group must be updated or not.\n\t *\n\t * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.\n\t * @return {boolean} Whether the node uniforms group requires an update or not.\n\t */\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is always updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\t_chainKeys[ 0 ] = groupNode;\n\t\t_chainKeys[ 1 ] = nodeUniformsGroup;\n\n\t\tlet groupData = this.groupsData.get( _chainKeys );\n\t\tif ( groupData === undefined ) this.groupsData.set( _chainKeys, groupData = {} );\n\n\t\t_chainKeys.length = 0;\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the cache key for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {number} The cache key.\n\t */\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\tnodeBuilder.material = renderObject.material;\n\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\tnodeBuilder.context.material = renderObject.material;\n\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\tif ( this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false ) {\n\n\t\t\t\t\tnodeBuilder.enableMultiview();\n\n\t\t\t\t}\n\n\t\t\t\tnodeBuilder.build();\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Deletes the given object from the internal data map\n\t *\n\t * @param {any} object - The object to delete.\n\t * @return {?Object} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Creates a node builder state for the given node builder.\n\t *\n\t * @private\n\t * @param {NodeBuilder} nodeBuilder - The node builder.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.observer,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns an environment node for the current configured\n\t * scene environment.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene environment.\n\t */\n\tgetEnvironmentNode( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\n\t\tlet environmentNode = null;\n\n\t\tif ( scene.environmentNode && scene.environmentNode.isNode ) {\n\n\t\t\tenvironmentNode = scene.environmentNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.environmentNode ) {\n\n\t\t\t\tenvironmentNode = sceneData.environmentNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn environmentNode;\n\n\t}\n\n\t/**\n\t * Returns a background node for the current configured\n\t * scene background.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene background.\n\t */\n\tgetBackgroundNode( scene ) {\n\n\t\tthis.updateBackground( scene );\n\n\t\tlet backgroundNode = null;\n\n\t\tif ( scene.backgroundNode && scene.backgroundNode.isNode ) {\n\n\t\t\tbackgroundNode = scene.backgroundNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.backgroundNode ) {\n\n\t\t\t\tbackgroundNode = sceneData.backgroundNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn backgroundNode;\n\n\t}\n\n\t/**\n\t * Returns a fog node for the current configured scene fog.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene fog.\n\t */\n\tgetFogNode( scene ) {\n\n\t\tthis.updateFog( scene );\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\t/**\n\t * Returns a cache key for the given scene and lights node.\n\t * This key is used by `RenderObject` as a part of the dynamic\n\t * cache key (a key that must be checked every time the render\n\t * objects is drawn).\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @return {number} The cache key.\n\t */\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\t_chainKeys[ 0 ] = scene;\n\t\t_chainKeys[ 1 ] = lightsNode;\n\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tconst cacheKeyData = this.callHashCache.get( _chainKeys ) || {};\n\n\t\tif ( cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tif ( lightsNode ) _cacheKeyValues.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) _cacheKeyValues.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) _cacheKeyValues.push( fogNode.getCacheKey() );\n\n\t\t\t_cacheKeyValues.push( this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0 );\n\t\t\t_cacheKeyValues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\n\t\t\tcacheKeyData.callId = callId;\n\t\t\tcacheKeyData.cacheKey = hashArray( _cacheKeyValues );\n\n\t\t\tthis.callHashCache.set( _chainKeys, cacheKeyData );\n\n\t\t\t_cacheKeyValues.length = 0;\n\n\t\t}\n\n\t\t_chainKeys.length = 0;\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\t/**\n\t * A boolean that indicates whether tone mapping should be enabled\n\t * or not.\n\t *\n\t * @type {boolean}\n\t */\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\t/**\n\t * If a scene background is configured, this method makes sure to\n\t * represent the background with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tconst backgroundNode = this.getCacheNode( 'background', background, () => {\n\n\t\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\t\treturn pmremTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn cubeMapNode( envMap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, forceUpdate );\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is part of the caching of nodes which are used to represents the\n\t * scene's background, fog or environment.\n\t *\n\t * @param {string} type - The type of object to cache.\n\t * @param {Object} object - The object.\n\t * @param {Function} callback - A callback that produces a node representation for the given object.\n\t * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.\n\t * @return {Node} The node representation.\n\t */\n\tgetCacheNode( type, object, callback, forceUpdate = false ) {\n\n\t\tconst nodeCache = this.cacheLib[ type ] || ( this.cacheLib[ type ] = new WeakMap() );\n\n\t\tlet node = nodeCache.get( object );\n\n\t\tif ( node === undefined || forceUpdate ) {\n\n\t\t\tnode = callback();\n\t\t\tnodeCache.set( object, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * If a scene fog is configured, this method makes sure to\n\t * represent the fog with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst sceneFog = scene.fog;\n\n\t\tif ( sceneFog ) {\n\n\t\t\tif ( sceneData.fog !== sceneFog ) {\n\n\t\t\t\tconst fogNode = this.getCacheNode( 'fog', sceneFog, () => {\n\n\t\t\t\t\tif ( sceneFog.isFogExp2 ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, densityFogFactor( density ) );\n\n\t\t\t\t\t} else if ( sceneFog.isFog ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, rangeFogFactor( near, far ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.Renderer: Unsupported fog configuration.', sceneFog );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = sceneFog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * If a scene environment is configured, this method makes sure to\n\t * represent the environment with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tconst environmentNode = this.getCacheNode( 'environment', environment, () => {\n\n\t\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\t\treturn cubeTexture( environment );\n\n\t\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( environment );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\t/**\n\t * Returns the current output cache key.\n\t *\n\t * @return {string} The output cache key.\n\t */\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace + ',' + renderer.xr.isPresenting;\n\n\t}\n\n\t/**\n\t * Checks if the output configuration (tone mapping and color space) for\n\t * the given target has changed.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {boolean} Whether the output configuration has changed or not.\n\t */\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = _outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\t/**\n\t * Returns a node that represents the output configuration (tone mapping and\n\t * color space) for the current target.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Node} The output node.\n\t */\n\tgetOutputNode( outputTarget ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = outputTarget.isArrayTexture ?\n\t\t\ttexture3D( outputTarget, vec3( screenUV, builtin( 'gl_ViewID_OVR' ) ) ).renderOutput( renderer.toneMapping, renderer.currentColorSpace ) :\n\t\t\ttexture( outputTarget, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\t_outputNodeMap.set( outputTarget, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateBefore()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateAfter()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\t/**\n\t * Frees the internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.cacheLib = {};\n\n\t}\n\n}\n\nexport default Nodes;\n"],"mappings":"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","ignoreList":[]}