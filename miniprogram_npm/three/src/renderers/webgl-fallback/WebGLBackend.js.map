{"version":3,"file":"node_modules/three/src/renderers/webgl-fallback/WebGLBackend.js","names":["GLSLNodeBuilder","Backend","getCacheKey","WebGLAttributeUtils","WebGLState","WebGLUtils","WebGLTextureUtils","WebGLExtensions","WebGLCapabilities","GLFeatureName","WebGLBufferRenderer","warnOnce","WebGLCoordinateSystem","WebGLTimestampQueryPool","WebGLBackend","constructor","parameters","super","this","isWebGLBackend","attributeUtils","extensions","capabilities","textureUtils","bufferRenderer","gl","state","utils","vaoCache","transformFeedbackCache","discard","disjoint","parallel","_currentContext","_knownBindings","WeakSet","_supportsInvalidateFramebuffer","navigator","test","userAgent","_xrFramebuffer","init","renderer","contextAttributes","antialias","samples","alpha","depth","stencil","glContext","undefined","context","domElement","getContext","onContextLost","event","preventDefault","contextLossInfo","api","message","statusMessage","reason","originalEvent","onDeviceLost","_onContextLost","addEventListener","get","coordinateSystem","getArrayBufferAsync","attribute","waitForGPU","_clientWaitAsync","makeXRCompatible","getContextAttributes","xrCompatible","setXRTarget","xrFramebuffer","setXRRenderTargetTextures","renderTarget","colorTexture","depthTexture","set","texture","textureGPU","glInternalFormat","RGBA8","stencilBuffer","DEPTH24_STENCIL8","DEPTH_COMPONENT24","has","_autoAllocateDepthBuffer","multiview","console","warn","initTimestampQuery","renderContext","trackTimestamp","type","isComputeNode","timestampQueryPool","allocateQueriesForContext","beginQuery","prepareTimestampBuffer","endQuery","beginRender","renderContextData","viewport","updateViewport","width","height","getDrawingBufferSize","scissor","x","y","scissorValue","previousContext","_setFramebuffer","clear","clearColor","clearDepth","clearStencil","occlusionQueryCount","currentOcclusionQueries","occlusionQueries","currentOcclusionQueryObjects","occlusionQueryObjects","lastOcclusionObject","Array","occlusionQueryIndex","finishRender","resetVertexState","ANY_SAMPLES_PASSED","resolveOccludedAsync","textures","i","length","generateMipmaps","renderTargetContextData","_useMultisampledExtension","fb","framebuffers","mask","COLOR_BUFFER_BIT","resolveDepthBuffer","depthBuffer","DEPTH_BUFFER_BIT","resolveStencilBuffer","STENCIL_BUFFER_BIT","msaaFrameBuffer","msaaRenderbuffers","isMRT","bindFramebuffer","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","framebufferRenderbuffer","COLOR_ATTACHMENT0","RENDERBUFFER","framebufferTexture2D","TEXTURE_2D","viewY","blitFramebuffer","NEAREST","invalidateFramebuffer","invalidationArray","depthInvalidationArray","occluded","check","completed","query","getQueryParameter","QUERY_RESULT_AVAILABLE","QUERY_RESULT","add","deleteQuery","requestAnimationFrame","isOccluded","object","viewportValue","setScissorTest","boolean","getClearColor","r","a","g","b","color","descriptor","setFrameBuffer","clearColorValue","getClearDepth","getClearStencil","setDepthMask","clearBufferfv","COLOR","clearBufferfi","DEPTH_STENCIL","DEPTH","clearBufferiv","STENCIL","beginCompute","computeGroup","FRAMEBUFFER","compute","computeNode","bindings","pipeline","count","enable","RASTERIZER_DISCARD","programGPU","transformBuffers","attributes","vaoKey","_getVaoKey","vaoGPU","_createVao","setVertexState","useProgram","_bindUniforms","transformFeedbackGPU","_getTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","beginTransformFeedback","POINTS","isArray","isStorageInstancedBufferAttribute","drawArraysInstanced","drawArrays","endTransformFeedback","dualAttributeData","pbo","copyBufferToTexture","transformBuffer","switchBuffers","finishCompute","disable","_isRenderCameraDepthArray","isArrayTexture","camera","isArrayCamera","draw","renderObject","material","hardwareClippingPlanes","contextData","drawParams","getDrawParameters","getBindings","frontFaceCW","isMesh","matrixWorld","determinant","setMaterial","getAttributes","attributesData","index","getIndex","indexGPU","bufferGPU","lastObject","occlusionTest","createQuery","isPoints","mode","isLineSegments","LINES","isLine","LINE_STRIP","isLineLoop","LINE_LOOP","wireframe","setLineWidth","wireframeLinewidth","getPixelRatio","TRIANGLES","vertexCount","instanceCount","firstVertex","array","BYTES_PER_ELEMENT","indexData","isBatchedMesh","_multiDrawInstances","renderMultiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","hasFeature","renderMultiDraw","renderInstances","render","cameras","isMultiViewCamera","cameraData","cameraIndex","getBindingGroup","indexesGPU","data","Uint32Array","len","createBuffer","bindBuffer","UNIFORM_BUFFER","bufferData","STATIC_DRAW","push","cameraIndexData","pixelRatio","isRenderCameraDepthArray","prevActiveCubeFace","activeCubeFace","textureData","clearedRenderId","_nodes","nodeFrame","renderId","_activeCubeFace","subCamera","layers","vp","Math","floor","bindBufferBase","needsRenderUpdate","getRenderCacheKey","createDefaultTexture","createTexture","options","updateTexture","destroyTexture","copyTextureToBuffer","faceIndex","createSampler","destroySampler","createNodeBuilder","createProgram","program","stage","code","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","shaderGPU","destroyProgram","delete","createRenderPipeline","promises","fragmentProgram","vertexProgram","fragmentShader","vertexShader","attachShader","linkProgram","p","Promise","resolve","checkStatus","getProgramParameter","COMPLETION_STATUS_KHR","_completeCompile","_handleSource","string","errorLine","lines","split","lines2","from","max","to","min","line","join","_getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","trim","errorMatches","exec","parseInt","toUpperCase","getShaderSource","_logProgramError","glFragmentShader","glVertexShader","debug","checkShaderErrors","programLog","getProgramInfoLog","LINK_STATUS","onShaderError","vertexErrors","fragmentErrors","error","getError","VALIDATE_STATUS","pipelineData","_setupBindings","createComputePipeline","computePipeline","computeProgram","transforms","transformVaryingNames","transformAttributeNodes","transform","varyingName","attributeNode","transformFeedbackVaryings","SEPARATE_ATTRIBS","attributeNodes","node","createAttribute","ARRAY_BUFFER","attributeData","createBindings","bindGroup","uniformBuffers","binding","isUniformBuffer","isSampledTexture","updateBindings","bindGroupData","t","isUniformsGroup","buffer","DYNAMIC_DRAW","glTextureType","updateBinding","createIndexAttribute","ELEMENT_ARRAY_BUFFER","createStorageAttribute","updateAttribute","destroyAttribute","name","keysMatching","Object","keys","filter","key","getMaxAnisotropy","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","srcLevel","dstLevel","copyFramebufferToTexture","rectangle","currentFrameBuffer","isCube","isWebGLCubeRenderTarget","isRenderTarget3D","isRenderTargetArray","isXRRenderTarget","_hasExternalTextures","msaaFb","depthRenderbuffer","multisampledRTTExt","multiviewExt","useMultisampledRTT","cacheKey","cubeFramebuffers","createFramebuffer","cubeFace","TEXTURE_CUBE_MAP_POSITIVE_X","attachment","framebufferTextureMultisampleMultiviewOVR","layer","framebufferTextureLayer","framebufferTexture2DMultisampleEXT","depthStyle","DEPTH_STENCIL_ATTACHMENT","DEPTH_ATTACHMENT","renderbuffer","createRenderbuffer","setupRenderBufferStorage","xrDepthRenderbuffer","bindRenderbuffer","depthData","_isOpaqueFramebuffer","renderbufferStorageMultisample","drawBuffers","id","createVertexArray","bindVertexArray","stride","offset","enableVertexAttribArray","isInterleavedBufferAttribute","bytesPerElement","isInteger","vertexAttribIPointer","itemSize","vertexAttribPointer","normalized","isInstancedBufferAttribute","vertexAttribDivisor","meshPerAttribute","isInstancedInterleavedBuffer","createTransformFeedback","TRANSFORM_FEEDBACK_BUFFER","location","getUniformBlockIndex","uniformBlockBinding","getUniformLocation","uniform1i","bindingData","bindTexture","TEXTURE0","dispose","extension","loseContext","removeEventListener"],"sources":["node_modules/three/src/renderers/webgl-fallback/WebGLBackend.js"],"sourcesContent":["import GLSLNodeBuilder from './nodes/GLSLNodeBuilder.js';\nimport Backend from '../common/Backend.js';\nimport { getCacheKey } from '../common/RenderContext.js';\n\nimport WebGLAttributeUtils from './utils/WebGLAttributeUtils.js';\nimport WebGLState from './utils/WebGLState.js';\nimport WebGLUtils from './utils/WebGLUtils.js';\nimport WebGLTextureUtils from './utils/WebGLTextureUtils.js';\nimport WebGLExtensions from './utils/WebGLExtensions.js';\nimport WebGLCapabilities from './utils/WebGLCapabilities.js';\nimport { GLFeatureName } from './utils/WebGLConstants.js';\nimport { WebGLBufferRenderer } from './WebGLBufferRenderer.js';\n\nimport { warnOnce } from '../../utils.js';\nimport { WebGLCoordinateSystem } from '../../constants.js';\nimport WebGLTimestampQueryPool from './utils/WebGLTimestampQueryPool.js';\n\n/**\n * A backend implementation targeting WebGL 2.\n *\n * @private\n * @augments Backend\n */\nclass WebGLBackend extends Backend {\n\n\t/**\n\t * WebGLBackend options.\n\t *\n\t * @typedef {Object} WebGLBackend~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.\n\t */\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {WebGLBackend~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLBackend = true;\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLAttributeUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.attributeUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLExtensions}\n\t\t * @default null\n\t\t */\n\t\tthis.extensions = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding capability-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLCapabilities}\n\t\t * @default null\n\t\t */\n\t\tthis.capabilities = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLTextureUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding renderer-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLBufferRenderer}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferRenderer = null;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {?WebGL2RenderingContext}\n\t\t * @default null\n\t\t */\n\t\tthis.gl = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding state-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLState}\n\t\t * @default null\n\t\t */\n\t\tthis.state = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.utils = null;\n\n\t\t/**\n\t\t * Dictionary for caching VAOs.\n\t\t *\n\t\t * @type {Object<string,WebGLVertexArrayObject>}\n\t\t */\n\t\tthis.vaoCache = {};\n\n\t\t/**\n\t\t * Dictionary for caching transform feedback objects.\n\t\t *\n\t\t * @type {Object<string,WebGLTransformFeedback>}\n\t\t */\n\t\tthis.transformFeedbackCache = {};\n\n\t\t/**\n\t\t * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.\n\t\t * Only relevant when using compute shaders.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.discard = false;\n\n\t\t/**\n\t\t * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the\n\t\t * device does not support the extension.\n\t\t *\n\t\t * @type {?EXTDisjointTimerQueryWebGL2}\n\t\t * @default null\n\t\t */\n\t\tthis.disjoint = null;\n\n\t\t/**\n\t\t* A reference to the `KHR_parallel_shader_compile` extension. `null` if the\n\t\t* device does not support the extension.\n\t\t*\n\t\t* @type {?KHRParallelShaderCompile}\n\t\t* @default null\n\t\t*/\n\t\tthis.parallel = null;\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentContext = null;\n\n\t\t/**\n\t\t * A unique collection of bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet<Array<BindGroup>>}\n\t\t */\n\t\tthis._knownBindings = new WeakSet();\n\n\n\t\t/**\n\t\t * Whether the device supports framebuffers invalidation or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\t\t/**\n\t\t * The target framebuffer when rendering with\n\t\t * the WebXR device API.\n\t\t *\n\t\t * @private\n\t\t * @type {WebGLFramebuffer}\n\t\t * @default null\n\t\t */\n\t\tthis._xrFramebuffer = null;\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst contextAttributes = {\n\t\t\tantialias: renderer.samples > 0,\n\t\t\talpha: true, // always true for performance reasons\n\t\t\tdepth: renderer.depth,\n\t\t\tstencil: renderer.stencil\n\t\t};\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2', contextAttributes );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\t\tthis.extensions.get( 'OVR_multiview2' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.utils._clientWaitAsync();\n\n\t}\n\n\t/**\n\t * Ensures the backend is XR compatible.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolve when the renderer is XR compatible.\n\t */\n\tasync makeXRCompatible() {\n\n\t\tconst attributes = this.gl.getContextAttributes();\n\n\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\tawait this.gl.makeXRCompatible();\n\n\t\t}\n\n\t}\n\t/**\n\t * Sets the XR rendering destination.\n\t *\n\t * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.\n\t */\n\tsetXRTarget( xrFramebuffer ) {\n\n\t\tthis._xrFramebuffer = xrFramebuffer;\n\n\t}\n\n\t/**\n\t * Configures the given XR render target with external textures.\n\t *\n\t * This method is only relevant when using the WebXR Layers API.\n\t *\n\t * @param {XRRenderTarget} renderTarget - The XR render target.\n\t * @param {WebGLTexture} colorTexture - A native color texture.\n\t * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.\n\t */\n\tsetXRRenderTargetTextures( renderTarget, colorTexture, depthTexture = null ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.set( renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 } ); // see #24698 why RGBA8 and not SRGB8_ALPHA8 is used\n\n\t\tif ( depthTexture !== null ) {\n\n\t\t\tconst glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\n\t\t\tthis.set( renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat: glInternalFormat } );\n\n\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t// are midframe flushes and an external depth texture.\n\t\t\tif ( ( this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided' );\n\n\t\t\t}\n\n\t\t\trenderTarget._autoAllocateDepthBuffer = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tinitTimestampQuery( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGLTimestampQueryPool( this.gl, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );\n\n\t\tif ( baseOffset !== null ) {\n\n\t\t\ttimestampQueryPool.beginQuery( renderContext );\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\t/**\n\t * Prepares the timestamp buffer.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tprepareTimestampBuffer( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\ttimestampQueryPool.endQuery( renderContext );\n\n\t}\n\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGL state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst { state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tconst { width, height } = this.getDrawingBufferSize();\n\t\t\tstate.viewport( 0, 0, width, height );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tstate.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.initTimestampQuery( renderContext );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tstate.resetVertexState();\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tif ( renderContext.textures !== null && renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\n\t\t\tif ( renderTarget.samples > 0 && this._useMultisampledExtension( renderTarget ) === false ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tif ( renderTarget.resolveDepthBuffer ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\t\t\t\tconst msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;\n\n\t\t\t\tconst textures = renderContext.textures;\n\t\t\t\tconst isMRT = textures.length > 1;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t// blitFramebuffer() can only copy/resolve the first color attachment of a framebuffer. When using MRT,\n\t\t\t\t\t// the engine temporarily removes all attachments and then configures each attachment for the resolve.\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t\t// configure attachment for resolve\n\n\t\t\t\t\t\tconst { textureGPU } = this.get( textures[ i ] );\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t// restore attachments\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst { textureGPU } = this.get( textures[ i ] );\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( this._supportsInvalidateFramebuffer === true ) {\n\n\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t}\n\n\t\t\t} else if ( renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tgl.invalidateFramebuffer( gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tconst { width, height } = this.getDrawingBufferSize();\n\t\t\t\tstate.viewport( 0, 0, width, height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) === 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { state } = this;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tstate.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst state = this.state;\n\n\t\tstate.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst clearColor = super.getClearColor();\n\n\t\t// Since the canvas is always created with alpha: true,\n\t\t// WebGL must always premultiply the clear color.\n\n\t\tclearColor.r *= clearColor.a;\n\t\tclearColor.g *= clearColor.a;\n\t\tclearColor.b *= clearColor.a;\n\n\t\treturn clearColor;\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {?Object} [descriptor=null] - The render context of the current set render target.\n\t * @param {boolean} [setFrameBuffer=true] - TODO.\n\t */\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {\n\n\t\tconst { gl, renderer } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t}\n\n\t\t\tconst clearDepth = renderer.getClearDepth();\n\t\t\tconst clearStencil = renderer.getClearStencil();\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ 0, 0, 0, 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, clearDepth, clearStencil );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ clearDepth ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ clearStencil ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( computeGroup );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {number|null} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline, count = null ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( this.discard === false ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis.vaoCache[ vaoKey ] = this._createVao( attributes );\n\n\t\t} else {\n\n\t\t\tstate.setVertexState( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tcount = ( count !== null ) ? count : computeNode.count;\n\n\t\tif ( Array.isArray( count ) ) {\n\n\t\t\twarnOnce( 'WebGLBackend.compute(): The count parameter must be a single number, not an array.' );\n\n\t\t\tcount = count[ 0 ];\n\n\t\t}\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo && this.has( dualAttributeData.pbo ) ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( computeGroup );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal to determine if the current render target is a render target array with depth 2D array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {boolean} Whether the render target is a render target array with depth 2D array texture.\n\t *\n\t * @private\n\t */\n\t_isRenderCameraDepthArray( renderContext ) {\n\n\t\treturn renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;\n\n\t}\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// vertex state\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst attributesData = this.get( attributes );\n\n\t\tlet vaoGPU = attributesData.vaoGPU;\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( attributes );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tvaoGPU = this._createVao( attributes );\n\n\t\t\t\tthis.vaoCache[ vaoKey ] = vaoGPU;\n\t\t\t\tattributesData.vaoGPU = vaoGPU;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst index = renderObject.getIndex();\n\t\tconst indexGPU = ( index !== null ) ? this.get( index ).bufferGPU : null;\n\n\t\tstate.setVertexState( vaoGPU, indexGPU );\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tconst draw = () => {\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\t// @deprecated, r174\n\t\t\t\t\twarnOnce( 'THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\t\twarnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t}\n\n\t\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' ).bindings[ 0 ];\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW );\n\n\t\t\t\t\tindexesGPU.push( bufferGPU );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst cameraIndexData = this.get( cameraIndex );\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tconst renderTarget = this._currentContext.renderTarget;\n\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( this._currentContext );\n\t\t\tconst prevActiveCubeFace = this._currentContext.activeCubeFace;\n\n\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t// Clear the depth texture\n\t\t\t\tconst textureData = this.get( renderTarget.depthTexture );\n\n\t\t\t\tif ( textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId ) {\n\n\t\t\t\t\ttextureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;\n\n\t\t\t\t\tconst { stencilBuffer } = renderTarget;\n\n\t\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\t\tthis.renderer._activeCubeFace = i;\n\t\t\t\t\t\tthis._currentContext.activeCubeFace = i;\n\n\t\t\t\t\t\tthis._setFramebuffer( this._currentContext );\n\t\t\t\t\t\tthis.clear( false, true, stencilBuffer, this._currentContext, false );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.renderer._activeCubeFace = prevActiveCubeFace;\n\t\t\t\t\tthis._currentContext.activeCubeFace = prevActiveCubeFace;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t\t\t// Update the active layer\n\t\t\t\t\t\tthis.renderer._activeCubeFace = i;\n\t\t\t\t\t\tthis._currentContext.activeCubeFace = i;\n\n\t\t\t\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\t\t\t\t\tif ( vp !== undefined ) {\n\n\t\t\t\t\t\tconst x = vp.x * pixelRatio;\n\t\t\t\t\t\tconst y = vp.y * pixelRatio;\n\t\t\t\t\t\tconst width = vp.width * pixelRatio;\n\t\t\t\t\t\tconst height = vp.height * pixelRatio;\n\n\t\t\t\t\t\tstate.viewport(\n\t\t\t\t\t\t\tMath.floor( x ),\n\t\t\t\t\t\t\tMath.floor( renderObject.context.height - height - y ),\n\t\t\t\t\t\t\tMath.floor( width ),\n\t\t\t\t\t\t\tMath.floor( height )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[ i ] );\n\n\t\t\t\t\tdraw();\n\n\t\t\t\t}\n\n\t\t\t\tthis._currentContext.activeCubeFace = prevActiveCubeFace;\n\t\t\t\tthis.renderer._activeCubeFace = prevActiveCubeFace;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdraw();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Explain why always null is returned.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Explain why no cache key is computed.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {GLSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t/**\n\t * Formats the source code of error messages.\n\t *\n\t * @private\n\t * @param {string} string - The code.\n\t * @param {number} errorLine - The error line.\n\t * @return {string} The formatted code.\n\t */\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Gets the shader compilation errors from the info log.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {WebGLShader} shader - The WebGL shader object.\n\t * @param {string} type - The shader type.\n\t * @return {string} The shader errors.\n\t */\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\n\t\tconst shaderInfoLog = gl.getShaderInfoLog( shader ) || '';\n\t\tconst errors = shaderInfoLog.trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Logs shader compilation errors.\n\t *\n\t * @private\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.\n\t * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.\n\t */\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programInfoLog = gl.getProgramInfoLog( programGPU ) || '';\n\t\t\tconst programLog = programInfoLog.trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Completes the shader program setup for the given render object.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {RenderPipeline} pipeline - The render pipeline.\n\t */\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings /*, cacheIndex, version*/ ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( bindGroup /*, bindings, cacheIndex, version*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: i ++,\n\t\t\t\t\tbufferGPU\n\t\t\t\t} );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: t ++,\n\t\t\t\t\ttextureGPU,\n\t\t\t\t\tglTextureType\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Configures the active framebuffer from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} descriptor - The render context.\n\t */\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isRenderTarget3D = renderTarget.isRenderTarget3D === true;\n\t\t\tconst isRenderTargetArray = renderTarget.depth > 1;\n\t\t\tconst isXRRenderTarget = renderTarget.isXRRenderTarget === true;\n\t\t\tconst _hasExternalTextures = ( isXRRenderTarget === true && renderTarget._hasExternalTextures === true );\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\t\t\tconst multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tconst multiviewExt = this.extensions.get( 'OVR_multiview2' );\n\t\t\tconst useMultisampledRTT = this._useMultisampledExtension( renderTarget );\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else if ( isXRRenderTarget && _hasExternalTextures === false ) {\n\n\t\t\t\tfb = this._xrFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\t\t\t\tconst depthInvalidationArray = [];\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( isRenderTarget3D || isRenderTargetArray ) {\n\n\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderTarget._autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\tconst renderbuffer = gl.createRenderbuffer();\n\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( renderbuffer, descriptor, 0, useMultisampledRTT );\n\t\t\t\t\trenderTargetContextData.xrDepthRenderbuffer = renderbuffer;\n\t\t\t\t\tdepthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );\n\n\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\t\tdepthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( _hasExternalTextures && useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( descriptor.depthTexture.isArrayTexture ) {\n\n\t\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderTargetContextData.depthInvalidationArray = depthInvalidationArray;\n\n\n\t\t\t} else {\n\n\t\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( descriptor );\n\n\t\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\tconst depthData = this.get( descriptor.depthTexture );\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\tgl.framebufferTextureLayer(\n\t\t\t\t\t\tgl.FRAMEBUFFER,\n\t\t\t\t\t\tdepthStyle,\n\t\t\t\t\t\tdepthData.textureGPU,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tlayer\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\t// rebind external XR textures\n\n\t\t\t\tif ( ( isXRRenderTarget || useMultisampledRTT || renderTarget.multiview ) && ( renderTarget._isOpaqueFramebuffer !== true ) ) {\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\t\t// rebind color\n\n\t\t\t\t\tconst textureData = this.get( descriptor.textures[ 0 ] );\n\n\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t} else if ( useMultisampledRTT ) {\n\n\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// rebind depth\n\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\tif ( renderTarget._autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\t\tconst renderbuffer = renderTargetContextData.xrDepthRenderbuffer;\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 && useMultisampledRTT === false && ! renderTarget.multiview ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, null );\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthBuffer && depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor, samples );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\t/**\n\t * Computes the VAO key for the given index and attributes.\n\t *\n\t * @private\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {string} The VAO key.\n\t */\n\t_getVaoKey( attributes ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t/**\n\t * Creates a VAO from the index and attributes.\n\t *\n\t * @private\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {Object} The VAO data.\n\t */\n\t_createVao( attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\treturn vaoGPU;\n\n\t}\n\n\t/**\n\t * Creates a transform feedback from the given transform buffers.\n\t *\n\t * @private\n\t * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.\n\t * @return {WebGLTransformFeedback} The transform feedback.\n\t */\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\t/**\n\t * Setups the given bindings.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t */\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given uniforms.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension\n\t * should be used when MSAA is enabled.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target that should be multisampled.\n\t * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.\n\t */\n\t_useMultisampledExtension( renderTarget ) {\n\n\t\tif ( renderTarget.multiview === true ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn renderTarget.samples > 0 && this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTarget._autoAllocateDepthBuffer !== false;\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tconst extension = this.extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nexport default WebGLBackend;\n"],"mappings":"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","ignoreList":[]}