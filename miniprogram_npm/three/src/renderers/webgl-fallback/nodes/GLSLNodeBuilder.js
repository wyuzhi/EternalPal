import{GLSLNodeParser,NodeBuilder,TextureNode,vectorComponents}from"../../../nodes/Nodes.js";import NodeUniformBuffer from"../../common/nodes/NodeUniformBuffer.js";import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import{NodeSampledTexture,NodeSampledCubeTexture,NodeSampledTexture3D}from"../../common/nodes/NodeSampledTexture.js";import{NoColorSpace,ByteType,ShortType,RGBAIntegerFormat,RGBIntegerFormat,RedIntegerFormat,RGIntegerFormat,UnsignedByteType,UnsignedIntType,UnsignedShortType,RedFormat,RGFormat,IntType,RGBFormat,RGBAFormat,FloatType}from"../../../constants.js";import{DataTexture}from"../../../textures/DataTexture.js";const glslMethods={textureDimensions:"textureSize",equals:"equal"},precisionLib={low:"lowp",medium:"mediump",high:"highp"},supports={swizzleAssign:!0,storageBuffer:!1},interpolationTypeMap={perspective:"smooth",linear:"noperspective"},interpolationModeMap={centroid:"centroid"},defaultPrecisions="\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\nprecision lowp sampler2DArrayShadow;\nprecision lowp samplerCubeShadow;\n";class GLSLNodeBuilder extends NodeBuilder{constructor(e,t){super(e,t,new GLSLNodeParser),this.uniformGroups={},this.transforms=[],this.extensions={},this.builtins={vertex:[],fragment:[],compute:[]}}needsToWorkingColorSpace(e){return!0===e.isVideoTexture&&e.colorSpace!==NoColorSpace}getMethod(e){return glslMethods[e]||e}getOutputStructName(){return""}buildFunctionCode(e){const t=e.layout,n=this.flowShaderNode(e),r=[];for(const e of t.inputs)r.push(this.getType(e.type)+" "+e.name);return`${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {\n\n\t${n.vars}\n\n${n.code}\n\treturn ${n.result};\n\n}`}setupPBO(e){const t=e.value;if(void 0===t.pbo){const e=t.array,n=t.count*t.itemSize,{itemSize:r}=t,o=t.array.constructor.name.toLowerCase().includes("int");let i=o?RedIntegerFormat:RedFormat;2===r?i=o?RGIntegerFormat:RGFormat:3===r?i=o?RGBIntegerFormat:RGBFormat:4===r&&(i=o?RGBAIntegerFormat:RGBAFormat);const s={Float32Array:FloatType,Uint8Array:UnsignedByteType,Uint16Array:UnsignedShortType,Uint32Array:UnsignedIntType,Int8Array:ByteType,Int16Array:ShortType,Int32Array:IntType,Uint8ClampedArray:UnsignedByteType},a=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(n/r))));let u=Math.ceil(n/r/a);a*u*r<n&&u++;const p=a*u*r,l=new e.constructor(p);l.set(e,0),t.array=l;const m=new DataTexture(t.array,a,u,i,s[t.array.constructor.name]||FloatType);m.needsUpdate=!0,m.isPBOTexture=!0;const d=new TextureNode(m,null,null);d.setPrecision("high"),t.pboNode=d,t.pbo=d.value,this.getUniformFromNode(t.pboNode,"texture",this.shaderStage,this.context.nodeName)}}getPropertyName(e,t=this.shaderStage){return e.isNodeUniform&&!0!==e.node.isTextureNode&&!0!==e.node.isBufferNode?t.charAt(0)+"_"+e.name:super.getPropertyName(e,t)}generatePBO(e){const{node:t,indexNode:n}=e,r=t.value;if(this.renderer.backend.has(r)){this.renderer.backend.get(r).pbo=r.pbo}const o=this.getUniformFromNode(r.pboNode,"texture",this.shaderStage,this.context.nodeName),i=this.getPropertyName(o);this.increaseUsage(n);const s=n.build(this,"uint"),a=this.getDataFromNode(e);let u=a.propertyName;if(void 0===u){const n=this.getVarFromNode(e);u=this.getPropertyName(n);const o=this.getDataFromNode(t);let p=o.propertySizeName;void 0===p&&(p=u+"Size",this.getVarFromNode(t,p,"uint"),this.addLineFlowCode(`${p} = uint( textureSize( ${i}, 0 ).x )`,e),o.propertySizeName=p);const{itemSize:l}=r,m="."+vectorComponents.join("").slice(0,l),d=`ivec2(${s} % ${p}, ${s} / ${p})`,c=this.generateTextureLoad(null,i,d,null,"0");let h="vec4";r.pbo.type===UnsignedIntType?h="uvec4":r.pbo.type===IntType&&(h="ivec4"),this.addLineFlowCode(`${u} = ${h}(${c})${m}`,e),a.propertyName=u}return u}generateTextureLoad(e,t,n,r,o="0"){return r?`texelFetch( ${t}, ivec3( ${n}, ${r} ), ${o} )`:`texelFetch( ${t}, ${n}, ${o} )`}generateTexture(e,t,n,r){return e.isDepthTexture?(r&&(n=`vec4( ${n}, ${r} )`),`texture( ${t}, ${n} ).x`):(r&&(n=`vec3( ${n}, ${r} )`),`texture( ${t}, ${n} )`)}generateTextureLevel(e,t,n,r){return`textureLod( ${t}, ${n}, ${r} )`}generateTextureBias(e,t,n,r){return`texture( ${t}, ${n}, ${r} )`}generateTextureGrad(e,t,n,r){return`textureGrad( ${t}, ${n}, ${r[0]}, ${r[1]} )`}generateTextureCompare(e,t,n,r,o,i=this.shaderStage){if("fragment"===i)return o?`texture( ${t}, vec4( ${n}, ${o}, ${r} ) )`:`texture( ${t}, vec3( ${n}, ${r} ) )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${i} shader.`)}getVars(e){const t=[],n=this.vars[e];if(void 0!==n)for(const e of n)t.push(`${this.getVar(e.type,e.name,e.count)};`);return t.join("\n\t")}getUniforms(e){const t=this.uniforms[e],n=[],r={};for(const o of t){let t=null,i=!1;if("texture"===o.type||"texture3D"===o.type){const e=o.node.value;let n="";!0!==e.isDataTexture&&!0!==e.isData3DTexture||(e.type===UnsignedIntType?n="u":e.type===IntType&&(n="i")),t="texture3D"===o.type&&!1===e.isArrayTexture?`${n}sampler3D ${o.name};`:e.compareFunction?!0===e.isArrayTexture?`sampler2DArrayShadow ${o.name};`:`sampler2DShadow ${o.name};`:!0===e.isArrayTexture||!0===e.isDataArrayTexture||!0===e.isCompressedArrayTexture?`${n}sampler2DArray ${o.name};`:`${n}sampler2D ${o.name};`}else if("cubeTexture"===o.type)t=`samplerCube ${o.name};`;else if("buffer"===o.type){const e=o.node,n=this.getType(e.bufferType),r=e.bufferCount,i=r>0?r:"";t=`${e.name} {\n\t${n} ${o.name}[${i}];\n};\n`}else{t=`${this.getVectorType(o.type)} ${this.getPropertyName(o,e)};`,i=!0}const s=o.node.precision;if(null!==s&&(t=precisionLib[s]+" "+t),i){t="\t"+t;const e=o.groupNode.name;(r[e]||(r[e]=[])).push(t)}else t="uniform "+t,n.push(t)}let o="";for(const t in r){const n=r[t];o+=this._getGLSLUniformStruct(e+"_"+t,n.join("\n"))+"\n"}return o+=n.join("\n"),o}getTypeFromAttribute(e){let t=super.getTypeFromAttribute(e);if(/^[iu]/.test(t)&&e.gpuType!==IntType){let n=e;e.isInterleavedBufferAttribute&&(n=e.data);const r=n.array;!1==(r instanceof Uint32Array||r instanceof Int32Array)&&(t=t.slice(1))}return t}getAttributes(e){let t="";if("vertex"===e||"compute"===e){const e=this.getAttributesArray();let n=0;for(const r of e)t+=`layout( location = ${n++} ) in ${r.type} ${r.name};\n`}return t}getStructMembers(e){const t=[];for(const n of e.members)t.push(`\t${n.type} ${n.name};`);return t.join("\n")}getStructs(e){const t=[],n=this.structs[e],r=[];for(const e of n)if(e.output)for(const t of e.members)r.push(`layout( location = ${t.index} ) out ${t.type} ${t.name};`);else{let n="struct "+e.name+" {\n";n+=this.getStructMembers(e),n+="\n};\n",t.push(n)}return 0===r.length&&r.push("layout( location = 0 ) out vec4 fragColor;"),"\n"+r.join("\n")+"\n\n"+t.join("\n")}getVaryings(e){let t="";const n=this.varyings;if("vertex"===e||"compute"===e)for(const r of n){"compute"===e&&(r.needsInterpolation=!0);const n=this.getType(r.type);if(r.needsInterpolation)if(r.interpolationType){t+=`${interpolationTypeMap[r.interpolationType]||r.interpolationType} ${interpolationModeMap[r.interpolationSampling]||""} out ${n} ${r.name};\n`}else{t+=`${n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":""}out ${n} ${r.name};\n`}else t+=`${n} ${r.name};\n`}else if("fragment"===e)for(const e of n)if(e.needsInterpolation){const n=this.getType(e.type);if(e.interpolationType){t+=`${interpolationTypeMap[e.interpolationType]||e.interpolationType} ${interpolationModeMap[e.interpolationSampling]||""} in ${n} ${e.name};\n`}else{t+=`${n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":""}in ${n} ${e.name};\n`}}for(const n of this.builtins[e])t+=`${n};\n`;return t}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getInvocationLocalIndex(){return`uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce(((e,t)=>e*t),1)}u`}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord.xy"}getFragDepth(){return"gl_FragDepth"}enableExtension(e,t,n=this.shaderStage){const r=this.extensions[n]||(this.extensions[n]=new Map);!1===r.has(e)&&r.set(e,{name:e,behavior:t})}getExtensions(e){const t=[];if("vertex"===e){const t=this.renderer.backend.extensions;this.object.isBatchedMesh&&t.has("WEBGL_multi_draw")&&this.enableExtension("GL_ANGLE_multi_draw","require",e)}const n=this.extensions[e];if(void 0!==n)for(const{name:e,behavior:r}of n.values())t.push(`#extension ${e} : ${r}`);return t.join("\n")}getClipDistance(){return"gl_ClipDistance"}isAvailable(e){let t=supports[e];if(void 0===t){let n;switch(t=!1,e){case"float32Filterable":n="OES_texture_float_linear";break;case"clipDistance":n="WEBGL_clip_cull_distance"}if(void 0!==n){const e=this.renderer.backend.extensions;e.has(n)&&(e.get(n),t=!0)}supports[e]=t}return t}isFlipY(){return!0}enableHardwareClipping(e){this.enableExtension("GL_ANGLE_clip_cull_distance","require"),this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`)}enableMultiview(){this.enableExtension("GL_OVR_multiview2","require","fragment"),this.enableExtension("GL_OVR_multiview2","require","vertex"),this.builtins.vertex.push("layout(num_views = 2) in")}registerTransform(e,t){this.transforms.push({varyingName:e,attributeNode:t})}getTransforms(){const e=this.transforms;let t="";for(let n=0;n<e.length;n++){const r=e[n],o=this.getPropertyName(r.attributeNode);o&&(t+=`${r.varyingName} = ${o};\n\t`)}return t}_getGLSLUniformStruct(e,t){return`\nlayout( std140 ) uniform ${e} {\n${t}\n};`}_getGLSLVertexCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions\n${e.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// attributes\n${e.attributes}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// transforms\n\t${e.transforms}\n\n\t// flow\n\t${e.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions\n${e.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n// structs\n${e.structs}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){let n="// code\n\n";n+=this.flowCode[t];const r=this.flowNodes[t],o=r[r.length-1];for(const e of r){const r=this.getFlowData(e),i=e.name;i&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${i}\n\t`),n+=`${r.code}\n\t`,e===o&&"compute"!==t&&(n+="// result\n\t","vertex"===t?(n+="gl_Position = ",n+=`${r.result};`):"fragment"===t&&(e.outputNode.isOutputStructNode||(n+="fragColor = ",n+=`${r.result};`)))}const i=e[t];i.extensions=this.getExtensions(t),i.uniforms=this.getUniforms(t),i.attributes=this.getAttributes(t),i.varyings=this.getVaryings(t),i.vars=this.getVars(t),i.structs=this.getStructs(t),i.codes=this.getCodes(t),i.transforms=this.getTransforms(t),i.flow=n}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):this.computeShader=this._getGLSLVertexCode(e.compute)}getUniformFromNode(e,t,n,r=null){const o=super.getUniformFromNode(e,t,n,r),i=this.getDataFromNode(e,n,this.globalCache);let s=i.uniformGPU;if(void 0===s){const r=e.groupNode,a=r.name,u=this.getBindGroupArray(a,n);if("texture"===t)s=new NodeSampledTexture(o.name,o.node,r),u.push(s);else if("cubeTexture"===t)s=new NodeSampledCubeTexture(o.name,o.node,r),u.push(s);else if("texture3D"===t)s=new NodeSampledTexture3D(o.name,o.node,r),u.push(s);else if("buffer"===t){e.name=`NodeBuffer_${e.id}`,o.name=`buffer${e.id}`;const t=new NodeUniformBuffer(e,r);t.name=e.name,u.push(t),s=t}else{const e=this.uniformGroups[n]||(this.uniformGroups[n]={});let i=e[a];void 0===i&&(i=new NodeUniformsGroup(n+"_"+a,r),e[a]=i,u.push(i)),s=this.getNodeUniform(o,t),i.addUniform(s)}i.uniformGPU=s}return o}}export default GLSLNodeBuilder;
//# sourceMappingURL=GLSLNodeBuilder.js.map