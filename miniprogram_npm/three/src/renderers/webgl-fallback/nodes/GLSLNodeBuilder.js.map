{"version":3,"file":"node_modules/three/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.js","names":["GLSLNodeParser","NodeBuilder","TextureNode","vectorComponents","NodeUniformBuffer","NodeUniformsGroup","NodeSampledTexture","NodeSampledCubeTexture","NodeSampledTexture3D","NoColorSpace","ByteType","ShortType","RGBAIntegerFormat","RGBIntegerFormat","RedIntegerFormat","RGIntegerFormat","UnsignedByteType","UnsignedIntType","UnsignedShortType","RedFormat","RGFormat","IntType","RGBFormat","RGBAFormat","FloatType","DataTexture","glslMethods","textureDimensions","equals","precisionLib","low","medium","high","supports","swizzleAssign","storageBuffer","interpolationTypeMap","perspective","linear","interpolationModeMap","centroid","defaultPrecisions","GLSLNodeBuilder","constructor","object","renderer","super","this","uniformGroups","transforms","extensions","builtins","vertex","fragment","compute","needsToWorkingColorSpace","texture","isVideoTexture","colorSpace","getMethod","method","getOutputStructName","buildFunctionCode","shaderNode","layout","flowData","flowShaderNode","parameters","input","inputs","push","getType","type","name","join","vars","code","result","setupPBO","storageBufferNode","attribute","value","undefined","pbo","originalArray","array","numElements","count","itemSize","isInteger","toLowerCase","includes","format","typeMap","Float32Array","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","width","Math","pow","ceil","log2","sqrt","height","newSize","newArray","set","pboTexture","needsUpdate","isPBOTexture","setPrecision","pboNode","getUniformFromNode","shaderStage","context","nodeName","getPropertyName","node","isNodeUniform","isTextureNode","isBufferNode","charAt","generatePBO","storageArrayElementNode","indexNode","backend","has","get","nodeUniform","textureName","increaseUsage","indexSnippet","build","elementNodeData","getDataFromNode","propertyName","nodeVar","getVarFromNode","bufferNodeData","propertySizeName","addLineFlowCode","channel","slice","uvSnippet","snippet","generateTextureLoad","prefix","textureProperty","uvIndexSnippet","depthSnippet","levelSnippet","generateTexture","isDepthTexture","generateTextureLevel","generateTextureBias","biasSnippet","generateTextureGrad","gradSnippet","generateTextureCompare","compareSnippet","console","error","getVars","snippets","variable","getVar","getUniforms","uniforms","bindingSnippets","uniform","group","typePrefix","isDataTexture","isData3DTexture","isArrayTexture","compareFunction","isDataArrayTexture","isCompressedArrayTexture","bufferNode","bufferType","bufferCount","bufferCountSnippet","getVectorType","precision","groupName","groupNode","output","groupSnippets","_getGLSLUniformStruct","getTypeFromAttribute","nodeType","test","gpuType","dataAttribute","isInterleavedBufferAttribute","data","getAttributes","attributes","getAttributesArray","location","getStructMembers","struct","member","members","getStructs","structs","outputSnippet","index","length","getVaryings","varyings","varying","needsInterpolation","interpolationType","interpolationSampling","builtin","getVertexIndex","getInstanceIndex","getInvocationLocalIndex","workgroupSize","reduce","acc","curr","getDrawIndex","getFrontFacing","getFragCoord","getFragDepth","enableExtension","behavior","map","Map","getExtensions","ext","isBatchedMesh","values","getClipDistance","isAvailable","extensionName","isFlipY","enableHardwareClipping","planeCount","enableMultiview","registerTransform","varyingName","attributeNode","getTransforms","i","transform","attributeName","_getGLSLVertexCode","shaderData","getSignature","codes","flow","_getGLSLFragmentCode","buildCode","shadersData","material","sortBindingGroups","flowCode","flowNodes","mainNode","flowSlotData","getFlowData","slotName","outputNode","isOutputStructNode","stageData","getCodes","vertexShader","fragmentShader","computeShader","uniformNode","nodeData","globalCache","uniformGPU","bindings","getBindGroupArray","id","buffer","uniformsStage","uniformsGroup","getNodeUniform","addUniform"],"sources":["node_modules/three/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.js"],"sourcesContent":["import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';\n\nimport NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';\nimport NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';\n\nimport { NodeSampledTexture, NodeSampledCubeTexture, NodeSampledTexture3D } from '../../common/nodes/NodeSampledTexture.js';\n\nimport { NoColorSpace, ByteType, ShortType, RGBAIntegerFormat, RGBIntegerFormat, RedIntegerFormat, RGIntegerFormat, UnsignedByteType, UnsignedIntType, UnsignedShortType, RedFormat, RGFormat, IntType, RGBFormat, RGBAFormat, FloatType } from '../../../constants.js';\nimport { DataTexture } from '../../../textures/DataTexture.js';\n\nconst glslMethods = {\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst interpolationTypeMap = {\n\tperspective: 'smooth',\n\tlinear: 'noperspective'\n};\n\nconst interpolationModeMap = {\n\t'centroid': 'centroid'\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\nprecision lowp sampler2DArrayShadow;\nprecision lowp samplerCubeShadow;\n`;\n\n/**\n * A node builder targeting GLSL.\n *\n * This module generates GLSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new GLSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * An array that holds objects defining the varying and attribute data in\n\t\t * context of Transform Feedback.\n\t\t *\n\t\t * @type {Array<Object<string,AttributeNode|string>>}\n\t\t */\n\t\tthis.transforms = [];\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of used extensions.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage an Array of used builtins.\n\t\t *\n\t\t * @type {Object<string,Array<string>>}\n\t\t */\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved GLSL method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\t/**\n\t * Returns the output struct name. Not relevant for GLSL.\n\t *\n\t * @return {string}\n\t */\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The GLSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t */\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a GLSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.\n\t * @return {string} The property name.\n\t */\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec4( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `texture( ${ textureProperty }, vec4( ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } ) )`;\n\n\t\t\t}\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true || texture.isData3DTexture === true ) {\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniform.type === 'texture3D' && texture.isArrayTexture === false ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler3D ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.compareFunction ) {\n\n\t\t\t\t\tif ( texture.isArrayTexture === true ) {\n\n\t\t\t\t\t\tsnippet = `sampler2DArrayShadow ${ uniform.name };`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a GLSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The GLSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tsnippets.push( `\\t${ member.type } ${ member.name };` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tconst outputSnippet = [];\n\n\t\tfor ( const struct of structs ) {\n\n\t\t\tif ( struct.output ) {\n\n\t\t\t\tfor ( const member of struct.members ) {\n\n\t\t\t\t\toutputSnippet.push( `layout( location = ${ member.index } ) out ${ member.type } ${ member.name };` );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet snippet = 'struct ' + struct.name + ' {\\n';\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};\\n';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( outputSnippet.length === 0 ) {\n\n\t\t\toutputSnippet.push( 'layout( location = 0 ) out vec4 fragColor;' );\n\n\t\t}\n\n\t\treturn '\\n' + outputSnippet.join( '\\n' ) + '\\n\\n' + snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\n\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;\n\t\t\t\t\t\tconst sampling = interpolationModeMap[ varying.interpolationSampling ] || '';\n\n\t\t\t\t\t\tsnippet += `${ interpolationType } ${ sampling } out ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\t\tsnippet += `${ flat }out ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet += `${type} ${varying.name};\\n`; // generate variable (no varying required)\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;\n\t\t\t\t\t\tconst sampling = interpolationModeMap[ varying.interpolationSampling ] || '';\n\n\t\t\t\t\t\tsnippet += `${ interpolationType } ${ sampling } in ${ type } ${ varying.name };\\n`;\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\t\tsnippet += `${ flat }in ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\t/**\n\t * Returns the draw index builtin.\n\t *\n\t * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.\n\t */\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\t/**\n\t * Enables the given extension.\n\t *\n\t * @param {string} name - The extension name.\n\t * @param {string} behavior - The extension behavior.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage.\n\t */\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the enabled extensions of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the enabled extensions.\n\t */\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `true` in context of GLSL.\n\t */\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\t/**\n\t * Enables multiview.\n\t */\n\tenableMultiview() {\n\n\t\tthis.enableExtension( 'GL_OVR_multiview2', 'require', 'fragment' );\n\t\tthis.enableExtension( 'GL_OVR_multiview2', 'require', 'vertex' );\n\n\t\tthis.builtins[ 'vertex' ].push( 'layout(num_views = 2) in' );\n\n\t}\n\n\t/**\n\t * Registers a transform in context of Transform Feedback.\n\t *\n\t * @param {string} varyingName - The varying name.\n\t * @param {AttributeNode} attributeNode - The attribute node.\n\t */\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\t/**\n\t * Returns the transforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the transforms.\n\t */\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tif ( attributeName ) snippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns a GLSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The GLSL snippet representing a struct.\n\t */\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n// structs\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nexport default GLSLNodeBuilder;\n"],"mappings":"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","ignoreList":[]}