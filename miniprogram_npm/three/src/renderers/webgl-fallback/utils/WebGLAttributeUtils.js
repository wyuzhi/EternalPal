import{IntType}from"../../../constants.js";let _id=0;class DualAttributeData{constructor(e,t){this.buffers=[e.bufferGPU,t],this.type=e.type,this.bufferType=e.bufferType,this.pbo=e.pbo,this.byteLength=e.byteLength,this.bytesPerElement=e.BYTES_PER_ELEMENT,this.version=e.version,this.isInteger=e.isInteger,this.activeBufferIndex=0,this.baseId=e.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[1^this.activeBufferIndex]}switchBuffers(){this.activeBufferIndex^=1}}class WebGLAttributeUtils{constructor(e){this.backend=e}createAttribute(e,t){const r=this.backend,{gl:f}=r,n=e.array,a=e.usage||f.STATIC_DRAW,i=e.isInterleavedBufferAttribute?e.data:e,s=r.get(i);let u,b=s.bufferGPU;if(void 0===b&&(b=this._createBuffer(f,t,n,a),s.bufferGPU=b,s.bufferType=t,s.version=i.version),n instanceof Float32Array)u=f.FLOAT;else if("undefined"!=typeof Float16Array&&n instanceof Float16Array)u=f.HALF_FLOAT;else if(n instanceof Uint16Array)u=e.isFloat16BufferAttribute?f.HALF_FLOAT:f.UNSIGNED_SHORT;else if(n instanceof Int16Array)u=f.SHORT;else if(n instanceof Uint32Array)u=f.UNSIGNED_INT;else if(n instanceof Int32Array)u=f.INT;else if(n instanceof Int8Array)u=f.BYTE;else if(n instanceof Uint8Array)u=f.UNSIGNED_BYTE;else{if(!(n instanceof Uint8ClampedArray))throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+n);u=f.UNSIGNED_BYTE}let o={bufferGPU:b,bufferType:t,type:u,byteLength:n.byteLength,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version,pbo:e.pbo,isInteger:u===f.INT||u===f.UNSIGNED_INT||e.gpuType===IntType,id:_id++};if(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute){const e=this._createBuffer(f,t,n,a);o=new DualAttributeData(o,e)}r.set(e,o)}updateAttribute(e){const t=this.backend,{gl:r}=t,f=e.array,n=e.isInterleavedBufferAttribute?e.data:e,a=t.get(n),i=a.bufferType,s=e.isInterleavedBufferAttribute?e.data.updateRanges:e.updateRanges;if(r.bindBuffer(i,a.bufferGPU),0===s.length)r.bufferSubData(i,0,f);else{for(let e=0,t=s.length;e<t;e++){const t=s[e];r.bufferSubData(i,t.start*f.BYTES_PER_ELEMENT,f,t.start,t.count)}n.clearUpdateRanges()}r.bindBuffer(i,null),a.version=n.version}destroyAttribute(e){const t=this.backend,{gl:r}=t;e.isInterleavedBufferAttribute&&t.delete(e.data);const f=t.get(e);r.deleteBuffer(f.bufferGPU),t.delete(e)}async getArrayBufferAsync(e){const t=this.backend,{gl:r}=t,f=e.isInterleavedBufferAttribute?e.data:e,{bufferGPU:n}=t.get(f),a=e.array,i=a.byteLength;r.bindBuffer(r.COPY_READ_BUFFER,n);const s=r.createBuffer();r.bindBuffer(r.COPY_WRITE_BUFFER,s),r.bufferData(r.COPY_WRITE_BUFFER,i,r.STREAM_READ),r.copyBufferSubData(r.COPY_READ_BUFFER,r.COPY_WRITE_BUFFER,0,0,i),await t.utils._clientWaitAsync();const u=new e.array.constructor(a.length);return r.bindBuffer(r.COPY_WRITE_BUFFER,s),r.getBufferSubData(r.COPY_WRITE_BUFFER,0,u),r.deleteBuffer(s),r.bindBuffer(r.COPY_READ_BUFFER,null),r.bindBuffer(r.COPY_WRITE_BUFFER,null),u.buffer}_createBuffer(e,t,r,f){const n=e.createBuffer();return e.bindBuffer(t,n),e.bufferData(t,r,f),e.bindBuffer(t,null),n}}export default WebGLAttributeUtils;
//# sourceMappingURL=WebGLAttributeUtils.js.map