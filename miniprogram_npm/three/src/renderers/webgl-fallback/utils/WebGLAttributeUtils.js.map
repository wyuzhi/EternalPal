{"version":3,"file":"node_modules/three/src/renderers/webgl-fallback/utils/WebGLAttributeUtils.js","names":["IntType","_id","DualAttributeData","constructor","attributeData","dualBuffer","this","buffers","bufferGPU","type","bufferType","pbo","byteLength","bytesPerElement","BYTES_PER_ELEMENT","version","isInteger","activeBufferIndex","baseId","id","transformBuffer","switchBuffers","WebGLAttributeUtils","backend","createAttribute","attribute","gl","array","usage","STATIC_DRAW","bufferAttribute","isInterleavedBufferAttribute","data","bufferData","get","undefined","_createBuffer","Float32Array","FLOAT","Float16Array","HALF_FLOAT","Uint16Array","isFloat16BufferAttribute","UNSIGNED_SHORT","Int16Array","SHORT","Uint32Array","UNSIGNED_INT","Int32Array","INT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Uint8ClampedArray","Error","gpuType","isStorageBufferAttribute","isStorageInstancedBufferAttribute","bufferGPUDual","set","updateAttribute","updateRanges","bindBuffer","length","bufferSubData","i","l","range","start","count","clearUpdateRanges","destroyAttribute","delete","deleteBuffer","getArrayBufferAsync","COPY_READ_BUFFER","writeBuffer","createBuffer","COPY_WRITE_BUFFER","STREAM_READ","copyBufferSubData","utils","_clientWaitAsync","dstBuffer","getBufferSubData","buffer"],"sources":["node_modules/three/src/renderers/webgl-fallback/utils/WebGLAttributeUtils.js"],"sourcesContent":["import { IntType } from '../../../constants.js';\n\nlet _id = 0;\n\n/**\n * This module is internally used in context of compute shaders.\n * This type of shader is not natively supported in WebGL 2 and\n * thus implemented via Transform Feedback. `DualAttributeData`\n * manages the related data.\n *\n * @private\n */\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGLAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t */\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {\n\n\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for transform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Creates a WebGL buffer with the given data.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t * @param {TypedArray} array - The array of the buffer attribute.\n\t * @param {GLenum} usage - The usage.\n\t * @return {WebGLBuffer} The WebGL buffer.\n\t */\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nexport default WebGLAttributeUtils;\n"],"mappings":"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","ignoreList":[]}