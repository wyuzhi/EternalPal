{"version":3,"file":"node_modules/three/src/renderers/webgl-fallback/utils/WebGLTimestampQueryPool.js","names":["warnOnce","TimestampQueryPool","WebGLTimestampQueryPool","constructor","gl","type","maxQueries","super","this","ext","getExtension","console","warn","trackTimestamp","queries","i","push","createQuery","activeQuery","queryStates","Map","allocateQueriesForContext","renderContext","currentQueryIndex","toUpperCase","baseOffset","set","queryOffsets","id","beginQuery","isDisposed","get","query","TIME_ELAPSED_EXT","error","endQuery","resolveQueriesAsync","pendingResolve","lastValue","resolvePromises","state","resolveQuery","length","totalDuration","Promise","all","reduce","acc","val","clear","resolve","timeoutId","isResolved","finalizeResolution","value","clearTimeout","checkQuery","getParameter","GPU_DISJOINT_EXT","getQueryParameter","QUERY_RESULT_AVAILABLE","setTimeout","elapsed","QUERY_RESULT","Number","dispose","deleteQuery"],"sources":["node_modules/three/src/renderers/webgl-fallback/utils/WebGLTimestampQueryPool.js"],"sourcesContent":["import { warnOnce } from '../../../utils.js';\nimport TimestampQueryPool from '../../common/TimestampQueryPool.js';\n\n/**\n * Manages a pool of WebGL timestamp queries for performance measurement.\n * Handles creation, execution, and resolution of timer queries using WebGL extensions.\n *\n * @augments TimestampQueryPool\n */\nclass WebGLTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n\t * Creates a new WebGL timestamp query pool.\n\t *\n\t * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.\n\t * @param {string} type - The type identifier for this query pool.\n\t * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n\t */\n\tconstructor( gl, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\n\t\tthis.gl = gl;\n\t\tthis.type = type;\n\n\t\t// Check for timer query extensions\n\t\tthis.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' ) ||\n\t\t\t\t  gl.getExtension( 'EXT_disjoint_timer_query' );\n\n\t\tif ( ! this.ext ) {\n\n\t\t\tconsole.warn( 'EXT_disjoint_timer_query not supported; timestamps will be disabled.' );\n\t\t\tthis.trackTimestamp = false;\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Create query objects\n\t\tthis.queries = [];\n\t\tfor ( let i = 0; i < this.maxQueries; i ++ ) {\n\n\t\t\tthis.queries.push( gl.createQuery() );\n\n\t\t}\n\n\t\tthis.activeQuery = null;\n\t\tthis.queryStates = new Map(); // Track state of each query: 'inactive', 'started', 'ended'\n\n\t}\n\n\t/**\n\t * Allocates a pair of queries for a given render context.\n\t *\n\t * @param {Object} renderContext - The render context to allocate queries for.\n\t * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n\t */\n\tallocateQueriesForContext( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp ) return null;\n\n\t\t// Check if we have enough space for a new query pair\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\t// Initialize query states\n\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\tthis.queryOffsets.set( renderContext.id, baseOffset );\n\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n\t * Begins a timestamp query for the specified render context.\n\t *\n\t * @param {Object} renderContext - The render context to begin timing for.\n\t */\n\tbeginQuery( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( renderContext.id );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Don't start a new query if there's an active one\n\t\tif ( this.activeQuery !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst query = this.queries[ baseOffset ];\n\t\tif ( ! query ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Only begin if query is inactive\n\t\t\tif ( this.queryStates.get( baseOffset ) === 'inactive' ) {\n\n\t\t\t\tthis.gl.beginQuery( this.ext.TIME_ELAPSED_EXT, query );\n\t\t\t\tthis.activeQuery = baseOffset;\n\t\t\t\tthis.queryStates.set( baseOffset, 'started' );\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error in beginQuery:', error );\n\t\t\tthis.activeQuery = null;\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Ends the active timestamp query for the specified render context.\n\t *\n\t * @param {Object} renderContext - The render context to end timing for.\n\t * @param {string} renderContext.id - Unique identifier for the render context.\n\t */\n\tendQuery( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( renderContext.id );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Only end if this is the active query\n\t\tif ( this.activeQuery !== baseOffset ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tthis.gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n\t\t\tthis.queryStates.set( baseOffset, 'ended' );\n\t\t\tthis.activeQuery = null;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error in endQuery:', error );\n\t\t\t// Reset state on error\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\t\tthis.activeQuery = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Asynchronously resolves all completed queries and returns the total duration.\n\t *\n\t * @async\n\t * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n\t */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.pendingResolve ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tthis.pendingResolve = true;\n\n\t\ttry {\n\n\t\t\t// Wait for all ended queries to complete\n\t\t\tconst resolvePromises = [];\n\n\t\t\tfor ( const [ baseOffset, state ] of this.queryStates ) {\n\n\t\t\t\tif ( state === 'ended' ) {\n\n\t\t\t\t\tconst query = this.queries[ baseOffset ];\n\t\t\t\t\tresolvePromises.push( this.resolveQuery( query ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( resolvePromises.length === 0 ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst results = await Promise.all( resolvePromises );\n\t\t\tconst totalDuration = results.reduce( ( acc, val ) => acc + val, 0 );\n\n\t\t\t// Store the last valid result\n\t\t\tthis.lastValue = totalDuration;\n\n\t\t\t// Reset states\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\t\t\tthis.queryStates.clear();\n\t\t\tthis.activeQuery = null;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error resolving queries:', error );\n\t\t\treturn this.lastValue;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resolves a single query, checking for completion and disjoint operation.\n\t *\n\t * @async\n\t * @param {WebGLQuery} query - The query object to resolve.\n\t * @returns {Promise<number>} The elapsed time in milliseconds.\n\t */\n\tasync resolveQuery( query ) {\n\n\t\treturn new Promise( ( resolve ) => {\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tresolve( this.lastValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet timeoutId;\n\t\t\tlet isResolved = false;\n\n\t\t\tconst cleanup = () => {\n\n\t\t\t\tif ( timeoutId ) {\n\n\t\t\t\t\tclearTimeout( timeoutId );\n\t\t\t\t\ttimeoutId = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst finalizeResolution = ( value ) => {\n\n\t\t\t\tif ( ! isResolved ) {\n\n\t\t\t\t\tisResolved = true;\n\t\t\t\t\tcleanup();\n\t\t\t\t\tresolve( value );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst checkQuery = () => {\n\n\t\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Check if the GPU timer was disjoint (i.e., timing was unreliable)\n\t\t\t\t\tconst disjoint = this.gl.getParameter( this.ext.GPU_DISJOINT_EXT );\n\t\t\t\t\tif ( disjoint ) {\n\n\t\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst available = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t\t\t\tif ( ! available ) {\n\n\t\t\t\t\t\ttimeoutId = setTimeout( checkQuery, 1 );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elapsed = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT );\n\t\t\t\t\tresolve( Number( elapsed ) / 1e6 ); // Convert nanoseconds to milliseconds\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tconsole.error( 'Error checking query:', error );\n\t\t\t\t\tresolve( this.lastValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheckQuery();\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Releases all resources held by this query pool.\n\t * This includes deleting all query objects and clearing internal state.\n\t */\n\tdispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tfor ( const query of this.queries ) {\n\n\t\t\tthis.gl.deleteQuery( query );\n\n\t\t}\n\n\t\tthis.queries = [];\n\t\tthis.queryStates.clear();\n\t\tthis.queryOffsets.clear();\n\t\tthis.lastValue = 0;\n\t\tthis.activeQuery = null;\n\n\t}\n\n}\n\nexport default WebGLTimestampQueryPool;\n"],"mappings":"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","ignoreList":[]}