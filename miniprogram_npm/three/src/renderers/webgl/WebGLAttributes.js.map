{"version":3,"file":"node_modules/three/src/renderers/webgl/WebGLAttributes.js","names":["WebGLAttributes","gl","buffers","WeakMap","get","attribute","isInterleavedBufferAttribute","data","remove","deleteBuffer","buffer","delete","update","bufferType","isGLBufferAttribute","cached","version","set","type","bytesPerElement","elementSize","undefined","array","usage","size","byteLength","createBuffer","bindBuffer","bufferData","onUploadCallback","Float32Array","FLOAT","Float16Array","HALF_FLOAT","Uint16Array","isFloat16BufferAttribute","UNSIGNED_SHORT","Int16Array","SHORT","Uint32Array","UNSIGNED_INT","Int32Array","INT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Uint8ClampedArray","Error","BYTES_PER_ELEMENT","updateRanges","length","bufferSubData","sort","a","b","start","mergeIndex","i","previousRange","range","count","Math","max","l","clearUpdateRanges","updateBuffer"],"sources":["node_modules/three/src/renderers/webgl/WebGLAttributes.js"],"sourcesContent":["function WebGLAttributes( gl ) {\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\t\tconst size = array.byteLength;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {\n\n\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tsize: size\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRanges = attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\t// Before applying update ranges, we merge any adjacent / overlapping\n\t\t\t// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led\n\t\t\t// to performance improvements for applications which make heavy use of\n\t\t\t// update ranges. Likely due to GPU command overhead.\n\t\t\t//\n\t\t\t// Note that to reduce garbage collection between frames, we merge the\n\t\t\t// update ranges in-place. This is safe because this method will clear the\n\t\t\t// update ranges once updated.\n\n\t\t\tupdateRanges.sort( ( a, b ) => a.start - b.start );\n\n\t\t\t// To merge the update ranges in-place, we work from left to right in the\n\t\t\t// existing updateRanges array, merging ranges. This may result in a final\n\t\t\t// array which is smaller than the original. This index tracks the last\n\t\t\t// index representing a merged range, any data after this index can be\n\t\t\t// trimmed once the merge algorithm is completed.\n\t\t\tlet mergeIndex = 0;\n\n\t\t\tfor ( let i = 1; i < updateRanges.length; i ++ ) {\n\n\t\t\t\tconst previousRange = updateRanges[ mergeIndex ];\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\t// We add one here to merge adjacent ranges. This is safe because ranges\n\t\t\t\t// operate over positive integers.\n\t\t\t\tif ( range.start <= previousRange.start + previousRange.count + 1 ) {\n\n\t\t\t\t\tpreviousRange.count = Math.max(\n\t\t\t\t\t\tpreviousRange.count,\n\t\t\t\t\t\trange.start + range.count - previousRange.start\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t++ mergeIndex;\n\t\t\t\t\tupdateRanges[ mergeIndex ] = range;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Trim the array to only contain the merged ranges.\n\t\t\tupdateRanges.length = mergeIndex + 1;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tattribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tif ( data.size !== attribute.array.byteLength ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );\n\n\t\t\t}\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\n\nexport { WebGLAttributes };\n"],"mappings":"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","ignoreList":[]}