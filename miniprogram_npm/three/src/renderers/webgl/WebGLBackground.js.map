{"version":3,"file":"node_modules/three/src/renderers/webgl/WebGLBackground.js","names":["BackSide","FrontSide","CubeUVReflectionMapping","SRGBTransfer","BoxGeometry","PlaneGeometry","ShaderMaterial","Color","ColorManagement","Euler","Matrix4","Mesh","ShaderLib","cloneUniforms","getUnlitUniformColorSpace","_rgb","r","b","g","_e1","_m1","WebGLBackground","renderer","cubemaps","cubeuvmaps","state","objects","alpha","premultipliedAlpha","clearColor","planeMesh","boxMesh","clearAlpha","currentBackground","currentBackgroundVersion","currentTonemapping","getBackground","scene","background","isScene","isTexture","backgroundBlurriness","get","setClear","color","getRGB","buffers","getClearColor","setClearColor","set","getClearAlpha","setClearAlpha","render","forceClear","isColor","environmentBlendMode","xr","getEnvironmentBlendMode","autoClear","depth","setTest","setMask","clear","autoClearColor","autoClearDepth","autoClearStencil","addToRenderList","renderList","isCubeTexture","mapping","undefined","name","uniforms","backgroundCube","vertexShader","fragmentShader","side","depthTest","depthWrite","fog","allowOverride","geometry","deleteAttribute","onBeforeRender","camera","this","matrixWorld","copyPosition","Object","defineProperty","material","envMap","value","update","copy","backgroundRotation","x","y","z","isRenderTargetTexture","flipEnvMap","backgroundIntensity","setFromMatrix4","makeRotationFromEuler","toneMapped","getTransfer","colorSpace","version","toneMapping","needsUpdate","layers","enableAll","unshift","t2D","matrixAutoUpdate","updateMatrix","uvTransform","matrix","dispose"],"sources":["node_modules/three/src/renderers/webgl/WebGLBackground.js"],"sourcesContent":["import { BackSide, FrontSide, CubeUVReflectionMapping, SRGBTransfer } from '../../constants.js';\nimport { BoxGeometry } from '../../geometries/BoxGeometry.js';\nimport { PlaneGeometry } from '../../geometries/PlaneGeometry.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { Color } from '../../math/Color.js';\nimport { ColorManagement } from '../../math/ColorManagement.js';\nimport { Euler } from '../../math/Euler.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { ShaderLib } from '../shaders/ShaderLib.js';\nimport { cloneUniforms, getUnlitUniformColorSpace } from '../shaders/UniformsUtils.js';\n\nconst _rgb = { r: 0, b: 0, g: 0 };\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction getBackground( scene ) {\n\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\treturn background;\n\n\t}\n\n\tfunction render( scene ) {\n\n\t\tlet forceClear = false;\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\t// buffers might not be writable which is required to ensure a correct clear\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t}\n\n\tfunction addToRenderList( renderList, scene ) {\n\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false,\n\t\t\t\t\t\tallowOverride: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\tif ( background.isCubeTexture && background.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1.y *= - 1;\n\t\t\t\t_e1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tboxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );\n\t\t\tboxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false,\n\t\t\t\t\t\tallowOverride: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tplaneMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\tfunction dispose() {\n\n\t\tif ( boxMesh !== undefined ) {\n\n\t\t\tboxMesh.geometry.dispose();\n\t\t\tboxMesh.material.dispose();\n\n\t\t\tboxMesh = undefined;\n\n\t\t}\n\n\t\tif ( planeMesh !== undefined ) {\n\n\t\t\tplaneMesh.geometry.dispose();\n\t\t\tplaneMesh.material.dispose();\n\n\t\t\tplaneMesh = undefined;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render,\n\t\taddToRenderList: addToRenderList,\n\t\tdispose: dispose\n\n\t};\n\n}\n\n\nexport { WebGLBackground };\n"],"mappings":"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","ignoreList":[]}