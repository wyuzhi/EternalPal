import{IntType}from"../../constants.js";function WebGLBindingStates(t,e){const n=t.getParameter(t.MAX_VERTEX_ATTRIBS),i={},o=l(null);let r=o,a=!1;function s(e){return t.bindVertexArray(e)}function c(e){return t.deleteVertexArray(e)}function l(t){const e=[],i=[],o=[];for(let t=0;t<n;t++)e[t]=0,i[t]=0,o[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:i,attributeDivisors:o,object:t,attributes:{},index:null}}function u(){const t=r.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){d(t,0)}function d(e,n){const i=r.newAttributes,o=r.enabledAttributes,a=r.attributeDivisors;i[e]=1,0===o[e]&&(t.enableVertexAttribArray(e),o[e]=1),a[e]!==n&&(t.vertexAttribDivisor(e,n),a[e]=n)}function b(){const e=r.newAttributes,n=r.enabledAttributes;for(let i=0,o=n.length;i<o;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function A(e,n,i,o,r,a,s){!0===s?t.vertexAttribIPointer(e,n,i,r,a):t.vertexAttribPointer(e,n,i,o,r,a)}function v(){x(),a=!0,r!==o&&(r=o,s(r.object))}function x(){o.geometry=null,o.program=null,o.wireframe=!1}return{setup:function(n,o,c,v,x){let m=!1;const S=function(e,n,o){const r=!0===o.wireframe;let a=i[e.id];void 0===a&&(a={},i[e.id]=a);let s=a[n.id];void 0===s&&(s={},a[n.id]=s);let c=s[r];void 0===c&&(c=l(t.createVertexArray()),s[r]=c);return c}(v,c,o);r!==S&&(r=S,s(r.object)),m=function(t,e,n,i){const o=r.attributes,a=e.attributes;let s=0;const c=n.getAttributes();for(const e in c){if(c[e].location>=0){const n=o[e];let i=a[e];if(void 0===i&&("instanceMatrix"===e&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(i=t.instanceColor)),void 0===n)return!0;if(n.attribute!==i)return!0;if(i&&n.data!==i.data)return!0;s++}}return r.attributesNum!==s||r.index!==i}(n,v,c,x),m&&function(t,e,n,i){const o={},a=e.attributes;let s=0;const c=n.getAttributes();for(const e in c){if(c[e].location>=0){let n=a[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const i={};i.attribute=n,n&&n.data&&(i.data=n.data),o[e]=i,s++}}r.attributes=o,r.attributesNum=s,r.index=i}(n,v,c,x),null!==x&&e.update(x,t.ELEMENT_ARRAY_BUFFER),(m||a)&&(a=!1,function(n,i,o,r){u();const a=r.attributes,s=o.getAttributes(),c=i.defaultAttributeValues;for(const i in s){const o=s[i];if(o.location>=0){let s=a[i];if(void 0===s&&("instanceMatrix"===i&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===i&&n.instanceColor&&(s=n.instanceColor)),void 0!==s){const i=s.normalized,a=s.itemSize,c=e.get(s);if(void 0===c)continue;const l=c.buffer,u=c.type,b=c.bytesPerElement,v=u===t.INT||u===t.UNSIGNED_INT||s.gpuType===IntType;if(s.isInterleavedBufferAttribute){const e=s.data,c=e.stride,x=s.offset;if(e.isInstancedInterleavedBuffer){for(let t=0;t<o.locationSize;t++)d(o.location+t,e.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let t=0;t<o.locationSize;t++)f(o.location+t);t.bindBuffer(t.ARRAY_BUFFER,l);for(let t=0;t<o.locationSize;t++)A(o.location+t,a/o.locationSize,u,i,c*b,(x+a/o.locationSize*t)*b,v)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<o.locationSize;t++)d(o.location+t,s.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<o.locationSize;t++)f(o.location+t);t.bindBuffer(t.ARRAY_BUFFER,l);for(let t=0;t<o.locationSize;t++)A(o.location+t,a/o.locationSize,u,i,a*b,a/o.locationSize*t*b,v)}}else if(void 0!==c){const e=c[i];if(void 0!==e)switch(e.length){case 2:t.vertexAttrib2fv(o.location,e);break;case 3:t.vertexAttrib3fv(o.location,e);break;case 4:t.vertexAttrib4fv(o.location,e);break;default:t.vertexAttrib1fv(o.location,e)}}}}b()}(n,o,c,v),null!==x&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(x).buffer))},reset:v,resetDefaultState:x,dispose:function(){v();for(const t in i){const e=i[t];for(const t in e){const n=e[t];for(const t in n)c(n[t].object),delete n[t];delete e[t]}delete i[t]}},releaseStatesOfGeometry:function(t){if(void 0===i[t.id])return;const e=i[t.id];for(const t in e){const n=e[t];for(const t in n)c(n[t].object),delete n[t];delete e[t]}delete i[t.id]},releaseStatesOfProgram:function(t){for(const e in i){const n=i[e];if(void 0===n[t.id])continue;const o=n[t.id];for(const t in o)c(o[t].object),delete o[t];delete n[t.id]}},initAttributes:u,enableAttribute:f,disableUnusedAttributes:b}}export{WebGLBindingStates};
//# sourceMappingURL=WebGLBindingStates.js.map