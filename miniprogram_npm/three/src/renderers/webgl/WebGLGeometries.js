import{Uint16BufferAttribute,Uint32BufferAttribute}from"../../core/BufferAttribute.js";import{arrayNeedsUint32}from"../../utils.js";function WebGLGeometries(e,t,r,n){const i={},o=new WeakMap;function s(e){const u=e.target;null!==u.index&&t.remove(u.index);for(const e in u.attributes)t.remove(u.attributes[e]);u.removeEventListener("dispose",s),delete i[u.id];const f=o.get(u);f&&(t.remove(f),o.delete(u)),n.releaseStatesOfGeometry(u),!0===u.isInstancedBufferGeometry&&delete u._maxInstanceCount,r.memory.geometries--}function u(e){const r=[],n=e.index,i=e.attributes.position;let s=0;if(null!==n){const e=n.array;s=n.version;for(let t=0,n=e.length;t<n;t+=3){const n=e[t+0],i=e[t+1],o=e[t+2];r.push(n,i,i,o,o,n)}}else{if(void 0===i)return;{const e=i.array;s=i.version;for(let t=0,n=e.length/3-1;t<n;t+=3){const e=t+0,n=t+1,i=t+2;r.push(e,n,n,i,i,e)}}}const u=new(arrayNeedsUint32(r)?Uint32BufferAttribute:Uint16BufferAttribute)(r,1);u.version=s;const f=o.get(e);f&&t.remove(f),o.set(e,u)}return{get:function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",s),i[t.id]=!0,r.memory.geometries++),t},update:function(r){const n=r.attributes;for(const r in n)t.update(n[r],e.ARRAY_BUFFER)},getWireframeAttribute:function(e){const t=o.get(e);if(t){const r=e.index;null!==r&&t.version<r.version&&u(e)}else u(e);return o.get(e)}}}export{WebGLGeometries};
//# sourceMappingURL=WebGLGeometries.js.map