import{Color}from"../../math/Color.js";import{Matrix4}from"../../math/Matrix4.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{UniformsLib}from"../shaders/UniformsLib.js";function UniformsCache(){const t={};return{get:function(o){if(void 0!==t[o.id])return t[o.id];let i;switch(o.type){case"DirectionalLight":i={direction:new Vector3,color:new Color};break;case"SpotLight":i={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":i={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":i={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3}}return t[o.id]=i,i}}}function ShadowUniformsCache(){const t={};return{get:function(o){if(void 0!==t[o.id])return t[o.id];let i;switch(o.type){case"DirectionalLight":case"SpotLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3}}return t[o.id]=i,i}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(t,o){return(o.castShadow?2:0)-(t.castShadow?2:0)+(o.map?1:0)-(t.map?1:0)}function WebGLLights(t){const o=new UniformsCache,i=ShadowUniformsCache(),e={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)e.probe.push(new Vector3);const a=new Vector3,r=new Matrix4,n=new Matrix4;return{setup:function(a){let r=0,n=0,s=0;for(let t=0;t<9;t++)e.probe[t].set(0,0,0);let h=0,c=0,d=0,l=0,p=0,m=0,w=0,g=0,L=0,S=0,u=0;a.sort(shadowCastingAndTexturingLightsFirst);for(let t=0,f=a.length;t<f;t++){const f=a[t],M=f.color,x=f.intensity,y=f.distance,b=f.shadow&&f.shadow.map?f.shadow.map.texture:null;if(f.isAmbientLight)r+=M.r*x,n+=M.g*x,s+=M.b*x;else if(f.isLightProbe){for(let t=0;t<9;t++)e.probe[t].addScaledVector(f.sh.coefficients[t],x);u++}else if(f.isDirectionalLight){const t=o.get(f);if(t.color.copy(f.color).multiplyScalar(f.intensity),f.castShadow){const t=f.shadow,o=i.get(f);o.shadowIntensity=t.intensity,o.shadowBias=t.bias,o.shadowNormalBias=t.normalBias,o.shadowRadius=t.radius,o.shadowMapSize=t.mapSize,e.directionalShadow[h]=o,e.directionalShadowMap[h]=b,e.directionalShadowMatrix[h]=f.shadow.matrix,m++}e.directional[h]=t,h++}else if(f.isSpotLight){const t=o.get(f);t.position.setFromMatrixPosition(f.matrixWorld),t.color.copy(M).multiplyScalar(x),t.distance=y,t.coneCos=Math.cos(f.angle),t.penumbraCos=Math.cos(f.angle*(1-f.penumbra)),t.decay=f.decay,e.spot[d]=t;const a=f.shadow;if(f.map&&(e.spotLightMap[L]=f.map,L++,a.updateMatrices(f),f.castShadow&&S++),e.spotLightMatrix[d]=a.matrix,f.castShadow){const t=i.get(f);t.shadowIntensity=a.intensity,t.shadowBias=a.bias,t.shadowNormalBias=a.normalBias,t.shadowRadius=a.radius,t.shadowMapSize=a.mapSize,e.spotShadow[d]=t,e.spotShadowMap[d]=b,g++}d++}else if(f.isRectAreaLight){const t=o.get(f);t.color.copy(M).multiplyScalar(x),t.halfWidth.set(.5*f.width,0,0),t.halfHeight.set(0,.5*f.height,0),e.rectArea[l]=t,l++}else if(f.isPointLight){const t=o.get(f);if(t.color.copy(f.color).multiplyScalar(f.intensity),t.distance=f.distance,t.decay=f.decay,f.castShadow){const t=f.shadow,o=i.get(f);o.shadowIntensity=t.intensity,o.shadowBias=t.bias,o.shadowNormalBias=t.normalBias,o.shadowRadius=t.radius,o.shadowMapSize=t.mapSize,o.shadowCameraNear=t.camera.near,o.shadowCameraFar=t.camera.far,e.pointShadow[c]=o,e.pointShadowMap[c]=b,e.pointShadowMatrix[c]=f.shadow.matrix,w++}e.point[c]=t,c++}else if(f.isHemisphereLight){const t=o.get(f);t.skyColor.copy(f.color).multiplyScalar(x),t.groundColor.copy(f.groundColor).multiplyScalar(x),e.hemi[p]=t,p++}}l>0&&(!0===t.has("OES_texture_float_linear")?(e.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,e.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(e.rectAreaLTC1=UniformsLib.LTC_HALF_1,e.rectAreaLTC2=UniformsLib.LTC_HALF_2)),e.ambient[0]=r,e.ambient[1]=n,e.ambient[2]=s;const f=e.hash;f.directionalLength===h&&f.pointLength===c&&f.spotLength===d&&f.rectAreaLength===l&&f.hemiLength===p&&f.numDirectionalShadows===m&&f.numPointShadows===w&&f.numSpotShadows===g&&f.numSpotMaps===L&&f.numLightProbes===u||(e.directional.length=h,e.spot.length=d,e.rectArea.length=l,e.point.length=c,e.hemi.length=p,e.directionalShadow.length=m,e.directionalShadowMap.length=m,e.pointShadow.length=w,e.pointShadowMap.length=w,e.spotShadow.length=g,e.spotShadowMap.length=g,e.directionalShadowMatrix.length=m,e.pointShadowMatrix.length=w,e.spotLightMatrix.length=g+L-S,e.spotLightMap.length=L,e.numSpotLightShadowsWithMaps=S,e.numLightProbes=u,f.directionalLength=h,f.pointLength=c,f.spotLength=d,f.rectAreaLength=l,f.hemiLength=p,f.numDirectionalShadows=m,f.numPointShadows=w,f.numSpotShadows=g,f.numSpotMaps=L,f.numLightProbes=u,e.version=nextVersion++)},setupView:function(t,o){let i=0,s=0,h=0,c=0,d=0;const l=o.matrixWorldInverse;for(let o=0,p=t.length;o<p;o++){const p=t[o];if(p.isDirectionalLight){const t=e.directional[i];t.direction.setFromMatrixPosition(p.matrixWorld),a.setFromMatrixPosition(p.target.matrixWorld),t.direction.sub(a),t.direction.transformDirection(l),i++}else if(p.isSpotLight){const t=e.spot[h];t.position.setFromMatrixPosition(p.matrixWorld),t.position.applyMatrix4(l),t.direction.setFromMatrixPosition(p.matrixWorld),a.setFromMatrixPosition(p.target.matrixWorld),t.direction.sub(a),t.direction.transformDirection(l),h++}else if(p.isRectAreaLight){const t=e.rectArea[c];t.position.setFromMatrixPosition(p.matrixWorld),t.position.applyMatrix4(l),n.identity(),r.copy(p.matrixWorld),r.premultiply(l),n.extractRotation(r),t.halfWidth.set(.5*p.width,0,0),t.halfHeight.set(0,.5*p.height,0),t.halfWidth.applyMatrix4(n),t.halfHeight.applyMatrix4(n),c++}else if(p.isPointLight){const t=e.point[s];t.position.setFromMatrixPosition(p.matrixWorld),t.position.applyMatrix4(l),s++}else if(p.isHemisphereLight){const t=e.hemi[d];t.direction.setFromMatrixPosition(p.matrixWorld),t.direction.transformDirection(l),d++}}},state:e}}export{WebGLLights};
//# sourceMappingURL=WebGLLights.js.map