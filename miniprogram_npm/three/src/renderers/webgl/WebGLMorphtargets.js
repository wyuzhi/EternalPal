import{FloatType}from"../../constants.js";import{DataArrayTexture}from"../../textures/DataArrayTexture.js";import{Vector4}from"../../math/Vector4.js";import{Vector2}from"../../math/Vector2.js";function WebGLMorphtargets(t,e,r){const o=new WeakMap,s=new Vector4;return{update:function(i,n,u){const a=i.morphTargetInfluences,m=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,p=void 0!==m?m.length:0;let l=o.get(n);if(void 0===l||l.count!==p){void 0!==l&&l.texture.dispose();const t=void 0!==n.morphAttributes.position,r=void 0!==n.morphAttributes.normal,i=void 0!==n.morphAttributes.color,u=n.morphAttributes.position||[],a=n.morphAttributes.normal||[],m=n.morphAttributes.color||[];let c=0;!0===t&&(c=1),!0===r&&(c=2),!0===i&&(c=3);let f=n.attributes.position.count*c,h=1;f>e.maxTextureSize&&(h=Math.ceil(f/e.maxTextureSize),f=e.maxTextureSize);const x=new Float32Array(f*h*4*p),T=new DataArrayTexture(x,f,h,p);T.type=FloatType,T.needsUpdate=!0;const d=4*c;for(let e=0;e<p;e++){const o=u[e],n=a[e],p=m[e],l=f*h*4*e;for(let e=0;e<o.count;e++){const u=e*d;!0===t&&(s.fromBufferAttribute(o,e),x[l+u+0]=s.x,x[l+u+1]=s.y,x[l+u+2]=s.z,x[l+u+3]=0),!0===r&&(s.fromBufferAttribute(n,e),x[l+u+4]=s.x,x[l+u+5]=s.y,x[l+u+6]=s.z,x[l+u+7]=0),!0===i&&(s.fromBufferAttribute(p,e),x[l+u+8]=s.x,x[l+u+9]=s.y,x[l+u+10]=s.z,x[l+u+11]=4===p.itemSize?s.w:1)}}l={count:p,texture:T,size:new Vector2(f,h)},o.set(n,l),n.addEventListener("dispose",(function t(){T.dispose(),o.delete(n),n.removeEventListener("dispose",t)}))}if(!0===i.isInstancedMesh&&null!==i.morphTexture)u.getUniforms().setValue(t,"morphTexture",i.morphTexture,r);else{let e=0;for(let t=0;t<a.length;t++)e+=a[t];const r=n.morphTargetsRelative?1:1-e;u.getUniforms().setValue(t,"morphTargetBaseInfluence",r),u.getUniforms().setValue(t,"morphTargetInfluences",a)}u.getUniforms().setValue(t,"morphTargetsTexture",l.texture,r),u.getUniforms().setValue(t,"morphTargetsTextureSize",l.size)}}}export{WebGLMorphtargets};
//# sourceMappingURL=WebGLMorphtargets.js.map