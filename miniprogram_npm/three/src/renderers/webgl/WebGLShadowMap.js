import{FrontSide,BackSide,DoubleSide,NearestFilter,PCFShadowMap,VSMShadowMap,RGBADepthPacking,NoBlending}from"../../constants.js";import{WebGLRenderTarget}from"../WebGLRenderTarget.js";import{MeshDepthMaterial}from"../../materials/MeshDepthMaterial.js";import{MeshDistanceMaterial}from"../../materials/MeshDistanceMaterial.js";import{ShaderMaterial}from"../../materials/ShaderMaterial.js";import{BufferAttribute}from"../../core/BufferAttribute.js";import{BufferGeometry}from"../../core/BufferGeometry.js";import{Mesh}from"../../objects/Mesh.js";import{Vector4}from"../../math/Vector4.js";import{Vector2}from"../../math/Vector2.js";import{Frustum}from"../../math/Frustum.js";import*as vsm from"../shaders/ShaderLib/vsm.glsl.js";function WebGLShadowMap(e,t,a){let i=new Frustum;const r=new Vector2,s=new Vector2,n=new Vector4,o=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),l=new MeshDistanceMaterial,d={},p=a.maxTextureSize,u={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},m=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vsm.vertex,fragmentShader:vsm.fragment}),c=m.clone();c.defines.HORIZONTAL_PASS=1;const h=new BufferGeometry;h.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const f=new Mesh(h,m),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let M=this.type;function w(a,i){const s=t.update(f);m.defines.VSM_SAMPLES!==a.blurSamples&&(m.defines.VSM_SAMPLES=a.blurSamples,c.defines.VSM_SAMPLES=a.blurSamples,m.needsUpdate=!0,c.needsUpdate=!0),null===a.mapPass&&(a.mapPass=new WebGLRenderTarget(r.x,r.y)),m.uniforms.shadow_pass.value=a.map.texture,m.uniforms.resolution.value=a.mapSize,m.uniforms.radius.value=a.radius,e.setRenderTarget(a.mapPass),e.clear(),e.renderBufferDirect(i,null,s,m,f,null),c.uniforms.shadow_pass.value=a.mapPass.texture,c.uniforms.resolution.value=a.mapSize,c.uniforms.radius.value=a.radius,e.setRenderTarget(a.map),e.clear(),e.renderBufferDirect(i,null,s,c,f,null)}function g(t,a,i,r){let s=null;const n=!0===i.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(void 0!==n)s=n;else if(s=!0===i.isPointLight?l:o,e.localClippingEnabled&&!0===a.clipShadows&&Array.isArray(a.clippingPlanes)&&0!==a.clippingPlanes.length||a.displacementMap&&0!==a.displacementScale||a.alphaMap&&a.alphaTest>0||a.map&&a.alphaTest>0||!0===a.alphaToCoverage){const e=s.uuid,t=a.uuid;let i=d[e];void 0===i&&(i={},d[e]=i);let r=i[t];void 0===r&&(r=s.clone(),i[t]=r,a.addEventListener("dispose",y)),s=r}if(s.visible=a.visible,s.wireframe=a.wireframe,s.side=r===VSMShadowMap?null!==a.shadowSide?a.shadowSide:a.side:null!==a.shadowSide?a.shadowSide:u[a.side],s.alphaMap=a.alphaMap,s.alphaTest=!0===a.alphaToCoverage?.5:a.alphaTest,s.map=a.map,s.clipShadows=a.clipShadows,s.clippingPlanes=a.clippingPlanes,s.clipIntersection=a.clipIntersection,s.displacementMap=a.displacementMap,s.displacementScale=a.displacementScale,s.displacementBias=a.displacementBias,s.wireframeLinewidth=a.wireframeLinewidth,s.linewidth=a.linewidth,!0===i.isPointLight&&!0===s.isMeshDistanceMaterial){e.properties.get(s).light=i}return s}function v(a,r,s,n,o){if(!1===a.visible)return;if(a.layers.test(r.layers)&&(a.isMesh||a.isLine||a.isPoints)&&(a.castShadow||a.receiveShadow&&o===VSMShadowMap)&&(!a.frustumCulled||i.intersectsObject(a))){a.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,a.matrixWorld);const i=t.update(a),l=a.material;if(Array.isArray(l)){const t=i.groups;for(let d=0,p=t.length;d<p;d++){const p=t[d],u=l[p.materialIndex];if(u&&u.visible){const t=g(a,u,n,o);a.onBeforeShadow(e,a,r,s,i,t,p),e.renderBufferDirect(s,null,i,t,a,p),a.onAfterShadow(e,a,r,s,i,t,p)}}}else if(l.visible){const t=g(a,l,n,o);a.onBeforeShadow(e,a,r,s,i,t,null),e.renderBufferDirect(s,null,i,t,a,null),a.onAfterShadow(e,a,r,s,i,t,null)}}const l=a.children;for(let e=0,t=l.length;e<t;e++)v(l[e],r,s,n,o)}function y(e){e.target.removeEventListener("dispose",y);for(const t in d){const a=d[t],i=e.target.uuid;if(i in a){a[i].dispose(),delete a[i]}}}this.render=function(t,a,o){if(!1===S.enabled)return;if(!1===S.autoUpdate&&!1===S.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),d=e.getActiveCubeFace(),u=e.getActiveMipmapLevel(),m=e.state;m.setBlending(NoBlending),m.buffers.depth.getReversed()?m.buffers.color.setClear(0,0,0,0):m.buffers.color.setClear(1,1,1,1),m.buffers.depth.setTest(!0),m.setScissorTest(!1);const c=M!==VSMShadowMap&&this.type===VSMShadowMap,h=M===VSMShadowMap&&this.type!==VSMShadowMap;for(let l=0,d=t.length;l<d;l++){const d=t[l],u=d.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",d,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const f=u.getFrameExtents();if(r.multiply(f),s.copy(u.mapSize),(r.x>p||r.y>p)&&(r.x>p&&(s.x=Math.floor(p/f.x),r.x=s.x*f.x,u.mapSize.x=s.x),r.y>p&&(s.y=Math.floor(p/f.y),r.y=s.y*f.y,u.mapSize.y=s.y)),null===u.map||!0===c||!0===h){const e=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};null!==u.map&&u.map.dispose(),u.map=new WebGLRenderTarget(r.x,r.y,e),u.map.texture.name=d.name+".shadowMap",u.camera.updateProjectionMatrix()}e.setRenderTarget(u.map),e.clear();const S=u.getViewportCount();for(let e=0;e<S;e++){const t=u.getViewport(e);n.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),m.viewport(n),u.updateMatrices(d,e),i=u.getFrustum(),v(a,o,u.camera,d,this.type)}!0!==u.isPointLightShadow&&this.type===VSMShadowMap&&w(u,o),u.needsUpdate=!1}M=this.type,S.needsUpdate=!1,e.setRenderTarget(l,d,u)}}export{WebGLShadowMap};
//# sourceMappingURL=WebGLShadowMap.js.map