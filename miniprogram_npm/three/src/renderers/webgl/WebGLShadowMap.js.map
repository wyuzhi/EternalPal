{"version":3,"file":"node_modules/three/src/renderers/webgl/WebGLShadowMap.js","names":["FrontSide","BackSide","DoubleSide","NearestFilter","PCFShadowMap","VSMShadowMap","RGBADepthPacking","NoBlending","WebGLRenderTarget","MeshDepthMaterial","MeshDistanceMaterial","ShaderMaterial","BufferAttribute","BufferGeometry","Mesh","Vector4","Vector2","Frustum","vsm","WebGLShadowMap","renderer","objects","capabilities","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterial","depthPacking","_distanceMaterial","_materialCache","_maxTextureSize","maxTextureSize","shadowSide","shadowMaterialVertical","defines","VSM_SAMPLES","uniforms","shadow_pass","value","resolution","radius","vertexShader","vertex","fragmentShader","fragment","shadowMaterialHorizontal","clone","HORIZONTAL_PASS","fullScreenTri","setAttribute","Float32Array","fullScreenMesh","scope","this","enabled","autoUpdate","needsUpdate","type","_previousType","VSMPass","shadow","camera","geometry","update","blurSamples","mapPass","x","y","map","texture","mapSize","setRenderTarget","clear","renderBufferDirect","getDepthMaterial","object","material","light","result","customMaterial","isPointLight","customDistanceMaterial","customDepthMaterial","undefined","localClippingEnabled","clipShadows","Array","isArray","clippingPlanes","length","displacementMap","displacementScale","alphaMap","alphaTest","alphaToCoverage","keyA","uuid","keyB","materialsForVariant","cachedMaterial","addEventListener","onMaterialDispose","visible","wireframe","side","clipIntersection","displacementBias","wireframeLinewidth","linewidth","isMeshDistanceMaterial","properties","get","renderObject","shadowCamera","layers","test","isMesh","isLine","isPoints","castShadow","receiveShadow","frustumCulled","intersectsObject","modelViewMatrix","multiplyMatrices","matrixWorldInverse","matrixWorld","groups","k","kl","group","groupMaterial","materialIndex","depthMaterial","onBeforeShadow","onAfterShadow","children","i","l","event","target","removeEventListener","id","cache","dispose","render","lights","scene","currentRenderTarget","getRenderTarget","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","state","setBlending","buffers","depth","getReversed","color","setClear","setTest","setScissorTest","toVSM","fromVSM","il","console","warn","copy","shadowFrameExtents","getFrameExtents","multiply","Math","floor","pars","minFilter","magFilter","name","updateProjectionMatrix","viewportCount","getViewportCount","vp","viewport","getViewport","set","z","w","updateMatrices","getFrustum","isPointLightShadow"],"sources":["node_modules/three/src/renderers/webgl/WebGLShadowMap.js"],"sourcesContent":["import { FrontSide, BackSide, DoubleSide, NearestFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\n\nimport * as vsm from '../shaders/ShaderLib/vsm.glsl.js';\n\nfunction WebGLShadowMap( renderer, objects, capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = capabilities.maxTextureSize;\n\n\tconst shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vsm.vertex,\n\t\tfragmentShader: vsm.fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\tlet _previousType = this.type;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst activeCubeFace = renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst _state = renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\n\t\tif ( _state.buffers.depth.getReversed() ) {\n\n\t\t\t_state.buffers.color.setClear( 0, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\n\t\t}\n\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// check for shadow map type changes\n\n\t\tconst toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );\n\t\tconst fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null || toVSM === true || fromVSM === true ) {\n\n\t\t\t\tconst pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n\n\t\t\t\tif ( shadow.map !== null ) {\n\n\t\t\t\t\tshadow.map.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( shadow.map );\n\t\t\trenderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\t_previousType = this.type;\n\n\t\tscope.needsUpdate = false;\n\n\t\trenderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.mapPass );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.map );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t\tif ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t\t( material.map && material.alphaTest > 0 ) ||\n\t\t\t\t( material.alphaToCoverage === true ) ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = ( material.alphaToCoverage === true ) ? 0.5 : material.alphaTest; // approximate alphaToCoverage by using a fixed alphaTest value\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tconst materialProperties = renderer.properties.get( result );\n\t\t\tmaterialProperties.light = light;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, type );\n\n\t\t\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, type );\n\n\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t// make sure to remove the unique distance/depth materials used for shadow map rendering\n\n\t\tfor ( const id in _materialCache ) {\n\n\t\t\tconst cache = _materialCache[ id ];\n\n\t\t\tconst uuid = event.target.uuid;\n\n\t\t\tif ( uuid in cache ) {\n\n\t\t\t\tconst shadowMaterial = cache[ uuid ];\n\t\t\t\tshadowMaterial.dispose();\n\t\t\t\tdelete cache[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { WebGLShadowMap };\n"],"mappings":"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","ignoreList":[]}