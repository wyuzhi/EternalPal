{"version":3,"file":"node_modules/three/src/renderers/webgl/WebGLUniformsGroups.js","names":["WebGLUniformsGroups","gl","info","capabilities","state","buffers","updateList","allocatedBindingPoints","maxBindingPoints","getParameter","MAX_UNIFORM_BUFFER_BINDINGS","hasUniformChanged","uniform","index","indexArray","cache","value","indexString","undefined","clone","cachedObject","equals","copy","getUniformSize","boundary","storage","isVector2","isVector3","isColor","isVector4","isMatrix3","isMatrix4","isTexture","console","warn","onUniformsGroupsDispose","event","uniformsGroup","target","removeEventListener","indexOf","__bindingPointIndex","splice","deleteBuffer","id","bind","program","webglProgram","uniformBlockBinding","update","buffer","uniforms","offset","chunkSize","i","l","length","uniformArray","Array","isArray","j","jl","values","k","kl","chunkOffset","chunkPadding","chunkStart","__data","Float32Array","BYTES_PER_ELEMENT","__offset","__size","__cache","prepareUniformsGroup","bindingPointIndex","push","error","allocateBindingPointIndex","createBuffer","size","usage","bindBuffer","UNIFORM_BUFFER","bufferData","bindBufferBase","addEventListener","updateUBOMapping","frame","render","il","arrayOffset","bufferSubData","elements","toArray","updateBufferData","dispose"],"sources":["node_modules/three/src/renderers/webgl/WebGLUniformsGroups.js"],"sourcesContent":["function WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tif ( hasUniformChanged( uniform, i, j, cache ) === true ) {\n\n\t\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\t\tlet arrayOffset = 0;\n\n\t\t\t\t\tfor ( let k = 0; k < values.length; k ++ ) {\n\n\t\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t\t// TODO add integer and struct support\n\t\t\t\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );\n\n\t\t\t\t\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value.elements[ 0 ];\n\t\t\t\t\t\t\tuniform.__data[ 1 ] = value.elements[ 1 ];\n\t\t\t\t\t\t\tuniform.__data[ 2 ] = value.elements[ 2 ];\n\t\t\t\t\t\t\tuniform.__data[ 3 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 4 ] = value.elements[ 3 ];\n\t\t\t\t\t\t\tuniform.__data[ 5 ] = value.elements[ 4 ];\n\t\t\t\t\t\t\tuniform.__data[ 6 ] = value.elements[ 5 ];\n\t\t\t\t\t\t\tuniform.__data[ 7 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 8 ] = value.elements[ 6 ];\n\t\t\t\t\t\t\tuniform.__data[ 9 ] = value.elements[ 7 ];\n\t\t\t\t\t\t\tuniform.__data[ 10 ] = value.elements[ 8 ];\n\t\t\t\t\t\t\tuniform.__data[ 11 ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue.toArray( uniform.__data, arrayOffset );\n\n\t\t\t\t\t\t\tarrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, indexArray, cache ) {\n\n\t\tconst value = uniform.value;\n\t\tconst indexString = index + '_' + indexArray;\n\n\t\tif ( cache[ indexString ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tcache[ indexString ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tcache[ indexString ] = value.clone();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\tconst cachedObject = cache[ indexString ];\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tif ( cachedObject !== value ) {\n\n\t\t\t\t\tcache[ indexString ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( cachedObject.equals( value ) === false ) {\n\n\t\t\t\t\tcachedObject.copy( value );\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\tfor ( let k = 0, kl = values.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\tconst chunkOffset = offset % chunkSize; // offset in the current chunk\n\t\t\t\t\tconst chunkPadding = chunkOffset % info.boundary; // required padding to match boundary\n\t\t\t\t\tconst chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data\n\n\t\t\t\t\toffset += chunkPadding;\n\n\t\t\t\t\t// Check for chunk overflow\n\t\t\t\t\tif ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {\n\n\t\t\t\t\t\t// Add padding and adjust offset\n\t\t\t\t\t\toffset += ( chunkSize - chunkStart );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following two properties will be used for partial buffer updates\n\t\t\t\t\tuniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\t\t\tuniform.__offset = offset;\n\n\t\t\t\t\t// Update the global offset\n\t\t\t\t\toffset += info.storage;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tconst chunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( value ) {\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t// float/int/bool\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\n\nexport { WebGLUniformsGroups };\n"],"mappings":"AAAA,SAASA,oBAAqBC,EAAIC,EAAMC,EAAcC,GAErD,IAAIC,EAAU,CAAC,EACXC,EAAa,CAAC,EACdC,EAAyB,GAE7B,MAAMC,EAAmBP,EAAGQ,aAAcR,EAAGS,6BA6J7C,SAASC,EAAmBC,EAASC,EAAOC,EAAYC,GAEvD,MAAMC,EAAQJ,EAAQI,MAChBC,EAAcJ,EAAQ,IAAMC,EAElC,QAA8BI,IAAzBH,EAAOE,GAcX,OARCF,EAAOE,GAFc,iBAAVD,GAAuC,kBAAVA,EAEjBA,EAIAA,EAAMG,SAIvB,EAED,CAEN,MAAMC,EAAeL,EAAOE,GAI5B,GAAsB,iBAAVD,GAAuC,kBAAVA,GAExC,GAAKI,IAAiBJ,EAGrB,OADAD,EAAOE,GAAgBD,GAChB,OAMR,IAAsC,IAAjCI,EAAaC,OAAQL,GAGzB,OADAI,EAAaE,KAAMN,IACZ,CAMV,CAEA,OAAO,CAER,CAsEA,SAASO,EAAgBP,GAExB,MAAMd,EAAO,CACZsB,SAAU,EACVC,QAAS,GAyDV,MApDsB,iBAAVT,GAAuC,kBAAVA,GAIxCd,EAAKsB,SAAW,EAChBtB,EAAKuB,QAAU,GAEJT,EAAMU,WAIjBxB,EAAKsB,SAAW,EAChBtB,EAAKuB,QAAU,GAEJT,EAAMW,WAAaX,EAAMY,SAIpC1B,EAAKsB,SAAW,GAChBtB,EAAKuB,QAAU,IAEJT,EAAMa,WAIjB3B,EAAKsB,SAAW,GAChBtB,EAAKuB,QAAU,IAEJT,EAAMc,WAIjB5B,EAAKsB,SAAW,GAChBtB,EAAKuB,QAAU,IAEJT,EAAMe,WAIjB7B,EAAKsB,SAAW,GAChBtB,EAAKuB,QAAU,IAEJT,EAAMgB,UAEjBC,QAAQC,KAAM,+EAIdD,QAAQC,KAAM,uDAAwDlB,GAIhEd,CAER,CAEA,SAASiC,EAAyBC,GAEjC,MAAMC,EAAgBD,EAAME,OAE5BD,EAAcE,oBAAqB,UAAWJ,GAE9C,MAAMtB,EAAQN,EAAuBiC,QAASH,EAAcI,qBAC5DlC,EAAuBmC,OAAQ7B,EAAO,GAEtCZ,EAAG0C,aAActC,EAASgC,EAAcO,YAEjCvC,EAASgC,EAAcO,WACvBtC,EAAY+B,EAAcO,GAElC,CAgBA,MAAO,CAENC,KArXD,SAAeR,EAAeS,GAE7B,MAAMC,EAAeD,EAAQA,QAC7B1C,EAAM4C,oBAAqBX,EAAeU,EAE3C,EAiXCE,OA/WD,SAAiBZ,EAAeS,GAE/B,IAAII,EAAS7C,EAASgC,EAAcO,SAEpB1B,IAAXgC,KAqMN,SAA+Bb,GAK9B,MAAMc,EAAWd,EAAcc,SAE/B,IAAIC,EAAS,EACb,MAAMC,EAAY,GAElB,IAAM,IAAIC,EAAI,EAAGC,EAAIJ,EAASK,OAAQF,EAAIC,EAAGD,IAAO,CAEnD,MAAMG,EAAeC,MAAMC,QAASR,EAAUG,IAAQH,EAAUG,GAAM,CAAEH,EAAUG,IAElF,IAAM,IAAIM,EAAI,EAAGC,EAAKJ,EAAaD,OAAQI,EAAIC,EAAID,IAAO,CAEzD,MAAMhD,EAAU6C,EAAcG,GAExBE,EAASJ,MAAMC,QAAS/C,EAAQI,OAAUJ,EAAQI,MAAQ,CAAEJ,EAAQI,OAE1E,IAAM,IAAI+C,EAAI,EAAGC,EAAKF,EAAON,OAAQO,EAAIC,EAAID,IAAO,CAEnD,MAEM7D,EAAOqB,EAFCuC,EAAQC,IAIhBE,EAAcb,EAASC,EACvBa,EAAeD,EAAc/D,EAAKsB,SAClC2C,EAAaF,EAAcC,EAEjCd,GAAUc,EAGU,IAAfC,GAAsBd,EAAYc,EAAejE,EAAKuB,UAG1D2B,GAAYC,EAAYc,GAKzBvD,EAAQwD,OAAS,IAAIC,aAAcnE,EAAKuB,QAAU4C,aAAaC,mBAC/D1D,EAAQ2D,SAAWnB,EAGnBA,GAAUlD,EAAKuB,OAEhB,CAED,CAED,CAIA,MAAMwC,EAAcb,EAASC,EAExBY,EAAc,IAAIb,GAAYC,EAAYY,GAI/C5B,EAAcmC,OAASpB,EACvBf,EAAcoC,QAAU,CAAC,CAI1B,CArQEC,CAAsBrC,GAEtBa,EA0BF,SAAuBb,GAItB,MAAMsC,EAgBP,WAEC,IAAM,IAAIrB,EAAI,EAAGA,EAAI9C,EAAkB8C,IAEtC,IAA+C,IAA1C/C,EAAuBiC,QAASc,GAGpC,OADA/C,EAAuBqE,KAAMtB,GACtBA,EAQT,OAFArB,QAAQ4C,MAAO,yFAER,CAER,CAjC2BC,GAC1BzC,EAAcI,oBAAsBkC,EAEpC,MAAMzB,EAASjD,EAAG8E,eACZC,EAAO3C,EAAcmC,OACrBS,EAAQ5C,EAAc4C,MAO5B,OALAhF,EAAGiF,WAAYjF,EAAGkF,eAAgBjC,GAClCjD,EAAGmF,WAAYnF,EAAGkF,eAAgBH,EAAMC,GACxChF,EAAGiF,WAAYjF,EAAGkF,eAAgB,MAClClF,EAAGoF,eAAgBpF,EAAGkF,eAAgBR,EAAmBzB,GAElDA,CAER,CA5CW6B,CAAc1C,GACvBhC,EAASgC,EAAcO,IAAOM,EAE9Bb,EAAciD,iBAAkB,UAAWnD,IAM5C,MAAMY,EAAeD,EAAQA,QAC7B1C,EAAMmF,iBAAkBlD,EAAeU,GAIvC,MAAMyC,EAAQtF,EAAKuF,OAAOD,MAErBlF,EAAY+B,EAAcO,MAAS4C,KAiDzC,SAA2BnD,GAE1B,MAAMa,EAAS7C,EAASgC,EAAcO,IAChCO,EAAWd,EAAcc,SACzBpC,EAAQsB,EAAcoC,QAE5BxE,EAAGiF,WAAYjF,EAAGkF,eAAgBjC,GAElC,IAAM,IAAII,EAAI,EAAGoC,EAAKvC,EAASK,OAAQF,EAAIoC,EAAIpC,IAAO,CAErD,MAAMG,EAAeC,MAAMC,QAASR,EAAUG,IAAQH,EAAUG,GAAM,CAAEH,EAAUG,IAElF,IAAM,IAAIM,EAAI,EAAGC,EAAKJ,EAAaD,OAAQI,EAAIC,EAAID,IAAO,CAEzD,MAAMhD,EAAU6C,EAAcG,GAE9B,IAAmD,IAA9CjD,EAAmBC,EAAS0C,EAAGM,EAAG7C,GAAmB,CAEzD,MAAMqC,EAASxC,EAAQ2D,SAEjBT,EAASJ,MAAMC,QAAS/C,EAAQI,OAAUJ,EAAQI,MAAQ,CAAEJ,EAAQI,OAE1E,IAAI2E,EAAc,EAElB,IAAM,IAAI5B,EAAI,EAAGA,EAAID,EAAON,OAAQO,IAAO,CAE1C,MAAM/C,EAAQ8C,EAAQC,GAEhB7D,EAAOqB,EAAgBP,GAGP,iBAAVA,GAAuC,kBAAVA,GAExCJ,EAAQwD,OAAQ,GAAMpD,EACtBf,EAAG2F,cAAe3F,EAAGkF,eAAgB/B,EAASuC,EAAa/E,EAAQwD,SAExDpD,EAAMc,WAIjBlB,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAM,EACtBxD,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAM,EACtBxD,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,GAAMpD,EAAM6E,SAAU,GACtCjF,EAAQwD,OAAQ,IAAOpD,EAAM6E,SAAU,GACvCjF,EAAQwD,OAAQ,IAAO,IAIvBpD,EAAM8E,QAASlF,EAAQwD,OAAQuB,GAE/BA,GAAezF,EAAKuB,QAAU4C,aAAaC,kBAI7C,CAEArE,EAAG2F,cAAe3F,EAAGkF,eAAgB/B,EAAQxC,EAAQwD,OAEtD,CAED,CAED,CAEAnE,EAAGiF,WAAYjF,EAAGkF,eAAgB,KAEnC,CAxHEY,CAAkB1D,GAElB/B,EAAY+B,EAAcO,IAAO4C,EAInC,EAiVCQ,QAnBD,WAEC,IAAM,MAAMpD,KAAMvC,EAEjBJ,EAAG0C,aAActC,EAASuC,IAI3BrC,EAAyB,GACzBF,EAAU,CAAC,EACXC,EAAa,CAAC,CAEf,EAWD,QAGSN","ignoreList":[]}