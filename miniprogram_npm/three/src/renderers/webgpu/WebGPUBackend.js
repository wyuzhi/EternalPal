import{GPUFeatureName,GPULoadOp,GPUStoreOp,GPUIndexFormat,GPUTextureViewDimension}from"./utils/WebGPUConstants.js";import WGSLNodeBuilder from"./nodes/WGSLNodeBuilder.js";import Backend from"../common/Backend.js";import WebGPUUtils from"./utils/WebGPUUtils.js";import WebGPUAttributeUtils from"./utils/WebGPUAttributeUtils.js";import WebGPUBindingUtils from"./utils/WebGPUBindingUtils.js";import WebGPUPipelineUtils from"./utils/WebGPUPipelineUtils.js";import WebGPUTextureUtils from"./utils/WebGPUTextureUtils.js";import{WebGPUCoordinateSystem}from"../../constants.js";import WebGPUTimestampQueryPool from"./utils/WebGPUTimestampQueryPool.js";import{warnOnce}from"../../utils.js";class WebGPUBackend extends Backend{constructor(e={}){super(e),this.isWebGPUBackend=!0,this.parameters.alpha=void 0===e.alpha||e.alpha,this.parameters.compatibilityMode=void 0!==e.compatibilityMode&&e.compatibilityMode,this.parameters.requiredLimits=void 0===e.requiredLimits?{}:e.requiredLimits,this.compatibilityMode=this.parameters.compatibilityMode,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new WebGPUUtils(this),this.attributeUtils=new WebGPUAttributeUtils(this),this.bindingUtils=new WebGPUBindingUtils(this),this.pipelineUtils=new WebGPUPipelineUtils(this),this.textureUtils=new WebGPUTextureUtils(this),this.occludedResolveCache=new Map}async init(e){await super.init(e);const t=this.parameters;let r;if(void 0===t.device){const e={powerPreference:t.powerPreference,featureLevel:t.compatibilityMode?"compatibility":void 0},i="undefined"!=typeof navigator?await navigator.gpu.requestAdapter(e):null;if(null===i)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const s=Object.values(GPUFeatureName),n=[];for(const e of s)i.features.has(e)&&n.push(e);const a={requiredFeatures:n,requiredLimits:t.requiredLimits};r=await i.requestDevice(a)}else r=t.device;r.lost.then((t=>{const r={api:"WebGPU",message:t.message||"Unknown reason",reason:t.reason||null,originalEvent:t};e.onDeviceLost(r)}));const i=void 0!==t.context?t.context:e.domElement.getContext("webgpu");this.device=r,this.context=i;const s=t.alpha?"premultiplied":"opaque";this.trackTimestamp=this.trackTimestamp&&this.hasFeature(GPUFeatureName.TimestampQuery),this.context.configure({device:this.device,format:this.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:s}),this.updateSize()}get coordinateSystem(){return WebGPUCoordinateSystem}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let e=this.defaultRenderPassdescriptor;if(null===e){const t=this.renderer;e={colorAttachments:[{view:null}]},!0!==this.renderer.depth&&!0!==this.renderer.stencil||(e.depthStencilAttachment={view:this.textureUtils.getDepthBuffer(t.depth,t.stencil).createView()});const r=e.colorAttachments[0];this.renderer.samples>0?r.view=this.colorBuffer.createView():r.resolveTarget=void 0,this.defaultRenderPassdescriptor=e}const t=e.colorAttachments[0];return this.renderer.samples>0?t.resolveTarget=this.context.getCurrentTexture().createView():t.view=this.context.getCurrentTexture().createView(),e}_isRenderCameraDepthArray(e){return e.depthTexture&&e.depthTexture.image.depth>1&&e.camera.isArrayCamera}_getRenderPassDescriptor(e,t={}){const r=e.renderTarget,i=this.get(r);let s=i.descriptors;if(void 0===s||i.width!==r.width||i.height!==r.height||i.dimensions!==r.dimensions||i.activeMipmapLevel!==e.activeMipmapLevel||i.activeCubeFace!==e.activeCubeFace||i.samples!==r.samples){s={},i.descriptors=s;const e=()=>{r.removeEventListener("dispose",e),this.delete(r)};!1===r.hasEventListener("dispose",e)&&r.addEventListener("dispose",e)}const n=e.getCacheKey();let a=s[n];if(void 0===a){const t=e.textures,o=[];let l;const c=this._isRenderCameraDepthArray(e);for(let i=0;i<t.length;i++){const s=this.get(t[i]),n={label:`colorAttachment_${i}`,baseMipLevel:e.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:e.activeCubeFace,arrayLayerCount:1,dimension:GPUTextureViewDimension.TwoD};if(r.isRenderTarget3D)l=e.activeCubeFace,n.baseArrayLayer=0,n.dimension=GPUTextureViewDimension.ThreeD,n.depthOrArrayLayers=t[i].image.depth;else if(r.isRenderTarget&&t[i].image.depth>1)if(!0===c){const t=e.camera.cameras;for(let e=0;e<t.length;e++){const t={...n,baseArrayLayer:e,arrayLayerCount:1,dimension:GPUTextureViewDimension.TwoD},r=s.texture.createView(t);o.push({view:r,resolveTarget:void 0,depthSlice:void 0})}}else n.dimension=GPUTextureViewDimension.TwoDArray,n.depthOrArrayLayers=t[i].image.depth;if(!0!==c){const e=s.texture.createView(n);let t,r;void 0!==s.msaaTexture?(t=s.msaaTexture.createView(),r=e):(t=e,r=void 0),o.push({view:t,resolveTarget:r,depthSlice:l})}}if(a={textureViews:o},e.depth){const t=this.get(e.depthTexture),r={};e.depthTexture.isArrayTexture&&(r.dimension=GPUTextureViewDimension.TwoD,r.arrayLayerCount=1,r.baseArrayLayer=e.activeCubeFace),a.depthStencilView=t.texture.createView(r)}s[n]=a,i.width=r.width,i.height=r.height,i.samples=r.samples,i.activeMipmapLevel=e.activeMipmapLevel,i.activeCubeFace=e.activeCubeFace,i.dimensions=r.dimensions}const o={colorAttachments:[]};for(let e=0;e<a.textureViews.length;e++){const r=a.textureViews[e];let i={r:0,g:0,b:0,a:1};0===e&&t.clearValue&&(i=t.clearValue),o.colorAttachments.push({view:r.view,depthSlice:r.depthSlice,resolveTarget:r.resolveTarget,loadOp:t.loadOp||GPULoadOp.Load,storeOp:t.storeOp||GPUStoreOp.Store,clearValue:i})}return a.depthStencilView&&(o.depthStencilAttachment={view:a.depthStencilView}),o}beginRender(e){const t=this.get(e),r=this.device,i=e.occlusionQueryCount;let s,n;i>0&&(t.currentOcclusionQuerySet&&t.currentOcclusionQuerySet.destroy(),t.currentOcclusionQueryBuffer&&t.currentOcclusionQueryBuffer.destroy(),t.currentOcclusionQuerySet=t.occlusionQuerySet,t.currentOcclusionQueryBuffer=t.occlusionQueryBuffer,t.currentOcclusionQueryObjects=t.occlusionQueryObjects,s=r.createQuerySet({type:"occlusion",count:i,label:`occlusionQuerySet_${e.id}`}),t.occlusionQuerySet=s,t.occlusionQueryIndex=0,t.occlusionQueryObjects=new Array(i),t.lastOcclusionObject=null),n=null===e.textures?this._getDefaultRenderPassDescriptor():this._getRenderPassDescriptor(e,{loadOp:GPULoadOp.Load}),this.initTimestampQuery(e,n),n.occlusionQuerySet=s;const a=n.depthStencilAttachment;if(null!==e.textures){const t=n.colorAttachments;for(let r=0;r<t.length;r++){const i=t[r];e.clearColor?(i.clearValue=0===r?e.clearColorValue:{r:0,g:0,b:0,a:1},i.loadOp=GPULoadOp.Clear):i.loadOp=GPULoadOp.Load,i.storeOp=GPUStoreOp.Store}}else{const t=n.colorAttachments[0];e.clearColor?(t.clearValue=e.clearColorValue,t.loadOp=GPULoadOp.Clear):t.loadOp=GPULoadOp.Load,t.storeOp=GPUStoreOp.Store}e.depth&&(e.clearDepth?(a.depthClearValue=e.clearDepthValue,a.depthLoadOp=GPULoadOp.Clear):a.depthLoadOp=GPULoadOp.Load,a.depthStoreOp=GPUStoreOp.Store),e.stencil&&(e.clearStencil?(a.stencilClearValue=e.clearStencilValue,a.stencilLoadOp=GPULoadOp.Clear):a.stencilLoadOp=GPULoadOp.Load,a.stencilStoreOp=GPUStoreOp.Store);const o=r.createCommandEncoder({label:"renderContext_"+e.id});if(!0===this._isRenderCameraDepthArray(e)){const r=e.camera.cameras;t.layerDescriptors&&t.layerDescriptors.length===r.length?this._updateDepthLayerDescriptors(e,t,r):this._createDepthLayerDescriptors(e,t,n,r),t.bundleEncoders=[],t.bundleSets=[];for(let i=0;i<r.length;i++){const r=this.pipelineUtils.createBundleEncoder(e,"renderBundleArrayCamera_"+i),s={attributes:{},bindingGroups:[],pipeline:null,index:null};t.bundleEncoders.push(r),t.bundleSets.push(s)}t.currentPass=null}else{const r=o.beginRenderPass(n);if(t.currentPass=r,e.viewport&&this.updateViewport(e),e.scissor){const{x:t,y:i,width:s,height:n}=e.scissorValue;r.setScissorRect(t,i,s,n)}}t.descriptor=n,t.encoder=o,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.renderBundles=[]}_createDepthLayerDescriptors(e,t,r,i){const s=r.depthStencilAttachment;t.layerDescriptors=[];const n=this.get(e.depthTexture);n.viewCache||(n.viewCache=[]);for(let a=0;a<i.length;a++){const i={...r,colorAttachments:[{...r.colorAttachments[0],view:r.colorAttachments[a].view}]};if(r.depthStencilAttachment){const t=a;n.viewCache[t]||(n.viewCache[t]=n.texture.createView({dimension:GPUTextureViewDimension.TwoD,baseArrayLayer:a,arrayLayerCount:1})),i.depthStencilAttachment={view:n.viewCache[t],depthLoadOp:s.depthLoadOp||GPULoadOp.Clear,depthStoreOp:s.depthStoreOp||GPUStoreOp.Store,depthClearValue:s.depthClearValue||1},e.stencil&&(i.depthStencilAttachment.stencilLoadOp=s.stencilLoadOp,i.depthStencilAttachment.stencilStoreOp=s.stencilStoreOp,i.depthStencilAttachment.stencilClearValue=s.stencilClearValue)}else i.depthStencilAttachment={...s};t.layerDescriptors.push(i)}}_updateDepthLayerDescriptors(e,t,r){for(let i=0;i<r.length;i++){const r=t.layerDescriptors[i];if(r.depthStencilAttachment){const t=r.depthStencilAttachment;e.depth&&(e.clearDepth?(t.depthClearValue=e.clearDepthValue,t.depthLoadOp=GPULoadOp.Clear):t.depthLoadOp=GPULoadOp.Load),e.stencil&&(e.clearStencil?(t.stencilClearValue=e.clearStencilValue,t.stencilLoadOp=GPULoadOp.Clear):t.stencilLoadOp=GPULoadOp.Load)}}}finishRender(e){const t=this.get(e),r=e.occlusionQueryCount;t.renderBundles.length>0&&t.currentPass.executeBundles(t.renderBundles),r>t.occlusionQueryIndex&&t.currentPass.endOcclusionQuery();const i=t.encoder;if(!0===this._isRenderCameraDepthArray(e)){const r=[];for(let e=0;e<t.bundleEncoders.length;e++){const i=t.bundleEncoders[e];r.push(i.finish())}for(let s=0;s<t.layerDescriptors.length;s++)if(s<r.length){const n=t.layerDescriptors[s],a=i.beginRenderPass(n);if(e.viewport){const{x:t,y:r,width:i,height:s,minDepth:n,maxDepth:o}=e.viewportValue;a.setViewport(t,r,i,s,n,o)}if(e.scissor){const{x:t,y:r,width:i,height:s}=e.scissorValue;a.setScissorRect(t,r,i,s)}a.executeBundles([r[s]]),a.end()}}else t.currentPass&&t.currentPass.end();if(r>0){const i=8*r;let s=this.occludedResolveCache.get(i);void 0===s&&(s=this.device.createBuffer({size:i,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(i,s));const n=this.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.encoder.resolveQuerySet(t.occlusionQuerySet,0,r,s,0),t.encoder.copyBufferToBuffer(s,0,n,0,i),t.occlusionQueryBuffer=n,this.resolveOccludedAsync(e)}if(this.device.queue.submit([t.encoder.finish()]),null!==e.textures){const t=e.textures;for(let e=0;e<t.length;e++){const r=t[e];!0===r.generateMipmaps&&this.textureUtils.generateMipmaps(r)}}}isOccluded(e,t){const r=this.get(e);return r.occluded&&r.occluded.has(t)}async resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueryBuffer:r,currentOcclusionQueryObjects:i}=t;if(r&&i){const e=new WeakSet;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueryBuffer=null,await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange(),n=new BigUint64Array(s);for(let t=0;t<i.length;t++)n[t]===BigInt(0)&&e.add(i[t]);r.destroy(),t.occluded=e}}updateViewport(e){const{currentPass:t}=this.get(e),{x:r,y:i,width:s,height:n,minDepth:a,maxDepth:o}=e.viewportValue;t.setViewport(r,i,s,n,a,o)}getClearColor(){const e=super.getClearColor();return!0===this.renderer.alpha&&(e.r*=e.a,e.g*=e.a,e.b*=e.a),e}clear(e,t,r,i=null){const s=this.device,n=this.renderer;let a,o,l,c,u=[];if(e){const e=this.getClearColor();o={r:e.r,g:e.g,b:e.b,a:e.a}}if(null===i){l=n.depth,c=n.stencil;const t=this._getDefaultRenderPassDescriptor();if(e){u=t.colorAttachments;const e=u[0];e.clearValue=o,e.loadOp=GPULoadOp.Clear,e.storeOp=GPUStoreOp.Store}(l||c)&&(a=t.depthStencilAttachment)}else{l=i.depth,c=i.stencil;const s={loadOp:e?GPULoadOp.Clear:GPULoadOp.Load,clearValue:e?o:void 0};l&&(s.depthLoadOp=t?GPULoadOp.Clear:GPULoadOp.Load,s.depthClearValue=t?n.getClearDepth():void 0,s.depthStoreOp=GPUStoreOp.Store),c&&(s.stencilLoadOp=r?GPULoadOp.Clear:GPULoadOp.Load,s.stencilClearValue=r?n.getClearStencil():void 0,s.stencilStoreOp=GPUStoreOp.Store);const d=this._getRenderPassDescriptor(i,s);u=d.colorAttachments,a=d.depthStencilAttachment}l&&a&&(t?(a.depthLoadOp=GPULoadOp.Clear,a.depthClearValue=n.getClearDepth(),a.depthStoreOp=GPUStoreOp.Store):(a.depthLoadOp=GPULoadOp.Load,a.depthStoreOp=GPUStoreOp.Store)),c&&a&&(r?(a.stencilLoadOp=GPULoadOp.Clear,a.stencilClearValue=n.getClearStencil(),a.stencilStoreOp=GPUStoreOp.Store):(a.stencilLoadOp=GPULoadOp.Load,a.stencilStoreOp=GPUStoreOp.Store));const d=s.createCommandEncoder({label:"clear"});d.beginRenderPass({colorAttachments:u,depthStencilAttachment:a}).end(),s.queue.submit([d.finish()])}beginCompute(e){const t=this.get(e),r={label:"computeGroup_"+e.id};this.initTimestampQuery(e,r),t.cmdEncoderGPU=this.device.createCommandEncoder({label:"computeGroup_"+e.id}),t.passEncoderGPU=t.cmdEncoderGPU.beginComputePass(r)}compute(e,t,r,i,s=null){const n=this.get(t),{passEncoderGPU:a}=this.get(e),o=this.get(i).pipeline;this.pipelineUtils.setPipeline(a,o);for(let e=0,t=r.length;e<t;e++){const t=r[e],i=this.get(t);a.setBindGroup(e,i.group)}let l;if(null===s&&(s=t.count),"number"==typeof s){const e=s;if(void 0===n.dispatchSize||n.count!==e){n.dispatchSize=[0,1,1],n.count=e;const r=t.workgroupSize;let i=r[0];for(let e=1;e<r.length;e++)i*=r[e];const s=Math.ceil(e/i),a=this.device.limits.maxComputeWorkgroupsPerDimension;l=[s,1,1],s>a&&(l[0]=Math.min(s,a),l[1]=Math.ceil(s/a)),n.dispatchSize=l}l=n.dispatchSize}else l=s;a.dispatchWorkgroups(l[0],l[1]||1,l[2]||1)}finishCompute(e){const t=this.get(e);t.passEncoderGPU.end(),this.device.queue.submit([t.cmdEncoderGPU.finish()])}async waitForGPU(){await this.device.queue.onSubmittedWorkDone()}draw(e,t){const{object:r,material:i,context:s,pipeline:n}=e,a=e.getBindings(),o=this.get(s),l=this.get(n).pipeline,c=e.getIndex(),u=null!==c,d=e.getDrawParameters();if(null===d)return;const p=(t,r)=>{this.pipelineUtils.setPipeline(t,l),r.pipeline=l;const n=r.bindingGroups;for(let e=0,r=a.length;e<r;e++){const r=a[e],i=this.get(r);n[r.index]!==r.id&&(t.setBindGroup(r.index,i.group),n[r.index]=r.id)}if(!0===u&&r.index!==c){const e=this.get(c).buffer,i=c.array instanceof Uint16Array?GPUIndexFormat.Uint16:GPUIndexFormat.Uint32;t.setIndexBuffer(e,i),r.index=c}const d=e.getVertexBuffers();for(let e=0,i=d.length;e<i;e++){const i=d[e];if(r.attributes[e]!==i){const s=this.get(i).buffer;t.setVertexBuffer(e,s),r.attributes[e]=i}}!0===s.stencil&&!0===i.stencilWrite&&o.currentStencilRef!==i.stencilRef&&(t.setStencilReference(i.stencilRef),o.currentStencilRef=i.stencilRef)},h=(i,s)=>{if(p(i,s),!0===r.isBatchedMesh){const e=r._multiDrawStarts,s=r._multiDrawCounts,n=r._multiDrawCount,a=r._multiDrawInstances;null!==a&&warnOnce("THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");for(let o=0;o<n;o++){const n=a?a[o]:1,l=n>1?0:o;!0===u?i.drawIndexed(s[o],n,e[o]/c.array.BYTES_PER_ELEMENT,0,l):i.draw(s[o],n,e[o],l),t.update(r,s[o],n)}}else if(!0===u){const{vertexCount:s,instanceCount:n,firstVertex:a}=d,o=e.getIndirect();if(null!==o){const e=this.get(o).buffer;i.drawIndexedIndirect(e,0)}else i.drawIndexed(s,n,a,0,0);t.update(r,s,n)}else{const{vertexCount:s,instanceCount:n,firstVertex:a}=d,o=e.getIndirect();if(null!==o){const e=this.get(o).buffer;i.drawIndirect(e,0)}else i.draw(s,n,a,0);t.update(r,s,n)}};if(e.camera.isArrayCamera&&e.camera.cameras.length>0){const t=this.get(e.camera),i=e.camera.cameras,n=e.getBindingGroup("cameraIndex");if(void 0===t.indexesGPU||t.indexesGPU.length!==i.length){const e=this.get(n),r=[],s=new Uint32Array([0,0,0,0]);for(let t=0,n=i.length;t<n;t++){s[0]=t;const i=this.bindingUtils.createBindGroupIndex(s,e.layout);r.push(i)}t.indexesGPU=r}const a=this.renderer.getPixelRatio();for(let e=0,l=i.length;e<l;e++){const l=i[e];if(r.layers.test(l.layers)){const r=l.viewport;let i=o.currentPass,c=o.currentSets;if(o.bundleEncoders){i=o.bundleEncoders[e],c=o.bundleSets[e]}r&&i.setViewport(Math.floor(r.x*a),Math.floor(r.y*a),Math.floor(r.width*a),Math.floor(r.height*a),s.viewportValue.minDepth,s.viewportValue.maxDepth),n&&t.indexesGPU&&(i.setBindGroup(n.index,t.indexesGPU[e]),c.bindingGroups[n.index]=n.id),h(i,c)}}}else if(o.currentPass){if(void 0!==o.occlusionQuerySet){const e=o.lastOcclusionObject;e!==r&&(null!==e&&!0===e.occlusionTest&&(o.currentPass.endOcclusionQuery(),o.occlusionQueryIndex++),!0===r.occlusionTest&&(o.currentPass.beginOcclusionQuery(o.occlusionQueryIndex),o.occlusionQueryObjects[o.occlusionQueryIndex]=r),o.lastOcclusionObject=r)}h(o.currentPass,o.currentSets)}}needsRenderUpdate(e){const t=this.get(e),{object:r,material:i}=e,s=this.utils,n=s.getSampleCountRenderContext(e.context),a=s.getCurrentColorSpace(e.context),o=s.getCurrentColorFormat(e.context),l=s.getCurrentDepthStencilFormat(e.context),c=s.getPrimitiveTopology(r,i);let u=!1;return t.material===i&&t.materialVersion===i.version&&t.transparent===i.transparent&&t.blending===i.blending&&t.premultipliedAlpha===i.premultipliedAlpha&&t.blendSrc===i.blendSrc&&t.blendDst===i.blendDst&&t.blendEquation===i.blendEquation&&t.blendSrcAlpha===i.blendSrcAlpha&&t.blendDstAlpha===i.blendDstAlpha&&t.blendEquationAlpha===i.blendEquationAlpha&&t.colorWrite===i.colorWrite&&t.depthWrite===i.depthWrite&&t.depthTest===i.depthTest&&t.depthFunc===i.depthFunc&&t.stencilWrite===i.stencilWrite&&t.stencilFunc===i.stencilFunc&&t.stencilFail===i.stencilFail&&t.stencilZFail===i.stencilZFail&&t.stencilZPass===i.stencilZPass&&t.stencilFuncMask===i.stencilFuncMask&&t.stencilWriteMask===i.stencilWriteMask&&t.side===i.side&&t.alphaToCoverage===i.alphaToCoverage&&t.sampleCount===n&&t.colorSpace===a&&t.colorFormat===o&&t.depthStencilFormat===l&&t.primitiveTopology===c&&t.clippingContextCacheKey===e.clippingContextCacheKey||(t.material=i,t.materialVersion=i.version,t.transparent=i.transparent,t.blending=i.blending,t.premultipliedAlpha=i.premultipliedAlpha,t.blendSrc=i.blendSrc,t.blendDst=i.blendDst,t.blendEquation=i.blendEquation,t.blendSrcAlpha=i.blendSrcAlpha,t.blendDstAlpha=i.blendDstAlpha,t.blendEquationAlpha=i.blendEquationAlpha,t.colorWrite=i.colorWrite,t.depthWrite=i.depthWrite,t.depthTest=i.depthTest,t.depthFunc=i.depthFunc,t.stencilWrite=i.stencilWrite,t.stencilFunc=i.stencilFunc,t.stencilFail=i.stencilFail,t.stencilZFail=i.stencilZFail,t.stencilZPass=i.stencilZPass,t.stencilFuncMask=i.stencilFuncMask,t.stencilWriteMask=i.stencilWriteMask,t.side=i.side,t.alphaToCoverage=i.alphaToCoverage,t.sampleCount=n,t.colorSpace=a,t.colorFormat=o,t.depthStencilFormat=l,t.primitiveTopology=c,t.clippingContextCacheKey=e.clippingContextCacheKey,u=!0),u}getRenderCacheKey(e){const{object:t,material:r}=e,i=this.utils,s=e.context;return[r.transparent,r.blending,r.premultipliedAlpha,r.blendSrc,r.blendDst,r.blendEquation,r.blendSrcAlpha,r.blendDstAlpha,r.blendEquationAlpha,r.colorWrite,r.depthWrite,r.depthTest,r.depthFunc,r.stencilWrite,r.stencilFunc,r.stencilFail,r.stencilZFail,r.stencilZPass,r.stencilFuncMask,r.stencilWriteMask,r.side,i.getSampleCountRenderContext(s),i.getCurrentColorSpace(s),i.getCurrentColorFormat(s),i.getCurrentDepthStencilFormat(s),i.getPrimitiveTopology(t,r),e.getGeometryCacheKey(),e.clippingContextCacheKey].join()}createSampler(e){this.textureUtils.createSampler(e)}destroySampler(e){this.textureUtils.destroySampler(e)}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}async copyTextureToBuffer(e,t,r,i,s,n){return this.textureUtils.copyTextureToBuffer(e,t,r,i,s,n)}initTimestampQuery(e,t){if(!this.trackTimestamp)return;const r=e.isComputeNode?"compute":"render";this.timestampQueryPool[r]||(this.timestampQueryPool[r]=new WebGPUTimestampQueryPool(this.device,r,2048));const i=this.timestampQueryPool[r],s=i.allocateQueriesForContext(e);t.timestampWrites={querySet:i.querySet,beginningOfPassWriteIndex:s,endOfPassWriteIndex:s+1}}createNodeBuilder(e,t){return new WGSLNodeBuilder(e,t)}createProgram(e){this.get(e).module={module:this.device.createShaderModule({code:e.code,label:e.stage+(""!==e.name?`_${e.name}`:"")}),entryPoint:"main"}}destroyProgram(e){this.delete(e)}createRenderPipeline(e,t){this.pipelineUtils.createRenderPipeline(e,t)}createComputePipeline(e,t){this.pipelineUtils.createComputePipeline(e,t)}beginBundle(e){const t=this.get(e);t._currentPass=t.currentPass,t._currentSets=t.currentSets,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.currentPass=this.pipelineUtils.createBundleEncoder(e)}finishBundle(e,t){const r=this.get(e),i=r.currentPass.finish();this.get(t).bundleGPU=i,r.currentSets=r._currentSets,r.currentPass=r._currentPass}addBundle(e,t){this.get(e).renderBundles.push(this.get(t).bundleGPU)}createBindings(e,t,r,i){this.bindingUtils.createBindings(e,t,r,i)}updateBindings(e,t,r,i){this.bindingUtils.createBindings(e,t,r,i)}updateBinding(e){this.bindingUtils.updateBinding(e)}createIndexAttribute(e){let t=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute)&&(t|=GPUBufferUsage.STORAGE),this.attributeUtils.createAttribute(e,t)}createAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createIndirectStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}hasFeature(e){return this.device.features.has(e)}copyTextureToTexture(e,t,r=null,i=null,s=0,n=0){let a=0,o=0,l=0,c=0,u=0,d=0,p=e.image.width,h=e.image.height,m=1;null!==r&&(!0===r.isBox3?(c=r.min.x,u=r.min.y,d=r.min.z,p=r.max.x-r.min.x,h=r.max.y-r.min.y,m=r.max.z-r.min.z):(c=r.min.x,u=r.min.y,p=r.max.x-r.min.x,h=r.max.y-r.min.y,m=1)),null!==i&&(a=i.x,o=i.y,l=i.z||0);const g=this.device.createCommandEncoder({label:"copyTextureToTexture_"+e.id+"_"+t.id}),f=this.get(e).texture,P=this.get(t).texture;g.copyTextureToTexture({texture:f,mipLevel:s,origin:{x:c,y:u,z:d}},{texture:P,mipLevel:n,origin:{x:a,y:o,z:l}},[p,h,m]),this.device.queue.submit([g.finish()]),0===n&&t.generateMipmaps&&this.textureUtils.generateMipmaps(t)}copyFramebufferToTexture(e,t,r){const i=this.get(t);let s=null;s=t.renderTarget?e.isDepthTexture?this.get(t.depthTexture).texture:this.get(t.textures[0]).texture:e.isDepthTexture?this.textureUtils.getDepthBuffer(t.depth,t.stencil):this.context.getCurrentTexture();const n=this.get(e).texture;if(s.format!==n.format)return void console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",s.format,n.format);let a;if(i.currentPass?(i.currentPass.end(),a=i.encoder):a=this.device.createCommandEncoder({label:"copyFramebufferToTexture_"+e.id}),a.copyTextureToTexture({texture:s,origin:[r.x,r.y,0]},{texture:n},[r.z,r.w]),i.currentPass){const{descriptor:e}=i;for(let t=0;t<e.colorAttachments.length;t++)e.colorAttachments[t].loadOp=GPULoadOp.Load;if(t.depth&&(e.depthStencilAttachment.depthLoadOp=GPULoadOp.Load),t.stencil&&(e.depthStencilAttachment.stencilLoadOp=GPULoadOp.Load),i.currentPass=a.beginRenderPass(e),i.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.viewport&&this.updateViewport(t),t.scissor){const{x:e,y:r,width:s,height:n}=t.scissorValue;i.currentPass.setScissorRect(e,r,s,n)}}else this.device.queue.submit([a.finish()]);e.generateMipmaps&&this.textureUtils.generateMipmaps(e)}}export default WebGPUBackend;
//# sourceMappingURL=WebGPUBackend.js.map