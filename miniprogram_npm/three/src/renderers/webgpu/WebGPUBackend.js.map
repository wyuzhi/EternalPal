{"version":3,"file":"node_modules/three/src/renderers/webgpu/WebGPUBackend.js","names":["GPUFeatureName","GPULoadOp","GPUStoreOp","GPUIndexFormat","GPUTextureViewDimension","WGSLNodeBuilder","Backend","WebGPUUtils","WebGPUAttributeUtils","WebGPUBindingUtils","WebGPUPipelineUtils","WebGPUTextureUtils","WebGPUCoordinateSystem","WebGPUTimestampQueryPool","warnOnce","WebGPUBackend","constructor","parameters","super","this","isWebGPUBackend","alpha","undefined","compatibilityMode","requiredLimits","device","context","colorBuffer","defaultRenderPassdescriptor","utils","attributeUtils","bindingUtils","pipelineUtils","textureUtils","occludedResolveCache","Map","init","renderer","adapterOptions","powerPreference","featureLevel","adapter","navigator","gpu","requestAdapter","Error","features","Object","values","supportedFeatures","name","has","push","deviceDescriptor","requiredFeatures","requestDevice","lost","then","info","deviceLossInfo","api","message","reason","originalEvent","onDeviceLost","domElement","getContext","alphaMode","trackTimestamp","hasFeature","TimestampQuery","configure","format","getPreferredCanvasFormat","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","updateSize","coordinateSystem","getArrayBufferAsync","attribute","_getDefaultRenderPassDescriptor","descriptor","colorAttachments","view","depth","stencil","depthStencilAttachment","getDepthBuffer","createView","colorAttachment","samples","resolveTarget","getCurrentTexture","_isRenderCameraDepthArray","renderContext","depthTexture","image","camera","isArrayCamera","_getRenderPassDescriptor","colorAttachmentsConfig","renderTarget","renderTargetData","get","descriptors","width","height","dimensions","activeMipmapLevel","activeCubeFace","onDispose","removeEventListener","delete","hasEventListener","addEventListener","cacheKey","getCacheKey","descriptorBase","textures","textureViews","sliceIndex","isRenderCameraDepthArray","i","length","textureData","viewDescriptor","label","baseMipLevel","mipLevelCount","baseArrayLayer","arrayLayerCount","dimension","TwoD","isRenderTarget3D","ThreeD","depthOrArrayLayers","isRenderTarget","cameras","layer","layerViewDescriptor","textureView","texture","depthSlice","TwoDArray","msaaTexture","depthTextureData","options","isArrayTexture","depthStencilView","viewInfo","clearValue","r","g","b","a","loadOp","Load","storeOp","Store","beginRender","renderContextData","occlusionQueryCount","occlusionQuerySet","currentOcclusionQuerySet","destroy","currentOcclusionQueryBuffer","occlusionQueryBuffer","currentOcclusionQueryObjects","occlusionQueryObjects","createQuerySet","type","count","id","occlusionQueryIndex","Array","lastOcclusionObject","initTimestampQuery","clearColor","clearColorValue","Clear","clearDepth","depthClearValue","clearDepthValue","depthLoadOp","depthStoreOp","clearStencil","stencilClearValue","clearStencilValue","stencilLoadOp","stencilStoreOp","encoder","createCommandEncoder","layerDescriptors","_updateDepthLayerDescriptors","_createDepthLayerDescriptors","bundleEncoders","bundleSets","bundleEncoder","createBundleEncoder","attributes","bindingGroups","pipeline","index","currentPass","beginRenderPass","viewport","updateViewport","scissor","x","y","scissorValue","setScissorRect","currentSets","renderBundles","viewCache","layerDescriptor","layerIndex","depthAttachment","finishRender","executeBundles","endOcclusionQuery","bundles","finish","renderPass","minDepth","maxDepth","viewportValue","setViewport","end","bufferSize","queryResolveBuffer","createBuffer","size","GPUBufferUsage","QUERY_RESOLVE","set","readBuffer","COPY_DST","MAP_READ","resolveQuerySet","copyBufferToBuffer","resolveOccludedAsync","queue","submit","generateMipmaps","isOccluded","object","occluded","WeakSet","mapAsync","GPUMapMode","READ","buffer","getMappedRange","results","BigUint64Array","BigInt","add","getClearColor","clear","color","renderTargetContext","supportsDepth","supportsStencil","clearConfig","getClearDepth","getClearStencil","beginCompute","computeGroup","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","compute","computeNode","bindings","dispatchSizeOrCount","computeNodeData","pipelineGPU","setPipeline","l","bindGroup","bindingsData","setBindGroup","group","dispatchSize","workgroupSize","dispatchCount","Math","ceil","maxComputeWorkgroupsPerDimension","limits","min","dispatchWorkgroups","finishCompute","groupData","waitForGPU","onSubmittedWorkDone","draw","renderObject","material","getBindings","getIndex","hasIndex","drawParams","getDrawParameters","setPipelineAndBindings","currentBindingGroups","indexFormat","array","Uint16Array","Uint16","Uint32","setIndexBuffer","vertexBuffers","getVertexBuffers","vertexBuffer","setVertexBuffer","stencilWrite","currentStencilRef","stencilRef","setStencilReference","isBatchedMesh","starts","_multiDrawStarts","counts","_multiDrawCounts","drawCount","_multiDrawCount","drawInstances","_multiDrawInstances","firstInstance","drawIndexed","BYTES_PER_ELEMENT","update","vertexCount","indexCount","instanceCount","firstVertex","firstIndex","indirect","getIndirect","drawIndexedIndirect","drawIndirect","cameraData","cameraIndex","getBindingGroup","indexesGPU","data","Uint32Array","len","bindGroupIndex","createBindGroupIndex","layout","pixelRatio","getPixelRatio","subCamera","layers","test","vp","pass","sets","floor","lastObject","occlusionTest","beginOcclusionQuery","needsRenderUpdate","sampleCount","getSampleCountRenderContext","colorSpace","getCurrentColorSpace","colorFormat","getCurrentColorFormat","depthStencilFormat","getCurrentDepthStencilFormat","primitiveTopology","getPrimitiveTopology","needsUpdate","materialVersion","version","transparent","blending","premultipliedAlpha","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","colorWrite","depthWrite","depthTest","depthFunc","stencilFunc","stencilFail","stencilZFail","stencilZPass","stencilFuncMask","stencilWriteMask","side","alphaToCoverage","clippingContextCacheKey","getRenderCacheKey","getGeometryCacheKey","join","createSampler","destroySampler","createDefaultTexture","createTexture","updateTexture","destroyTexture","copyTextureToBuffer","faceIndex","isComputeNode","timestampQueryPool","baseOffset","allocateQueriesForContext","timestampWrites","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","createNodeBuilder","createProgram","program","module","createShaderModule","code","stage","entryPoint","destroyProgram","createRenderPipeline","promises","createComputePipeline","computePipeline","beginBundle","_currentPass","_currentSets","finishBundle","bundle","bundleGPU","addBundle","createBindings","cacheIndex","updateBindings","updateBinding","binding","createIndexAttribute","INDEX","isStorageBufferAttribute","isStorageInstancedBufferAttribute","STORAGE","createAttribute","VERTEX","createStorageAttribute","createIndirectStorageAttribute","INDIRECT","updateAttribute","destroyAttribute","getColorBuffer","getMaxAnisotropy","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","srcLevel","dstLevel","dstX","dstY","dstZ","srcX","srcY","srcZ","srcWidth","srcHeight","srcDepth","isBox3","z","max","sourceGPU","destinationGPU","mipLevel","origin","copyFramebufferToTexture","rectangle","isDepthTexture","console","error","w"],"sources":["node_modules/three/src/renderers/webgpu/WebGPUBackend.js"],"sourcesContent":["/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\nimport { GPUFeatureName, GPULoadOp, GPUStoreOp, GPUIndexFormat, GPUTextureViewDimension } from './utils/WebGPUConstants.js';\n\nimport WGSLNodeBuilder from './nodes/WGSLNodeBuilder.js';\nimport Backend from '../common/Backend.js';\n\nimport WebGPUUtils from './utils/WebGPUUtils.js';\nimport WebGPUAttributeUtils from './utils/WebGPUAttributeUtils.js';\nimport WebGPUBindingUtils from './utils/WebGPUBindingUtils.js';\nimport WebGPUPipelineUtils from './utils/WebGPUPipelineUtils.js';\nimport WebGPUTextureUtils from './utils/WebGPUTextureUtils.js';\n\nimport { WebGPUCoordinateSystem } from '../../constants.js';\nimport WebGPUTimestampQueryPool from './utils/WebGPUTimestampQueryPool.js';\nimport { warnOnce } from '../../utils.js';\n\n/**\n * A backend implementation targeting WebGPU.\n *\n * @private\n * @augments Backend\n */\nclass WebGPUBackend extends Backend {\n\n\t/**\n\t * WebGPUBackend options.\n\t *\n\t * @typedef {Object} WebGPUBackend~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.\n\t * @property {string} [powerPreference=undefined] - The power preference.\n\t * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.\n\t * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.\n\t * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.\n\t */\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\t\tthis.parameters.compatibilityMode = ( parameters.compatibilityMode === undefined ) ? false : parameters.compatibilityMode;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\t/**\n\t\t * Indicates whether the backend is in compatibility mode or not.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.compatibilityMode = this.parameters.compatibilityMode;\n\n\t\t/**\n\t\t * A reference to the device.\n\t\t *\n\t\t * @type {?GPUDevice}\n\t\t * @default null\n\t\t */\n\t\tthis.device = null;\n\n\t\t/**\n\t\t * A reference to the context.\n\t\t *\n\t\t * @type {?GPUCanvasContext}\n\t\t * @default null\n\t\t */\n\t\tthis.context = null;\n\n\t\t/**\n\t\t * A reference to the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {?GPUTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * A reference to the default render pass descriptor.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common utility functions.\n\t\t *\n\t\t * @type {WebGPUUtils}\n\t\t */\n\t\tthis.utils = new WebGPUUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUAttributeUtils}\n\t\t */\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader binding-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUBindingUtils}\n\t\t */\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader pipeline-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUPipelineUtils}\n\t\t */\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUTextureUtils}\n\t\t */\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\n\t\t/**\n\t\t * A map that manages the resolve buffers for occlusion queries.\n\t\t *\n\t\t * @type {Map<number,GPUBuffer>}\n\t\t */\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference,\n\t\t\t\tfeatureLevel: parameters.compatibilityMode ? 'compatibility' : undefined\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: alphaMode\n\t\t} );\n\n\t\tthis.updateSize();\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {GPUCanvasContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Returns the default render pass descriptor.\n\t *\n\t * In WebGPU, the default framebuffer must be configured\n\t * like custom framebuffers so the backend needs a render\n\t * pass descriptor even when rendering directly to screen.\n\t *\n\t * @private\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tlet descriptor = this.defaultRenderPassdescriptor;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ],\n\t\t\t};\n\n\t\t\tif ( this.renderer.depth === true || this.renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tthis.defaultRenderPassdescriptor = descriptor;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Internal to determine if the current render target is a render target array with depth 2D array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {boolean} Whether the render target is a render target array with depth 2D array texture.\n\t *\n\t * @private\n\t */\n\t_isRenderCameraDepthArray( renderContext ) {\n\n\t\treturn renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;\n\n\t}\n\n\t/**\n\t * Returns the render pass descriptor for the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getRenderPassDescriptor( renderContext, colorAttachmentsConfig = {} ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.dimensions !== renderTarget.dimensions ||\n\t\t\trenderTargetData.activeMipmapLevel !== renderContext.activeMipmapLevel ||\n\t\t\trenderTargetData.activeCubeFace !== renderContext.activeCubeFace ||\n\t\t\trenderTargetData.samples !== renderTarget.samples\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\tif ( renderTarget.hasEventListener( 'dispose', onDispose ) === false ) {\n\n\t\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\t\tlet descriptorBase = descriptors[ cacheKey ];\n\n\t\tif ( descriptorBase === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst textureViews = [];\n\n\t\t\tlet sliceIndex;\n\n\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( renderContext );\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst viewDescriptor = {\n\t\t\t\t\tlabel: `colorAttachment_${ i }`,\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t};\n\n\t\t\t\tif ( renderTarget.isRenderTarget3D ) {\n\n\t\t\t\t\tsliceIndex = renderContext.activeCubeFace;\n\n\t\t\t\t\tviewDescriptor.baseArrayLayer = 0;\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.ThreeD;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t} else if ( renderTarget.isRenderTarget && textures[ i ].image.depth > 1 ) {\n\n\t\t\t\t\tif ( isRenderCameraDepthArray === true ) {\n\n\t\t\t\t\t\tconst cameras = renderContext.camera.cameras;\n\t\t\t\t\t\tfor ( let layer = 0; layer < cameras.length; layer ++ ) {\n\n\t\t\t\t\t\t\tconst layerViewDescriptor = {\n\t\t\t\t\t\t\t\t...viewDescriptor,\n\t\t\t\t\t\t\t\tbaseArrayLayer: layer,\n\t\t\t\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst textureView = textureData.texture.createView( layerViewDescriptor );\n\t\t\t\t\t\t\ttextureViews.push( {\n\t\t\t\t\t\t\t\tview: textureView,\n\t\t\t\t\t\t\t\tresolveTarget: undefined,\n\t\t\t\t\t\t\t\tdepthSlice: undefined\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;\n\t\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isRenderCameraDepthArray !== true ) {\n\n\t\t\t\t\tconst textureView = textureData.texture.createView( viewDescriptor );\n\n\t\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tview = textureView;\n\t\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureViews.push( {\n\t\t\t\t\t\tview,\n\t\t\t\t\t\tresolveTarget,\n\t\t\t\t\t\tdepthSlice: sliceIndex\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdescriptorBase = { textureViews };\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\t\t\t\tconst options = {};\n\t\t\t\tif ( renderContext.depthTexture.isArrayTexture ) {\n\n\t\t\t\t\toptions.dimension = GPUTextureViewDimension.TwoD;\n\t\t\t\t\toptions.arrayLayerCount = 1;\n\t\t\t\t\toptions.baseArrayLayer = renderContext.activeCubeFace;\n\n\t\t\t\t}\n\n\t\t\t\tdescriptorBase.depthStencilView = depthTextureData.texture.createView( options );\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptorBase;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;\n\t\t\trenderTargetData.activeCubeFace = renderContext.activeCubeFace;\n\t\t\trenderTargetData.dimensions = renderTarget.dimensions;\n\n\t\t}\n\n\t\tconst descriptor = {\n\t\t\tcolorAttachments: []\n\t\t};\n\n\t\t// Apply dynamic properties to cached views\n\t\tfor ( let i = 0; i < descriptorBase.textureViews.length; i ++ ) {\n\n\t\t\tconst viewInfo = descriptorBase.textureViews[ i ];\n\n\t\t\tlet clearValue = { r: 0, g: 0, b: 0, a: 1 };\n\t\t\tif ( i === 0 && colorAttachmentsConfig.clearValue ) {\n\n\t\t\t\tclearValue = colorAttachmentsConfig.clearValue;\n\n\t\t\t}\n\n\t\t\tdescriptor.colorAttachments.push( {\n\t\t\t\tview: viewInfo.view,\n\t\t\t\tdepthSlice: viewInfo.depthSlice,\n\t\t\t\tresolveTarget: viewInfo.resolveTarget,\n\t\t\t\tloadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,\n\t\t\t\tstoreOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,\n\t\t\t\tclearValue: clearValue\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( descriptorBase.depthStencilView ) {\n\n\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\tview: descriptorBase.depthStencilView\n\t\t\t};\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGPU state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext, { loadOp: GPULoadOp.Load } );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( renderContext, descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  \tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t  if ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\n\t\t// shadow arrays - prepare bundle encoders for each camera in an array camera\n\n\t\tif ( this._isRenderCameraDepthArray( renderContext ) === true ) {\n\n\t\t\tconst cameras = renderContext.camera.cameras;\n\n\t\t\tif ( ! renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length ) {\n\n\t\t\t\tthis._createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras );\n\n\t\t\t} else {\n\n\t\t\t\tthis._updateDepthLayerDescriptors( renderContext, renderContextData, cameras );\n\n\t\t\t}\n\n\t\t\t// Create bundle encoders for each layer\n\t\t\trenderContextData.bundleEncoders = [];\n\t\t\trenderContextData.bundleSets = [];\n\n\t\t\t// Create separate bundle encoders for each camera in the array\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tconst bundleEncoder = this.pipelineUtils.createBundleEncoder(\n\t\t\t\t\trenderContext,\n\t\t\t\t\t'renderBundleArrayCamera_' + i\n\t\t\t\t);\n\n\t\t\t\t// Initialize state tracking for this bundle\n\t\t\t\tconst bundleSets = {\n\t\t\t\t\tattributes: {},\n\t\t\t\t\tbindingGroups: [],\n\t\t\t\t\tpipeline: null,\n\t\t\t\t\tindex: null\n\t\t\t\t};\n\n\t\t\t\trenderContextData.bundleEncoders.push( bundleEncoder );\n\t\t\t\trenderContextData.bundleSets.push( bundleSets );\n\n\t\t\t}\n\n\t\t\t// We'll complete the bundles in finishRender\n\t\t\trenderContextData.currentPass = null;\n\n\t\t} else {\n\n\t\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentPass = currentPass;\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\t\t\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t}\n\n\t/**\n\t * This method creates layer descriptors for each camera in an array camera\n\t * to prepare for rendering to a depth array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} renderContextData - The render context data.\n\t * @param {Object} descriptor  - The render pass descriptor.\n\t * @param {ArrayCamera} cameras - The array camera.\n\t *\n\t * @private\n\t */\n\t_createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras ) {\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\t\trenderContextData.layerDescriptors = [];\n\n\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\t\tif ( ! depthTextureData.viewCache ) {\n\n\t\t\tdepthTextureData.viewCache = [];\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tconst layerDescriptor = {\n\t\t\t\t...descriptor,\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\t...descriptor.colorAttachments[ 0 ],\n\t\t\t\t\tview: descriptor.colorAttachments[ i ].view\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tif ( descriptor.depthStencilAttachment ) {\n\n\t\t\t\tconst layerIndex = i;\n\n\t\t\t\tif ( ! depthTextureData.viewCache[ layerIndex ] ) {\n\n\t\t\t\t\tdepthTextureData.viewCache[ layerIndex ] = depthTextureData.texture.createView( {\n\t\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\t\t\tbaseArrayLayer: i,\n\t\t\t\t\t\tarrayLayerCount: 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tlayerDescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.viewCache[ layerIndex ],\n\t\t\t\t\tdepthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,\n\t\t\t\t\tdepthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,\n\t\t\t\t\tdepthClearValue: depthStencilAttachment.depthClearValue || 1.0\n\t\t\t\t};\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlayerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };\n\n\t\t\t}\n\n\t\t\trenderContextData.layerDescriptors.push( layerDescriptor );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method updates the layer descriptors for each camera in an array camera\n\t * to prepare for rendering to a depth array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} renderContextData - The render context data.\n\t * @param {ArrayCamera} cameras - The array camera.\n\t *\n\t */\n\t_updateDepthLayerDescriptors( renderContext, renderContextData, cameras ) {\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tconst layerDescriptor = renderContextData.layerDescriptors[ i ];\n\n\t\t\tif ( layerDescriptor.depthStencilAttachment ) {\n\n\t\t\t\tconst depthAttachment = layerDescriptor.depthStencilAttachment;\n\n\t\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\t\t\tdepthAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\t\t\tdepthAttachment.depthLoadOp = GPULoadOp.Clear;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdepthAttachment.depthLoadOp = GPULoadOp.Load;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\t\t\tdepthAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\t\t\tdepthAttachment.stencilLoadOp = GPULoadOp.Clear;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdepthAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\t// shadow arrays - Execute bundles for each layer\n\n\t\tconst encoder = renderContextData.encoder;\n\n\t\tif ( this._isRenderCameraDepthArray( renderContext ) === true ) {\n\n\t\t  const bundles = [];\n\n\t\t  for ( let i = 0; i < renderContextData.bundleEncoders.length; i ++ ) {\n\n\t\t\t\tconst bundleEncoder = renderContextData.bundleEncoders[ i ];\n\t\t\t\tbundles.push( bundleEncoder.finish() );\n\n\t\t\t}\n\n\t\t  for ( let i = 0; i < renderContextData.layerDescriptors.length; i ++ ) {\n\n\t\t\t\tif ( i < bundles.length ) {\n\n\t\t\t\t\tconst layerDescriptor = renderContextData.layerDescriptors[ i ];\n\t\t\t\t\tconst renderPass = encoder.beginRenderPass( layerDescriptor );\n\n\t\t\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\t\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\t\t\t\t\t\trenderPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\t\t\t\t\t\trenderPass.setScissorRect( x, y, width, height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderPass.executeBundles( [ bundles[ i ] ] );\n\n\t\t\t\t\trenderPass.end();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( renderContextData.currentPass ) {\n\n\t\t  renderContextData.currentPass.end();\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Promise} A Promise that resolves when the occlusion query results have been processed.\n\t */\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] === BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst clearColor = super.getClearColor();\n\n\t\t// only premultiply alpha when alphaMode is \"premultiplied\"\n\n\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t}\n\n\t\treturn clearColor;\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.\n\t */\n\tclear( color, depth, stencil, renderTargetContext = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t}\n\n\t\tif ( renderTargetContext === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetContext.depth;\n\t\t\tsupportsStencil = renderTargetContext.stencil;\n\n\t\t\tconst clearConfig = {\n\t\t\t\tloadOp: color ? GPULoadOp.Clear : GPULoadOp.Load,\n\t\t\t\tclearValue: color ? clearValue : undefined\n\t\t\t};\n\n\t\t\tif ( supportsDepth ) {\n\n\t\t\t\tclearConfig.depthLoadOp = depth ? GPULoadOp.Clear : GPULoadOp.Load;\n\t\t\t\tclearConfig.depthClearValue = depth ? renderer.getClearDepth() : undefined;\n\t\t\t\tclearConfig.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsStencil ) {\n\n\t\t\t\tclearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;\n\t\t\t\tclearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : undefined;\n\t\t\t\tclearConfig.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tconst descriptor = this._getRenderPassDescriptor( renderTargetContext, clearConfig );\n\n\t\t\tcolorAttachments = descriptor.colorAttachments;\n\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t}\n\n\t\tif ( supportsDepth && depthStencilAttachment ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil && depthStencilAttachment ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'clear' } );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'computeGroup_' + computeGroup.id\n\t\t};\n\n\t\tthis.initTimestampQuery( computeGroup, descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder( { label: 'computeGroup_' + computeGroup.id } );\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {Array<number>|number} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline, dispatchSizeOrCount = null ) {\n\n\t\tconst computeNodeData = this.get( computeNode );\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\n\t\tthis.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tlet dispatchSize;\n\n\t\tif ( dispatchSizeOrCount === null ) {\n\n\t\t\tdispatchSizeOrCount = computeNode.count;\n\n\t\t}\n\n\t\tif ( typeof dispatchSizeOrCount === 'number' ) {\n\n\t\t\t// If a single number is given, we calculate the dispatch size based on the workgroup size\n\n\t\t\tconst count = dispatchSizeOrCount;\n\n\t\t\tif ( computeNodeData.dispatchSize === undefined || computeNodeData.count !== count ) {\n\n\t\t\t\t// cache dispatch size to avoid recalculating it every time\n\n\t\t\t\tcomputeNodeData.dispatchSize = [ 0, 1, 1 ];\n\t\t\t\tcomputeNodeData.count = count;\n\n\t\t\t\tconst workgroupSize = computeNode.workgroupSize;\n\n\t\t\t\tlet size = workgroupSize[ 0 ];\n\n\t\t\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\t\t\tsize *= workgroupSize[ i ];\n\n\t\t\t\tconst dispatchCount = Math.ceil( count / size );\n\n\t\t\t\t//\n\n\t\t\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\t\t\tdispatchSize = [ dispatchCount, 1, 1 ];\n\n\t\t\t\tif ( dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\t\t\tdispatchSize[ 0 ] = Math.min( dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\t\t\tdispatchSize[ 1 ] = Math.ceil( dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t\t\t}\n\n\t\t\t\tcomputeNodeData.dispatchSize = dispatchSize;\n\n\t\t\t}\n\n\t\t\tdispatchSize = computeNodeData.dispatchSize;\n\n\t\t} else {\n\n\t\t\tdispatchSize = dispatchSizeOrCount;\n\n\t\t}\n\n\t\t//\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize[ 0 ],\n\t\t\tdispatchSize[ 1 ] || 1,\n\t\t\tdispatchSize[ 2 ] || 1\n\t\t);\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, material, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\n\t\tconst index = renderObject.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tconst setPipelineAndBindings = ( passEncoderGPU, currentSets ) => {\n\n\t\t\t// pipeline\n\t\t\tthis.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t\t// bind groups\n\t\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\t\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\t\tconst bindGroup = bindings[ i ];\n\t\t\t\tconst bindingsData = this.get( bindGroup );\n\t\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// attributes\n\n\t\t\t// index\n\n\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\t\tcurrentSets.index = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// vertex buffers\n\n\t\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// stencil\n\n\t\t\tif ( context.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef ) {\n\n\t\t\t\tpassEncoderGPU.setStencilReference( material.stencilRef );\n\t\t\t\trenderContextData.currentStencilRef = material.stencilRef;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\t// Define draw function\n\t\tconst draw = ( passEncoderGPU, currentSets ) => {\n\n\t\t\tsetPipelineAndBindings( passEncoderGPU, currentSets );\n\n\t\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\t\tconst starts = object._multiDrawStarts;\n\t\t\t\tconst counts = object._multiDrawCounts;\n\t\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\t\tif ( drawInstances !== null ) {\n\n\t\t\t\t\t// @deprecated, r174\n\t\t\t\t\twarnOnce( 'THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpassEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo.update( object, counts[ i ], count );\n\n\t\t\t\t}\n\n\t\t\t} else if ( hasIndex === true ) {\n\n\t\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0 ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' );\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst bindingsData = this.get( cameraIndex );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tconst bindGroupIndex = this.bindingUtils.createBindGroupIndex( data, bindingsData.layout );\n\n\t\t\t\t\tindexesGPU.push( bindGroupIndex );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\n\n\t\t\t\t\tlet pass = renderContextData.currentPass;\n\t\t\t\t\tlet sets = renderContextData.currentSets;\n\t\t\t\t\tif ( renderContextData.bundleEncoders ) {\n\n\t\t\t\t\t\tconst bundleEncoder = renderContextData.bundleEncoders[ i ];\n\t\t\t\t\t\tconst bundleSets = renderContextData.bundleSets[ i ];\n\t\t\t\t\t\tpass = bundleEncoder;\n\t\t\t\t\t\tsets = bundleSets;\n\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif ( vp ) {\n\n\t\t\t\t\t\tpass.setViewport(\n\t\t\t\t\t\t\tMath.floor( vp.x * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.y * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.width * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.height * pixelRatio ),\n\t\t\t\t\t\t\tcontext.viewportValue.minDepth,\n\t\t\t\t\t\t\tcontext.viewportValue.maxDepth\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Set camera index binding for this layer\n\t\t\t\t\tif ( cameraIndex && cameraData.indexesGPU ) {\n\n\t\t\t\t\t\tpass.setBindGroup( cameraIndex.index, cameraData.indexesGPU[ i ] );\n\t\t\t\t\t\tsets.bindingGroups[ cameraIndex.index ] = cameraIndex.id;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdraw( pass, sets );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Regular single camera rendering\n\t\t\tif ( renderContextData.currentPass ) {\n\n\t\t\t\t// Handle occlusion queries\n\t\t\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\t\t\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\t\t\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\t\t\trenderContextData.currentPass.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdraw( renderContextData.currentPass, renderContextData.currentSets );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} descriptor - The query descriptor.\n\t */\n\tinitTimestampQuery( renderContext, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGPUTimestampQueryPool( this.device, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );\n\n\t\tdescriptor.timestampWrites = {\n\t\t\tquerySet: timestampQueryPool.querySet,\n\t\t\tbeginningOfPassWriteIndex: baseOffset,\n\t\t\tendOfPassWriteIndex: baseOffset + 1,\n\t\t  };\n\n\t}\n\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {WGSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage + ( program.name !== '' ? `_${ program.name }` : '' ) } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\t/**\n\t * Prepares the state for encoding render bundles.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\t/**\n\t * After processing render bundles this method finalizes related work.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle.\n\t */\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\t/**\n\t * Adds a render bundle to the render context data.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle to add.\n\t */\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tlet usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\tusage |= GPUBufferUsage.STORAGE;\n\n\t\t}\n\n\t\tthis.attributeUtils.createAttribute( attribute, usage );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of an indirect storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\t/**\n\t * Triggers an update of the default render pass descriptor.\n\t */\n\tupdateSize() {\n\n\t\tthis.colorBuffer = this.textureUtils.getColorBuffer();\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t}\n\n\t// utils public\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The mipmap level to copy.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstZ = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcZ = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\t\tlet srcDepth = 1;\n\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tif ( srcRegion.isBox3 === true ) {\n\n\t\t\t\tsrcX = srcRegion.min.x;\n\t\t\t\tsrcY = srcRegion.min.y;\n\t\t\t\tsrcZ = srcRegion.min.z;\n\t\t\t\tsrcWidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\tsrcHeight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tsrcDepth = srcRegion.max.z - srcRegion.min.z;\n\n\t\t\t} else {\n\n\t\t\t\t// Assume it's a Box2\n\t\t\t\tsrcX = srcRegion.min.x;\n\t\t\t\tsrcY = srcRegion.min.y;\n\t\t\t\tsrcWidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\tsrcHeight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tsrcDepth = 1;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstZ = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: srcLevel,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcZ }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: dstLevel,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstZ }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\tsrcDepth\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\tif ( dstLevel === 0 && dstTexture.generateMipmaps ) {\n\n\t\t\tthis.textureUtils.generateMipmaps( dstTexture );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\tconsole.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\trenderContextData.currentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) {\n\n\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t}\n\n\t}\n\n}\n\nexport default WebGPUBackend;\n"],"mappings":"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","ignoreList":[]}