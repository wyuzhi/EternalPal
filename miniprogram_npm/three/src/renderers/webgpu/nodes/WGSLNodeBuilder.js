import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import NodeSampler from"../../common/nodes/NodeSampler.js";import{NodeSampledTexture,NodeSampledCubeTexture,NodeSampledTexture3D}from"../../common/nodes/NodeSampledTexture.js";import NodeUniformBuffer from"../../common/nodes/NodeUniformBuffer.js";import NodeStorageBuffer from"../../common/nodes/NodeStorageBuffer.js";import{NodeBuilder,CodeNode}from"../../../nodes/Nodes.js";import{getFormat}from"../utils/WebGPUTextureUtils.js";import WGSLNodeParser from"./WGSLNodeParser.js";import{NodeAccess}from"../../../nodes/core/constants.js";import VarNode from"../../../nodes/core/VarNode.js";import ExpressionNode from"../../../nodes/code/ExpressionNode.js";import{FloatType,RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping,NearestFilter}from"../../../constants.js";const GPUShaderStage="undefined"!=typeof self?self.GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4},accessNames={[NodeAccess.READ_ONLY]:"read",[NodeAccess.WRITE_ONLY]:"write",[NodeAccess.READ_WRITE]:"read_write"},wrapNames={[RepeatWrapping]:"repeat",[ClampToEdgeWrapping]:"clamp",[MirroredRepeatWrapping]:"mirror"},gpuShaderStageLib={vertex:GPUShaderStage?GPUShaderStage.VERTEX:1,fragment:GPUShaderStage?GPUShaderStage.FRAGMENT:2,compute:GPUShaderStage?GPUShaderStage.COMPUTE:4},supports={instance:!0,swizzleAssign:!1,storageBuffer:!0},wgslFnOpLib={"^^":"tsl_xor"},wgslTypeLib={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},wgslCodeCache={},wgslPolyfill={tsl_xor:new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping_float:new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),mirrorWrapping_float:new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),clampWrapping_float:new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),biquadraticTexture:new CodeNode("\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n")},wgslMethods={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"tsl_mod_float",mod_vec2:"tsl_mod_vec2",mod_vec3:"tsl_mod_vec3",mod_vec4:"tsl_mod_vec4",equals_bool:"tsl_equals_bool",equals_bvec2:"tsl_equals_bvec2",equals_bvec3:"tsl_equals_bvec3",equals_bvec4:"tsl_equals_bvec4",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"};"undefined"!=typeof navigator&&/Windows/g.test(navigator.userAgent)&&(wgslPolyfill.pow_float=new CodeNode("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),wgslPolyfill.pow_vec2=new CodeNode("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[wgslPolyfill.pow_float]),wgslPolyfill.pow_vec3=new CodeNode("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[wgslPolyfill.pow_float]),wgslPolyfill.pow_vec4=new CodeNode("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[wgslPolyfill.pow_float]),wgslMethods.pow_float="tsl_pow_float",wgslMethods.pow_vec2="tsl_pow_vec2",wgslMethods.pow_vec3="tsl_pow_vec3",wgslMethods.pow_vec4="tsl_pow_vec4");let diagnostics="";!0!==("undefined"!=typeof navigator&&/Firefox|Deno/g.test(navigator.userAgent))&&(diagnostics+="diagnostic( off, derivative_uniformity );\n");class WGSLNodeBuilder extends NodeBuilder{constructor(e,t){super(e,t,new WGSLNodeParser),this.uniformGroups={},this.builtins={},this.directives={},this.scopedArrays=new Map}_generateTextureSample(e,t,r,n,o=this.shaderStage){return"fragment"===o?n?`textureSample( ${t}, ${t}_sampler, ${r}, ${n} )`:`textureSample( ${t}, ${t}_sampler, ${r} )`:this.generateTextureSampleLevel(e,t,r,"0",n)}generateTextureSampleLevel(e,t,r,n,o){return!1===this.isUnfilterable(e)?`textureSampleLevel( ${t}, ${t}_sampler, ${r}, ${n} )`:this.isFilteredTexture(e)?this.generateFilteredTexture(e,t,r,n):this.generateTextureLod(e,t,r,o,n)}generateWrapFunction(e){const t=`tsl_coord_${wrapNames[e.wrapS]}S_${wrapNames[e.wrapT]}_${e.isData3DTexture?"3d":"2d"}T`;let r=wgslCodeCache[t];if(void 0===r){const n=[],o=e.isData3DTexture?"vec3f":"vec2f";let s=`fn ${t}( coord : ${o} ) -> ${o} {\n\n\treturn ${o}(\n`;const i=(e,t)=>{e===RepeatWrapping?(n.push(wgslPolyfill.repeatWrapping_float),s+=`\t\ttsl_repeatWrapping_float( coord.${t} )`):e===ClampToEdgeWrapping?(n.push(wgslPolyfill.clampWrapping_float),s+=`\t\ttsl_clampWrapping_float( coord.${t} )`):e===MirroredRepeatWrapping?(n.push(wgslPolyfill.mirrorWrapping_float),s+=`\t\ttsl_mirrorWrapping_float( coord.${t} )`):(s+=`\t\tcoord.${t}`,console.warn(`WebGPURenderer: Unsupported texture wrap type "${e}" for vertex shader.`))};i(e.wrapS,"x"),s+=",\n",i(e.wrapT,"y"),e.isData3DTexture&&(s+=",\n",i(e.wrapR,"z")),s+="\n\t);\n\n}\n",wgslCodeCache[t]=r=new CodeNode(s,n)}return r.build(this),t}generateArrayDeclaration(e,t){return`array< ${this.getType(e)}, ${t} >`}generateTextureDimension(e,t,r){const n=this.getDataFromNode(e,this.shaderStage,this.globalCache);void 0===n.dimensionsSnippet&&(n.dimensionsSnippet={});let o=n.dimensionsSnippet[r];if(void 0===n.dimensionsSnippet[r]){let s,i;const{primarySamples:a}=this.renderer.backend.utils.getTextureSampleData(e),u=a>1;i=e.isData3DTexture?"vec3<u32>":"vec2<u32>",s=u||e.isStorageTexture?t:`${t}${r?`, u32( ${r} )`:""}`,o=new VarNode(new ExpressionNode(`textureDimensions( ${s} )`,i)),n.dimensionsSnippet[r]=o,(e.isArrayTexture||e.isDataArrayTexture||e.isData3DTexture)&&(n.arrayLayerCount=new VarNode(new ExpressionNode(`textureNumLayers(${t})`,"u32"))),e.isTextureCube&&(n.cubeFaceCount=new VarNode(new ExpressionNode("6u","u32")))}return o.build(this)}generateFilteredTexture(e,t,r,n="0u"){this._include("biquadraticTexture");return`tsl_biquadraticTexture( ${t}, ${this.generateWrapFunction(e)}( ${r} ), ${this.generateTextureDimension(e,t,n)}, u32( ${n} ) )`}generateTextureLod(e,t,r,n,o="0u"){const s=this.generateWrapFunction(e),i=this.generateTextureDimension(e,t,o),a=e.isData3DTexture?"vec3":"vec2",u=`${a}<u32>( ${s}( ${r} ) * ${a}<f32>( ${i} ) )`;return this.generateTextureLoad(e,t,u,n,o)}generateTextureLoad(e,t,r,n,o="0u"){let s;return n?s=`textureLoad( ${t}, ${r}, ${n}, u32( ${o} ) )`:(s=`textureLoad( ${t}, ${r}, u32( ${o} ) )`,this.renderer.backend.compatibilityMode&&e.isDepthTexture&&(s+=".x")),s}generateTextureStore(e,t,r,n,o){let s;return s=n?`textureStore( ${t}, ${r}, ${n}, ${o} )`:`textureStore( ${t}, ${r}, ${o} )`,s}isSampleCompare(e){return!0===e.isDepthTexture&&null!==e.compareFunction}isUnfilterable(e){return"float"!==this.getComponentTypeFromTexture(e)||!this.isAvailable("float32Filterable")&&!0===e.isDataTexture&&e.type===FloatType||!1===this.isSampleCompare(e)&&e.minFilter===NearestFilter&&e.magFilter===NearestFilter||this.renderer.backend.utils.getTextureSampleData(e).primarySamples>1}generateTexture(e,t,r,n,o=this.shaderStage){let s=null;return s=this.isUnfilterable(e)?this.generateTextureLod(e,t,r,n,"0",o):this._generateTextureSample(e,t,r,n,o),s}generateTextureGrad(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return`textureSampleGrad( ${t}, ${t}_sampler, ${r},  ${n[0]}, ${n[1]} )`;console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${s} shader.`)}generateTextureCompare(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return!0===e.isDepthTexture&&!0===e.isArrayTexture?`textureSampleCompare( ${t}, ${t}_sampler, ${r}, ${o}, ${n} )`:`textureSampleCompare( ${t}, ${t}_sampler, ${r}, ${n} )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${s} shader.`)}generateTextureLevel(e,t,r,n,o){return!1===this.isUnfilterable(e)?`textureSampleLevel( ${t}, ${t}_sampler, ${r}, ${n} )`:this.isFilteredTexture(e)?this.generateFilteredTexture(e,t,r,n):this.generateTextureLod(e,t,r,o,n)}generateTextureBias(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return`textureSampleBias( ${t}, ${t}_sampler, ${r}, ${n} )`;console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${s} shader.`)}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`varyings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,r=e.type;return"texture"===r||"cubeTexture"===r||"storageTexture"===r||"texture3D"===r?t:"buffer"===r||"storageBuffer"===r||"indirectStorageBuffer"===r?this.isCustomStruct(e)?t:t+".value":e.groupNode.name+"."+t}return super.getPropertyName(e)}getOutputStructName(){return"output"}getFunctionOperator(e){const t=wgslFnOpLib[e];return void 0!==t?(this._include(t),t):null}getNodeAccess(e,t){return"compute"!==t?!0===e.isAtomic?(console.warn("WebGPURenderer: Atomic operations are only supported in compute shaders."),NodeAccess.READ_WRITE):NodeAccess.READ_ONLY:e.access}getStorageAccess(e,t){return accessNames[this.getNodeAccess(e,t)]}getUniformFromNode(e,t,r,n=null){const o=super.getUniformFromNode(e,t,r,n),s=this.getDataFromNode(e,r,this.globalCache);if(void 0===s.uniformGPU){let i;const a=e.groupNode,u=a.name,l=this.getBindGroupArray(u,r);if("texture"===t||"cubeTexture"===t||"storageTexture"===t||"texture3D"===t){let n=null;const s=this.getNodeAccess(e,r);if("texture"===t||"storageTexture"===t?n=!0===e.value.is3DTexture?new NodeSampledTexture3D(o.name,o.node,a,s):new NodeSampledTexture(o.name,o.node,a,s):"cubeTexture"===t?n=new NodeSampledCubeTexture(o.name,o.node,a,s):"texture3D"===t&&(n=new NodeSampledTexture3D(o.name,o.node,a,s)),n.store=!0===e.isStorageTextureNode,n.setVisibility(gpuShaderStageLib[r]),!1===this.isUnfilterable(e.value)&&!1===n.store){const e=new NodeSampler(`${o.name}_sampler`,o.node,a);e.setVisibility(gpuShaderStageLib[r]),l.push(e,n),i=[e,n]}else l.push(n),i=[n]}else if("buffer"===t||"storageBuffer"===t||"indirectStorageBuffer"===t){const s=new("buffer"===t?NodeUniformBuffer:NodeStorageBuffer)(e,a);s.setVisibility(gpuShaderStageLib[r]),l.push(s),i=s,o.name=n||"NodeBuffer_"+o.id}else{const e=this.uniformGroups[r]||(this.uniformGroups[r]={});let n=e[u];void 0===n&&(n=new NodeUniformsGroup(u,a),n.setVisibility(gpuShaderStageLib[r]),e[u]=n,l.push(n)),i=this.getNodeUniform(o,t),n.addUniform(i)}s.uniformGPU=i}return o}getBuiltin(e,t,r,n=this.shaderStage){const o=this.builtins[n]||(this.builtins[n]=new Map);return!1===o.has(e)&&o.set(e,{name:e,property:t,type:r}),t}hasBuiltin(e,t=this.shaderStage){return void 0!==this.builtins[t]&&this.builtins[t].has(e)}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(e){const t=e.layout,r=this.flowShaderNode(e),n=[];for(const e of t.inputs)n.push(e.name+" : "+this.getType(e.type));let o=`fn ${t.name}( ${n.join(", ")} ) -> ${this.getType(t.type)} {\n${r.vars}\n${r.code}\n`;return r.result&&(o+=`\treturn ${r.result};\n`),o+="\n}\n",o}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getInvocationLocalIndex(){return this.getBuiltin("local_invocation_index","invocationLocalIndex","u32","attribute")}getSubgroupSize(){return this.enableSubGroups(),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute")}getInvocationSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_invocation_id","invocationSubgroupIndex","u32","attribute")}getSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_id","subgroupIndex","u32","attribute")}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}getClipDistance(){return"varyings.hw_clip_distances"}isFlipY(){return!1}enableDirective(e,t=this.shaderStage){(this.directives[t]||(this.directives[t]=new Set)).add(e)}getDirectives(e){const t=[],r=this.directives[e];if(void 0!==r)for(const e of r)t.push(`enable ${e};`);return t.join("\n")}enableSubGroups(){this.enableDirective("subgroups")}enableSubgroupsF16(){this.enableDirective("subgroups-f16")}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}enableHardwareClipping(e){this.enableClipDistances(),this.getBuiltin("clip_distances","hw_clip_distances",`array<f32, ${e} >`,"vertex")}getBuiltins(e){const t=[],r=this.builtins[e];if(void 0!==r)for(const{name:e,property:n,type:o}of r.values())t.push(`@builtin( ${e} ) ${n} : ${o}`);return t.join(",\n\t")}getScopedArray(e,t,r,n){return!1===this.scopedArrays.has(e)&&this.scopedArrays.set(e,{name:e,scope:t,bufferType:r,bufferCount:n}),e}getScopedArrays(e){if("compute"!==e)return;const t=[];for(const{name:e,scope:r,bufferType:n,bufferCount:o}of this.scopedArrays.values()){const s=this.getType(n);t.push(`var<${r}> ${e}: array< ${s}, ${o} >;`)}return t.join("\n")}getAttributes(e){const t=[];if("compute"===e&&(this.getBuiltin("global_invocation_id","globalId","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute"),this.renderer.hasFeature("subgroups")&&(this.enableDirective("subgroups",e),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute"))),"vertex"===e||"compute"===e){const e=this.getBuiltins("attribute");e&&t.push(e);const r=this.getAttributesArray();for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,s=this.getType(n.type);t.push(`@location( ${e} ) ${o} : ${s}`)}}return t.join(",\n\t")}getStructMembers(e){const t=[];for(const r of e.members){const n=e.output?"@location( "+r.index+" ) ":"";let o=this.getType(r.type);r.atomic&&(o="atomic< "+o+" >"),t.push(`\t${n+r.name} : ${o}`)}return e.output&&t.push(`\t${this.getBuiltins("output")}`),t.join(",\n")}getStructs(e){let t="";const r=this.structs[e];if(r.length>0){const e=[];for(const t of r){let r=`struct ${t.name} {\n`;r+=this.getStructMembers(t),r+="\n};",e.push(r)}t="\n"+e.join("\n\n")+"\n"}return t}getVar(e,t,r=null){let n=`var ${t} : `;return n+=null!==r?this.generateArrayDeclaration(e,r):this.getType(e),n}getVars(e){const t=[],r=this.vars[e];if(void 0!==r)for(const e of r)t.push(`\t${this.getVar(e.type,e.name,e.count)};`);return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const r=this.varyings,n=this.vars[e];for(let o=0;o<r.length;o++){const s=r[o];if(s.needsInterpolation){let e=`@location( ${o} )`;if(s.interpolationType){const t=null!==s.interpolationSampling?`, ${s.interpolationSampling} )`:" )";e+=` @interpolate( ${s.interpolationType}${t}`}else/^(int|uint|ivec|uvec)/.test(s.type)&&(e+=` @interpolate( ${this.renderer.backend.compatibilityMode?"flat, either":"flat"} )`);t.push(`${e} ${s.name} : ${this.getType(s.type)}`)}else"vertex"===e&&!1===n.includes(s)&&n.push(s)}}const r=this.getBuiltins(e);r&&t.push(r);const n=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("VaryingsStruct","\t"+n):n}isCustomStruct(e){const t=e.value,r=e.node,n=(t.isBufferAttribute||t.isInstancedBufferAttribute)&&null!==r.structTypeNode,o=r.value&&r.value.array&&"number"==typeof r.value.itemSize&&r.value.array.length>r.value.itemSize;return n&&!o}getUniforms(e){const t=this.uniforms[e],r=[],n=[],o=[],s={};for(const o of t){const t=o.groupNode.name,i=this.bindingsIndexes[t];if("texture"===o.type||"cubeTexture"===o.type||"storageTexture"===o.type||"texture3D"===o.type){const t=o.node.value;let n;!1===this.isUnfilterable(t)&&!0!==o.node.isStorageTextureNode&&(this.isSampleCompare(t)?r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name}_sampler : sampler_comparison;`):r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name}_sampler : sampler;`));let s="";const{primarySamples:a}=this.renderer.backend.utils.getTextureSampleData(t);if(a>1&&(s="_multisampled"),!0===t.isCubeTexture)n="texture_cube<f32>";else if(!0===t.isDepthTexture)n=this.renderer.backend.compatibilityMode&&null===t.compareFunction?`texture${s}_2d<f32>`:`texture_depth${s}_2d${!0===t.isArrayTexture?"_array":""}`;else if(!0===o.node.isStorageTextureNode){const r=getFormat(t),s=this.getStorageAccess(o.node,e),i=o.node.value.is3DTexture,a=o.node.value.isArrayTexture;n=`texture_storage_${i?"3d":"2d"+(a?"_array":"")}<${r}, ${s}>`}else if(!0===t.isArrayTexture||!0===t.isDataArrayTexture||!0===t.isCompressedArrayTexture)n="texture_2d_array<f32>";else if(!0===t.is3DTexture||!0===t.isData3DTexture)n="texture_3d<f32>";else{n=`texture${s}_2d<${this.getComponentTypeFromTexture(t).charAt(0)}32>`}r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name} : ${n};`)}else if("buffer"===o.type||"storageBuffer"===o.type||"indirectStorageBuffer"===o.type){const t=o.node,r=this.getType(t.getNodeType(this)),s=t.bufferCount,a=s>0&&"buffer"===o.type?", "+s:"",u=t.isStorageBufferNode?`storage, ${this.getStorageAccess(t,e)}`:"uniform";if(this.isCustomStruct(o))n.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var<${u}> ${o.name} : ${r};`);else{const e=`\tvalue : array< ${t.isAtomic?`atomic<${r}>`:`${r}`}${a} >`;n.push(this._getWGSLStructBinding(o.name,e,u,i.binding++,i.group))}}else{const e=this.getType(this.getVectorType(o.type)),t=o.groupNode.name;(s[t]||(s[t]={index:i.binding++,id:i.group,snippets:[]})).snippets.push(`\t${o.name} : ${e}`)}}for(const e in s){const t=s[e];o.push(this._getWGSLStructBinding(e,t.snippets.join(",\n"),"uniform",t.index,t.id))}let i=r.join("\n");return i+=n.join("\n"),i+=o.join("\n"),i}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){this.shaderStage=t;const r=e[t];r.uniforms=this.getUniforms(t),r.attributes=this.getAttributes(t),r.varyings=this.getVaryings(t),r.structs=this.getStructs(t),r.vars=this.getVars(t),r.codes=this.getCodes(t),r.directives=this.getDirectives(t),r.scopedArrays=this.getScopedArrays(t);let n="// code\n\n";n+=this.flowCode[t];const o=this.flowNodes[t],s=o[o.length-1],i=s.outputNode,a=void 0!==i&&!0===i.isOutputStructNode;for(const e of o){const o=this.getFlowData(e),u=e.name;if(u&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${u}\n`),n+=`${o.code}\n\t`,e===s&&"compute"!==t)if(n+="// result\n\n\t","vertex"===t)n+=`varyings.Vertex = ${o.result};`;else if("fragment"===t)if(a)r.returnType=i.getNodeType(this),r.structs+="var<private> output : "+r.returnType+";",n+=`return ${o.result};`;else{let e="\t@location(0) color: vec4<f32>";const t=this.getBuiltins("output");t&&(e+=",\n\t"+t),r.returnType="OutputStruct",r.structs+=this._getWGSLStruct("OutputStruct",e),r.structs+="\nvar<private> output : OutputStruct;",n+=`output.color = ${o.result};\n\n\treturn output;`}}r.flow=n}if(this.shaderStage=null,null!==this.material)this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment);else{const t=this.object.workgroupSize;this.computeShader=this._getWGSLComputeCode(e.compute,t)}}getMethod(e,t=null){let r;return null!==t&&(r=this._getWGSLMethod(e+"_"+t)),void 0===r&&(r=this._getWGSLMethod(e)),r||e}getType(e){return wgslTypeLib[e]||e}isAvailable(e){let t=supports[e];return void 0===t&&("float32Filterable"===e?t=this.renderer.hasFeature("float32-filterable"):"clipDistance"===e&&(t=this.renderer.hasFeature("clip-distances")),supports[e]=t),t}_getWGSLMethod(e){return void 0!==wgslPolyfill[e]&&this._include(e),wgslMethods[e]}_include(e){const t=wgslPolyfill[e];return t.build(this),null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(t),t}_getWGSLVertexCode(e){return`${this.getSignature()}\n// directives\n${e.directives}\n\n// structs\n${e.structs}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n// global\n${diagnostics}\n\n// structs\n${e.structs}\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> ${e.returnType} {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){const[r,n,o]=t;return`${this.getSignature()}\n// directives\n${e.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${e.scopedArrays}\n\n// structs\n${e.structs}\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${r}, ${n}, ${o} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = globalId.x\n\t\t+ globalId.y * ( ${r} * numWorkgroups.x )\n\t\t+ globalId.z * ( ${r} * numWorkgroups.x ) * ( ${n} * numWorkgroups.y );\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,r,n=0,o=0){const s=e+"Struct";return`${this._getWGSLStruct(s,t)}\n@binding( ${n} ) @group( ${o} )\nvar<${r}> ${e} : ${s};`}}export default WGSLNodeBuilder;
//# sourceMappingURL=WGSLNodeBuilder.js.map