{"version":3,"file":"node_modules/three/src/renderers/webgpu/nodes/WGSLNodeBuilder.js","names":["NodeUniformsGroup","NodeSampler","NodeSampledTexture","NodeSampledCubeTexture","NodeSampledTexture3D","NodeUniformBuffer","NodeStorageBuffer","NodeBuilder","CodeNode","getFormat","WGSLNodeParser","NodeAccess","VarNode","ExpressionNode","FloatType","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","GPUShaderStage","self","VERTEX","FRAGMENT","COMPUTE","accessNames","READ_ONLY","WRITE_ONLY","READ_WRITE","wrapNames","gpuShaderStageLib","vertex","fragment","compute","supports","instance","swizzleAssign","storageBuffer","wgslFnOpLib","wgslTypeLib","float","int","uint","bool","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","wgslCodeCache","wgslPolyfill","tsl_xor","mod_float","mod_vec2","mod_vec3","mod_vec4","equals_bool","equals_bvec2","equals_bvec3","equals_bvec4","repeatWrapping_float","mirrorWrapping_float","clampWrapping_float","biquadraticTexture","wgslMethods","dFdx","dFdy","inversesqrt","bitcast","navigator","test","userAgent","pow_float","pow_vec2","pow_vec3","pow_vec4","diagnostics","WGSLNodeBuilder","constructor","object","renderer","super","this","uniformGroups","builtins","directives","scopedArrays","Map","_generateTextureSample","texture","textureProperty","uvSnippet","depthSnippet","shaderStage","generateTextureSampleLevel","levelSnippet","isUnfilterable","isFilteredTexture","generateFilteredTexture","generateTextureLod","generateWrapFunction","functionName","wrapS","wrapT","isData3DTexture","nodeCode","undefined","includes","coordType","code","addWrapSnippet","wrap","axis","push","console","warn","wrapR","build","generateArrayDeclaration","type","count","getType","generateTextureDimension","textureData","getDataFromNode","globalCache","dimensionsSnippet","textureDimensionNode","textureDimensionsParams","dimensionType","primarySamples","backend","utils","getTextureSampleData","isMultisampled","isStorageTexture","isArrayTexture","isDataArrayTexture","arrayLayerCount","isTextureCube","cubeFaceCount","_include","wrapFunction","textureDimension","vecType","coordSnippet","generateTextureLoad","uvIndexSnippet","snippet","compatibilityMode","isDepthTexture","generateTextureStore","valueSnippet","isSampleCompare","compareFunction","getComponentTypeFromTexture","isAvailable","isDataTexture","minFilter","magFilter","generateTexture","generateTextureGrad","gradSnippet","error","generateTextureCompare","compareSnippet","generateTextureLevel","generateTextureBias","biasSnippet","getPropertyName","node","isNodeVarying","needsInterpolation","name","isNodeUniform","isCustomStruct","groupNode","getOutputStructName","getFunctionOperator","op","fnOp","getNodeAccess","isAtomic","access","getStorageAccess","getUniformFromNode","uniformNode","nodeData","uniformGPU","group","groupName","bindings","getBindGroupArray","value","is3DTexture","store","isStorageTextureNode","setVisibility","sampler","buffer","id","uniformsStage","uniformsGroup","getNodeUniform","addUniform","getBuiltin","property","map","has","set","hasBuiltin","getVertexIndex","buildFunctionCode","shaderNode","layout","flowData","flowShaderNode","parameters","input","inputs","join","vars","result","getInstanceIndex","getInvocationLocalIndex","getSubgroupSize","enableSubGroups","getInvocationSubgroupIndex","getSubgroupIndex","getDrawIndex","getFrontFacing","getFragCoord","getFragDepth","getClipDistance","isFlipY","enableDirective","Set","add","getDirectives","snippets","directive","enableSubgroupsF16","enableClipDistances","enableShaderF16","enableDualSourceBlending","enableHardwareClipping","planeCount","getBuiltins","values","getScopedArray","scope","bufferType","bufferCount","getScopedArrays","getAttributes","hasFeature","attributes","getAttributesArray","index","length","attribute","getStructMembers","struct","member","members","prefix","output","atomic","getStructs","structs","getVar","getVars","variable","getVaryings","varyings","varying","attributesSnippet","interpolationType","samplingSnippet","interpolationSampling","_getWGSLStruct","nodeUniform","bufferNode","isAttributeStructType","isBufferAttribute","isInstancedBufferAttribute","structTypeNode","isStructArray","array","itemSize","getUniforms","uniforms","bindingSnippets","bufferSnippets","structSnippets","uniform","uniformIndexes","bindingsIndexes","textureType","binding","multisampled","isCubeTexture","format","is3D","isCompressedArrayTexture","charAt","getNodeType","bufferCountSnippet","bufferAccessMode","isStorageBufferNode","bufferSnippet","_getWGSLStructBinding","vectorType","getVectorType","buildCode","shadersData","material","sortBindingGroups","stageData","codes","getCodes","flow","flowCode","flowNodes","mainNode","outputNode","isOutputStruct","isOutputStructNode","flowSlotData","getFlowData","slotName","returnType","structSnippet","vertexShader","_getWGSLVertexCode","fragmentShader","_getWGSLFragmentCode","workgroupSize","computeShader","_getWGSLComputeCode","getMethod","method","wgslMethod","_getWGSLMethod","codeNode","currentFunctionNode","shaderData","getSignature","workgroupSizeX","workgroupSizeY","workgroupSizeZ","structName"],"sources":["node_modules/three/src/renderers/webgpu/nodes/WGSLNodeBuilder.js"],"sourcesContent":["import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';\n\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture, NodeSampledTexture3D } from '../../common/nodes/NodeSampledTexture.js';\n\nimport NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';\nimport NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';\n\nimport { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';\n\nimport { getFormat } from '../utils/WebGPUTextureUtils.js';\n\nimport WGSLNodeParser from './WGSLNodeParser.js';\nimport { NodeAccess } from '../../../nodes/core/constants.js';\n\nimport VarNode from '../../../nodes/core/VarNode.js';\nimport ExpressionNode from '../../../nodes/code/ExpressionNode.js';\n\nimport { FloatType, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter } from '../../../constants.js';\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n/**\n * A node builder targeting WGSL.\n *\n * This module generates WGSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new WGSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of builtins.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.builtins = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Set of directives.\n\t\t *\n\t\t * @type {Object<string,Set<string>>}\n\t\t */\n\t\tthis.directives = {};\n\n\t\t/**\n\t\t * A map for managing scope arrays. Only relevant for when using\n\t\t * {@link WorkgroupInfoNode} in context of compute shaders.\n\t\t *\n\t\t * @type {Map<string,Object>}\n\t\t */\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampled textures.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureSampleLevel( texture, textureProperty, uvSnippet, '0', depthSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet ) {\n\n\t\tif ( this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates a wrap function used in context of textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @return {string} The name of the generated function.\n\t */\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${ texture.isData3DTexture ? '3d' : '2d' }T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\t// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n\t\t\tconst coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n\t\t\tlet code = `fn ${ functionName }( coord : ${ coordType } ) -> ${ coordType } {\\n\\n\\treturn ${ coordType }(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tcode += ',\\n';\n\t\t\t\taddWrapSnippet( texture.wrapR, 'z' );\n\n\t\t\t}\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn `array< ${ this.getType( type ) }, ${ count } >`;\n\n\t}\n\n\t/**\n\t * Generates a WGSL variable that holds the texture dimension of the given texture.\n\t * It also returns information about the number of layers (elements) of an arrayed\n\t * texture as well as the cube face count of cube textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @param {string} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The name of the dimension variable.\n\t */\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\t\t\tlet dimensionType;\n\n\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\t\t\tconst isMultisampled = primarySamples > 1;\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tdimensionType = 'vec3<u32>';\n\n\t\t\t} else {\n\n\t\t\t\t// Regular 2D textures, depth textures, etc.\n\t\t\t\tdimensionType = 'vec2<u32>';\n\n\t\t\t}\n\n\t\t\t// Build parameters string based on texture type and multisampling\n\t\t\tif ( isMultisampled || texture.isStorageTexture ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t\tif ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\t\ttextureData.arrayLayerCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode(\n\t\t\t\t\t\t`textureNumLayers(${textureProperty})`,\n\t\t\t\t\t\t'u32'\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// For cube textures, we know it's always 6 faces\n\t\t\tif ( texture.isTextureCube ) {\n\n\t\t\t\ttextureData.cubeFaceCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode( '6u', 'u32' )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a manual filtered texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.\n\t * Since it's a lookup, no sampling or filtering is applied.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n\t\tconst coordSnippet = `${ vecType }<u32>( ${ wrapFunction }( ${ uvSnippet } ) * ${ vecType }<f32>( ${ textureDimension } ) )`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tlet snippet;\n\n\t\tif ( depthSnippet ) {\n\n\t\t\tsnippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tsnippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t\tif ( this.renderer.backend.compatibilityMode && texture.isDepthTexture ) {\n\n\t\t\t\tsnippet += '.x';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that writes a single texel to a texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet ) {\n\n\t\tlet snippet;\n\n\t\tif ( depthSnippet ) {\n\n\t\t\tsnippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, ${ valueSnippet } )`;\n\n\t\t} else {\n\n\t\t\tsnippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sampled values of the given texture should be compared against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.\n\t */\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is unfilterable.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the given texture is unfilterable or not.\n\t */\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\tthis.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( texture.isDepthTexture === true && texture.isArrayTexture === true ) {\n\n\t\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet ) {\n\n\t\tif ( this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a WGSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tif ( this.isCustomStruct( node ) ) {\n\n\t\t\t\t\treturn name;\n\n\t\t\t\t}\n\n\t\t\t\treturn name + '.value';\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name.\n\t *\n\t * @return {string} The name of the output struct.\n\t */\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t *\n\t * @param {string} op - The operator name to resolve.\n\t * @return {?string} The resolved operator name.\n\t */\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the node access for the given node and shader stage.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The node access.\n\t */\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\tif ( node.isAtomic === true ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Atomic operations are only supported in compute shaders.' );\n\n\t\t\t\treturn NodeAccess.READ_WRITE;\n\n\t\t\t}\n\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\t}\n\n\t\treturn node.access;\n\n\t}\n\n\t/**\n\t * Returns A WGSL snippet representing the storage access.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet representing the storage access.\n\t */\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\tif ( node.value.is3DTexture === true ) {\n\n\t\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${ uniformNode.name }_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t\tuniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\t/**\n\t * This method should be used whenever builtins are required in nodes.\n\t * The internal builtins data structure will make sure builtins are\n\t * defined in the WGSL source.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} property - The property name.\n\t * @param {string} type - The node data type.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given builtin is defined in the given shader stage.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {boolean} Whether the given builtin is defined in the given shader stage or not.\n\t */\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The WGSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the instance index builtin.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\t/**\n\t * Returns the invocation local index builtin.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup size builtin.\n\t *\n\t * @return {string} The subgroup size.\n\t */\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the invocation subgroup index builtin.\n\t *\n\t * @return {string} The invocation subgroup index.\n\t */\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns the subgroup index builtin.\n\t *\n\t * @return {string} The subgroup index.\n\t */\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Overwritten as a NOP since this method is intended for the WebGL 2 backend.\n\t *\n\t * @return {null} Null.\n\t */\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `false` in context of WGSL.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Enables the given directive for the given shader stage.\n\t *\n\t * @param {string} name - The directive name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.\n\t */\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\t/**\n\t * Returns the directives of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that enables the directives of the given stage.\n\t */\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups' directive.\n\t */\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups-f16' directive.\n\t */\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'clip_distances' directive.\n\t */\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\t/**\n\t * Enables the 'f16' directive.\n\t */\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'dual_source_blending' directive.\n\t */\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\t/**\n\t * Returns the builtins of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that represents the builtins of the given stage.\n\t */\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * This method should be used when a new scoped buffer is used in context of\n\t * compute shaders. It adds the array to the internal data structure which is\n\t * later used to generate the respective WGSL.\n\t *\n\t * @param {string} name - The array name.\n\t * @param {string} scope - The scope.\n\t * @param {string} bufferType - The buffer type.\n\t * @param {string} bufferCount - The buffer count.\n\t * @return {string} The array name.\n\t */\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Returns the scoped arrays of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string|undefined} The WGSL snippet that defines the scoped arrays.\n\t * Returns `undefined` when used in the vertex or fragment stage.\n\t */\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'globalId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a WGSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The WGSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tconst prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';\n\n\t\t\tlet type = this.getType( member.type );\n\n\t\t\tif ( member.atomic ) {\n\n\t\t\t\ttype = 'atomic< ' + type + ' >';\n\n\t\t\t}\n\n\t\t\tsnippets.push( `\\t${ prefix + member.name } : ${ type }` );\n\n\t\t}\n\n\t\tif ( struct.output ) {\n\n\t\t\tsnippets.push( `\\t${ this.getBuiltins( 'output' ) }` );\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tlet result = '';\n\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length > 0 ) {\n\n\t\t\tconst snippets = [];\n\n\t\t\tfor ( const struct of structs ) {\n\n\t\t\t\tlet snippet = `struct ${ struct.name } {\\n`;\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t\tresult = '\\n' + snippets.join( '\\n\\n' ) + '\\n';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns a WGSL string representing a variable.\n\t *\n\t * @param {string} type - The variable's type.\n\t * @param {string} name - The variable's name.\n\t * @param {?number} [count=null] - The array length.\n\t * @return {string} The WGSL snippet that defines a variable.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\tlet snippet = `var ${ name } : `;\n\n\t\tif ( count !== null ) {\n\n\t\t\tsnippet += this.generateArrayDeclaration( type, count );\n\n\t\t} else {\n\n\t\t\tsnippet += this.getType( type );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst samplingSnippet = varying.interpolationSampling !== null ? `, ${ varying.interpolationSampling } )` : ' )';\n\n\t\t\t\t\t\tattributesSnippet += ` @interpolate( ${ varying.interpolationType }${ samplingSnippet }`;\n\n\t\t\t\t\t\t// Otherwise, optimize interpolation when sensible\n\n\t\t\t\t\t} else if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ` @interpolate( ${ this.renderer.backend.compatibilityMode ? 'flat, either' : 'flat' } )`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tisCustomStruct( nodeUniform ) {\n\n\t\tconst attribute = nodeUniform.value;\n\t\tconst bufferNode = nodeUniform.node;\n\n\t\tconst isAttributeStructType = ( attribute.isBufferAttribute || attribute.isInstancedBufferAttribute ) && bufferNode.structTypeNode !== null;\n\n\t\tconst isStructArray =\n\t\t\t( bufferNode.value && bufferNode.value.array ) &&\n\t\t\t( typeof bufferNode.value.itemSize === 'number' && bufferNode.value.array.length > bufferNode.value.itemSize );\n\n\t\treturn isAttributeStructType && ! isStructArray;\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\tif ( this.renderer.backend.compatibilityMode && texture.compareFunction === null ) {\n\n\t\t\t\t\t\ttextureType = `texture${ multisampled }_2d<f32>`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureType = `texture_depth${ multisampled }_2d${ texture.isArrayTexture === true ? '_array' : '' }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\tconst is3D = uniform.node.value.is3DTexture;\n\t\t\t\t\tconst isArrayTexture = uniform.node.value.isArrayTexture;\n\n\t\t\t\t\tconst dimension = is3D ? '3d' : `2d${ isArrayTexture ? '_array' : '' }`;\n\n\t\t\t\t\ttextureType = `texture_storage_${ dimension }<${ format }, ${ access }>`;\n\n\t\t\t\t} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.is3DTexture === true || texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${ multisampled }_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.getNodeType( this ) );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tif ( this.isCustomStruct( uniform ) ) {\n\n\t\t\t\t\tbufferSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var<${ bufferAccessMode }> ${ uniform.name } : ${ bufferType };` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${ bufferType }>` : `${ bufferType }`;\n\t\t\t\t\tconst bufferSnippet = `\\tvalue : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >`;\n\n\t\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tthis.shaderStage = shaderStage;\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.getNodeType( this );\n\t\t\t\t\t\t\tstageData.structs += 'var<private> output : ' + stageData.returnType + ';';\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tthis.shaderStage = null;\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\t// Early strictly validated in computeNode\n\n\t\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, workgroupSize );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @param {?string} [output=null] - An optional output.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\t/**\n\t * Returns the WGSL type of the given node data type.\n\t *\n\t * @param {string} type - The node data type.\n\t * @return {string} The WGSL type.\n\t */\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @private\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t/**\n\t * Includes the given method name into the current\n\t * function node.\n\t *\n\t * @private\n\t * @param {string} name - The method name to include.\n\t * @return {CodeNode} The respective code node.\n\t */\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t/**\n\t * Returns a WGSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL compute shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @param {string} workgroupSize - The workgroup size.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\tconst [ workgroupSizeX, workgroupSizeY, workgroupSizeZ ] = workgroupSize;\n\n\t\treturn `${ this.getSignature() }\n// directives\n${ shaderData.directives }\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${ shaderData.scopedArrays }\n\n// structs\n${ shaderData.structs }\n\n// uniforms\n${ shaderData.uniforms }\n\n// codes\n${ shaderData.codes }\n\n@compute @workgroup_size( ${ workgroupSizeX }, ${ workgroupSizeY }, ${ workgroupSizeZ } )\nfn main( ${ shaderData.attributes } ) {\n\n\t// system\n\tinstanceIndex = globalId.x\n\t\t+ globalId.y * ( ${ workgroupSizeX } * numWorkgroups.x )\n\t\t+ globalId.z * ( ${ workgroupSizeX } * numWorkgroups.x ) * ( ${ workgroupSizeY } * numWorkgroups.y );\n\n\t// vars\n\t${ shaderData.vars }\n\n\t// flow\n\t${ shaderData.flow }\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The WGSL snippet representing a struct.\n\t */\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct binding.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @param {string} access - The access.\n\t * @param {number} [binding=0] - The binding index.\n\t * @param {number} [group=0] - The group index.\n\t * @return {string} The WGSL snippet representing a struct binding.\n\t */\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${ binding } ) @group( ${ group } )\nvar<${access}> ${ name } : ${ structName };`;\n\n\t}\n\n}\n\nexport default WGSLNodeBuilder;\n"],"mappings":"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","ignoreList":[]}