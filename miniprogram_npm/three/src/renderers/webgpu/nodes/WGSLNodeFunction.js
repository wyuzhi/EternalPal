import NodeFunction from"../../../nodes/core/NodeFunction.js";import NodeFunctionInput from"../../../nodes/core/NodeFunctionInput.js";const declarationRegexp=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,propertiesRegexp=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi,wgslTypeLib={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_depth_2d_array:"depthTexture",texture_depth_multisampled_2d:"depthTexture",texture_depth_cube:"depthTexture",texture_depth_cube_array:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"},parse=e=>{const t=(e=e.trim()).match(declarationRegexp);if(null!==t&&4===t.length){const u=t[2],o=[];let r=null;for(;null!==(r=propertiesRegexp.exec(u));)o.push({name:r[1],type:r[2]});const c=[];for(let e=0;e<o.length;e++){const{name:t,type:u}=o[e];let r=u;r.startsWith("ptr")?r="pointer":(r.startsWith("texture")&&(r=u.split("<")[0]),r=wgslTypeLib[r]),c.push(new NodeFunctionInput(r,t))}const s=e.substring(t[0].length),n=t[3]||"void",i=void 0!==t[1]?t[1]:"";return{type:wgslTypeLib[n]||n,inputs:c,name:i,inputsCode:u,blockCode:s,outputType:n}}throw new Error("FunctionNode: Function is not a WGSL code.")};class WGSLNodeFunction extends NodeFunction{constructor(e){const{type:t,inputs:u,name:o,inputsCode:r,blockCode:c,outputType:s}=parse(e);super(t,u,o),this.inputsCode=r,this.blockCode=c,this.outputType=s}getCode(e=this.name){const t="void"!==this.outputType?"-> "+this.outputType:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}export default WGSLNodeFunction;
//# sourceMappingURL=WGSLNodeFunction.js.map