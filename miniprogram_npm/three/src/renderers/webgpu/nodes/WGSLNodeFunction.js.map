{"version":3,"file":"node_modules/three/src/renderers/webgpu/nodes/WGSLNodeFunction.js","names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","wgslTypeLib","f32","i32","u32","bool","vec2f","vec2i","vec2u","vec2b","vec3f","vec3i","vec3u","vec3b","vec4f","vec4i","vec4u","vec4b","mat2x2f","mat3x3f","mat4x4f","sampler","texture_1d","texture_2d","texture_2d_array","texture_multisampled_2d","texture_depth_2d","texture_depth_2d_array","texture_depth_multisampled_2d","texture_depth_cube","texture_depth_cube_array","texture_3d","texture_cube","texture_cube_array","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","parse","source","declaration","trim","match","length","inputsCode","propsMatches","exec","push","name","type","inputs","i","resolvedType","startsWith","split","blockCode","substring","outputType","undefined","Error","WGSLNodeFunction","constructor","super","this","getCode"],"sources":["node_modules/three/src/renderers/webgpu/nodes/WGSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../../../nodes/core/NodeFunction.js';\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\t'texture_depth_2d_array': 'depthTexture',\n\t'texture_depth_multisampled_2d': 'depthTexture',\n\t'texture_depth_cube': 'depthTexture',\n\t'texture_depth_cube_array': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new WGSL node function.\n\t *\n\t * @param {string} source - The WGSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\t/**\n\t * This method returns the WGSL code of the node function.\n\t *\n\t * @param {string} [name=this.name] - The function's name.\n\t * @return {string} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\nexport default WGSLNodeFunction;\n"],"mappings":"OAAOA,iBAAkB,6CAClBC,sBAAuB,2CAE9B,MAAMC,kBAAoB,mFACpBC,iBAAmB,mDAEnBC,YAAc,CACnBC,IAAO,QACPC,IAAO,MACPC,IAAO,OACPC,KAAQ,OAER,YAAa,OACZ,YAAa,QACb,YAAa,QACb,aAAc,QAEfC,MAAS,OACTC,MAAS,QACTC,MAAS,QACTC,MAAS,QAET,YAAa,OACb,YAAa,QACb,YAAa,QACb,aAAc,QAEdC,MAAS,OACTC,MAAS,QACTC,MAAS,QACTC,MAAS,QAET,YAAa,OACb,YAAa,QACb,YAAa,QACb,aAAc,QAEdC,MAAS,OACTC,MAAS,QACTC,MAAS,QACTC,MAAS,QAET,cAAe,OACfC,QAAW,OAEX,cAAe,OACfC,QAAW,OAEX,cAAe,OACfC,QAAW,OAEXC,QAAW,UAEXC,WAAc,UAEdC,WAAc,UACdC,iBAAoB,UACpBC,wBAA2B,cAE3BC,iBAAoB,eACpBC,uBAA0B,eAC1BC,8BAAiC,eACjCC,mBAAsB,eACtBC,yBAA4B,eAE5BC,WAAc,YAEdC,aAAgB,cAChBC,mBAAsB,cAEtBC,mBAAsB,iBACtBC,mBAAsB,iBACtBC,yBAA4B,iBAC5BC,mBAAsB,kBAIjBC,MAAUC,IAIf,MAAMC,GAFND,EAASA,EAAOE,QAEWC,MAAO3C,mBAElC,GAAqB,OAAhByC,GAA+C,IAAvBA,EAAYG,OAAe,CAEvD,MAAMC,EAAaJ,EAAa,GAC1BK,EAAe,GACrB,IAAIH,EAAQ,KAEZ,KAA4D,QAAlDA,EAAQ1C,iBAAiB8C,KAAMF,KAExCC,EAAaE,KAAM,CAAEC,KAAMN,EAAO,GAAKO,KAAMP,EAAO,KAKrD,MAAMQ,EAAS,GACf,IAAM,IAAIC,EAAI,EAAGA,EAAIN,EAAaF,OAAQQ,IAAO,CAEhD,MAAMH,KAAEA,EAAIC,KAAEA,GAASJ,EAAcM,GAErC,IAAIC,EAAeH,EAEdG,EAAaC,WAAY,OAE7BD,EAAe,WAIVA,EAAaC,WAAY,aAE7BD,EAAeH,EAAKK,MAAO,KAAO,IAInCF,EAAenD,YAAamD,IAI7BF,EAAOH,KAAM,IAAIjD,kBAAmBsD,EAAcJ,GAEnD,CAEA,MAAMO,EAAYhB,EAAOiB,UAAWhB,EAAa,GAAIG,QAC/Cc,EAAajB,EAAa,IAAO,OAEjCQ,OAA4BU,IAArBlB,EAAa,GAAoBA,EAAa,GAAM,GAGjE,MAAO,CACNS,KAHYhD,YAAawD,IAAgBA,EAIzCP,SACAF,OACAJ,aACAW,YACAE,aAGF,CAEC,MAAM,IAAIE,MAAO,6CAElB,EASD,MAAMC,yBAAyB/D,aAO9B,WAAAgE,CAAatB,GAEZ,MAAMU,KAAEA,EAAIC,OAAEA,EAAMF,KAAEA,EAAIJ,WAAEA,EAAUW,UAAEA,EAASE,WAAEA,GAAenB,MAAOC,GAEzEuB,MAAOb,EAAMC,EAAQF,GAErBe,KAAKnB,WAAaA,EAClBmB,KAAKR,UAAYA,EACjBQ,KAAKN,WAAaA,CAEnB,CAQA,OAAAO,CAAShB,EAAOe,KAAKf,MAEpB,MAAMS,EAAiC,SAApBM,KAAKN,WAAwB,MAAQM,KAAKN,WAAa,GAE1E,MAAO,MAAOT,OAAYe,KAAKnB,WAAWH,YAAcgB,IAAgBM,KAAKR,SAE9E,iBAIcK","ignoreList":[]}