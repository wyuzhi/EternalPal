{"version":3,"file":"node_modules/three/src/renderers/webgpu/utils/WebGPUAttributeUtils.js","names":["GPUInputStepMode","Float16BufferAttribute","typedArraysToVertexFormatPrefix","Map","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float16Array","set","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","constructor","backend","this","createAttribute","attribute","usage","bufferAttribute","_getBufferAttribute","bufferData","get","buffer","undefined","device","array","normalized","GPUBufferUsage","INDEX","i","length","isStorageBufferAttribute","isStorageInstancedBufferAttribute","itemSize","count","subarray","_force3to4BytesAlignment","byteLength","size","createBuffer","label","name","mappedAtCreation","getMappedRange","unmap","updateAttribute","isTypedArray","_isTypedArray","updateRanges","queue","writeBuffer","byteOffsetFactor","BYTES_PER_ELEMENT","l","range","dataOffset","Math","floor","start","ceil","bufferOffset","clearUpdateRanges","createShaderVertexBuffers","renderObject","attributes","getAttributes","vertexBuffers","slot","geometryAttribute","bytesPerElement","vertexBufferLayout","arrayStride","stepMode","isInterleavedBufferAttribute","data","stride","isInstancedInterleavedBuffer","Instance","Vertex","isInstancedBufferAttribute","format","_getVertexFormat","offset","push","shaderLocation","Array","from","values","destroyAttribute","destroy","delete","getArrayBufferAsync","bufferGPU","readBufferGPU","COPY_DST","MAP_READ","cmdEncoder","createCommandEncoder","copyBufferToBuffer","gpuCommands","finish","submit","mapAsync","GPUMapMode","READ","arrayBuffer","dstBuffer","slice","ArrayType","AttributeType","prefix","bytesPerUnit","paddedItemSize","Error","console","error","ArrayBuffer","isView","DataView"],"sources":["node_modules/three/src/renderers/webgpu/utils/WebGPUAttributeUtils.js"],"sourcesContent":["import { GPUInputStepMode } from './WebGPUConstants.js';\n\nimport { Float16BufferAttribute } from '../../../core/BufferAttribute.js';\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nif ( typeof Float16Array !== 'undefined' ) {\n\n\ttypedArraysToVertexFormatPrefix.set( Float16Array, [ 'float16' ] );\n\n}\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\n/**\n * A WebGPU backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGPUAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.\n\t */\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false ) {\n\n\t\t\t\tif ( array.constructor === Int16Array || array.constructor === Int8Array ) {\n\n\t\t\t\t\tarray = new Int32Array( array );\n\n\t\t\t\t} else if ( array.constructor === Uint16Array || array.constructor === Uint8Array ) {\n\n\t\t\t\t\tarray = new Uint32Array( array );\n\n\t\t\t\t\tif ( usage & GPUBufferUsage.INDEX ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( array[ i ] === 0xffff ) array[ i ] = 0xffffffff; // use correct primitive restart index\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t\tbufferData._force3to4BytesAlignment = true;\n\n\t\t\t}\n\n\t\t\t// ensure 4 byte alignment\n\t\t\tconst byteLength = array.byteLength;\n\t\t\tconst size = byteLength + ( ( 4 - ( byteLength % 4 ) ) % 4 );\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tlet array = bufferAttribute.array;\n\n\t\t//  if storage buffer ensure 4 byte alignment\n\t\tif ( bufferData._force3to4BytesAlignment === true ) {\n\n\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t}\n\n\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tlet dataOffset, size;\n\n\t\t\t\tif ( bufferData._force3to4BytesAlignment === true ) {\n\n\t\t\t\t\tconst vertexStart = Math.floor( range.start / 3 );\n\t\t\t\t\tconst vertexCount = Math.ceil( range.count / 3 );\n\t\t\t\t\tdataOffset = vertexStart * 4 * byteOffsetFactor;\n\t\t\t\t\tsize = vertexCount * 4 * byteOffsetFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataOffset = range.start * byteOffsetFactor;\n\t\t\t\t\tsize = range.count * byteOffsetFactor;\n\n\t\t\t\t}\n\n\t\t\t\tconst bufferOffset = dataOffset * ( isTypedArray ? array.BYTES_PER_ELEMENT : 1 ); // bufferOffset is always in bytes\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\tbufferOffset,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method creates the vertex buffer layout data which are\n\t * require when creating a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.\n\t */\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: `${ attribute.name }_readback`,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {\n\t\t\tlabel: `readback_encoder_${ attribute.name }`\n\t\t} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\tconst dstBuffer = new attribute.array.constructor( arrayBuffer.slice( 0 ) );\n\n\t\treadBufferGPU.unmap();\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Returns the vertex format of the given buffer attribute.\n\t *\n\t * @private\n\t * @param {BufferAttribute} geometryAttribute - The buffer attribute.\n\t * @return {string|undefined} The vertex format (e.g. 'float32x3').\n\t */\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize === 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given array is a typed array.\n\t *\n\t * @private\n\t * @param {any} array - The array.\n\t * @return {boolean} Whether the given array is a typed array or not.\n\t */\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @private\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nexport default WebGPUAttributeUtils;\n"],"mappings":"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","ignoreList":[]}