{"version":3,"file":"node_modules/three/src/renderers/webgpu/utils/WebGPUBindingUtils.js","names":["GPUTextureAspect","GPUTextureViewDimension","GPUTextureSampleType","GPUBufferBindingType","GPUStorageTextureAccess","GPUSamplerBindingType","FloatType","IntType","UnsignedIntType","NodeAccess","WebGPUBindingUtils","constructor","backend","this","bindGroupLayoutCache","WeakMap","createBindingsLayout","bindGroup","device","entries","index","binding","bindings","bindingGPU","visibility","isUniformBuffer","isStorageBuffer","buffer","access","READ_WRITE","WRITE_ONLY","type","Storage","ReadOnlyStorage","isSampledTexture","store","storageTexture","format","get","texture","ReadWrite","WriteOnly","ReadOnly","isArrayTexture","viewDimension","TwoDArray","is3DTexture","ThreeD","primarySamples","utils","getTextureSampleData","multisampled","isDepthTexture","sampleType","UnfilterableFloat","compatibilityMode","compareFunction","Depth","isDataTexture","isDataArrayTexture","isData3DTexture","SInt","UInt","hasFeature","Float","isSampledCubeTexture","Cube","isCompressedArrayTexture","isSampledTexture3D","isSampler","sampler","Comparison","NonFiltering","console","error","push","createBindGroupLayout","createBindings","cacheIndex","version","bindingsData","bindGroupGPU","bindLayoutGPU","bindingsReference","undefined","set","groups","versions","createBindGroup","group","layout","updateBinding","bufferGPU","queue","writeBuffer","createBindGroupIndex","data","usage","GPUBufferUsage","UNIFORM","COPY_DST","createBuffer","label","size","resource","layoutGPU","bindingPoint","entriesGPU","bindingData","byteLength","name","attribute","textureData","resourceGPU","externalTexture","importExternalTexture","source","mipLevelCount","propertyName","width","height","depthOrArrayLayers","aspectGPU","All","dimensionViewGPU","TwoD","createView","aspect","dimension","textureGPU"],"sources":["node_modules/three/src/renderers/webgpu/utils/WebGPUBindingUtils.js"],"sourcesContent":["import {\n\tGPUTextureAspect, GPUTextureViewDimension, GPUTextureSampleType, GPUBufferBindingType, GPUStorageTextureAccess,\n\tGPUSamplerBindingType\n} from './WebGPUConstants.js';\n\nimport { FloatType, IntType, UnsignedIntType } from '../../../constants.js';\nimport { NodeAccess } from '../../../nodes/core/constants.js';\n\n/**\n * A WebGPU backend utility module for managing bindings.\n *\n * When reading the documentation it's helpful to keep in mind that\n * all class definitions starting with 'GPU*' are modules from the\n * WebGPU API. So for example `BindGroup` is a class from the engine\n * whereas `GPUBindGroup` is a class from WebGPU.\n *\n * @private\n */\nclass WebGPUBindingUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A cache for managing bind group layouts.\n\t\t *\n\t\t * @type {WeakMap<Array<Binding>,GPUBindGroupLayout>}\n\t\t */\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group layout for the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @return {GPUBindGroupLayout} The GPU bind group layout.\n\t */\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isArrayTexture ) {\n\n\t\t\t\t\tstorageTexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.texture.is3DTexture ) {\n\n\t\t\t\t\tstorageTexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tconst { primarySamples } = backend.utils.getTextureSampleData( binding.texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t\tif ( ! binding.texture.isDepthTexture ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( backend.compatibilityMode && binding.texture.compareFunction === null ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = GPUSamplerBindingType.Comparison;\n\n\t\t\t\t\t} else if ( backend.compatibilityMode ) {\n\n\t\t\t\t\t\tsampler.type = GPUSamplerBindingType.NonFiltering;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the camera index.\n\t *\n\t * @param {Uint32Array} data - The index data.\n\t * @param {GPUBindGroupLayout} layout - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroupIndex( data, layout ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\t\tconst index = data[ 0 ];\n\n\t\tconst buffer = device.createBuffer( {\n\t\t\tlabel: 'bindingCameraIndex_' + index,\n\t\t\tsize: 16, // uint(4) * 4\n\t\t\tusage: usage\n\t\t} );\n\n\t\tdevice.queue.writeBuffer( buffer, 0, data, 0 );\n\n\t\tconst entries = [ { binding: 0, resource: { buffer } } ];\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroupCameraIndex_' + index,\n\t\t\tlayout,\n\t\t\tentries\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the given bind group and GPU layout.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tlet propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }`;\n\n\t\t\t\t\tif ( textureData.texture.depthOrArrayLayers > 1 ) {\n\n\t\t\t\t\t\tpropertyName += `-${ textureData.texture.depthOrArrayLayers }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName += `-${ mipLevelCount }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\nexport default WebGPUBindingUtils;\n"],"mappings":"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","ignoreList":[]}