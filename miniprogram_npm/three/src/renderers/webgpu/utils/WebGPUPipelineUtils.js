import{BlendColorFactor,OneMinusBlendColorFactor}from"../../common/Constants.js";import{GPUFrontFace,GPUCullMode,GPUColorWriteFlags,GPUCompareFunction,GPUBlendFactor,GPUBlendOperation,GPUIndexFormat,GPUStencilOperation}from"./WebGPUConstants.js";import{FrontSide,BackSide,DoubleSide,NeverDepth,AlwaysDepth,LessDepth,LessEqualDepth,EqualDepth,GreaterEqualDepth,GreaterDepth,NotEqualDepth,NoBlending,NormalBlending,AdditiveBlending,SubtractiveBlending,MultiplyBlending,CustomBlending,ZeroFactor,OneFactor,SrcColorFactor,OneMinusSrcColorFactor,SrcAlphaFactor,OneMinusSrcAlphaFactor,DstColorFactor,OneMinusDstColorFactor,DstAlphaFactor,OneMinusDstAlphaFactor,SrcAlphaSaturateFactor,AddEquation,SubtractEquation,ReverseSubtractEquation,MinEquation,MaxEquation,KeepStencilOp,ZeroStencilOp,ReplaceStencilOp,InvertStencilOp,IncrementStencilOp,DecrementStencilOp,IncrementWrapStencilOp,DecrementWrapStencilOp,NeverStencilFunc,AlwaysStencilFunc,LessStencilFunc,LessEqualStencilFunc,EqualStencilFunc,GreaterEqualStencilFunc,GreaterStencilFunc,NotEqualStencilFunc}from"../../../constants.js";class WebGPUPipelineUtils{constructor(e){this.backend=e,this._activePipelines=new WeakMap}setPipeline(e,t){this._activePipelines.get(e)!==t&&(e.setPipeline(t),this._activePipelines.set(e,t))}_getSampleCount(e){return this.backend.utils.getSampleCountRenderContext(e)}createRenderPipeline(e,t){const{object:n,material:r,geometry:a,pipeline:l}=e,{vertexProgram:o,fragmentProgram:c}=l,i=this.backend,s=i.device,p=i.utils,d=i.get(l),u=[];for(const t of e.getBindings()){const e=i.get(t);u.push(e.layout)}const F=i.attributeUtils.createShaderVertexBuffers(e);let P;r.blending===NoBlending||r.blending===NormalBlending&&!1===r.transparent||(P=this._getBlending(r));let G={};!0===r.stencilWrite&&(G={compare:this._getStencilCompare(r),failOp:this._getStencilOperation(r.stencilFail),depthFailOp:this._getStencilOperation(r.stencilZFail),passOp:this._getStencilOperation(r.stencilZPass)});const U=this._getColorWriteMask(r),h=[];if(null!==e.context.textures){const t=e.context.textures;for(let e=0;e<t.length;e++){const n=p.getTextureFormatGPU(t[e]);h.push({format:n,blend:P,writeMask:U})}}else{const t=p.getCurrentColorFormat(e.context);h.push({format:t,blend:P,writeMask:U})}const b=i.get(o).module,S=i.get(c).module,m=this._getPrimitiveState(n,a,r),B=this._getDepthCompare(r),g=p.getCurrentDepthStencilFormat(e.context),O=this._getSampleCount(e.context),C={label:`renderPipeline_${r.name||r.type}_${r.id}`,vertex:Object.assign({},b,{buffers:F}),fragment:Object.assign({},S,{targets:h}),primitive:m,multisample:{count:O,alphaToCoverageEnabled:r.alphaToCoverage&&O>1},layout:s.createPipelineLayout({bindGroupLayouts:u})},k={},E=e.context.depth,A=e.context.stencil;if(!0!==E&&!0!==A||(!0===E&&(k.format=g,k.depthWriteEnabled=r.depthWrite,k.depthCompare=B),!0===A&&(k.stencilFront=G,k.stencilBack={},k.stencilReadMask=r.stencilFuncMask,k.stencilWriteMask=r.stencilWriteMask),!0===r.polygonOffset&&(k.depthBias=r.polygonOffsetUnits,k.depthBiasSlopeScale=r.polygonOffsetFactor,k.depthBiasClamp=0),C.depthStencil=k),null===t)d.pipeline=s.createRenderPipeline(C);else{const e=new Promise((e=>{s.createRenderPipelineAsync(C).then((t=>{d.pipeline=t,e()}))}));t.push(e)}}createBundleEncoder(e,t="renderBundleEncoder"){const n=this.backend,{utils:r,device:a}=n,l=r.getCurrentDepthStencilFormat(e),o={label:t,colorFormats:[r.getCurrentColorFormat(e)],depthStencilFormat:l,sampleCount:this._getSampleCount(e)};return a.createRenderBundleEncoder(o)}createComputePipeline(e,t){const n=this.backend,r=n.device,a=n.get(e.computeProgram).module,l=n.get(e),o=[];for(const e of t){const t=n.get(e);o.push(t.layout)}l.pipeline=r.createComputePipeline({compute:a,layout:r.createPipelineLayout({bindGroupLayouts:o})})}_getBlending(e){let t,n;const r=e.blending,a=e.blendSrc,l=e.blendDst,o=e.blendEquation;if(r===CustomBlending){const r=null!==e.blendSrcAlpha?e.blendSrcAlpha:a,c=null!==e.blendDstAlpha?e.blendDstAlpha:l,i=null!==e.blendEquationAlpha?e.blendEquationAlpha:o;t={srcFactor:this._getBlendFactor(a),dstFactor:this._getBlendFactor(l),operation:this._getBlendOperation(o)},n={srcFactor:this._getBlendFactor(r),dstFactor:this._getBlendFactor(c),operation:this._getBlendOperation(i)}}else{const a=(e,r,a,l)=>{t={srcFactor:e,dstFactor:r,operation:GPUBlendOperation.Add},n={srcFactor:a,dstFactor:l,operation:GPUBlendOperation.Add}};if(e.premultipliedAlpha)switch(r){case NormalBlending:a(GPUBlendFactor.One,GPUBlendFactor.OneMinusSrcAlpha,GPUBlendFactor.One,GPUBlendFactor.OneMinusSrcAlpha);break;case AdditiveBlending:a(GPUBlendFactor.One,GPUBlendFactor.One,GPUBlendFactor.One,GPUBlendFactor.One);break;case SubtractiveBlending:a(GPUBlendFactor.Zero,GPUBlendFactor.OneMinusSrc,GPUBlendFactor.Zero,GPUBlendFactor.One);break;case MultiplyBlending:a(GPUBlendFactor.Dst,GPUBlendFactor.OneMinusSrcAlpha,GPUBlendFactor.Zero,GPUBlendFactor.One)}else switch(r){case NormalBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.OneMinusSrcAlpha,GPUBlendFactor.One,GPUBlendFactor.OneMinusSrcAlpha);break;case AdditiveBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.One,GPUBlendFactor.One,GPUBlendFactor.One);break;case SubtractiveBlending:console.error("THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");break;case MultiplyBlending:console.error("THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true")}}if(void 0!==t&&void 0!==n)return{color:t,alpha:n};console.error("THREE.WebGPURenderer: Invalid blending: ",r)}_getBlendFactor(e){let t;switch(e){case ZeroFactor:t=GPUBlendFactor.Zero;break;case OneFactor:t=GPUBlendFactor.One;break;case SrcColorFactor:t=GPUBlendFactor.Src;break;case OneMinusSrcColorFactor:t=GPUBlendFactor.OneMinusSrc;break;case SrcAlphaFactor:t=GPUBlendFactor.SrcAlpha;break;case OneMinusSrcAlphaFactor:t=GPUBlendFactor.OneMinusSrcAlpha;break;case DstColorFactor:t=GPUBlendFactor.Dst;break;case OneMinusDstColorFactor:t=GPUBlendFactor.OneMinusDst;break;case DstAlphaFactor:t=GPUBlendFactor.DstAlpha;break;case OneMinusDstAlphaFactor:t=GPUBlendFactor.OneMinusDstAlpha;break;case SrcAlphaSaturateFactor:t=GPUBlendFactor.SrcAlphaSaturated;break;case BlendColorFactor:t=GPUBlendFactor.Constant;break;case OneMinusBlendColorFactor:t=GPUBlendFactor.OneMinusConstant;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",e)}return t}_getStencilCompare(e){let t;const n=e.stencilFunc;switch(n){case NeverStencilFunc:t=GPUCompareFunction.Never;break;case AlwaysStencilFunc:t=GPUCompareFunction.Always;break;case LessStencilFunc:t=GPUCompareFunction.Less;break;case LessEqualStencilFunc:t=GPUCompareFunction.LessEqual;break;case EqualStencilFunc:t=GPUCompareFunction.Equal;break;case GreaterEqualStencilFunc:t=GPUCompareFunction.GreaterEqual;break;case GreaterStencilFunc:t=GPUCompareFunction.Greater;break;case NotEqualStencilFunc:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",n)}return t}_getStencilOperation(e){let t;switch(e){case KeepStencilOp:t=GPUStencilOperation.Keep;break;case ZeroStencilOp:t=GPUStencilOperation.Zero;break;case ReplaceStencilOp:t=GPUStencilOperation.Replace;break;case InvertStencilOp:t=GPUStencilOperation.Invert;break;case IncrementStencilOp:t=GPUStencilOperation.IncrementClamp;break;case DecrementStencilOp:t=GPUStencilOperation.DecrementClamp;break;case IncrementWrapStencilOp:t=GPUStencilOperation.IncrementWrap;break;case DecrementWrapStencilOp:t=GPUStencilOperation.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",t)}return t}_getBlendOperation(e){let t;switch(e){case AddEquation:t=GPUBlendOperation.Add;break;case SubtractEquation:t=GPUBlendOperation.Subtract;break;case ReverseSubtractEquation:t=GPUBlendOperation.ReverseSubtract;break;case MinEquation:t=GPUBlendOperation.Min;break;case MaxEquation:t=GPUBlendOperation.Max;break;default:console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.",e)}return t}_getPrimitiveState(e,t,n){const r={},a=this.backend.utils;switch(r.topology=a.getPrimitiveTopology(e,n),null!==t.index&&!0===e.isLine&&!0!==e.isLineSegments&&(r.stripIndexFormat=t.index.array instanceof Uint16Array?GPUIndexFormat.Uint16:GPUIndexFormat.Uint32),n.side){case FrontSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.Back;break;case BackSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.Front;break;case DoubleSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.None;break;default:console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.",n.side)}return r}_getColorWriteMask(e){return!0===e.colorWrite?GPUColorWriteFlags.All:GPUColorWriteFlags.None}_getDepthCompare(e){let t;if(!1===e.depthTest)t=GPUCompareFunction.Always;else{const n=e.depthFunc;switch(n){case NeverDepth:t=GPUCompareFunction.Never;break;case AlwaysDepth:t=GPUCompareFunction.Always;break;case LessDepth:t=GPUCompareFunction.Less;break;case LessEqualDepth:t=GPUCompareFunction.LessEqual;break;case EqualDepth:t=GPUCompareFunction.Equal;break;case GreaterEqualDepth:t=GPUCompareFunction.GreaterEqual;break;case GreaterDepth:t=GPUCompareFunction.Greater;break;case NotEqualDepth:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPUPipelineUtils: Invalid depth function.",n)}}return t}}export default WebGPUPipelineUtils;
//# sourceMappingURL=WebGPUPipelineUtils.js.map