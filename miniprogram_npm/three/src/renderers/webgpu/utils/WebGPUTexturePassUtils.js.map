{"version":3,"file":"node_modules/three/src/renderers/webgpu/utils/WebGPUTexturePassUtils.js","names":["DataMap","GPUTextureViewDimension","GPUIndexFormat","GPUFilterMode","GPUPrimitiveTopology","GPULoadOp","GPUStoreOp","WebGPUTexturePassUtils","constructor","device","super","this","mipmapSampler","createSampler","minFilter","Linear","flipYSampler","Nearest","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","label","code","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","format","pipeline","undefined","createRenderPipeline","vertex","module","entryPoint","fragment","targets","primitive","topology","TriangleStrip","stripIndexFormat","Uint32","layout","getFlipYPipeline","flipY","textureGPU","textureGPUDescriptor","baseArrayLayer","width","height","size","transferPipeline","flipYPipeline","tempTexture","createTexture","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","mipLevelCount","dimension","TwoD","dstView","commandEncoder","createCommandEncoder","pass","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","bindGroup","createBindGroup","entries","binding","resource","passEncoder","beginRenderPass","colorAttachments","view","loadOp","Clear","storeOp","Store","clearValue","setPipeline","setBindGroup","draw","end","queue","submit","finish","destroy","generateMipmaps","textureData","get","useCount","layers","passes","_mipmapCreateBundles","_mipmapRunBundles","i","passDescriptor","createRenderBundleEncoder","colorFormats","push","renderBundles","levels","length","executeBundles"],"sources":["node_modules/three/src/renderers/webgpu/utils/WebGPUTexturePassUtils.js"],"sourcesContent":["import DataMap from '../../common/DataMap.js';\nimport { GPUTextureViewDimension, GPUIndexFormat, GPUFilterMode, GPUPrimitiveTopology, GPULoadOp, GPUStoreOp } from './WebGPUConstants.js';\n\n/**\n * A WebGPU backend utility module used by {@link WebGPUTextureUtils}.\n *\n * @private\n */\nclass WebGPUTexturePassUtils extends DataMap {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {GPUDevice} device - The WebGPU device.\n\t */\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The WebGPU device.\n\t\t *\n\t\t * @type {GPUDevice}\n\t\t */\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\n\t\t/**\n\t\t * The mipmap GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\n\t\t/**\n\t\t * The flipY GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for copy/transfer passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<string,GPURenderPipeline>}\n\t\t */\n\t\tthis.transferPipelines = {};\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for flipY passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<string,GPURenderPipeline>}\n\t\t */\n\t\tthis.flipYPipelines = {};\n\n\t\t/**\n\t\t * The mipmap vertex shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\t/**\n\t\t * The mipmap fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\t/**\n\t\t * The flipY fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the internal copy render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {string} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the flipY render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {string} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.useCount === undefined ) {\n\n\t\t\ttextureData.useCount = 0;\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\tif ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;\n\n\t\ttextureData.useCount ++;\n\n\t}\n\n\t/**\n\t * Since multiple copy render passes are required to generate mipmaps, the passes\n\t * are managed as render bundles to improve performance.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.\n\t * @return {Array<Object>} An array of render bundles.\n\t */\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t/**\n\t * Executes the render bundles.\n\t *\n\t * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.\n\t * @param {Array<Object>} passes - An array of render bundles.\n\t */\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nexport default WebGPUTexturePassUtils;\n"],"mappings":"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","ignoreList":[]}