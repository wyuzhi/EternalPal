{"version":3,"file":"node_modules/three/src/renderers/webgpu/utils/WebGPUTextureUtils.js","names":["GPUTextureFormat","GPUAddressMode","GPUFilterMode","GPUTextureDimension","GPUFeatureName","GPUTextureViewDimension","ColorManagement","WebGPUTexturePassUtils","ByteType","ShortType","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","RepeatWrapping","MirroredRepeatWrapping","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBAFormat","RGBFormat","RedFormat","RGFormat","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","UnsignedByteType","FloatType","HalfFloatType","SRGBTransfer","DepthFormat","DepthStencilFormat","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","UnsignedIntType","UnsignedShortType","UnsignedInt248Type","UnsignedInt5999Type","NeverCompare","AlwaysCompare","LessCompare","LessEqualCompare","EqualCompare","GreaterEqualCompare","GreaterCompare","NotEqualCompare","IntType","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","CubeTexture","DepthTexture","Texture","_compareToWebGPU","_flipMap","WebGPUTextureUtils","constructor","backend","this","_passUtils","defaultTexture","defaultCubeTexture","defaultVideoFrame","colorBuffer","depthTexture","name","createSampler","texture","device","textureGPU","get","samplerDescriptorGPU","addressModeU","_convertAddressMode","wrapS","addressModeV","wrapT","addressModeW","wrapR","magFilter","_convertFilterMode","minFilter","mipmapFilter","maxAnisotropy","Linear","anisotropy","isDepthTexture","compareFunction","compare","sampler","createDefaultTexture","format","getFormat","isCubeTexture","_getDefaultCubeTextureGPU","_getDefaultTextureGPU","createTexture","options","textureData","initialized","Error","undefined","needsMipmaps","levels","depth","width","height","isFramebufferTexture","renderTarget","utils","getCurrentColorFormat","getPreferredCanvasFormat","dimension","_getDimension","internalFormat","samples","primarySamples","isMSAA","getTextureSampleData","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","COPY_SRC","isStorageTexture","STORAGE_BINDING","isCompressedTexture","isCompressedArrayTexture","RENDER_ATTACHMENT","textureDescriptorGPU","label","size","depthOrArrayLayers","mipLevelCount","sampleCount","console","warn","textureBindingViewDimension","Cube","msaaTextureDescriptorGPU","Object","assign","msaaTexture","destroyTexture","destroy","delete","destroySampler","generateMipmaps","i","_generateMipmaps","image","getColorBuffer","getDrawingBufferSize","getSampleCount","renderer","getDepthBuffer","stencil","depthTextureGPU","type","updateTexture","isRenderTargetTexture","isDataTexture","_copyBufferToTexture","flipY","isArrayTexture","isDataArrayTexture","isData3DTexture","_copyCompressedBufferToTexture","mipmaps","_copyCubeMapToTexture","images","premultiplyAlpha","_copyImageToTexture","version","onUpdate","copyTextureToBuffer","x","y","faceIndex","bytesPerTexel","_getBytesPerTexel","bytesPerRow","Math","ceil","readBuffer","createBuffer","GPUBufferUsage","MAP_READ","encoder","createCommandEncoder","origin","z","buffer","typedArrayType","_getTypedArrayType","queue","submit","finish","mapAsync","GPUMapMode","READ","getMappedRange","flipIndex","originDepth","copyExternalImageToTexture","source","mipLevel","premultipliedAlpha","_getPassUtils","passUtils","baseArrayLayer","_flipY","data","writeTexture","offset","blockData","_getBlockData","length","mipmap","byteLength","bytesPerImage","j","rowsPerImage","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","value","addressMode","ClampToEdge","Repeat","MirrorRepeat","filterMode","Nearest","R8Unorm","R8Snorm","R8Uint","R8Sint","R16Uint","R16Sint","R16Float","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","R32Uint","R32Sint","R32Float","RG16Uint","RG16Sint","RG16Float","RGBA8Unorm","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB9E5UFloat","RGB10A2Unorm","RG11B10UFloat","Depth32Float","Depth24Plus","Depth24PlusStencil8","Depth32FloatStencil8","RG32Uint","RG32Sint","RG32Float","RGBA16Uint","RGBA16Sint","RGBA16Float","RGBA32Uint","RGBA32Sint","RGBA32Float","Uint8Array","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","is3DTexture","ThreeD","TwoD","colorSpace","transfer","getTransfer","formatGPU","error","Depth16Unorm","features","has"],"sources":["node_modules/three/src/renderers/webgpu/utils/WebGPUTextureUtils.js"],"sourcesContent":["import {\n\tGPUTextureFormat, GPUAddressMode, GPUFilterMode, GPUTextureDimension, GPUFeatureName, GPUTextureViewDimension\n} from './WebGPUConstants.js';\nimport { ColorManagement } from '../../../math/ColorManagement.js';\n\nimport WebGPUTexturePassUtils from './WebGPUTexturePassUtils.js';\n\nimport {\n\tByteType, ShortType,\n\tNearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter,\n\tRepeatWrapping, MirroredRepeatWrapping,\n\tRGB_ETC2_Format, RGBA_ETC2_EAC_Format,\n\tRGBAFormat, RGBFormat, RedFormat, RGFormat, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, UnsignedByteType, FloatType, HalfFloatType, SRGBTransfer, DepthFormat, DepthStencilFormat,\n\tRGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format,\n\tRGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, UnsignedIntType, UnsignedShortType, UnsignedInt248Type, UnsignedInt5999Type,\n\tNeverCompare, AlwaysCompare, LessCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, IntType, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat\n} from '../../../constants.js';\nimport { CubeTexture } from '../../../textures/CubeTexture.js';\nimport { DepthTexture } from '../../../textures/DepthTexture.js';\nimport { Texture } from '../../../textures/Texture.js';\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\n/**\n * A WebGPU backend utility module for managing textures.\n *\n * @private\n */\nclass WebGPUTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the pass utils.\n\t\t *\n\t\t * @type {?WebGPUTexturePassUtils}\n\t\t * @default null\n\t\t */\n\t\tthis._passUtils = null;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,Texture>}\n\t\t */\n\t\tthis.defaultTexture = {};\n\n\t\t/**\n\t\t * A dictionary for managing default cube textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,CubeTexture>}\n\t\t */\n\t\tthis.defaultCubeTexture = {};\n\n\t\t/**\n\t\t * A default video frame.\n\t\t *\n\t\t * @type {?VideoFrame}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultVideoFrame = null;\n\n\t\t/**\n\t\t * Represents the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {?GPUTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * Represents the depth attachment of the default framebuffer.\n\t\t *\n\t\t * @type {DepthTexture}\n\t\t */\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tconst { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySamples,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( format === undefined ) {\n\n\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\tthis.createDefaultTexture( texture );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;\n\n\t\t}\n\n\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\tif ( isMSAA ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = samples;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the color buffer representing the color\n\t * attachment of the default framebuffer.\n\t *\n\t * @return {GPUTexture} The color buffer.\n\t */\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\t/**\n\t * Returns the depth buffer representing the depth\n\t * attachment of the default framebuffer.\n\t *\n\t * @param {boolean} [depth=true] - Whether depth is enabled or not.\n\t * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.\n\t * @return {GPUTexture} The depth buffer.\n\t */\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY, texture.premultiplyAlpha );\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY, texture.premultiplyAlpha );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t/**\n\t * Returns the default GPU texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default GPU cube texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads cube texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array} images - The cube image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.\n\t */\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY, premultiplyAlpha ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY, premultiplyAlpha );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.\n\t */\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image,\n\t\t\t\tflipY: flipY\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth },\n\t\t\t\tpremultipliedAlpha: premultiplyAlpha\n\t\t\t}, {\n\t\t\t\twidth: textureDescriptorGPU.size.width,\n\t\t\t\theight: textureDescriptorGPU.size.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns the pass utils singleton.\n\t *\n\t * @private\n\t * @return {WebGPUTexturePassUtils} The utils instance.\n\t */\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [originDepth=0] - The origin depth.\n\t */\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Object} image - An object defining the image buffer data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {number} [depth=0] - TODO.\n\t */\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads compressed texture data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array<Object>} mipmaps - An array with mipmap data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t */\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is only relevant for compressed texture formats. It returns a block\n\t * data descriptor for the given GPU compressed texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU compressed texture format.\n\t * @return {Object} The block data descriptor.\n\t */\n\t_getBlockData( format ) {\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSnorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t/**\n\t * Converts the three.js uv wrapping constants to GPU address mode constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a uv wrapping mode.\n\t * @return {string} The GPU address mode.\n\t */\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t/**\n\t * Converts the three.js filter constants to GPU filter constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a filter mode.\n\t * @return {string} The GPU filter mode.\n\t */\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t/**\n\t * Returns the GPU dimensions for the given texture.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The GPU dimension.\n\t */\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.is3DTexture || texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\n/**\n * Returns the GPU format for the given texture.\n *\n * @param {Texture} texture - The texture.\n * @param {?GPUDevice} [device=null] - The GPU device which is used for feature detection.\n * It is not necessary to apply the device for most formats.\n * @return {string} The GPU format.\n */\nexport function getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\tconst transfer = ColorManagement.getTransfer( colorSpace );\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nexport default WebGPUTextureUtils;\n"],"mappings":"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","ignoreList":[]}