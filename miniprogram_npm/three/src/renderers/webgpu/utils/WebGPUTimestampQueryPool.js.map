{"version":3,"file":"node_modules/three/src/renderers/webgpu/utils/WebGPUTimestampQueryPool.js","names":["warnOnce","TimestampQueryPool","WebGPUTimestampQueryPool","constructor","device","type","maxQueries","super","this","querySet","createQuerySet","count","label","bufferSize","resolveBuffer","createBuffer","size","usage","GPUBufferUsage","QUERY_RESOLVE","COPY_SRC","resultBuffer","COPY_DST","MAP_READ","allocateQueriesForContext","renderContext","trackTimestamp","isDisposed","currentQueryIndex","toUpperCase","baseOffset","queryOffsets","set","id","resolveQueriesAsync","lastValue","pendingResolve","_resolveQueries","mapState","currentOffsets","Map","queryCount","bytesUsed","clear","commandEncoder","createCommandEncoder","resolveQuerySet","copyBufferToBuffer","commandBuffer","finish","queue","submit","mapAsync","GPUMapMode","READ","unmap","times","BigUint64Array","getMappedRange","totalDuration","startTime","endTime","Number","error","console","dispose","destroy"],"sources":["node_modules/three/src/renderers/webgpu/utils/WebGPUTimestampQueryPool.js"],"sourcesContent":["import { warnOnce } from '../../../utils.js';\nimport TimestampQueryPool from '../../common/TimestampQueryPool.js';\n\n/**\n * Manages a pool of WebGPU timestamp queries for performance measurement.\n * Extends the base TimestampQueryPool to provide WebGPU-specific implementation.\n *\n * @augments TimestampQueryPool\n */\nclass WebGPUTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n\t * Creates a new WebGPU timestamp query pool.\n\t *\n\t * @param {GPUDevice} device - The WebGPU device to create queries on.\n\t * @param {string} type - The type identifier for this query pool.\n\t * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n\t */\n\tconstructor( device, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\t\tthis.device = device;\n\t\tthis.type = type;\n\n\t\tthis.querySet = this.device.createQuerySet( {\n\t\t\ttype: 'timestamp',\n\t\t\tcount: this.maxQueries,\n\t\t\tlabel: `queryset_global_timestamp_${type}`\n\t\t} );\n\n\t\tconst bufferSize = this.maxQueries * 8;\n\t\tthis.resolveBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_resolve_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t} );\n\n\t\tthis.resultBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_result_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t}\n\n\t/**\n\t * Allocates a pair of queries for a given render context.\n\t *\n\t * @param {Object} renderContext - The render context to allocate queries for.\n\t * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n\t */\n\tallocateQueriesForContext( renderContext ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) return null;\n\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\tthis.queryOffsets.set( renderContext.id, baseOffset );\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n\t * Asynchronously resolves all pending queries and returns the total duration.\n\t * If there's already a pending resolve operation, returns that promise instead.\n\t *\n\t * @async\n\t * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n\t */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tif ( this.pendingResolve ) {\n\n\t\t\treturn this.pendingResolve;\n\n\t\t}\n\n\t\tthis.pendingResolve = this._resolveQueries();\n\n\t\ttry {\n\n\t\t\tconst result = await this.pendingResolve;\n\t\t\treturn result;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal method to resolve queries and calculate total duration.\n\t *\n\t * @async\n\t * @private\n\t * @returns {Promise<number>} The total duration in milliseconds.\n\t */\n\tasync _resolveQueries() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst currentOffsets = new Map( this.queryOffsets );\n\t\t\tconst queryCount = this.currentQueryIndex;\n\t\t\tconst bytesUsed = queryCount * 8;\n\n\t\t\t// Reset state before GPU work\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\n\t\t\tconst commandEncoder = this.device.createCommandEncoder();\n\n\t\t\tcommandEncoder.resolveQuerySet(\n\t\t\t\tthis.querySet,\n\t\t\t\t0,\n\t\t\t\tqueryCount,\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\tcommandEncoder.copyBufferToBuffer(\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0,\n\t\t\t\tthis.resultBuffer,\n\t\t\t\t0,\n\t\t\t\tbytesUsed\n\t\t\t);\n\n\t\t\tconst commandBuffer = commandEncoder.finish();\n\t\t\tthis.device.queue.submit( [ commandBuffer ] );\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\t// Create and track the mapping operation\n\t\t\tawait this.resultBuffer.mapAsync( GPUMapMode.READ, 0, bytesUsed );\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t\t}\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst times = new BigUint64Array( this.resultBuffer.getMappedRange( 0, bytesUsed ) );\n\t\t\tlet totalDuration = 0;\n\n\t\t\tfor ( const [ , baseOffset ] of currentOffsets ) {\n\n\t\t\t\tconst startTime = times[ baseOffset ];\n\t\t\t\tconst endTime = times[ baseOffset + 1 ];\n\t\t\t\tconst duration = Number( endTime - startTime ) / 1e6;\n\t\t\t\ttotalDuration += duration;\n\n\t\t\t}\n\n\t\t\tthis.resultBuffer.unmap();\n\t\t\tthis.lastValue = totalDuration;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'Error resolving queries:', error );\n\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t}\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Dispose of the query pool.\n\t *\n\t * @async\n\t * @returns {Promise} A Promise that resolves when the dispose has been executed.\n\t */\n\tasync dispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\t// Wait for pending resolve operation\n\t\tif ( this.pendingResolve ) {\n\n\t\t\ttry {\n\n\t\t\t\tawait this.pendingResolve;\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'Error waiting for pending resolve:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Ensure buffer is unmapped before destroying\n\t\tif ( this.resultBuffer && this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\ttry {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'Error unmapping buffer:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Destroy resources\n\t\tif ( this.querySet ) {\n\n\t\t\tthis.querySet.destroy();\n\t\t\tthis.querySet = null;\n\n\t\t}\n\n\t\tif ( this.resolveBuffer ) {\n\n\t\t\tthis.resolveBuffer.destroy();\n\t\t\tthis.resolveBuffer = null;\n\n\t\t}\n\n\t\tif ( this.resultBuffer ) {\n\n\t\t\tthis.resultBuffer.destroy();\n\t\t\tthis.resultBuffer = null;\n\n\t\t}\n\n\t\tthis.queryOffsets.clear();\n\t\tthis.pendingResolve = null;\n\n\t}\n\n}\n\nexport default WebGPUTimestampQueryPool;\n"],"mappings":"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","ignoreList":[]}