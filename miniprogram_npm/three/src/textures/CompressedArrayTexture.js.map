{"version":3,"file":"node_modules/three/src/textures/CompressedArrayTexture.js","names":["ClampToEdgeWrapping","CompressedTexture","CompressedArrayTexture","constructor","mipmaps","width","height","depth","format","type","super","this","isCompressedArrayTexture","image","wrapR","layerUpdates","Set","addLayerUpdate","layerIndex","add","clearLayerUpdates","clear"],"sources":["node_modules/three/src/textures/CompressedArrayTexture.js"],"sourcesContent":["import { ClampToEdgeWrapping } from '../constants.js';\nimport { CompressedTexture } from './CompressedTexture.js';\n\n/**\n * Creates a texture 2D array based on data in compressed form.\n *\n * These texture are usually loaded with {@link CompressedTextureLoader}.\n *\n * @augments CompressedTexture\n */\nclass CompressedArrayTexture extends CompressedTexture {\n\n\t/**\n\t * Constructs a new compressed array texture.\n\t *\n\t * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)\n\t * the data and dimensions.\n\t * @param {number} width - The width of the texture.\n\t * @param {number} height - The height of the texture.\n\t * @param {number} depth - The depth of the texture.\n\t * @param {number} [format=RGBAFormat] - The min filter value.\n\t * @param {number} [type=UnsignedByteType] - The min filter value.\n\t */\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCompressedArrayTexture = true;\n\n\t\t/**\n\t\t * The image property of a compressed texture just defines its dimensions.\n\t\t *\n\t\t * @name CompressedArrayTexture#image\n\t\t * @type {{width:number,height:number,depth:number}}\n\t\t */\n\t\tthis.image.depth = depth;\n\n\t\t/**\n\t\t * This defines how the texture is wrapped in the depth and corresponds to\n\t\t * *W* in UVW mapping.\n\t\t *\n\t\t * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}\n\t\t * @default ClampToEdgeWrapping\n\t\t */\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\t/**\n\t\t * A set of all layers which need to be updated in the texture.\n\t\t *\n\t\t * @type {Set<number>}\n\t\t */\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\t/**\n\t * Describes that a specific layer of the texture needs to be updated.\n\t * Normally when {@link Texture#needsUpdate} is set to `true`, the\n\t * entire compressed texture array is sent to the GPU. Marking specific\n\t * layers will only transmit subsets of all mipmaps associated with a\n\t * specific depth in the array which is often much more performant.\n\t *\n\t * @param {number} layerIndex - The layer index that should be updated.\n\t */\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\t/**\n\t * Resets the layer updates registry.\n\t */\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nexport { CompressedArrayTexture };\n"],"mappings":"OAASA,wBAA2B,yBAC3BC,sBAAyB,yBASlC,MAAMC,+BAA+BD,kBAapC,WAAAE,CAAaC,EAASC,EAAOC,EAAQC,EAAOC,EAAQC,GAEnDC,MAAON,EAASC,EAAOC,EAAQE,EAAQC,GASvCE,KAAKC,0BAA2B,EAQhCD,KAAKE,MAAMN,MAAQA,EASnBI,KAAKG,MAAQd,oBAObW,KAAKI,aAAe,IAAIC,GAEzB,CAWA,cAAAC,CAAgBC,GAEfP,KAAKI,aAAaI,IAAKD,EAExB,CAKA,iBAAAE,GAECT,KAAKI,aAAaM,OAEnB,SAIQnB","ignoreList":[]}