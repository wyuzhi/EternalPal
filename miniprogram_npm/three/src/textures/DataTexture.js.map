{"version":3,"file":"node_modules/three/src/textures/DataTexture.js","names":["Texture","NearestFilter","DataTexture","constructor","data","width","height","format","type","mapping","wrapS","wrapT","magFilter","minFilter","anisotropy","colorSpace","super","this","isDataTexture","image","generateMipmaps","flipY","unpackAlignment"],"sources":["node_modules/three/src/textures/DataTexture.js"],"sourcesContent":["import { Texture } from './Texture.js';\nimport { NearestFilter } from '../constants.js';\n\n/**\n * Creates a texture directly from raw buffer data.\n *\n * The interpretation of the data depends on type and format: If the type is\n * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the\n * texel data. If the format is `RGBAFormat`, data needs four values for\n * one texel; Red, Green, Blue and Alpha (typically the opacity).\n *\n * @augments Texture\n */\nclass DataTexture extends Texture {\n\n\t/**\n\t * Constructs a new data texture.\n\t *\n\t * @param {?TypedArray} [data=null] - The buffer data.\n\t * @param {number} [width=1] - The width of the texture.\n\t * @param {number} [height=1] - The height of the texture.\n\t * @param {number} [format=RGBAFormat] - The texture format.\n\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t * @param {number} [magFilter=NearestFilter] - The mag filter value.\n\t * @param {number} [minFilter=NearestFilter] - The min filter value.\n\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t * @param {string} [colorSpace=NoColorSpace] - The color space.\n\t */\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isDataTexture = true;\n\n\t\t/**\n\t\t * The image definition of a data texture.\n\t\t *\n\t\t * @type {{data:TypedArray,width:number,height:number}}\n\t\t */\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\t/**\n\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t *\n\t\t * Overwritten and set to `false` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * If set to `true`, the texture is flipped along the vertical axis when\n\t\t * uploaded to the GPU.\n\t\t *\n\t\t * Overwritten and set to `false` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.flipY = false;\n\n\t\t/**\n\t\t * Specifies the alignment requirements for the start of each pixel row in memory.\n\t\t *\n\t\t * Overwritten and set to `1` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default 1\n\t\t */\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nexport { DataTexture };\n"],"mappings":"OAASA,YAAe,sBACfC,kBAAqB,kBAY9B,MAAMC,oBAAoBF,QAkBzB,WAAAG,CAAaC,EAAO,KAAMC,EAAQ,EAAGC,EAAS,EAAGC,EAAQC,EAAMC,EAASC,EAAOC,EAAOC,EAAYX,cAAeY,EAAYZ,cAAea,EAAYC,GAEvJC,MAAO,KAAMP,EAASC,EAAOC,EAAOC,EAAWC,EAAWN,EAAQC,EAAMM,EAAYC,GASpFE,KAAKC,eAAgB,EAOrBD,KAAKE,MAAQ,CAAEf,KAAMA,EAAMC,MAAOA,EAAOC,OAAQA,GAUjDW,KAAKG,iBAAkB,EAWvBH,KAAKI,OAAQ,EAUbJ,KAAKK,gBAAkB,CAExB,SAIQpB","ignoreList":[]}