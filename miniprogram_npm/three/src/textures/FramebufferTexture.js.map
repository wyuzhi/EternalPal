{"version":3,"file":"node_modules/three/src/textures/FramebufferTexture.js","names":["Texture","NearestFilter","FramebufferTexture","constructor","width","height","super","this","isFramebufferTexture","magFilter","minFilter","generateMipmaps","needsUpdate"],"sources":["node_modules/three/src/textures/FramebufferTexture.js"],"sourcesContent":["import { Texture } from './Texture.js';\nimport { NearestFilter } from '../constants.js';\n\n/**\n * This class can only be used in combination with `copyFramebufferToTexture()` methods\n * of renderers. It extracts the contents of the current bound framebuffer and provides it\n * as a texture for further usage.\n *\n * ```js\n * const pixelRatio = window.devicePixelRatio;\n * const textureSize = 128 * pixelRatio;\n *\n * const frameTexture = new FramebufferTexture( textureSize, textureSize );\n *\n * // calculate start position for copying part of the frame data\n * const vector = new Vector2();\n * vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );\n * vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );\n *\n * renderer.render( scene, camera );\n *\n * // copy part of the rendered frame into the framebuffer texture\n * renderer.copyFramebufferToTexture( frameTexture, vector );\n * ```\n *\n * @augments Texture\n */\nclass FramebufferTexture extends Texture {\n\n\t/**\n\t * Constructs a new framebuffer texture.\n\t *\n\t * @param {number} [width] - The width of the texture.\n\t * @param {number} [height] - The height of the texture.\n\t */\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFramebufferTexture = true;\n\n\t\t/**\n\t\t * How the texture is sampled when a texel covers more than one pixel.\n\t\t *\n\t\t * Overwritten and set to `NearestFilter` by default to disable filtering.\n\t\t *\n\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t * @default NearestFilter\n\t\t */\n\t\tthis.magFilter = NearestFilter;\n\n\t\t/**\n\t\t * How the texture is sampled when a texel covers less than one pixel.\n\t\t *\n\t\t * Overwritten and set to `NearestFilter` by default to disable filtering.\n\t\t *\n\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t * @default NearestFilter\n\t\t */\n\t\tthis.minFilter = NearestFilter;\n\n\t\t/**\n\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t *\n\t\t * Overwritten and set to `false` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nexport { FramebufferTexture };\n"],"mappings":"OAASA,YAAe,sBACfC,kBAAqB,kBA0B9B,MAAMC,2BAA2BF,QAQhC,WAAAG,CAAaC,EAAOC,GAEnBC,MAAO,CAAEF,QAAOC,WAShBE,KAAKC,sBAAuB,EAU5BD,KAAKE,UAAYR,cAUjBM,KAAKG,UAAYT,cAUjBM,KAAKI,iBAAkB,EAEvBJ,KAAKK,aAAc,CAEpB,SAIQV","ignoreList":[]}