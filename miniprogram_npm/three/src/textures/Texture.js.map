{"version":3,"file":"node_modules/three/src/textures/Texture.js","names":["EventDispatcher","MirroredRepeatWrapping","ClampToEdgeWrapping","RepeatWrapping","UnsignedByteType","RGBAFormat","LinearMipmapLinearFilter","LinearFilter","UVMapping","NoColorSpace","generateUUID","Vector2","Vector3","Matrix3","Source","_textureId","_tempVec3","Texture","constructor","image","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","DEFAULT_ANISOTROPY","colorSpace","super","this","isTexture","Object","defineProperty","value","uuid","name","source","mipmaps","channel","internalFormat","offset","repeat","center","rotation","matrixAutoUpdate","matrix","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","userData","updateRanges","version","onUpdate","renderTarget","isRenderTargetTexture","isArrayTexture","depth","pmremVersion","width","getSize","x","height","y","z","data","updateMatrix","setUvTransform","addUpdateRange","start","count","push","clearUpdateRanges","length","clone","copy","slice","JSON","parse","stringify","needsUpdate","setValues","values","key","newValue","undefined","console","warn","currentValue","isVector2","isVector3","isMatrix3","toJSON","meta","isRootObject","textures","output","metadata","generator","wrap","keys","dispose","dispatchEvent","transformUv","uv","applyMatrix3","Math","floor","abs","ceil","needsPMREMUpdate"],"sources":["node_modules/three/src/textures/Texture.js"],"sourcesContent":["import { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping,\n\tNoColorSpace,\n} from '../constants.js';\nimport { generateUUID } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Source } from './Source.js';\n\nlet _textureId = 0;\n\nconst _tempVec3 = /*@__PURE__*/ new Vector3();\n\n/**\n * Base class for all textures.\n *\n * Note: After the initial use of a texture, its dimensions, format, and type\n * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.\n *\n * @augments EventDispatcher\n */\nclass Texture extends EventDispatcher {\n\n\t/**\n\t * Constructs a new texture.\n\t *\n\t * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.\n\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t * @param {number} [magFilter=LinearFilter] - The mag filter value.\n\t * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.\n\t * @param {number} [format=RGBAFormat] - The texture format.\n\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t * @param {string} [colorSpace=NoColorSpace] - The color space.\n\t */\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTexture = true;\n\n\t\t/**\n\t\t * The ID of the texture.\n\t\t *\n\t\t * @name Texture#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\t/**\n\t\t * The UUID of the material.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the material.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The data definition of a texture. A reference to the data source can be\n\t\t * shared across textures. This is often useful in context of spritesheets\n\t\t * where multiple textures render the same data but with different texture\n\t\t * transformations.\n\t\t *\n\t\t * @type {Source}\n\t\t */\n\t\tthis.source = new Source( image );\n\n\t\t/**\n\t\t * An array holding user-defined mipmaps.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.mipmaps = [];\n\n\t\t/**\n\t\t * How the texture is applied to the object. The value `UVMapping`\n\t\t * is the default, where texture or uv coordinates are used to apply the map.\n\t\t *\n\t\t * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}\n\t\t * @default UVMapping\n\t\t*/\n\t\tthis.mapping = mapping;\n\n\t\t/**\n\t\t * Lets you select the uv attribute to map the texture to. `0` for `uv`,\n\t\t * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.channel = 0;\n\n\t\t/**\n\t\t * This defines how the texture is wrapped horizontally and corresponds to\n\t\t * *U* in UV mapping.\n\t\t *\n\t\t * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}\n\t\t * @default ClampToEdgeWrapping\n\t\t */\n\t\tthis.wrapS = wrapS;\n\n\t\t/**\n\t\t * This defines how the texture is wrapped horizontally and corresponds to\n\t\t * *V* in UV mapping.\n\t\t *\n\t\t * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}\n\t\t * @default ClampToEdgeWrapping\n\t\t */\n\t\tthis.wrapT = wrapT;\n\n\t\t/**\n\t\t * How the texture is sampled when a texel covers more than one pixel.\n\t\t *\n\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t * @default LinearFilter\n\t\t */\n\t\tthis.magFilter = magFilter;\n\n\t\t/**\n\t\t * How the texture is sampled when a texel covers less than one pixel.\n\t\t *\n\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t * @default LinearMipmapLinearFilter\n\t\t */\n\t\tthis.minFilter = minFilter;\n\n\t\t/**\n\t\t * The number of samples taken along the axis through the pixel that has the\n\t\t * highest density of texels. By default, this value is `1`. A higher value\n\t\t * gives a less blurry result than a basic mipmap, at the cost of more\n\t\t * texture samples being used.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.anisotropy = anisotropy;\n\n\t\t/**\n\t\t * The format of the texture.\n\t\t *\n\t\t * @type {number}\n\t\t * @default RGBAFormat\n\t\t */\n\t\tthis.format = format;\n\n\t\t/**\n\t\t * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and\n\t\t * defines how the texture data is going to be stored on the GPU.\n\t\t *\n\t\t * This property allows to overwrite the default format.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.internalFormat = null;\n\n\t\t/**\n\t\t * The data type of the texture.\n\t\t *\n\t\t * @type {number}\n\t\t * @default UnsignedByteType\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * How much a single repetition of the texture is offset from the beginning,\n\t\t * in each direction U and V. Typical range is `0.0` to `1.0`.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (0,0)\n\t\t */\n\t\tthis.offset = new Vector2( 0, 0 );\n\n\t\t/**\n\t\t * How many times the texture is repeated across the surface, in each\n\t\t * direction U and V. If repeat is set greater than `1` in either direction,\n\t\t * the corresponding wrap parameter should also be set to `RepeatWrapping`\n\t\t * or `MirroredRepeatWrapping` to achieve the desired tiling effect.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (1,1)\n\t\t */\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\t/**\n\t\t * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds\n\t\t * to the center of the texture. Default is `(0, 0)`, the lower left.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (0,0)\n\t\t */\n\t\tthis.center = new Vector2( 0, 0 );\n\n\t\t/**\n\t\t * How much the texture is rotated around the center point, in radians.\n\t\t * Positive values are counter-clockwise.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.rotation = 0;\n\n\t\t/**\n\t\t * Whether to update the texture's uv-transformation {@link Texture#matrix}\n\t\t * from the properties {@link Texture#offset}, {@link Texture#repeat},\n\t\t * {@link Texture#rotation}, and {@link Texture#center}.\n\t\t *\n\t\t * Set this to `false` if you are specifying the uv-transform matrix directly.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.matrixAutoUpdate = true;\n\n\t\t/**\n\t\t * The uv-transformation matrix of the texture.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.matrix = new Matrix3();\n\n\t\t/**\n\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t *\n\t\t * Set this to `false` if you are creating mipmaps manually.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.generateMipmaps = true;\n\n\t\t/**\n\t\t * If set to `true`, the alpha channel, if present, is multiplied into the\n\t\t * color channels when the texture is uploaded to the GPU.\n\t\t *\n\t\t * Note that this property has no effect when using `ImageBitmap`. You need to\n\t\t * configure premultiply alpha on bitmap creation instead.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.premultiplyAlpha = false;\n\n\t\t/**\n\t\t * If set to `true`, the texture is flipped along the vertical axis when\n\t\t * uploaded to the GPU.\n\t\t *\n\t\t * Note that this property has no effect when using `ImageBitmap`. You need to\n\t\t * configure the flip on bitmap creation instead.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.flipY = true;\n\n\t\t/**\n\t\t * Specifies the alignment requirements for the start of each pixel row in memory.\n\t\t * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),\n\t\t * `4` (word-alignment), and `8` (rows start on double-word boundaries).\n\t\t *\n\t\t * @type {number}\n\t\t * @default 4\n\t\t */\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t/**\n\t\t * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default NoColorSpace\n\t\t */\n\t\tthis.colorSpace = colorSpace;\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the texture. It\n\t\t * should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t\t/**\n\t\t * This can be used to only update a subregion or specific rows of the texture (for example, just the\n\t\t * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.updateRanges = [];\n\n\t\t/**\n\t\t * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * A callback function, called when the texture is updated (e.g., when\n\t\t * {@link Texture#needsUpdate} has been set to true and then the texture is used).\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onUpdate = null;\n\n\t\t/**\n\t\t * An optional back reference to the textures render target.\n\t\t *\n\t\t * @type {?(RenderTarget|WebGLRenderTarget)}\n\t\t * @default null\n\t\t */\n\t\tthis.renderTarget = null;\n\n\t\t/**\n\t\t * Indicates whether a texture belongs to a render target or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default false\n\t\t */\n\t\tthis.isRenderTargetTexture = false;\n\n\t\t/**\n\t\t * Indicates if a texture should be handled like a texture array.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default false\n\t\t */\n\t\tthis.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;\n\n\t\t/**\n\t\t * Indicates whether this texture should be processed by `PMREMGenerator` or not\n\t\t * (only relevant for render target textures).\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.pmremVersion = 0;\n\n\t}\n\n\t/**\n\t * The width of the texture in pixels.\n\t */\n\tget width() {\n\n\t\treturn this.source.getSize( _tempVec3 ).x;\n\n\t}\n\n\t/**\n\t * The height of the texture in pixels.\n\t */\n\tget height() {\n\n\t\treturn this.source.getSize( _tempVec3 ).y;\n\n\t}\n\n\t/**\n\t * The depth of the texture in pixels.\n\t */\n\tget depth() {\n\n\t\treturn this.source.getSize( _tempVec3 ).z;\n\n\t}\n\n\t/**\n\t * The image object holding the texture data.\n\t *\n\t * @type {?Object}\n\t */\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\t/**\n\t * Updates the texture transformation matrix from the from the properties {@link Texture#offset},\n\t * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.\n\t */\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\t/**\n\t * Adds a range of data in the data texture to be updated on the GPU.\n\t *\n\t * @param {number} start - Position at which to start update.\n\t * @param {number} count - The number of components to update.\n\t */\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\t/**\n\t * Clears the update ranges.\n\t */\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\t/**\n\t * Returns a new texture with copied values from this instance.\n\t *\n\t * @return {Texture} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given texture to this instance.\n\t *\n\t * @param {Texture} source - The texture to copy.\n\t * @return {Texture} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.renderTarget = source.renderTarget;\n\t\tthis.isRenderTargetTexture = source.isRenderTargetTexture;\n\t\tthis.isArrayTexture = source.isArrayTexture;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this texture's properties based on `values`.\n\t * @param {Object} values - A container with texture parameters.\n\t */\n\tsetValues( values ) {\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Texture.setValues(): parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Texture.setValues(): property '${ key }' does not exist.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the texture into JSON.\n\t *\n\t * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n\t * @return {Object} A JSON object representing the serialized texture.\n\t * @see {@link ObjectLoader#parse}\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t *\n\t * @fires Texture#dispose\n\t */\n\tdispose() {\n\n\t\t/**\n\t\t * Fires when the texture has been disposed of.\n\t\t *\n\t\t * @event Texture#dispose\n\t\t * @type {Object}\n\t\t */\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Transforms the given uv vector with the textures uv transformation matrix.\n\t *\n\t * @param {Vector2} uv - The uv vector.\n\t * @return {Vector2} The transformed uv vector.\n\t */\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\t/**\n\t * Setting this property to `true` indicates the engine the texture\n\t * must be updated in the next render. This triggers a texture upload\n\t * to the GPU and ensures correct texture parameter configuration.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setting this property to `true` indicates the engine the PMREM\n\t * must be regenerated.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * The default image for all textures.\n *\n * @static\n * @type {?Image}\n * @default null\n */\nTexture.DEFAULT_IMAGE = null;\n\n/**\n * The default mapping for all textures.\n *\n * @static\n * @type {number}\n * @default UVMapping\n */\nTexture.DEFAULT_MAPPING = UVMapping;\n\n/**\n * The default anisotropy value for all textures.\n *\n * @static\n * @type {number}\n * @default 1\n */\nTexture.DEFAULT_ANISOTROPY = 1;\n\nexport { Texture };\n"],"mappings":"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","ignoreList":[]}