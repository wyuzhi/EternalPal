{"version":3,"file":"node_modules/three/src/textures/VideoFrameTexture.js","names":["VideoTexture","VideoFrameTexture","constructor","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","super","this","isVideoFrameTexture","update","clone","copy","setFrame","frame","image","needsUpdate"],"sources":["node_modules/three/src/textures/VideoFrameTexture.js"],"sourcesContent":["import { VideoTexture } from './VideoTexture.js';\n\n/**\n * This class can be used as an alternative way to define video data. Instead of using\n * an instance of `HTMLVideoElement` like with `VideoTexture`, `VideoFrameTexture` expects each frame is\n * defined manually via {@link VideoFrameTexture#setFrame}. A typical use case for this module is when\n * video frames are decoded with the WebCodecs API.\n *\n * ```js\n * const texture = new THREE.VideoFrameTexture();\n * texture.setFrame( frame );\n * ```\n *\n * @augments VideoTexture\n */\nclass VideoFrameTexture extends VideoTexture {\n\n\t/**\n\t * Constructs a new video frame texture.\n\t *\n\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t * @param {number} [magFilter=LinearFilter] - The mag filter value.\n\t * @param {number} [minFilter=LinearFilter] - The min filter value.\n\t * @param {number} [format=RGBAFormat] - The texture format.\n\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t */\n\tconstructor( mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( {}, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVideoFrameTexture = true;\n\n\t}\n\n\t/**\n\t * This method overwritten with an empty implementation since\n\t * this type of texture is updated via `setFrame()`.\n\t */\n\tupdate() {}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this ); // restoring Texture.clone()\n\n\t}\n\n\t/**\n\t * Sets the current frame of the video. This will automatically update the texture\n\t * so the data can be used for rendering.\n\t *\n\t * @param {VideoFrame} frame - The video frame.\n\t */\n\tsetFrame( frame ) {\n\n\t\tthis.image = frame;\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nexport { VideoFrameTexture };\n"],"mappings":"OAASA,iBAAoB,oBAe7B,MAAMC,0BAA0BD,aAc/B,WAAAE,CAAaC,EAASC,EAAOC,EAAOC,EAAWC,EAAWC,EAAQC,EAAMC,GAEvEC,MAAO,CAAC,EAAGR,EAASC,EAAOC,EAAOC,EAAWC,EAAWC,EAAQC,EAAMC,GAStEE,KAAKC,qBAAsB,CAE5B,CAMA,MAAAC,GAAU,CAEV,KAAAC,GAEC,OAAO,IAAIH,KAAKV,aAAcc,KAAMJ,KAErC,CAQA,QAAAK,CAAUC,GAETN,KAAKO,MAAQD,EACbN,KAAKQ,aAAc,CAEpB,SAIQnB","ignoreList":[]}