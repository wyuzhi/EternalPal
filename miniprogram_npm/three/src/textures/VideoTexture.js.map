{"version":3,"file":"node_modules/three/src/textures/VideoTexture.js","names":["LinearFilter","Texture","VideoTexture","constructor","video","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","super","this","isVideoTexture","generateMipmaps","_requestVideoFrameCallbackId","scope","requestVideoFrameCallback","updateVideo","needsUpdate","clone","image","copy","update","readyState","HAVE_CURRENT_DATA","dispose","source","data","cancelVideoFrameCallback"],"sources":["node_modules/three/src/textures/VideoTexture.js"],"sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { Texture } from './Texture.js';\n\n/**\n * A texture for use with a video.\n *\n * ```js\n * // assuming you have created a HTML video element with id=\"video\"\n * const video = document.getElementById( 'video' );\n * const texture = new THREE.VideoTexture( video );\n * ```\n *\n * Note: When using video textures with {@link WebGPURenderer}, {@link Texture#colorSpace} must be\n * set to THREE.SRGBColorSpace.\n *\n * Note: After the initial use of a texture, its dimensions, format, and type\n * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.\n *\n * @augments Texture\n */\nclass VideoTexture extends Texture {\n\n\t/**\n\t * Constructs a new video texture.\n\t *\n\t * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.\n\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t * @param {number} [magFilter=LinearFilter] - The mag filter value.\n\t * @param {number} [minFilter=LinearFilter] - The min filter value.\n\t * @param {number} [format=RGBAFormat] - The texture format.\n\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t */\n\tconstructor( video, mapping, wrapS, wrapT, magFilter = LinearFilter, minFilter = LinearFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVideoTexture = true;\n\n\t\t/**\n\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t *\n\t\t * Overwritten and set to `false` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * The video frame request callback identifier, which is a positive integer.\n\t\t *\n\t\t * Value of 0 represents no scheduled rVFC.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._requestVideoFrameCallbackId = 0;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tscope._requestVideoFrameCallbackId = video.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tthis._requestVideoFrameCallbackId = video.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\t/**\n\t * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}\n\t * to `true` every time a new frame is available.\n\t *\n\t * Only relevant if `requestVideoFrameCallback` is not supported in the browser.\n\t */\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @override\n\t */\n\tdispose() {\n\n\t\tif ( this._requestVideoFrameCallbackId !== 0 ) {\n\n\t\t\tthis.source.data.cancelVideoFrameCallback( this._requestVideoFrameCallbackId );\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\nexport { VideoTexture };\n"],"mappings":"OAASA,iBAAoB,yBACpBC,YAAe,eAmBxB,MAAMC,qBAAqBD,QAe1B,WAAAE,CAAaC,EAAOC,EAASC,EAAOC,EAAOC,EAAYR,aAAcS,EAAYT,aAAcU,EAAQC,EAAMC,GAE5GC,MAAOT,EAAOC,EAASC,EAAOC,EAAOC,EAAWC,EAAWC,EAAQC,EAAMC,GASzEE,KAAKC,gBAAiB,EAUtBD,KAAKE,iBAAkB,EAUvBF,KAAKG,6BAA+B,EAEpC,MAAMC,EAAQJ,KAST,8BAA+BV,IAEnCU,KAAKG,6BAA+Bb,EAAMe,2BAT3C,SAASC,IAERF,EAAMG,aAAc,EACpBH,EAAMD,6BAA+Bb,EAAMe,0BAA2BC,EAEvE,IAQD,CAEA,KAAAE,GAEC,OAAO,IAAIR,KAAKX,YAAaW,KAAKS,OAAQC,KAAMV,KAEjD,CAQA,MAAAW,GAEC,MAAMrB,EAAQU,KAAKS,OAGY,IAFD,8BAA+BnB,GAErBA,EAAMsB,YAActB,EAAMuB,oBAEjEb,KAAKO,aAAc,EAIrB,CAKA,OAAAO,GAE4C,IAAtCd,KAAKG,8BAETH,KAAKe,OAAOC,KAAKC,yBAA0BjB,KAAKG,8BAIjDJ,MAAMe,SAEP,SAIQ1B","ignoreList":[]}