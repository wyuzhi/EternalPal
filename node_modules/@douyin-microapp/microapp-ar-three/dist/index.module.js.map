{"version":3,"file":"index.module.js","sources":["../src/ArProcessor.ts","../src/ArFootProcessor.ts","../src/ArMixer.ts","../src/ArNailProcessor.ts","../src/Utils/ArNailUtils.ts"],"sourcesContent":["export enum MaskType {\n  remove = 0,\n  reveal = 1,\n}\n\nexport interface ArProcessor {\n  name: string\n\n  maskTextures?: THREE.DataTexture[]\n  maskType?: MaskType\n  threshold?: number\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\ninterface FootAlgResult {\n  left: number[][]\n  right: number[][]\n  leftMask: Uint8Array\n  rightMask: Uint8Array\n  maskWidth: number\n  maskHeight: number\n}\n\ninterface FootModels {\n  left: THREE.Object3D\n  right: THREE.Object3D\n}\n\ninterface ArFootProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: FootAlgResult\n  models: FootModels\n}\n\nexport class ArFootProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.remove\n\n  constructor({ three }: ArFootProcessorParams) {\n    this.name = 'ArFootProcessor'\n    this.three = three\n    this.threshold = 1.0\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n  }\n\n  private updateMesh(matrix: number[], mesh: THREE.Object3D) {\n    const position = new this.three.Vector3()\n    const quaternion = new this.three.Quaternion()\n    const scale = new this.three.Vector3(1, 1, 1)\n    const trs = new this.three.Matrix4()\n    for (let i = 0; i < matrix.length; i++) {\n      trs.elements[i] = matrix[i]\n    }\n    trs.decompose(position, quaternion, scale)\n\n    mesh.position.copy(position)\n    mesh.scale.copy(scale)\n    mesh.quaternion.copy(quaternion)\n  }\n\n  public updateModels({ algResult, models }: UpdateModelsParams) {\n    if (algResult == null) {\n      models['left'].visible = false\n      models['right'].visible = false\n      return\n    }\n    if (algResult.left.length !== 0) {\n      this.updateMesh(algResult.left[0], models['left'])\n      models['left'].visible = true\n    } else {\n      models['left'].visible = false\n    }\n    if (algResult.right.length !== 0) {\n      this.updateMesh(algResult.right[0], models['right'])\n      models['right'].visible = true\n    } else {\n      models['right'].visible = false\n    }\n\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.leftMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n      this.maskTextures[1].copy(\n        new this.three.DataTexture(\n          algResult.rightMask,\n          algResult.maskWidth,\n          algResult.maskHeight,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.leftMask)\n      this.maskTextures[1].image.data.set(algResult.rightMask)\n    }\n\n    this.maskTextures[0].needsUpdate = true\n    this.maskTextures[1].needsUpdate = true\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\n\nconst VS_CODE_TEMPLATE = `\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\nconst FS_CODE_HEADER = `\nuniform sampler2D texModel;\nuniform sampler2D texCamera;\n\nvarying vec2 vUv;\nvoid main(void) {\n    vec4 model = texture2D(texModel, vUv);\n    vec4 camera = texture2D(texCamera, vUv);\n    vec4 result = camera;\n\n    vec4 removeMaskTexel;\n    vec4 revealMaskTexel;\n\n`\nconst FS_CODE_REMOVE_PROCESSOR = `\n    if(removeMaskTexel.a >= 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\nconst FS_CODE_REVEAL_PROCESSOR = `\n    if(revealMaskTexel.a < 1.0) {\n      model.a = 0.0;\n    }\n    if(model.a == 0.0) {\n      result = camera;\n    }\n    else {\n      result = model;\n    }\n`\n\nconst FS_CODE_FOOTER = `\n    gl_FragColor = vec4(result);\n}`\n\nfunction getMaskTexelAndBinarizeAlphaCodeSegment(\n  maskTextureID: string,\n  maskTexelID: string,\n  processor: ArProcessor\n) {\n  // get mask texel and binarize texel alpha value\n  const threshold = processor.threshold == null ? 0.0 : processor.threshold\n  return `\n    vec4 ${maskTexelID} = texture2D(${maskTextureID}, vUv);\n    ${maskTexelID}.a = ${maskTexelID}.a >= ${threshold.toPrecision(\n    2\n  )} ? 1.0 : 0.0;\n`\n}\n\ninterface ArMixerParams {\n  three: typeof THREE\n  processors: ArProcessor[]\n  cameraTexture: THREE.Texture\n  modelTexture: THREE.Texture\n  mixedTextureWidth: number\n  mixedTextureHeight: number\n}\n\ninterface RenderParams {\n  renderer: THREE.WebGLRenderer\n}\n\nfunction getFsCodeAndShaderUniforms(\n  cameraTexture: THREE.Texture,\n  modelTexture: THREE.Texture,\n  processors: ArProcessor[]\n) {\n  let fsDeclareMaskTexture: string = ''\n\n  let fsRemoveMaskProcessCodeSegment: string = ''\n  let fsRevealMaskProcessCodeSegment: string = ''\n\n  const shaderUniforms: { [uniform: string]: THREE.IUniform } = {\n    texCamera: { value: cameraTexture },\n    texModel: { value: modelTexture },\n  }\n\n  const revealMaskTexelIDs: string[] = []\n  const removeMaskTexelIDs: string[] = []\n\n  for (let i = 0; i < processors.length; i++) {\n    const { maskTextures, maskType } = processors[i]\n    if (maskTextures == null) continue\n    if (maskType == null) continue\n\n    // get arXxxxProcessor from ArXxxxProcessor and use it in shader\n    const processorName = `${processors[\n      i\n    ].name[0].toLocaleLowerCase()}${processors[i].name.slice(1)}`\n\n    for (let j = 0; j < maskTextures.length; j++) {\n      const maskTextureID = `${processorName}MaskTextures${String(j)}`\n      const maskTexelID = `${processorName}MaskTexel${String(j)}`\n\n      // add maskTexture to shader uniform\n      fsDeclareMaskTexture += `uniform sampler2D ${maskTextureID};\\n`\n      shaderUniforms[maskTextureID] = { value: maskTextures[j] }\n\n      // add all maskTexel\n      switch (maskType) {\n        case MaskType.remove:\n          fsRemoveMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          removeMaskTexelIDs.push(maskTexelID)\n          break\n        case MaskType.reveal:\n          fsRevealMaskProcessCodeSegment +=\n            getMaskTexelAndBinarizeAlphaCodeSegment(\n              maskTextureID,\n              maskTexelID,\n              processors[i]\n            )\n          revealMaskTexelIDs.push(maskTexelID)\n          break\n      }\n    }\n  }\n\n  if (removeMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    removeMaskTexel = ${removeMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRemoveMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REMOVE_PROCESSOR}`\n  }\n  if (revealMaskTexelIDs.length !== 0) {\n    const addAllTexelCode = `    revealMaskTexel = ${revealMaskTexelIDs.join(\n      ' + '\n    )};\\n`\n    fsRevealMaskProcessCodeSegment += `${addAllTexelCode}\\n${FS_CODE_REVEAL_PROCESSOR}`\n  }\n\n  const fsCode =\n    fsDeclareMaskTexture +\n    FS_CODE_HEADER +\n    fsRemoveMaskProcessCodeSegment +\n    fsRevealMaskProcessCodeSegment +\n    FS_CODE_FOOTER\n\n  return { shaderUniforms, fsCode }\n}\n\nexport class ArMixer {\n  private mixedRenderTarget: THREE.WebGLRenderTarget\n  private maskScene: THREE.Scene\n  private maskCamera: THREE.OrthographicCamera\n  private three: typeof THREE\n\n  public mixedTexture: THREE.Texture\n  public processors: ArProcessor[]\n\n  constructor({\n    three,\n    processors,\n    cameraTexture,\n    modelTexture,\n    mixedTextureWidth,\n    mixedTextureHeight,\n  }: ArMixerParams) {\n    this.three = three\n    this.processors = processors\n\n    const shaderUniformsFsCodeData = getFsCodeAndShaderUniforms(\n      cameraTexture,\n      modelTexture,\n      this.processors\n    )\n\n    const mixedShaderMaterial = new this.three.ShaderMaterial({\n      uniforms: shaderUniformsFsCodeData.shaderUniforms,\n      vertexShader: VS_CODE_TEMPLATE,\n      fragmentShader: shaderUniformsFsCodeData.fsCode,\n    })\n\n    const planeGeometry = new this.three.PlaneGeometry(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n    this.mixedRenderTarget = new this.three.WebGLRenderTarget(\n      mixedTextureWidth,\n      mixedTextureHeight\n    )\n\n    const maskPlane = new this.three.Mesh(planeGeometry, mixedShaderMaterial)\n    maskPlane.position.z = -10\n    this.maskScene = new this.three.Scene()\n    this.maskScene.add(maskPlane)\n\n    this.maskCamera = new this.three.OrthographicCamera(\n      mixedTextureWidth / -2,\n      mixedTextureWidth / 2,\n      mixedTextureHeight / 2,\n      mixedTextureHeight / -2,\n      1,\n      1000\n    )\n\n    this.mixedTexture = this.mixedRenderTarget.texture\n  }\n\n  public render({ renderer }: RenderParams) {\n    const originRenderTarget = renderer.getRenderTarget()\n    renderer.setRenderTarget(this.mixedRenderTarget)\n    renderer.render(this.maskScene, this.maskCamera)\n    renderer.setRenderTarget(originRenderTarget)\n  }\n}\n","import type THREE from 'three'\nimport { ArProcessor, MaskType } from './ArProcessor'\nimport { Rect, PointArray } from './Utils/base_type'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n\ninterface SingleNailKeypointResult {\n  nailRect: Rect\n  keyPoints: PointArray\n  nailType: number\n}\n\ninterface NailMaskResult {\n  width: number\n  height: number\n  nailNum: number\n  nailMask: Uint8Array\n}\n\ninterface NailAlgResult {\n  nailMaskResult: NailMaskResult\n  nailKeypointResults: SingleNailKeypointResult[]\n}\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\n// Get the area and centroid of the triangle, used to calculate the centroid of the nail polygon\ninterface GetTriangleAreaAndCentroidParams {\n  p0: Point\n  p1: Point\n  p2: Point\n}\n\ninterface GetNailPolygonCentroidParams {\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n}\n\ninterface UpdateNailModelParams {\n  nailModel: THREE.Mesh\n  keyPoints: PointArray\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\ninterface UpdateNailModelGroupParams {\n  nailModelGroup: THREE.Group\n  algResult: NailAlgResult\n  cameraWidth: number\n  cameraHeight: number\n  THREE: typeof THREE\n}\n\nfunction getTriangleAreaAndCentroid({\n  p0,\n  p1,\n  p2,\n}: GetTriangleAreaAndCentroidParams) {\n  const x1 = Math.abs(p0.x - p2.x)\n  const x2 = Math.abs(p1.x - p2.x)\n\n  const y1 = Math.abs(p0.y - p2.y)\n  const y2 = Math.abs(p1.y - p2.y)\n\n  const triangleArea = 0.5 * Math.abs(x1 * y2 - x2 * y1)\n\n  const triangleCenterX = (p2.x + p0.x + p1.x) / 3\n  const triangleCenterY = (p2.y + p0.y + p1.y) / 3\n\n  return {\n    area: triangleArea,\n    centroid: {\n      x: triangleCenterX,\n      y: triangleCenterY,\n    },\n  }\n}\n\nfunction getNailPolygonCentroid({\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n}: GetNailPolygonCentroidParams) {\n  const tempPointArray = new Array()\n  const fixPoint = {\n    x: keyPoints.get(7).x * cameraWidth - cameraWidth / 2,\n    y: keyPoints.get(7).y * cameraHeight - cameraHeight / 2,\n    z: -10,\n  }\n  let result\n  let nailArea = 0\n  let nailCentroidX = 0\n  let nailCentroidY = 0\n\n  for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n    const point = keyPoints.get(i)\n\n    tempPointArray.push({\n      x: point.x * cameraWidth - cameraWidth / 2,\n      y: point.y * cameraHeight - cameraHeight / 2,\n      z: -10,\n    })\n\n    if (i > 0 && i !== 7) {\n      result = getTriangleAreaAndCentroid({\n        p0: tempPointArray[i - 1],\n        p1: tempPointArray[i],\n        p2: fixPoint,\n      })\n      nailArea += result.area\n      nailCentroidX += result.centroid.x * result.area\n      nailCentroidY += result.centroid.y * result.area\n    }\n  }\n  nailCentroidX /= nailArea\n  nailCentroidY /= nailArea\n  return {\n    x: nailCentroidX,\n    y: nailCentroidY,\n  }\n}\n\nfunction updateNailModel({\n  nailModel,\n  keyPoints,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelParams): void {\n  const nailCentroid = getNailPolygonCentroid({\n    keyPoints,\n    cameraWidth,\n    cameraHeight,\n  })\n\n  const positionArray = new Float32Array(\n    nailModel.geometry.attributes.position.array.length\n  )\n\n  // move nail convex polygon vertices so that the convex polygon wraps the nail\n  if (nailModel.geometry.attributes.position instanceof THREE.BufferAttribute) {\n    for (let i = 0; i < NAIL_KEY_POINTS_COUNT; i++) {\n      const point = {\n        x: keyPoints.get(i).x * cameraWidth - cameraWidth / 2,\n        y: keyPoints.get(i).y * cameraHeight - cameraHeight / 2,\n      }\n      const offsetX = point.x - nailCentroid.x\n      const offsetY = point.y - nailCentroid.y\n      positionArray[i * 3] = point.x + 0.2 * offsetX\n      positionArray[i * 3 + 1] = point.y + 0.2 * offsetY\n      positionArray[i * 3 + 2] = -10\n    }\n    nailModel.geometry.attributes.position.array = positionArray\n  }\n\n  nailModel.visible = true\n  nailModel.geometry.attributes.position.needsUpdate = true\n}\n\nfunction updateNailModelGroup({\n  algResult,\n  nailModelGroup,\n  cameraWidth,\n  cameraHeight,\n  THREE,\n}: UpdateNailModelGroupParams) {\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.children[i].visible = false\n  }\n  for (let i = 0; i < algResult.nailMaskResult.nailNum; i++) {\n    const nailType = algResult.nailKeypointResults[i].nailType - 1\n    const { keyPoints } = algResult.nailKeypointResults[i]\n    if (nailType < 0) continue\n    updateNailModel({\n      nailModel: nailModelGroup.children[nailType] as THREE.Mesh,\n      keyPoints,\n      cameraWidth,\n      cameraHeight,\n      THREE,\n    })\n  }\n}\n\ninterface ArNailProcessorParams {\n  three: typeof THREE\n}\n\ninterface UpdateModelsParams {\n  algResult?: NailAlgResult\n  models: THREE.Group\n  cameraWidth: number\n  cameraHeight: number\n}\n\nexport class ArNailProcessor implements ArProcessor {\n  private three: typeof THREE\n  public name: string\n  public maskTextures: THREE.DataTexture[]\n  public threshold = 0.0\n  public maskType = MaskType.reveal\n\n  constructor({ three }: ArNailProcessorParams) {\n    this.name = 'ArNailProcessor'\n    this.three = three\n    this.threshold = 0.5\n    this.maskTextures = [\n      new this.three.DataTexture(\n        new Uint8Array(1),\n        1,\n        1,\n        this.three.AlphaFormat\n      ),\n    ]\n    this.maskTextures[0].needsUpdate = true\n  }\n\n  public updateModels({\n    algResult,\n    models,\n    cameraWidth,\n    cameraHeight,\n  }: UpdateModelsParams) {\n    if (algResult == null) {\n      return\n    }\n    if (this.maskTextures[0].image.width === 1) {\n      this.maskTextures[0].copy(\n        new this.three.DataTexture(\n          algResult.nailMaskResult.nailMask,\n          algResult.nailMaskResult.width,\n          algResult.nailMaskResult.height,\n          this.three.AlphaFormat\n        )\n      )\n    } else {\n      this.maskTextures[0].image.data.set(algResult.nailMaskResult.nailMask)\n    }\n    this.maskTextures[0].needsUpdate = true\n\n    updateNailModelGroup({\n      algResult,\n      nailModelGroup: models,\n      cameraWidth,\n      cameraHeight,\n      THREE: this.three,\n    })\n  }\n}\n","import type THREE from 'three'\n\nconst NAIL_KEY_POINTS_COUNT = 8\nconst NAIL_COUNT = 5\n// Texture Coordinates used to generate highlights\nconst NAIL_UV_ARRAY = new Float32Array([\n  1 / 6,\n  1 / 4,\n  7 / 24,\n  1 / 8,\n  1 / 2,\n  1 / 12,\n  17 / 24,\n  1 / 8,\n  5 / 6,\n  1 / 4,\n  17 / 24,\n  5 / 6,\n  1 / 2,\n  11 / 12,\n  7 / 24,\n  5 / 6,\n])\nconst HIGHLIGHT_TEXTURE_WIDTH = 512\nconst HIGHLIGHT_TEXTURE_HEIGHT = 512\n// Index used to generate highlight polygon\nconst HIGHLIGHT_GEOMETRY_INDEX = [0, 1, 4, 1, 2, 4, 2, 3, 4]\n// Index used to generate nail polygon\nconst NAIL_GEOMETRY_INDEX = [\n  7, 0, 6, 0, 1, 6, 1, 2, 6, 2, 3, 6, 3, 4, 6, 4, 5, 6,\n]\n\ninterface GetHighLightTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color\n}\n\ninterface GetNailModelParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\ninterface GetNailModelGroupParams {\n  THREE: typeof THREE\n  highLightTexture: THREE.Texture\n}\n\nfunction getHighLightTexture({\n  THREE,\n  renderer,\n  color,\n}: GetHighLightTextureParams) {\n  // Highlight polygon\n  const highLightVertices = new Float32Array([\n    -0.17 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.25 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.07 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.21 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.03 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.16 * HIGHLIGHT_TEXTURE_WIDTH,\n    -0.22 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n    -0.14 * HIGHLIGHT_TEXTURE_WIDTH,\n    0.02 * HIGHLIGHT_TEXTURE_HEIGHT,\n    1.0,\n  ])\n  const highLightScene = new THREE.Scene()\n  const highLightCamera = new THREE.OrthographicCamera(\n    HIGHLIGHT_TEXTURE_WIDTH / -2,\n    HIGHLIGHT_TEXTURE_WIDTH / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / 2,\n    HIGHLIGHT_TEXTURE_HEIGHT / -2,\n    1,\n    1000\n  )\n  const highLightRenderTarget = new THREE.WebGLRenderTarget(\n    HIGHLIGHT_TEXTURE_WIDTH,\n    HIGHLIGHT_TEXTURE_HEIGHT\n  )\n  const highLightGeometry = new THREE.BufferGeometry()\n  highLightGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(highLightVertices, 3)\n  )\n  highLightGeometry.setIndex(HIGHLIGHT_GEOMETRY_INDEX)\n  const highLightMaterial = new THREE.MeshBasicMaterial({\n    color: new THREE.Color(0xffffff),\n  })\n\n  const highLightModel = new THREE.Mesh(highLightGeometry, highLightMaterial)\n  highLightModel.position.z = -10\n\n  // set nail color\n  highLightScene.add(highLightModel)\n  renderer.setRenderTarget(highLightRenderTarget)\n  const originColor = new THREE.Color()\n  renderer.getClearColor(originColor)\n  renderer.setClearColor(color)\n  renderer.render(highLightScene, highLightCamera)\n  renderer.setClearColor(originColor, renderer.getClearAlpha())\n  renderer.setRenderTarget(null)\n\n  return highLightRenderTarget.texture\n}\n\nfunction getNailModel({ THREE, highLightTexture }: GetNailModelParams) {\n  const nailVSCode = `\n    varying vec2 vUv;\n\n    void main()\n    {\n        vUv = uv;\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n  `\n\n  const nailFSCode = `\n    uniform sampler2D highLightTexture;\n\n    varying vec2 vUv;\n    void main(void) {\n        vec4 tex = texture2D(highLightTexture, vUv);\n        gl_FragColor = vec4(tex.r, tex.g, tex.b, 1.0);\n    }\n  `\n  const nailKeyPointsConponentCount = 3\n  const positionArray = new Float32Array(\n    nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT\n  )\n\n  for (\n    let i = 0;\n    i < nailKeyPointsConponentCount * NAIL_KEY_POINTS_COUNT;\n    i++\n  ) {\n    positionArray[i] = i\n  }\n  const nailGeometry = new THREE.BufferGeometry()\n  nailGeometry.setAttribute(\n    'position',\n    new THREE.BufferAttribute(positionArray, nailKeyPointsConponentCount)\n  )\n  nailGeometry.setAttribute('uv', new THREE.BufferAttribute(NAIL_UV_ARRAY, 2))\n  nailGeometry.setIndex(NAIL_GEOMETRY_INDEX)\n\n  const nailShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      highLightTexture: { value: highLightTexture },\n    },\n    vertexShader: nailVSCode,\n    fragmentShader: nailFSCode,\n  })\n  nailShaderMaterial.side = THREE.DoubleSide\n\n  return new THREE.Mesh(nailGeometry, nailShaderMaterial)\n}\n\nfunction getNailModelGroup({\n  THREE,\n  highLightTexture,\n}: GetNailModelGroupParams) {\n  const nailModelGroup = new THREE.Group()\n  for (let i = 0; i < NAIL_COUNT; i++) {\n    nailModelGroup.add(getNailModel({ THREE, highLightTexture }))\n  }\n  return nailModelGroup\n}\n\ninterface GetNailModelGroupByColorParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  color: THREE.Color | string | number\n}\n\ninterface GetNailModelGroupByTextureParams {\n  THREE: typeof THREE\n  renderer: THREE.WebGLRenderer\n  texture: THREE.Texture\n}\n\nconst ArNailUtils = {\n  getNailModelGroupByColor: ({\n    THREE,\n    renderer,\n    color,\n  }: GetNailModelGroupByColorParams) => {\n    if (!(color instanceof THREE.Color)) {\n      color = new THREE.Color(color)\n    }\n    const highLightTexture = getHighLightTexture({ THREE, renderer, color })\n    const nailModelGroup = getNailModelGroup({ THREE, highLightTexture })\n    return nailModelGroup\n  },\n\n  getNailModelGroupByTexture: ({\n    THREE,\n    texture,\n  }: GetNailModelGroupByTextureParams) => {\n    const nailModelGroup = getNailModelGroup({\n      THREE,\n      highLightTexture: texture,\n    })\n    return nailModelGroup\n  },\n}\n\nexport { ArNailUtils }\n"],"names":["MaskType","ArFootProcessor","three","name","maskTextures","threshold","maskType","remove","this","DataTexture","Uint8Array","AlphaFormat","updateMesh","matrix","mesh","position","Vector3","quaternion","Quaternion","scale","trs","Matrix4","i","length","elements","decompose","copy","updateModels","algResult","models","visible","left","right","image","width","leftMask","maskWidth","maskHeight","rightMask","data","set","needsUpdate","getMaskTexelAndBinarizeAlphaCodeSegment","maskTextureID","maskTexelID","processor","toPrecision","ArMixer","processors","cameraTexture","modelTexture","mixedTextureWidth","mixedTextureHeight","mixedRenderTarget","maskScene","maskCamera","mixedTexture","shaderUniformsFsCodeData","fsDeclareMaskTexture","fsRemoveMaskProcessCodeSegment","fsRevealMaskProcessCodeSegment","shaderUniforms","texCamera","value","texModel","revealMaskTexelIDs","removeMaskTexelIDs","processorName","toLocaleLowerCase","slice","j","String","push","reveal","join","addAllTexelCode","fsCode","getFsCodeAndShaderUniforms","mixedShaderMaterial","ShaderMaterial","uniforms","vertexShader","fragmentShader","planeGeometry","PlaneGeometry","WebGLRenderTarget","maskPlane","Mesh","z","Scene","add","OrthographicCamera","texture","render","renderer","originRenderTarget","getRenderTarget","setRenderTarget","updateNailModel","nailModel","keyPoints","cameraWidth","cameraHeight","THREE","nailCentroid","result","p0","p1","p2","x1","x2","y1","y2","tempPointArray","Array","fixPoint","x","get","y","nailArea","nailCentroidX","nailCentroidY","point","Math","abs","area","centroid","getNailPolygonCentroid","positionArray","Float32Array","geometry","attributes","array","BufferAttribute","offsetY","ArNailProcessor","nailMaskResult","nailMask","height","nailModelGroup","children","nailNum","nailType","nailKeypointResults","updateNailModelGroup","NAIL_UV_ARRAY","HIGHLIGHT_GEOMETRY_INDEX","NAIL_GEOMETRY_INDEX","getNailModel","highLightTexture","nailKeyPointsConponentCount","nailGeometry","BufferGeometry","setAttribute","setIndex","nailShaderMaterial","side","DoubleSide","getNailModelGroup","Group","ArNailUtils","getNailModelGroupByColor","color","Color","highLightVertices","highLightScene","highLightCamera","HIGHLIGHT_TEXTURE_WIDTH","HIGHLIGHT_TEXTURE_HEIGHT","highLightRenderTarget","highLightGeometry","highLightMaterial","MeshBasicMaterial","highLightModel","originColor","getClearColor","setClearColor","getClearAlpha","getHighLightTexture","getNailModelGroupByTexture"],"mappings":"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"}